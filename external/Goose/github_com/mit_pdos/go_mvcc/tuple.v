(* autogenerated from github.com/mit-pdos/go-mvcc/tuple *)
From Perennial.goose_lang Require Import prelude.
Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

From Goose Require github_com.mit_pdos.go_mvcc.common.
From Goose Require github_com.mit_pdos.go_mvcc.config.

(* *
    * The lifetime of a version is a half-open interval `(begin, val]`. *)
Definition Version := struct.decl [
  "begin" :: uint64T;
  "end" :: uint64T;
  "val" :: uint64T
].

(* *
    * `tidown`
    *		An TID specifying which txn owns the permission to write this tuple.
    * `tidlast`
    *		An TID specifying the last txn (in the sense of the largest TID, not
    *		actual physical time) that reads or writes this tuple. *)
Definition Tuple := struct.decl [
  "latch" :: ptrT;
  "rcond" :: ptrT;
  "tidown" :: uint64T;
  "tidlast" :: uint64T;
  "verlast" :: struct.t Version;
  "vers" :: slice.T (struct.t Version)
].

(* *
    * TODO: Maybe start from the end (i.e., the newest version).
    * TODO: Can simply return a value rather than a version. *)
Definition findRightVer: val :=
  rec: "findRightVer" "tid" "vers" :=
    let: "ver" := ref (zero_val (struct.t Version)) in
    let: "ret" := ref_to uint64T common.RET_NONEXIST in
    ForSlice (struct.t Version) <> "v" "vers"
      (if: (struct.get Version "begin" "v" < "tid") && ("tid" ≤ struct.get Version "end" "v")
      then
        "ver" <-[struct.t Version] "v";;
        "ret" <-[uint64T] common.RET_SUCCESS
      else #());;
    (![struct.t Version] "ver", ![uint64T] "ret").

(* *
    * Preconditions:
    *
    * Postconditions:
    * 1. On a successful return, the txn `tid` get the permission to update this
    * tuple (when we also acquire the latch of this tuple). *)
Definition Tuple__Own: val :=
  rec: "Tuple__Own" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    (if: "tid" < struct.loadF Tuple "tidlast" "tuple"
    then
      lock.release (struct.loadF Tuple "latch" "tuple");;
      common.RET_UNSERIALIZABLE
    else
      (if: struct.loadF Tuple "tidown" "tuple" ≠ #0
      then
        lock.release (struct.loadF Tuple "latch" "tuple");;
        common.RET_RETRY
      else
        struct.storeF Tuple "tidown" "tuple" "tid";;
        lock.release (struct.loadF Tuple "latch" "tuple");;
        common.RET_SUCCESS)).

Definition Tuple__appendVersion: val :=
  rec: "Tuple__appendVersion" "tuple" "tid" "val" :=
    let: "verLast" := ref (zero_val (struct.t Version)) in
    "verLast" <-[struct.t Version] struct.loadF Tuple "verlast" "tuple";;
    (if: (struct.get Version "end" (![struct.t Version] "verLast") = config.TID_SENTINEL)
    then struct.storeF Version "end" "verLast" "tid"
    else #());;
    struct.storeF Tuple "vers" "tuple" (SliceAppend (struct.t Version) (struct.loadF Tuple "vers" "tuple") (![struct.t Version] "verLast"));;
    let: "verNext" := struct.mk Version [
      "begin" ::= "tid";
      "end" ::= config.TID_SENTINEL;
      "val" ::= "val"
    ] in
    struct.storeF Tuple "verlast" "tuple" "verNext";;
    struct.storeF Tuple "tidown" "tuple" #0;;
    struct.storeF Tuple "tidlast" "tuple" "tid";;
    #().

(* *
    * Preconditions:
    * 1. The txn `tid` has the permission to update this tuple. *)
Definition Tuple__AppendVersion: val :=
  rec: "Tuple__AppendVersion" "tuple" "tid" "val" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    Tuple__appendVersion "tuple" "tid" "val";;
    lock.condBroadcast (struct.loadF Tuple "rcond" "tuple");;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

Definition Tuple__killVersion: val :=
  rec: "Tuple__killVersion" "tuple" "tid" :=
    let: "ret" := ref (zero_val uint64T) in
    (if: (struct.get Version "end" (struct.loadF Tuple "verlast" "tuple") = config.TID_SENTINEL)
    then "ret" <-[uint64T] common.RET_SUCCESS
    else "ret" <-[uint64T] common.RET_NONEXIST);;
    struct.storeF Version "end" (struct.fieldRef Tuple "verlast" "tuple") "tid";;
    struct.storeF Tuple "tidown" "tuple" #0;;
    struct.storeF Tuple "tidlast" "tuple" "tid";;
    ![uint64T] "ret".

(* *
    * Preconditions:
    * 1. The txn `tid` has the permission to update this tuple. *)
Definition Tuple__KillVersion: val :=
  rec: "Tuple__KillVersion" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    let: "ret" := Tuple__killVersion "tuple" "tid" in
    lock.condBroadcast (struct.loadF Tuple "rcond" "tuple");;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    "ret".

(* *
    * Preconditions: *)
Definition Tuple__Free: val :=
  rec: "Tuple__Free" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    struct.storeF Tuple "tidown" "tuple" #0;;
    lock.condBroadcast (struct.loadF Tuple "rcond" "tuple");;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

(* *
    * Preconditions: *)
Definition Tuple__ReadVersion: val :=
  rec: "Tuple__ReadVersion" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    let: "verLast" := ref (zero_val (struct.t Version)) in
    "verLast" <-[struct.t Version] struct.loadF Tuple "verlast" "tuple";;
    Skip;;
    (for: (λ: <>, ("tid" > struct.get Version "begin" (![struct.t Version] "verLast")) && (struct.loadF Tuple "tidown" "tuple" ≠ #0)); (λ: <>, Skip) := λ: <>,
      lock.condWait (struct.loadF Tuple "rcond" "tuple");;
      "verLast" <-[struct.t Version] struct.loadF Tuple "verlast" "tuple";;
      Continue);;
    (if: "tid" ≤ struct.get Version "begin" (![struct.t Version] "verLast")
    then
      let: ("ver", "found") := findRightVer "tid" (struct.loadF Tuple "vers" "tuple") in
      lock.release (struct.loadF Tuple "latch" "tuple");;
      (struct.get Version "val" "ver", "found")
    else
      let: "val" := ref (zero_val uint64T) in
      let: "ret" := ref (zero_val uint64T) in
      (if: "tid" ≤ struct.get Version "end" (![struct.t Version] "verLast")
      then
        "val" <-[uint64T] struct.get Version "val" (![struct.t Version] "verLast");;
        "ret" <-[uint64T] common.RET_SUCCESS
      else "ret" <-[uint64T] common.RET_NONEXIST);;
      (if: struct.loadF Tuple "tidlast" "tuple" < "tid"
      then struct.storeF Tuple "tidlast" "tuple" "tid"
      else #());;
      lock.release (struct.loadF Tuple "latch" "tuple");;
      (![uint64T] "val", ![uint64T] "ret")).

Definition Tuple__removeVersions: val :=
  rec: "Tuple__removeVersions" "tuple" "tid" :=
    let: "idx" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: ![uint64T] "idx" ≥ slice.len (struct.loadF Tuple "vers" "tuple")
      then Break
      else
        let: "ver" := SliceGet (struct.t Version) (struct.loadF Tuple "vers" "tuple") (![uint64T] "idx") in
        (if: struct.get Version "end" "ver" > "tid"
        then Break
        else
          "idx" <-[uint64T] ![uint64T] "idx" + #1;;
          Continue)));;
    struct.storeF Tuple "vers" "tuple" (SliceSkip (struct.t Version) (struct.loadF Tuple "vers" "tuple") (![uint64T] "idx"));;
    #().

(* *
    * Remove all versions whose `end` timestamp is less than or equal to `tid`.
    * Preconditions: *)
Definition Tuple__RemoveVersions: val :=
  rec: "Tuple__RemoveVersions" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    Tuple__removeVersions "tuple" "tid";;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

Definition MkTuple: val :=
  rec: "MkTuple" <> :=
    let: "tuple" := struct.alloc Tuple (zero_val (struct.t Tuple)) in
    struct.storeF Tuple "latch" "tuple" (lock.new #());;
    struct.storeF Tuple "rcond" "tuple" (lock.newCond (struct.loadF Tuple "latch" "tuple"));;
    struct.storeF Tuple "tidown" "tuple" #0;;
    struct.storeF Tuple "tidlast" "tuple" #0;;
    struct.storeF Tuple "verlast" "tuple" (struct.mk Version [
      "begin" ::= #0;
      "end" ::= #0;
      "val" ::= #0
    ]);;
    struct.storeF Tuple "vers" "tuple" (NewSlice (struct.t Version) #0);;
    "tuple".

End code.
