(* autogenerated from github.com/mit-pdos/rsm/tpl *)
From Perennial.goose_lang Require Import prelude.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition Keys: ty := slice.T stringT.

Definition Value := struct.decl [
  "b" :: boolT;
  "s" :: stringT
].

Definition WriteEntry := struct.decl [
  "k" :: stringT;
  "v" :: stringT
].

(* Axiomatized *)
Definition member: val :=
  rec: "member" "s" "k" :=
    #false.

Definition DB := struct.decl [
  "lockm" :: mapT boolT;
  "txnm" :: mapT (slice.T stringT);
  "kvm" :: mapT stringT
].

Definition DB__lock: val :=
  rec: "DB__lock" "db" "ts" "key" :=
    let: ("keys", "ok") := MapGet (struct.loadF DB "txnm" "db") "ts" in
    (if: "ok" && (member "keys" "key")
    then #true
    else
      let: (<>, "lck") := MapGet (struct.loadF DB "lockm" "db") "key" in
      (if: "lck"
      then #false
      else
        MapInsert (struct.loadF DB "lockm" "db") "key" #true;;
        (if: (~ "ok")
        then
          let: "keysNew" := NewSlice stringT #1 in
          SliceSet stringT "keysNew" #0 "key";;
          MapInsert (struct.loadF DB "txnm" "db") "ts" "keysNew"
        else MapInsert (struct.loadF DB "txnm" "db") "ts" (SliceAppend stringT "keys" "key"));;
        #true)).

Definition DB__unlockAll: val :=
  rec: "DB__unlockAll" "db" "ts" :=
    let: ("keys", <>) := MapGet (struct.loadF DB "txnm" "db") "ts" in
    ForSlice stringT <> "key" "keys"
      (MapDelete (struct.loadF DB "lockm" "db") "key");;
    MapDelete (struct.loadF DB "txnm" "db") "ts";;
    #().

Definition DB__Read: val :=
  rec: "DB__Read" "db" "ts" "key" :=
    let: "lck" := DB__lock "db" "ts" "key" in
    (if: (~ "lck")
    then
      (struct.mk Value [
       ], #false)
    else
      let: ("v", "ok") := MapGet (struct.loadF DB "kvm" "db") "key" in
      (struct.mk Value [
         "b" ::= "ok";
         "s" ::= "v"
       ], #true)).

Definition DB__Commit: val :=
  rec: "DB__Commit" "db" "ts" "wrs" :=
    let: "idx" := ref (zero_val uint64T) in
    Skip;;
    (for: (λ: <>, (![uint64T] "idx") < (slice.len "wrs")); (λ: <>, Skip) := λ: <>,
      let: "ent" := SliceGet (struct.t WriteEntry) "wrs" (![uint64T] "idx") in
      let: "lck" := DB__lock "db" "ts" (struct.get WriteEntry "k" "ent") in
      (if: (~ "lck")
      then Break
      else
        "idx" <-[uint64T] ((![uint64T] "idx") + #1);;
        Continue));;
    (if: (![uint64T] "idx") < (slice.len "wrs")
    then
      DB__unlockAll "db" "ts";;
      #false
    else
      "idx" <-[uint64T] #0;;
      Skip;;
      (for: (λ: <>, (![uint64T] "idx") < (slice.len "wrs")); (λ: <>, Skip) := λ: <>,
        let: "ent" := SliceGet (struct.t WriteEntry) "wrs" (![uint64T] "idx") in
        MapInsert (struct.loadF DB "kvm" "db") (struct.get WriteEntry "k" "ent") (struct.get WriteEntry "v" "ent");;
        "idx" <-[uint64T] ((![uint64T] "idx") + #1);;
        Continue);;
      DB__unlockAll "db" "ts";;
      #true).

Definition Txn := struct.decl [
  "ts" :: uint64T;
  "wrs" :: mapT stringT;
  "db" :: ptrT
].

Definition Txn__begin: val :=
  rec: "Txn__begin" "txn" :=
    struct.storeF Txn "ts" "txn" #0;;
    #().

Definition slicem: val :=
  rec: "slicem" "m" :=
    slice.nil.

Definition Txn__commit: val :=
  rec: "Txn__commit" "txn" :=
    let: "s" := slicem (struct.loadF Txn "wrs" "txn") in
    let: "cmt" := DB__Commit (struct.loadF Txn "db" "txn") (struct.loadF Txn "ts" "txn") "s" in
    "cmt".

Definition Txn__Read: val :=
  rec: "Txn__Read" "txn" "key" :=
    let: ("v", "ok") := MapGet (struct.loadF Txn "wrs" "txn") "key" in
    (if: "ok"
    then
      (struct.mk Value [
         "b" ::= #true;
         "s" ::= "v"
       ], #true)
    else
      let: ("vdb", "okdb") := DB__Read (struct.loadF Txn "db" "txn") (struct.loadF Txn "ts" "txn") "key" in
      ("vdb", "okdb")).

Definition Txn__Write: val :=
  rec: "Txn__Write" "txn" "key" "value" :=
    MapInsert (struct.loadF Txn "wrs" "txn") "key" "value";;
    #().

Definition Txn__Run: val :=
  rec: "Txn__Run" "txn" "body" :=
    Txn__begin "txn";;
    let: "cmt" := "body" "txn" in
    (if: (~ "cmt")
    then #false
    else
      let: "ok" := Txn__commit "txn" in
      "ok").

Definition NewTxn: val :=
  rec: "NewTxn" <> :=
    struct.new Txn [
    ].

(* Example *)
Definition swap: val :=
  rec: "swap" "txn" :=
    let: ("x", "okx") := Txn__Read "txn" #(str"0") in
    (if: (~ "okx")
    then #false
    else
      let: ("y", "oky") := Txn__Read "txn" #(str"1") in
      (if: (~ "oky")
      then #false
      else
        Txn__Write "txn" #(str"0") (struct.get Value "s" "y");;
        Txn__Write "txn" #(str"1") (struct.get Value "s" "x");;
        #true)).

Definition AtomicSwap: val :=
  rec: "AtomicSwap" <> :=
    let: "txn" := NewTxn #() in
    let: "committed" := Txn__Run "txn" swap in
    "committed".

End code.
