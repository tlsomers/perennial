(* autogenerated from github.com/mit-pdos/gokv/memkv *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.grove_prelude.

From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.gokv.connman.
From Goose Require github_com.mit_pdos.gokv.urpc.rpc.
From Goose Require github_com.tchajed.marshal.

(* 0_common.go *)

Definition HostName: ty := uint64T.

Definition ValueType: ty := uint64T.

Definition ErrorType: ty := uint64T.

Definition ENone : expr := #0.

Definition EDontHaveShard : expr := #1.

Definition NSHARD : expr := #65536.

Definition KV_FRESHCID : expr := #0.

Definition KV_PUT : expr := #1.

Definition KV_GET : expr := #2.

Definition KV_CONDITIONAL_PUT : expr := #3.

Definition KV_INS_SHARD : expr := #4.

Definition KV_MOV_SHARD : expr := #5.

Definition shardOf: val :=
  rec: "shardOf" "key" :=
    "key" `rem` NSHARD.

(* "universal" reply type for the reply table *)
Definition ShardReply := struct.decl [
  "Err" :: ErrorType;
  "Value" :: slice.T byteT;
  "Success" :: boolT
].

Definition PutRequest := struct.decl [
  "CID" :: uint64T;
  "Seq" :: uint64T;
  "Key" :: uint64T;
  "Value" :: slice.T byteT
].

(* doesn't include the operation type *)
Definition EncodePutRequest: val :=
  rec: "EncodePutRequest" "args" :=
    let: "num_bytes" := std.SumAssumeNoOverflow (#8 + #8 + #8 + #8) (slice.len (struct.loadF PutRequest "Value" "args")) in
    let: "e" := marshal.NewEnc "num_bytes" in
    marshal.Enc__PutInt "e" (struct.loadF PutRequest "CID" "args");;
    marshal.Enc__PutInt "e" (struct.loadF PutRequest "Seq" "args");;
    marshal.Enc__PutInt "e" (struct.loadF PutRequest "Key" "args");;
    marshal.Enc__PutInt "e" (slice.len (struct.loadF PutRequest "Value" "args"));;
    marshal.Enc__PutBytes "e" (struct.loadF PutRequest "Value" "args");;
    marshal.Enc__Finish "e".

Definition DecodePutRequest: val :=
  rec: "DecodePutRequest" "reqData" :=
    let: "req" := struct.alloc PutRequest (zero_val (struct.t PutRequest)) in
    let: "d" := marshal.NewDec "reqData" in
    struct.storeF PutRequest "CID" "req" (marshal.Dec__GetInt "d");;
    struct.storeF PutRequest "Seq" "req" (marshal.Dec__GetInt "d");;
    struct.storeF PutRequest "Key" "req" (marshal.Dec__GetInt "d");;
    struct.storeF PutRequest "Value" "req" (marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d"));;
    "req".

Definition PutReply := struct.decl [
  "Err" :: ErrorType
].

Definition EncodePutReply: val :=
  rec: "EncodePutReply" "reply" :=
    let: "e" := marshal.NewEnc #8 in
    marshal.Enc__PutInt "e" (struct.loadF PutReply "Err" "reply");;
    marshal.Enc__Finish "e".

Definition DecodePutReply: val :=
  rec: "DecodePutReply" "replyData" :=
    let: "reply" := struct.alloc PutReply (zero_val (struct.t PutReply)) in
    let: "d" := marshal.NewDec "replyData" in
    struct.storeF PutReply "Err" "reply" (marshal.Dec__GetInt "d");;
    "reply".

Definition GetRequest := struct.decl [
  "CID" :: uint64T;
  "Seq" :: uint64T;
  "Key" :: uint64T
].

Definition GetReply := struct.decl [
  "Err" :: ErrorType;
  "Value" :: slice.T byteT
].

Definition EncodeGetRequest: val :=
  rec: "EncodeGetRequest" "req" :=
    let: "e" := marshal.NewEnc (#3 * #8) in
    marshal.Enc__PutInt "e" (struct.loadF GetRequest "CID" "req");;
    marshal.Enc__PutInt "e" (struct.loadF GetRequest "Seq" "req");;
    marshal.Enc__PutInt "e" (struct.loadF GetRequest "Key" "req");;
    marshal.Enc__Finish "e".

Definition DecodeGetRequest: val :=
  rec: "DecodeGetRequest" "rawReq" :=
    let: "req" := struct.alloc GetRequest (zero_val (struct.t GetRequest)) in
    let: "d" := marshal.NewDec "rawReq" in
    struct.storeF GetRequest "CID" "req" (marshal.Dec__GetInt "d");;
    struct.storeF GetRequest "Seq" "req" (marshal.Dec__GetInt "d");;
    struct.storeF GetRequest "Key" "req" (marshal.Dec__GetInt "d");;
    "req".

Definition EncodeGetReply: val :=
  rec: "EncodeGetReply" "rep" :=
    let: "num_bytes" := std.SumAssumeNoOverflow (#8 + #8) (slice.len (struct.loadF GetReply "Value" "rep")) in
    let: "e" := marshal.NewEnc "num_bytes" in
    marshal.Enc__PutInt "e" (struct.loadF GetReply "Err" "rep");;
    marshal.Enc__PutInt "e" (slice.len (struct.loadF GetReply "Value" "rep"));;
    marshal.Enc__PutBytes "e" (struct.loadF GetReply "Value" "rep");;
    marshal.Enc__Finish "e".

Definition DecodeGetReply: val :=
  rec: "DecodeGetReply" "rawRep" :=
    let: "rep" := struct.alloc GetReply (zero_val (struct.t GetReply)) in
    let: "d" := marshal.NewDec "rawRep" in
    struct.storeF GetReply "Err" "rep" (marshal.Dec__GetInt "d");;
    struct.storeF GetReply "Value" "rep" (marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d"));;
    "rep".

Definition ConditionalPutRequest := struct.decl [
  "CID" :: uint64T;
  "Seq" :: uint64T;
  "Key" :: uint64T;
  "ExpectedValue" :: slice.T byteT;
  "NewValue" :: slice.T byteT
].

Definition ConditionalPutReply := struct.decl [
  "Err" :: ErrorType;
  "Success" :: boolT
].

Definition EncodeConditionalPutRequest: val :=
  rec: "EncodeConditionalPutRequest" "req" :=
    let: "num_bytes" := std.SumAssumeNoOverflow (#8 + #8 + #8 + #8 + #8) (std.SumAssumeNoOverflow (slice.len (struct.loadF ConditionalPutRequest "ExpectedValue" "req")) (slice.len (struct.loadF ConditionalPutRequest "NewValue" "req"))) in
    let: "e" := marshal.NewEnc "num_bytes" in
    marshal.Enc__PutInt "e" (struct.loadF ConditionalPutRequest "CID" "req");;
    marshal.Enc__PutInt "e" (struct.loadF ConditionalPutRequest "Seq" "req");;
    marshal.Enc__PutInt "e" (struct.loadF ConditionalPutRequest "Key" "req");;
    marshal.Enc__PutInt "e" (slice.len (struct.loadF ConditionalPutRequest "ExpectedValue" "req"));;
    marshal.Enc__PutBytes "e" (struct.loadF ConditionalPutRequest "ExpectedValue" "req");;
    marshal.Enc__PutInt "e" (slice.len (struct.loadF ConditionalPutRequest "NewValue" "req"));;
    marshal.Enc__PutBytes "e" (struct.loadF ConditionalPutRequest "NewValue" "req");;
    marshal.Enc__Finish "e".

Definition DecodeConditionalPutRequest: val :=
  rec: "DecodeConditionalPutRequest" "rawReq" :=
    let: "req" := struct.alloc ConditionalPutRequest (zero_val (struct.t ConditionalPutRequest)) in
    let: "d" := marshal.NewDec "rawReq" in
    struct.storeF ConditionalPutRequest "CID" "req" (marshal.Dec__GetInt "d");;
    struct.storeF ConditionalPutRequest "Seq" "req" (marshal.Dec__GetInt "d");;
    struct.storeF ConditionalPutRequest "Key" "req" (marshal.Dec__GetInt "d");;
    struct.storeF ConditionalPutRequest "ExpectedValue" "req" (marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d"));;
    struct.storeF ConditionalPutRequest "NewValue" "req" (marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d"));;
    "req".

Definition EncodeConditionalPutReply: val :=
  rec: "EncodeConditionalPutReply" "reply" :=
    let: "e" := marshal.NewEnc (#8 + #1) in
    marshal.Enc__PutInt "e" (struct.loadF ConditionalPutReply "Err" "reply");;
    marshal.Enc__PutBool "e" (struct.loadF ConditionalPutReply "Success" "reply");;
    marshal.Enc__Finish "e".

Definition DecodeConditionalPutReply: val :=
  rec: "DecodeConditionalPutReply" "replyData" :=
    let: "reply" := struct.alloc ConditionalPutReply (zero_val (struct.t ConditionalPutReply)) in
    let: "d" := marshal.NewDec "replyData" in
    struct.storeF ConditionalPutReply "Err" "reply" (marshal.Dec__GetInt "d");;
    struct.storeF ConditionalPutReply "Success" "reply" (marshal.Dec__GetBool "d");;
    "reply".

Definition InstallShardRequest := struct.decl [
  "CID" :: uint64T;
  "Seq" :: uint64T;
  "Sid" :: uint64T;
  "Kvs" :: mapT (slice.T byteT)
].

(* NOTE: probably can just amortize this by keeping track of this with the map itself *)
Definition SizeOfMarshalledMap: val :=
  rec: "SizeOfMarshalledMap" "m" :=
    let: "s" := ref (zero_val uint64T) in
    "s" <-[uint64T] #8;;
    MapIter "m" (λ: <> "value",
      let: "v" := std.SumAssumeNoOverflow (slice.len "value") (#8 + #8) in
      "s" <-[uint64T] std.SumAssumeNoOverflow (![uint64T] "s") "v");;
    ![uint64T] "s".

Definition EncSliceMap: val :=
  rec: "EncSliceMap" "e" "m" :=
    marshal.Enc__PutInt "e" (MapLen "m");;
    MapIter "m" (λ: "key" "value",
      marshal.Enc__PutInt "e" "key";;
      marshal.Enc__PutInt "e" (slice.len "value");;
      marshal.Enc__PutBytes "e" "value");;
    #().

Definition DecSliceMap: val :=
  rec: "DecSliceMap" "d" :=
    let: "sz" := marshal.Dec__GetInt "d" in
    let: "m" := NewMap (slice.T byteT) #() in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, ![uint64T] "i" < "sz"); (λ: <>, Skip) := λ: <>,
      let: "k" := marshal.Dec__GetInt "d" in
      let: "v" := marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d") in
      MapInsert "m" "k" "v";;
      "i" <-[uint64T] ![uint64T] "i" + #1;;
      Continue);;
    "m".

Definition encodeInstallShardRequest: val :=
  rec: "encodeInstallShardRequest" "req" :=
    let: "num_bytes" := std.SumAssumeNoOverflow (#8 + #8 + #8) (SizeOfMarshalledMap (struct.loadF InstallShardRequest "Kvs" "req")) in
    let: "e" := marshal.NewEnc "num_bytes" in
    marshal.Enc__PutInt "e" (struct.loadF InstallShardRequest "CID" "req");;
    marshal.Enc__PutInt "e" (struct.loadF InstallShardRequest "Seq" "req");;
    marshal.Enc__PutInt "e" (struct.loadF InstallShardRequest "Sid" "req");;
    EncSliceMap "e" (struct.loadF InstallShardRequest "Kvs" "req");;
    marshal.Enc__Finish "e".

Definition decodeInstallShardRequest: val :=
  rec: "decodeInstallShardRequest" "rawReq" :=
    let: "d" := marshal.NewDec "rawReq" in
    let: "req" := struct.alloc InstallShardRequest (zero_val (struct.t InstallShardRequest)) in
    struct.storeF InstallShardRequest "CID" "req" (marshal.Dec__GetInt "d");;
    struct.storeF InstallShardRequest "Seq" "req" (marshal.Dec__GetInt "d");;
    struct.storeF InstallShardRequest "Sid" "req" (marshal.Dec__GetInt "d");;
    struct.storeF InstallShardRequest "Kvs" "req" (DecSliceMap "d");;
    "req".

Definition MoveShardRequest := struct.decl [
  "Sid" :: uint64T;
  "Dst" :: HostName
].

Definition encodeMoveShardRequest: val :=
  rec: "encodeMoveShardRequest" "req" :=
    let: "e" := marshal.NewEnc (#8 + #8) in
    marshal.Enc__PutInt "e" (struct.loadF MoveShardRequest "Sid" "req");;
    marshal.Enc__PutInt "e" (struct.loadF MoveShardRequest "Dst" "req");;
    marshal.Enc__Finish "e".

Definition decodeMoveShardRequest: val :=
  rec: "decodeMoveShardRequest" "rawReq" :=
    let: "req" := struct.alloc MoveShardRequest (zero_val (struct.t MoveShardRequest)) in
    let: "d" := marshal.NewDec "rawReq" in
    struct.storeF MoveShardRequest "Sid" "req" (marshal.Dec__GetInt "d");;
    struct.storeF MoveShardRequest "Dst" "req" (marshal.Dec__GetInt "d");;
    "req".

(* FIXME: these should just be in goose std or something *)
Definition EncodeUint64: val :=
  rec: "EncodeUint64" "i" :=
    let: "e" := marshal.NewEnc #8 in
    marshal.Enc__PutInt "e" "i";;
    marshal.Enc__Finish "e".

Definition DecodeUint64: val :=
  rec: "DecodeUint64" "raw" :=
    marshal.Dec__GetInt (marshal.NewDec "raw").

Definition encodeShardMap: val :=
  rec: "encodeShardMap" "shardMap" :=
    let: "e" := marshal.NewEnc (#8 * NSHARD) in
    marshal.Enc__PutInts "e" (![slice.T uint64T] "shardMap");;
    marshal.Enc__Finish "e".

Definition decodeShardMap: val :=
  rec: "decodeShardMap" "raw" :=
    let: "d" := marshal.NewDec "raw" in
    marshal.Dec__GetInts "d" NSHARD.

(* 1_memkv_shard_clerk.go *)

Definition KVShardClerk := struct.decl [
  "seq" :: uint64T;
  "cid" :: uint64T;
  "host" :: HostName;
  "c" :: struct.ptrT connman.ConnMan
].

Definition MakeFreshKVShardClerk: val :=
  rec: "MakeFreshKVShardClerk" "host" "c" :=
    let: "ck" := struct.alloc KVShardClerk (zero_val (struct.t KVShardClerk)) in
    struct.storeF KVShardClerk "host" "ck" "host";;
    struct.storeF KVShardClerk "c" "ck" "c";;
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") "host" KV_FRESHCID (NewSlice byteT #0) "rawRep" #100;;
    struct.storeF KVShardClerk "cid" "ck" (DecodeUint64 (![slice.T byteT] "rawRep"));;
    struct.storeF KVShardClerk "seq" "ck" #1;;
    "ck".

Definition KVShardClerk__Put: val :=
  rec: "KVShardClerk__Put" "ck" "key" "value" :=
    let: "args" := struct.alloc PutRequest (zero_val (struct.t PutRequest)) in
    struct.storeF PutRequest "CID" "args" (struct.loadF KVShardClerk "cid" "ck");;
    struct.storeF PutRequest "Seq" "args" (struct.loadF KVShardClerk "seq" "ck");;
    struct.storeF PutRequest "Key" "args" "key";;
    struct.storeF PutRequest "Value" "args" "value";;
    struct.storeF KVShardClerk "seq" "ck" (std.SumAssumeNoOverflow (struct.loadF KVShardClerk "seq" "ck") #1);;
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_PUT (EncodePutRequest "args") "rawRep" #100;;
    let: "rep" := DecodePutReply (![slice.T byteT] "rawRep") in
    struct.loadF PutReply "Err" "rep".

Definition KVShardClerk__Get: val :=
  rec: "KVShardClerk__Get" "ck" "key" "value" :=
    let: "args" := struct.alloc GetRequest (zero_val (struct.t GetRequest)) in
    struct.storeF GetRequest "CID" "args" (struct.loadF KVShardClerk "cid" "ck");;
    struct.storeF GetRequest "Seq" "args" (struct.loadF KVShardClerk "seq" "ck");;
    struct.storeF GetRequest "Key" "args" "key";;
    struct.storeF KVShardClerk "seq" "ck" (std.SumAssumeNoOverflow (struct.loadF KVShardClerk "seq" "ck") #1);;
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_GET (EncodeGetRequest "args") "rawRep" #100;;
    let: "rep" := DecodeGetReply (![slice.T byteT] "rawRep") in
    "value" <-[slice.T byteT] struct.loadF GetReply "Value" "rep";;
    struct.loadF GetReply "Err" "rep".

Definition KVShardClerk__ConditionalPut: val :=
  rec: "KVShardClerk__ConditionalPut" "ck" "key" "expectedValue" "newValue" "success" :=
    let: "args" := struct.alloc ConditionalPutRequest (zero_val (struct.t ConditionalPutRequest)) in
    struct.storeF ConditionalPutRequest "CID" "args" (struct.loadF KVShardClerk "cid" "ck");;
    struct.storeF ConditionalPutRequest "Seq" "args" (struct.loadF KVShardClerk "seq" "ck");;
    struct.storeF ConditionalPutRequest "Key" "args" "key";;
    struct.storeF ConditionalPutRequest "ExpectedValue" "args" "expectedValue";;
    struct.storeF ConditionalPutRequest "NewValue" "args" "newValue";;
    struct.storeF KVShardClerk "seq" "ck" (std.SumAssumeNoOverflow (struct.loadF KVShardClerk "seq" "ck") #1);;
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_CONDITIONAL_PUT (EncodeConditionalPutRequest "args") "rawRep" #100;;
    let: "rep" := DecodeConditionalPutReply (![slice.T byteT] "rawRep") in
    "success" <-[boolT] struct.loadF ConditionalPutReply "Success" "rep";;
    struct.loadF ConditionalPutReply "Err" "rep".

Definition KVShardClerk__InstallShard: val :=
  rec: "KVShardClerk__InstallShard" "ck" "sid" "kvs" :=
    let: "args" := struct.alloc InstallShardRequest (zero_val (struct.t InstallShardRequest)) in
    struct.storeF InstallShardRequest "CID" "args" (struct.loadF KVShardClerk "cid" "ck");;
    struct.storeF InstallShardRequest "Seq" "args" (struct.loadF KVShardClerk "seq" "ck");;
    struct.storeF InstallShardRequest "Sid" "args" "sid";;
    struct.storeF InstallShardRequest "Kvs" "args" "kvs";;
    struct.storeF KVShardClerk "seq" "ck" (std.SumAssumeNoOverflow (struct.loadF KVShardClerk "seq" "ck") #1);;
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_INS_SHARD (encodeInstallShardRequest "args") "rawRep" #100;;
    #().

Definition KVShardClerk__MoveShard: val :=
  rec: "KVShardClerk__MoveShard" "ck" "sid" "dst" :=
    let: "args" := struct.alloc MoveShardRequest (zero_val (struct.t MoveShardRequest)) in
    struct.storeF MoveShardRequest "Sid" "args" "sid";;
    struct.storeF MoveShardRequest "Dst" "args" "dst";;
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_MOV_SHARD (encodeMoveShardRequest "args") "rawRep" #100;;
    #().

(* The coordinator, and the main clerk, need to talk to a bunch of shards. *)
Definition ShardClerkSet := struct.decl [
  "cls" :: mapT (struct.ptrT KVShardClerk);
  "c" :: struct.ptrT connman.ConnMan
].

Definition MakeShardClerkSet: val :=
  rec: "MakeShardClerkSet" "c" :=
    struct.new ShardClerkSet [
      "cls" ::= NewMap (struct.ptrT KVShardClerk) #();
      "c" ::= "c"
    ].

Definition ShardClerkSet__GetClerk: val :=
  rec: "ShardClerkSet__GetClerk" "s" "host" :=
    let: ("ck", "ok") := MapGet (struct.loadF ShardClerkSet "cls" "s") "host" in
    (if: ~ "ok"
    then
      let: "ck2" := MakeFreshKVShardClerk "host" (struct.loadF ShardClerkSet "c" "s") in
      MapInsert (struct.loadF ShardClerkSet "cls" "s") "host" "ck2";;
      "ck2"
    else "ck").

(* 2_memkv_shard.go *)

Definition KvMap: ty := mapT (slice.T byteT).

Definition KVShardServer := struct.decl [
  "me" :: stringT;
  "mu" :: lockRefT;
  "lastReply" :: mapT (struct.t ShardReply);
  "lastSeq" :: mapT uint64T;
  "nextCID" :: uint64T;
  "shardMap" :: slice.T boolT;
  "kvss" :: slice.T KvMap;
  "peers" :: mapT (struct.ptrT KVShardClerk);
  "cm" :: struct.ptrT connman.ConnMan
].

Definition PutArgs := struct.decl [
  "Key" :: uint64T;
  "Value" :: ValueType
].

Definition KVShardServer__put_inner: val :=
  rec: "KVShardServer__put_inner" "s" "args" "reply" :=
    let: ("last", "ok") := MapGet (struct.loadF KVShardServer "lastSeq" "s") (struct.loadF PutRequest "CID" "args") in
    let: "seq" := struct.loadF PutRequest "Seq" "args" in
    (if: "ok" && ("seq" ≤ "last")
    then
      struct.storeF PutReply "Err" "reply" (struct.get ShardReply "Err" (Fst (MapGet (struct.loadF KVShardServer "lastReply" "s") (struct.loadF PutRequest "CID" "args"))));;
      #()
    else
      MapInsert (struct.loadF KVShardServer "lastSeq" "s") (struct.loadF PutRequest "CID" "args") (struct.loadF PutRequest "Seq" "args");;
      let: "sid" := shardOf (struct.loadF PutRequest "Key" "args") in
      (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" "s") "sid" = #true)
      then
        MapInsert (SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") "sid") (struct.loadF PutRequest "Key" "args") (struct.loadF PutRequest "Value" "args");;
        struct.storeF PutReply "Err" "reply" ENone
      else struct.storeF PutReply "Err" "reply" EDontHaveShard);;
      MapInsert (struct.loadF KVShardServer "lastReply" "s") (struct.loadF PutRequest "CID" "args") (struct.mk ShardReply [
        "Err" ::= struct.loadF PutReply "Err" "reply"
      ]);;
      #()).

Definition KVShardServer__PutRPC: val :=
  rec: "KVShardServer__PutRPC" "s" "args" "reply" :=
    lock.acquire (struct.loadF KVShardServer "mu" "s");;
    KVShardServer__put_inner "s" "args" "reply";;
    lock.release (struct.loadF KVShardServer "mu" "s");;
    #().

Definition KVShardServer__get_inner: val :=
  rec: "KVShardServer__get_inner" "s" "args" "reply" :=
    let: ("last", "ok") := MapGet (struct.loadF KVShardServer "lastSeq" "s") (struct.loadF GetRequest "CID" "args") in
    let: "seq" := struct.loadF GetRequest "Seq" "args" in
    (if: "ok" && ("seq" ≤ "last")
    then
      let: "lastReply" := Fst (MapGet (struct.loadF KVShardServer "lastReply" "s") (struct.loadF GetRequest "CID" "args")) in
      struct.storeF GetReply "Err" "reply" (struct.get ShardReply "Err" "lastReply");;
      struct.storeF GetReply "Value" "reply" (struct.get ShardReply "Value" "lastReply");;
      #()
    else
      MapInsert (struct.loadF KVShardServer "lastSeq" "s") (struct.loadF GetRequest "CID" "args") (struct.loadF GetRequest "Seq" "args");;
      let: "sid" := shardOf (struct.loadF GetRequest "Key" "args") in
      (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" "s") "sid" = #true)
      then
        struct.storeF GetReply "Value" "reply" (Fst (MapGet (SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") "sid") (struct.loadF GetRequest "Key" "args")));;
        struct.storeF GetReply "Err" "reply" ENone
      else struct.storeF GetReply "Err" "reply" EDontHaveShard);;
      MapInsert (struct.loadF KVShardServer "lastReply" "s") (struct.loadF GetRequest "CID" "args") (struct.mk ShardReply [
        "Err" ::= struct.loadF GetReply "Err" "reply";
        "Value" ::= struct.loadF GetReply "Value" "reply"
      ]);;
      #()).

Definition KVShardServer__GetRPC: val :=
  rec: "KVShardServer__GetRPC" "s" "args" "reply" :=
    lock.acquire (struct.loadF KVShardServer "mu" "s");;
    KVShardServer__get_inner "s" "args" "reply";;
    lock.release (struct.loadF KVShardServer "mu" "s");;
    #().

Definition KVShardServer__conditional_put_inner: val :=
  rec: "KVShardServer__conditional_put_inner" "s" "args" "reply" :=
    let: ("last", "ok") := MapGet (struct.loadF KVShardServer "lastSeq" "s") (struct.loadF ConditionalPutRequest "CID" "args") in
    let: "seq" := struct.loadF ConditionalPutRequest "Seq" "args" in
    (if: "ok" && ("seq" ≤ "last")
    then
      let: "lastReply" := Fst (MapGet (struct.loadF KVShardServer "lastReply" "s") (struct.loadF ConditionalPutRequest "CID" "args")) in
      struct.storeF ConditionalPutReply "Err" "reply" (struct.get ShardReply "Err" "lastReply");;
      struct.storeF ConditionalPutReply "Success" "reply" (struct.get ShardReply "Success" "lastReply");;
      #()
    else
      MapInsert (struct.loadF KVShardServer "lastSeq" "s") (struct.loadF ConditionalPutRequest "CID" "args") (struct.loadF ConditionalPutRequest "Seq" "args");;
      let: "sid" := shardOf (struct.loadF ConditionalPutRequest "Key" "args") in
      (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" "s") "sid" = #true)
      then
        let: "m" := SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") "sid" in
        let: "equal" := std.BytesEqual (struct.loadF ConditionalPutRequest "ExpectedValue" "args") (Fst (MapGet "m" (struct.loadF ConditionalPutRequest "Key" "args"))) in
        (if: "equal"
        then MapInsert "m" (struct.loadF ConditionalPutRequest "Key" "args") (struct.loadF ConditionalPutRequest "NewValue" "args")
        else #());;
        struct.storeF ConditionalPutReply "Success" "reply" "equal";;
        struct.storeF ConditionalPutReply "Err" "reply" ENone
      else struct.storeF ConditionalPutReply "Err" "reply" EDontHaveShard);;
      MapInsert (struct.loadF KVShardServer "lastReply" "s") (struct.loadF ConditionalPutRequest "CID" "args") (struct.mk ShardReply [
        "Err" ::= struct.loadF ConditionalPutReply "Err" "reply";
        "Success" ::= struct.loadF ConditionalPutReply "Success" "reply"
      ]);;
      #()).

Definition KVShardServer__ConditionalPutRPC: val :=
  rec: "KVShardServer__ConditionalPutRPC" "s" "args" "reply" :=
    lock.acquire (struct.loadF KVShardServer "mu" "s");;
    KVShardServer__conditional_put_inner "s" "args" "reply";;
    lock.release (struct.loadF KVShardServer "mu" "s");;
    #().

(* NOTE: easy to do a little optimization with shard migration:
   add a "RemoveShard" rpc, which removes the shard on the target server, and
   returns half of the ghost state for that shard. Meanwhile, InstallShard()
   will only grant half the ghost state, and physical state will keep track of
   the fact that the shard is only good for read-only operations up until that
   flag is updated (i.e. until RemoveShard() is run). *)
Definition KVShardServer__install_shard_inner: val :=
  rec: "KVShardServer__install_shard_inner" "s" "args" :=
    let: ("last", "ok") := MapGet (struct.loadF KVShardServer "lastSeq" "s") (struct.loadF InstallShardRequest "CID" "args") in
    let: "seq" := struct.loadF InstallShardRequest "Seq" "args" in
    (if: "ok" && ("seq" ≤ "last")
    then #()
    else
      MapInsert (struct.loadF KVShardServer "lastSeq" "s") (struct.loadF InstallShardRequest "CID" "args") (struct.loadF InstallShardRequest "Seq" "args");;
      SliceSet boolT (struct.loadF KVShardServer "shardMap" "s") (struct.loadF InstallShardRequest "Sid" "args") #true;;
      SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") (struct.loadF InstallShardRequest "Sid" "args") (struct.loadF InstallShardRequest "Kvs" "args");;
      MapInsert (struct.loadF KVShardServer "lastReply" "s") (struct.loadF InstallShardRequest "CID" "args") (struct.mk ShardReply [
        "Err" ::= #0;
        "Value" ::= slice.nil
      ]);;
      #()).

Definition KVShardServer__InstallShardRPC: val :=
  rec: "KVShardServer__InstallShardRPC" "s" "args" :=
    lock.acquire (struct.loadF KVShardServer "mu" "s");;
    KVShardServer__install_shard_inner "s" "args";;
    lock.release (struct.loadF KVShardServer "mu" "s");;
    #().

Definition KVShardServer__MoveShardRPC: val :=
  rec: "KVShardServer__MoveShardRPC" "s" "args" :=
    lock.acquire (struct.loadF KVShardServer "mu" "s");;
    let: (<>, "ok") := MapGet (struct.loadF KVShardServer "peers" "s") (struct.loadF MoveShardRequest "Dst" "args") in
    (if: ~ "ok"
    then
      let: "ck" := MakeFreshKVShardClerk (struct.loadF MoveShardRequest "Dst" "args") (struct.loadF KVShardServer "cm" "s") in
      MapInsert (struct.loadF KVShardServer "peers" "s") (struct.loadF MoveShardRequest "Dst" "args") "ck"
    else #());;
    (if: ~ (SliceGet boolT (struct.loadF KVShardServer "shardMap" "s") (struct.loadF MoveShardRequest "Sid" "args"))
    then
      lock.release (struct.loadF KVShardServer "mu" "s");;
      #()
    else
      let: "kvs" := SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") (struct.loadF MoveShardRequest "Sid" "args") in
      SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") (struct.loadF MoveShardRequest "Sid" "args") (NewMap (slice.T byteT) #());;
      SliceSet boolT (struct.loadF KVShardServer "shardMap" "s") (struct.loadF MoveShardRequest "Sid" "args") #false;;
      KVShardClerk__InstallShard (Fst (MapGet (struct.loadF KVShardServer "peers" "s") (struct.loadF MoveShardRequest "Dst" "args"))) (struct.loadF MoveShardRequest "Sid" "args") "kvs";;
      lock.release (struct.loadF KVShardServer "mu" "s");;
      #()).

Definition MakeKVShardServer: val :=
  rec: "MakeKVShardServer" "is_init" :=
    let: "srv" := struct.alloc KVShardServer (zero_val (struct.t KVShardServer)) in
    struct.storeF KVShardServer "mu" "srv" (lock.new #());;
    struct.storeF KVShardServer "lastReply" "srv" (NewMap (struct.t ShardReply) #());;
    struct.storeF KVShardServer "lastSeq" "srv" (NewMap uint64T #());;
    struct.storeF KVShardServer "shardMap" "srv" (NewSlice boolT NSHARD);;
    struct.storeF KVShardServer "kvss" "srv" (NewSlice KvMap NSHARD);;
    struct.storeF KVShardServer "peers" "srv" (NewMap (struct.ptrT KVShardClerk) #());;
    struct.storeF KVShardServer "cm" "srv" (connman.MakeConnMan #());;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "i" < NSHARD); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
      SliceSet boolT (struct.loadF KVShardServer "shardMap" "srv") (![uint64T] "i") "is_init";;
      (if: "is_init"
      then
        SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "srv") (![uint64T] "i") (NewMap (slice.T byteT) #());;
        Continue
      else Continue));;
    "srv".

Definition KVShardServer__GetCIDRPC: val :=
  rec: "KVShardServer__GetCIDRPC" "s" :=
    lock.acquire (struct.loadF KVShardServer "mu" "s");;
    let: "r" := struct.loadF KVShardServer "nextCID" "s" in
    std.SumAssumeNoOverflow (struct.loadF KVShardServer "nextCID" "s") #1;;
    struct.storeF KVShardServer "nextCID" "s" (struct.loadF KVShardServer "nextCID" "s" + #1);;
    lock.release (struct.loadF KVShardServer "mu" "s");;
    "r".

Definition KVShardServer__Start: val :=
  rec: "KVShardServer__Start" "mkv" "host" :=
    let: "handlers" := NewMap ((slice.T byteT -> refT (slice.T byteT) -> unitT)%ht) #() in
    MapInsert "handlers" KV_FRESHCID (λ: "rawReq" "rawReply",
      "rawReply" <-[slice.T byteT] EncodeUint64 (KVShardServer__GetCIDRPC "mkv");;
      #()
      );;
    MapInsert "handlers" KV_PUT (λ: "rawReq" "rawReply",
      let: "rep" := struct.alloc PutReply (zero_val (struct.t PutReply)) in
      KVShardServer__PutRPC "mkv" (DecodePutRequest "rawReq") "rep";;
      "rawReply" <-[slice.T byteT] EncodePutReply "rep";;
      #()
      );;
    MapInsert "handlers" KV_GET (λ: "rawReq" "rawReply",
      let: "rep" := struct.alloc GetReply (zero_val (struct.t GetReply)) in
      KVShardServer__GetRPC "mkv" (DecodeGetRequest "rawReq") "rep";;
      "rawReply" <-[slice.T byteT] EncodeGetReply "rep";;
      #()
      );;
    MapInsert "handlers" KV_CONDITIONAL_PUT (λ: "rawReq" "rawReply",
      let: "rep" := struct.alloc ConditionalPutReply (zero_val (struct.t ConditionalPutReply)) in
      KVShardServer__ConditionalPutRPC "mkv" (DecodeConditionalPutRequest "rawReq") "rep";;
      "rawReply" <-[slice.T byteT] EncodeConditionalPutReply "rep";;
      #()
      );;
    MapInsert "handlers" KV_INS_SHARD (λ: "rawReq" "rawReply",
      KVShardServer__InstallShardRPC "mkv" (decodeInstallShardRequest "rawReq");;
      "rawReply" <-[slice.T byteT] NewSlice byteT #0;;
      #()
      );;
    MapInsert "handlers" KV_MOV_SHARD (λ: "rawReq" "rawReply",
      KVShardServer__MoveShardRPC "mkv" (decodeMoveShardRequest "rawReq");;
      "rawReply" <-[slice.T byteT] NewSlice byteT #0;;
      #()
      );;
    let: "s" := rpc.MakeRPCServer "handlers" in
    rpc.RPCServer__Serve "s" "host" #1;;
    #().

(* 3_memkv_coord.go *)

Definition COORD_ADD : expr := #1.

Definition COORD_GET : expr := #2.

Definition KVCoord := struct.decl [
  "mu" :: lockRefT;
  "shardMap" :: slice.T HostName;
  "hostShards" :: mapT uint64T;
  "shardClerks" :: struct.ptrT ShardClerkSet
].

Definition KVCoord__AddServerRPC: val :=
  rec: "KVCoord__AddServerRPC" "c" "newhost" :=
    lock.acquire (struct.loadF KVCoord "mu" "c");;
    (* log.Printf("Rebalancing\n") *)
    MapInsert (struct.loadF KVCoord "hostShards" "c") "newhost" #0;;
    let: "numHosts" := MapLen (struct.loadF KVCoord "hostShards" "c") in
    let: "numShardFloor" := NSHARD `quot` "numHosts" in
    let: "numShardCeil" := NSHARD `quot` "numHosts" + #1 in
    let: "nf_left" := ref (zero_val uint64T) in
    "nf_left" <-[uint64T] "numHosts" - NSHARD - ("numHosts" * NSHARD) `quot` "numHosts";;
    ForSlice uint64T "sid" "host" (struct.loadF KVCoord "shardMap" "c")
      (let: "n" := Fst (MapGet (struct.loadF KVCoord "hostShards" "c") "host") in
      (if: "n" > "numShardFloor"
      then
        (if: ("n" = "numShardCeil")
        then
          (if: ![uint64T] "nf_left" > #0
          then
            "nf_left" <-[uint64T] ![uint64T] "nf_left" - #1;;
            KVShardClerk__MoveShard (ShardClerkSet__GetClerk (struct.loadF KVCoord "shardClerks" "c") "host") "sid" "newhost";;
            MapInsert (struct.loadF KVCoord "hostShards" "c") "host" ("n" - #1);;
            MapInsert (struct.loadF KVCoord "hostShards" "c") "newhost" (Fst (MapGet (struct.loadF KVCoord "hostShards" "c") "newhost") + #1);;
            SliceSet uint64T (struct.loadF KVCoord "shardMap" "c") "sid" "newhost"
          else #())
        else
          KVShardClerk__MoveShard (ShardClerkSet__GetClerk (struct.loadF KVCoord "shardClerks" "c") "host") "sid" "newhost";;
          MapInsert (struct.loadF KVCoord "hostShards" "c") "host" ("n" - #1);;
          MapInsert (struct.loadF KVCoord "hostShards" "c") "newhost" (Fst (MapGet (struct.loadF KVCoord "hostShards" "c") "newhost") + #1);;
          SliceSet uint64T (struct.loadF KVCoord "shardMap" "c") "sid" "newhost")
      else #()));;
    (* log.Println("Done rebalancing") *)
    (* log.Printf("%+v", c.hostShards) *)
    lock.release (struct.loadF KVCoord "mu" "c");;
    #().

Definition KVCoord__GetShardMapRPC: val :=
  rec: "KVCoord__GetShardMapRPC" "c" <> "rep" :=
    lock.acquire (struct.loadF KVCoord "mu" "c");;
    "rep" <-[slice.T byteT] encodeShardMap (struct.fieldRef KVCoord "shardMap" "c");;
    lock.release (struct.loadF KVCoord "mu" "c");;
    #().

Definition MakeKVCoordServer: val :=
  rec: "MakeKVCoordServer" "initserver" :=
    let: "s" := struct.alloc KVCoord (zero_val (struct.t KVCoord)) in
    struct.storeF KVCoord "mu" "s" (lock.new #());;
    struct.storeF KVCoord "shardMap" "s" (NewSlice HostName NSHARD);;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "i" < NSHARD); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
      SliceSet uint64T (struct.loadF KVCoord "shardMap" "s") (![uint64T] "i") "initserver";;
      Continue);;
    struct.storeF KVCoord "hostShards" "s" (NewMap uint64T #());;
    MapInsert (struct.loadF KVCoord "hostShards" "s") "initserver" NSHARD;;
    struct.storeF KVCoord "shardClerks" "s" (MakeShardClerkSet (connman.MakeConnMan #()));;
    "s".

Definition KVCoord__Start: val :=
  rec: "KVCoord__Start" "c" "host" :=
    let: "handlers" := NewMap ((slice.T byteT -> refT (slice.T byteT) -> unitT)%ht) #() in
    MapInsert "handlers" COORD_ADD (λ: "rawReq" "rawRep",
      let: "s" := DecodeUint64 "rawReq" in
      KVCoord__AddServerRPC "c" "s";;
      #()
      );;
    MapInsert "handlers" COORD_GET (KVCoord__GetShardMapRPC "c");;
    let: "s" := rpc.MakeRPCServer "handlers" in
    rpc.RPCServer__Serve "s" "host" #1;;
    #().

(* 4_memkv_seq_clerk.go *)

Definition KVCoordClerk := struct.decl [
  "host" :: HostName;
  "c" :: struct.ptrT connman.ConnMan
].

Definition KVCoordClerk__AddShardServer: val :=
  rec: "KVCoordClerk__AddShardServer" "ck" "dst" :=
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVCoordClerk "c" "ck") (struct.loadF KVCoordClerk "host" "ck") COORD_ADD (EncodeUint64 "dst") "rawRep" #50000;;
    #().

Definition KVCoordClerk__GetShardMap: val :=
  rec: "KVCoordClerk__GetShardMap" "ck" :=
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVCoordClerk "c" "ck") (struct.loadF KVCoordClerk "host" "ck") COORD_GET (NewSlice byteT #0) "rawRep" #50000;;
    decodeShardMap (![slice.T byteT] "rawRep").

(* "Sequential" KV clerk, can only be used for one request at a time.
   NOTE: a single clerk keeps quite a bit of state, via the shardMap[], so it
   might be good to not need to duplicate shardMap[] for a pool of clerks that's
   safe for concurrent use *)
Definition SeqKVClerk := struct.decl [
  "shardClerks" :: struct.ptrT ShardClerkSet;
  "coordCk" :: struct.ptrT KVCoordClerk;
  "shardMap" :: slice.T HostName
].

Definition SeqKVClerk__Get: val :=
  rec: "SeqKVClerk__Get" "ck" "key" :=
    let: "val" := ref (zero_val (slice.T byteT)) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := shardOf "key" in
      let: "shardServer" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" "ck") "sid" in
      let: "shardCk" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" "ck") "shardServer" in
      let: "err" := KVShardClerk__Get "shardCk" "key" "val" in
      (if: ("err" = ENone)
      then Break
      else
        struct.storeF SeqKVClerk "shardMap" "ck" (KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" "ck"));;
        Continue));;
    ![slice.T byteT] "val".

Definition SeqKVClerk__Put: val :=
  rec: "SeqKVClerk__Put" "ck" "key" "value" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := shardOf "key" in
      let: "shardServer" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" "ck") "sid" in
      let: "shardCk" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" "ck") "shardServer" in
      let: "err" := KVShardClerk__Put "shardCk" "key" "value" in
      (if: ("err" = ENone)
      then Break
      else
        struct.storeF SeqKVClerk "shardMap" "ck" (KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" "ck"));;
        Continue));;
    #().

Definition SeqKVClerk__ConditionalPut: val :=
  rec: "SeqKVClerk__ConditionalPut" "ck" "key" "expectedValue" "newValue" :=
    let: "success" := ref (zero_val boolT) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := shardOf "key" in
      let: "shardServer" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" "ck") "sid" in
      let: "shardCk" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" "ck") "shardServer" in
      let: "err" := KVShardClerk__ConditionalPut "shardCk" "key" "expectedValue" "newValue" "success" in
      (if: ("err" = ENone)
      then Break
      else
        struct.storeF SeqKVClerk "shardMap" "ck" (KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" "ck"));;
        Continue));;
    ![boolT] "success".

Definition SeqKVClerk__Add: val :=
  rec: "SeqKVClerk__Add" "ck" "host" :=
    KVCoordClerk__AddShardServer (struct.loadF SeqKVClerk "coordCk" "ck") "host";;
    #().

Definition MakeSeqKVClerk: val :=
  rec: "MakeSeqKVClerk" "coord" "cm" :=
    let: "cck" := struct.alloc KVCoordClerk (zero_val (struct.t KVCoordClerk)) in
    let: "ck" := struct.alloc SeqKVClerk (zero_val (struct.t SeqKVClerk)) in
    struct.storeF SeqKVClerk "coordCk" "ck" "cck";;
    struct.storeF KVCoordClerk "host" (struct.loadF SeqKVClerk "coordCk" "ck") "coord";;
    struct.storeF KVCoordClerk "c" (struct.loadF SeqKVClerk "coordCk" "ck") "cm";;
    struct.storeF SeqKVClerk "shardClerks" "ck" (MakeShardClerkSet "cm");;
    struct.storeF SeqKVClerk "shardMap" "ck" (KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" "ck"));;
    "ck".

(* 5_memkv_clerk.go *)

Definition seqKVClerkPtr: ty := struct.ptrT SeqKVClerk.

Definition KVClerk := struct.decl [
  "mu" :: lockRefT;
  "freeClerks" :: slice.T seqKVClerkPtr;
  "cm" :: struct.ptrT connman.ConnMan;
  "coord" :: HostName
].

Definition KVClerk__getSeqClerk: val :=
  rec: "KVClerk__getSeqClerk" "p" :=
    lock.acquire (struct.loadF KVClerk "mu" "p");;
    let: "n" := slice.len (struct.loadF KVClerk "freeClerks" "p") in
    (if: ("n" = #0)
    then
      lock.release (struct.loadF KVClerk "mu" "p");;
      MakeSeqKVClerk (struct.loadF KVClerk "coord" "p") (connman.MakeConnMan #())
    else
      let: "ck" := SliceGet seqKVClerkPtr (struct.loadF KVClerk "freeClerks" "p") ("n" - #1) in
      struct.storeF KVClerk "freeClerks" "p" (SliceTake (struct.loadF KVClerk "freeClerks" "p") ("n" - #1));;
      lock.release (struct.loadF KVClerk "mu" "p");;
      "ck").

Definition KVClerk__putSeqClerk: val :=
  rec: "KVClerk__putSeqClerk" "p" "ck" :=
    Fork (lock.acquire (struct.loadF KVClerk "mu" "p");;
          struct.storeF KVClerk "freeClerks" "p" (SliceAppend seqKVClerkPtr (struct.loadF KVClerk "freeClerks" "p") "ck");;
          lock.release (struct.loadF KVClerk "mu" "p"));;
    #().

(* the hope is that after a while, the number of clerks needed to maintain a
   request rate for an open system benchmark will stabilize. *)
Definition KVClerk__Put: val :=
  rec: "KVClerk__Put" "p" "key" "value" :=
    let: "ck" := KVClerk__getSeqClerk "p" in
    SeqKVClerk__Put "ck" "key" "value";;
    KVClerk__putSeqClerk "p" "ck";;
    #().

Definition KVClerk__Get: val :=
  rec: "KVClerk__Get" "p" "key" :=
    let: "ck" := KVClerk__getSeqClerk "p" in
    let: "value" := SeqKVClerk__Get "ck" "key" in
    KVClerk__putSeqClerk "p" "ck";;
    "value".

Definition KVClerk__ConditionalPut: val :=
  rec: "KVClerk__ConditionalPut" "p" "key" "expectedValue" "newValue" :=
    let: "ck" := KVClerk__getSeqClerk "p" in
    let: "ret" := SeqKVClerk__ConditionalPut "ck" "key" "expectedValue" "newValue" in
    KVClerk__putSeqClerk "p" "ck";;
    "ret".

(* FIXME: rename to AddShardServer *)
Definition KVClerk__Add: val :=
  rec: "KVClerk__Add" "p" "host" :=
    let: "ck" := KVClerk__getSeqClerk "p" in
    SeqKVClerk__Add "ck" "host";;
    KVClerk__putSeqClerk "p" "ck";;
    #().

(* returns a slice of "values" (which are byte slices) in the same order as the
   keys passed in as input
   FIXME: benchmark *)
Definition KVClerk__MGet: val :=
  rec: "KVClerk__MGet" "p" "keys" :=
    let: "vals" := NewSlice (slice.T byteT) (slice.len "keys") in
    std.Multipar (slice.len "keys") (λ: "i",
      SliceSet (slice.T byteT) "vals" "i" (KVClerk__Get "p" (SliceGet uint64T "keys" "i"));;
      #()
      );;
    "vals".

Definition MakeKVClerk: val :=
  rec: "MakeKVClerk" "coord" "cm" :=
    let: "p" := struct.alloc KVClerk (zero_val (struct.t KVClerk)) in
    struct.storeF KVClerk "mu" "p" (lock.new #());;
    struct.storeF KVClerk "coord" "p" "coord";;
    struct.storeF KVClerk "cm" "p" "cm";;
    struct.storeF KVClerk "freeClerks" "p" (NewSlice seqKVClerkPtr #0);;
    "p".
