(* autogenerated from github.com/mit-pdos/gokv/connman *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.grove_prelude.

From Goose Require github_com.mit_pdos.gokv.urpc.rpc.

Definition HostName: ty := uint64T.

Definition ConnMan := struct.decl [
  "mu" :: lockRefT;
  "rpcCls" :: mapT (struct.ptrT rpc.RPCClient);
  "making" :: mapT condvarRefT
].

Definition ConnMan__getNewClient: val :=
  rec: "ConnMan__getNewClient" "c" "host" :=
    let: "cl" := ref (zero_val (refT (struct.t rpc.RPCClient))) in
    let: ("cond", "ok") := MapGet (struct.loadF ConnMan "making" "c") "host" in
    (if: "ok"
    then
      lock.condWait "cond";;
      "cl" <-[refT (struct.t rpc.RPCClient)] Fst (MapGet (struct.loadF ConnMan "rpcCls" "c") "host")
    else
      MapInsert (struct.loadF ConnMan "making" "c") "host" (lock.newCond (struct.loadF ConnMan "mu" "c"));;
      lock.release (struct.loadF ConnMan "mu" "c");;
      "cl" <-[refT (struct.t rpc.RPCClient)] rpc.MakeRPCClient "host";;
      lock.acquire (struct.loadF ConnMan "mu" "c");;
      MapInsert (struct.loadF ConnMan "rpcCls" "c") "host" (![refT (struct.t rpc.RPCClient)] "cl");;
      lock.condBroadcast (Fst (MapGet (struct.loadF ConnMan "making" "c") "host"));;
      MapDelete (struct.loadF ConnMan "making" "c") "host");;
    ![refT (struct.t rpc.RPCClient)] "cl".

(* This repeatedly retries the RPC after retryTimeout until it gets a response. *)
Definition ConnMan__CallAtLeastOnce: val :=
  rec: "ConnMan__CallAtLeastOnce" "c" "host" "rpcid" "args" "reply" "retryTimeout" :=
    let: "cl" := ref (zero_val (refT (struct.t rpc.RPCClient))) in
    lock.acquire (struct.loadF ConnMan "mu" "c");;
    let: ("cl1", "ok") := MapGet (struct.loadF ConnMan "rpcCls" "c") "host" in
    (if: ~ "ok"
    then "cl" <-[refT (struct.t rpc.RPCClient)] ConnMan__getNewClient "c" "host"
    else "cl" <-[refT (struct.t rpc.RPCClient)] "cl1");;
    lock.release (struct.loadF ConnMan "mu" "c");;
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := rpc.RPCClient__Call (![refT (struct.t rpc.RPCClient)] "cl") "rpcid" "args" "reply" "retryTimeout" in
      (if: ("err" = rpc.ErrTimeout)
      then Continue
      else
        (if: ("err" = rpc.ErrDisconnect)
        then
          lock.acquire (struct.loadF ConnMan "mu" "c");;
          (if: ![refT (struct.t rpc.RPCClient)] "cl" ≠ Fst (MapGet (struct.loadF ConnMan "rpcCls" "c") "host")
          then "cl" <-[refT (struct.t rpc.RPCClient)] Fst (MapGet (struct.loadF ConnMan "rpcCls" "c") "host")
          else
            MapDelete (struct.loadF ConnMan "rpcCls" "c") "host";;
            "cl" <-[refT (struct.t rpc.RPCClient)] ConnMan__getNewClient "c" "host");;
          lock.release (struct.loadF ConnMan "mu" "c");;
          Continue
        else Break));;
      Continue).
