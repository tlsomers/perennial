(* autogenerated from github.com/mit-pdos/gokv/aof *)
From Perennial.goose_lang Require Import prelude.
From Perennial.program_proof.lockservice Require Import grove_prelude.
From Goose Require github_com.mit_pdos.lockservice.lockservice.
                

Module AppendOnlyFile.
  Definition S := struct.decl [
    "fname" :: stringT;
    "mu" :: lockRefT;
    "durableCond" :: condvarRefT;
    "lengthCond" :: condvarRefT;
    "membuf" :: slice.T byteT;
    "length" :: uint64T;
    "durableLength" :: uint64T
  ].
End AppendOnlyFile.

Definition CreateAppendOnlyFile: val :=
  rec: "CreateAppendOnlyFile" "fname" :=
    let: "a" := struct.alloc AppendOnlyFile.S (zero_val (struct.t AppendOnlyFile.S)) in
    struct.storeF AppendOnlyFile.S "mu" "a" (lock.new #());;
    struct.storeF AppendOnlyFile.S "lengthCond" "a" (lock.newCond (struct.loadF AppendOnlyFile.S "mu" "a"));;
    struct.storeF AppendOnlyFile.S "durableCond" "a" (lock.newCond (struct.loadF AppendOnlyFile.S "mu" "a"));;
    Fork (lock.acquire (struct.loadF AppendOnlyFile.S "mu" "a");;
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            (if: (slice.len (struct.loadF AppendOnlyFile.S "membuf" "a") = #0)
            then
              lock.condWait (struct.loadF AppendOnlyFile.S "lengthCond" "a");;
              Continue
            else
              let: "l" := struct.loadF AppendOnlyFile.S "membuf" "a" in
              let: "newLength" := struct.loadF AppendOnlyFile.S "length" "a" in
              struct.storeF AppendOnlyFile.S "membuf" "a" (NewSlice byteT #0);;
              lock.release (struct.loadF AppendOnlyFile.S "mu" "a");;
              grove_ffi.AtomicAppend "fname" "l";;
              lock.acquire (struct.loadF AppendOnlyFile.S "mu" "a");;
              struct.storeF AppendOnlyFile.S "durableLength" "a" "newLength";;
              lock.condBroadcast (struct.loadF AppendOnlyFile.S "durableCond" "a");;
              Continue)));;
    "a".

Definition AppendOnlyFile__Append: val :=
  rec: "AppendOnlyFile__Append" "a" "data" :=
    lock.acquire (struct.loadF AppendOnlyFile.S "mu" "a");;
    struct.storeF AppendOnlyFile.S "membuf" "a" (SliceAppendSlice byteT (struct.loadF AppendOnlyFile.S "membuf" "a") "data");;
    Skip;;
    (for: (λ: <>, struct.loadF AppendOnlyFile.S "length" "a" + slice.len "data" < struct.loadF AppendOnlyFile.S "length" "a"); (λ: <>, Skip) := λ: <>,
      Continue);;
    struct.storeF AppendOnlyFile.S "length" "a" (struct.loadF AppendOnlyFile.S "length" "a" + slice.len "data");;
    let: "r" := struct.loadF AppendOnlyFile.S "length" "a" in
    lock.condSignal (struct.loadF AppendOnlyFile.S "lengthCond" "a");;
    lock.release (struct.loadF AppendOnlyFile.S "mu" "a");;
    "r".

Definition AppendOnlyFile__WaitAppend: val :=
  rec: "AppendOnlyFile__WaitAppend" "a" "length" :=
    lock.acquire (struct.loadF AppendOnlyFile.S "mu" "a");;
    Skip;;
    (for: (λ: <>, struct.loadF AppendOnlyFile.S "durableLength" "a" < "length"); (λ: <>, Skip) := λ: <>,
      lock.condWait (struct.loadF AppendOnlyFile.S "durableCond" "a");;
      Continue);;
    lock.release (struct.loadF AppendOnlyFile.S "mu" "a").
