(* autogenerated from github.com/mit-pdos/gokv/mpaxos *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.gokv.urpc.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_marshal.go *)

Definition Error: ty := uint64T.

Definition ENone : expr := #0.

Definition EEpochStale : expr := #1.

Definition EOutOfOrder : expr := #2.

Definition ETimeout : expr := #3.

Definition ENotLeader : expr := #4.

Definition applyAsFollowerArgs := struct.decl [
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT
].

Definition encodeApplyAsFollowerArgs: val :=
  rec: "encodeApplyAsFollowerArgs" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + #8 + slice.len (struct.loadF applyAsFollowerArgs "state" "o"))) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "epoch" "o");;
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "nextIndex" "o");;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "state" "o");;
    ![slice.T byteT] "enc".

Definition decodeApplyAsFollowerArgs: val :=
  rec: "decodeApplyAsFollowerArgs" "s" :=
    let: "enc" := ref_to (slice.T byteT) "s" in
    let: "o" := struct.alloc applyAsFollowerArgs (zero_val (struct.t applyAsFollowerArgs)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF applyAsFollowerArgs "epoch" "o" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF applyAsFollowerArgs "nextIndex" "o" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF applyAsFollowerArgs "state" "o" (![slice.T byteT] "enc");;
    "o".

Definition applyAsFollowerReply := struct.decl [
  "err" :: Error
].

Definition decodeApplyAsFollowerReply: val :=
  rec: "decodeApplyAsFollowerReply" "s" :=
    let: "o" := struct.alloc applyAsFollowerReply (zero_val (struct.t applyAsFollowerReply)) in
    let: ("err", <>) := marshal.ReadInt "s" in
    struct.storeF applyAsFollowerReply "err" "o" "err";;
    "o".

Definition encodeApplyAsFollowerReply: val :=
  rec: "encodeApplyAsFollowerReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerReply "err" "o");;
    ![slice.T byteT] "enc".

Definition enterNewEpochArgs := struct.decl [
  "epoch" :: uint64T
].

Definition encodeEnterNewEpochArgs: val :=
  rec: "encodeEnterNewEpochArgs" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochArgs "epoch" "o");;
    ![slice.T byteT] "enc".

Definition decodeEnterNewEpochArgs: val :=
  rec: "decodeEnterNewEpochArgs" "s" :=
    let: "o" := struct.alloc enterNewEpochArgs (zero_val (struct.t enterNewEpochArgs)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt "s" in
    struct.storeF enterNewEpochArgs "epoch" "o" "0_ret";;
    "1_ret";;
    "o".

Definition enterNewEpochReply := struct.decl [
  "err" :: Error;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT
].

Definition decodeEnterNewEpochReply: val :=
  rec: "decodeEnterNewEpochReply" "s" :=
    let: "o" := struct.alloc enterNewEpochReply (zero_val (struct.t enterNewEpochReply)) in
    let: "enc" := ref_to (slice.T byteT) "s" in
    let: "err" := ref (zero_val uint64T) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    "err" <-[uint64T] "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF enterNewEpochReply "err" "o" (![uint64T] "err");;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF enterNewEpochReply "acceptedEpoch" "o" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF enterNewEpochReply "nextIndex" "o" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF enterNewEpochReply "state" "o" (![slice.T byteT] "enc");;
    "o".

Definition encodeEnterNewEpochReply: val :=
  rec: "encodeEnterNewEpochReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + #8 + #8 + slice.len (struct.loadF enterNewEpochReply "state" "o"))) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "err" "o");;
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "acceptedEpoch" "o");;
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "nextIndex" "o");;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "state" "o");;
    ![slice.T byteT] "enc".

Definition applyReply := struct.decl [
  "err" :: Error;
  "ret" :: slice.T byteT
].

Definition encodeApplyReply: val :=
  rec: "encodeApplyReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + slice.len (struct.loadF applyReply "ret" "o"))) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyReply "err" "o");;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF applyReply "ret" "o");;
    ![slice.T byteT] "enc".

Definition decodeApplyReply: val :=
  rec: "decodeApplyReply" "s" :=
    let: "enc" := ref_to (slice.T byteT) "s" in
    let: "o" := struct.alloc applyReply (zero_val (struct.t applyReply)) in
    let: "err" := ref (zero_val uint64T) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    "err" <-[uint64T] "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF applyReply "err" "o" (![uint64T] "err");;
    struct.storeF applyReply "ret" "o" (![slice.T byteT] "enc");;
    "o".

(* 1_reconnectingclient.go *)

Definition ReconnectingClient := struct.decl [
  "mu" :: ptrT;
  "valid" :: boolT;
  "urpcCl" :: ptrT;
  "making" :: boolT;
  "made_cond" :: ptrT;
  "addr" :: uint64T
].

Definition MakeReconnectingClient: val :=
  rec: "MakeReconnectingClient" "addr" :=
    let: "r" := struct.alloc ReconnectingClient (zero_val (struct.t ReconnectingClient)) in
    struct.storeF ReconnectingClient "mu" "r" (lock.new #());;
    struct.storeF ReconnectingClient "valid" "r" #false;;
    struct.storeF ReconnectingClient "making" "r" #false;;
    struct.storeF ReconnectingClient "made_cond" "r" (lock.newCond (struct.loadF ReconnectingClient "mu" "r"));;
    struct.storeF ReconnectingClient "addr" "r" "addr";;
    "r".

Definition ReconnectingClient__getClient: val :=
  rec: "ReconnectingClient__getClient" "cl" :=
    lock.acquire (struct.loadF ReconnectingClient "mu" "cl");;
    (if: struct.loadF ReconnectingClient "valid" "cl"
    then
      let: "ret" := struct.loadF ReconnectingClient "urpcCl" "cl" in
      lock.release (struct.loadF ReconnectingClient "mu" "cl");;
      "ret"
    else
      struct.storeF ReconnectingClient "making" "cl" #true;;
      lock.release (struct.loadF ReconnectingClient "mu" "cl");;
      let: "newRpcCl" := urpc.MakeClient (struct.loadF ReconnectingClient "addr" "cl") in
      lock.acquire (struct.loadF ReconnectingClient "mu" "cl");;
      struct.storeF ReconnectingClient "urpcCl" "cl" "newRpcCl";;
      lock.condBroadcast (struct.loadF ReconnectingClient "made_cond" "cl");;
      struct.storeF ReconnectingClient "valid" "cl" #true;;
      struct.storeF ReconnectingClient "making" "cl" #false;;
      lock.release (struct.loadF ReconnectingClient "mu" "cl");;
      "newRpcCl").

Definition ReconnectingClient__Call: val :=
  rec: "ReconnectingClient__Call" "cl" "rpcid" "args" "reply" "timeout_ms" :=
    let: "urpcCl" := ReconnectingClient__getClient "cl" in
    let: "err" := urpc.Client__Call "urpcCl" "rpcid" "args" "reply" "timeout_ms" in
    (if: ("err" = urpc.ErrDisconnect)
    then
      lock.acquire (struct.loadF ReconnectingClient "mu" "cl");;
      struct.storeF ReconnectingClient "valid" "cl" #false;;
      lock.release (struct.loadF ReconnectingClient "mu" "cl")
    else #());;
    "err".

(* 2_internalclerk.go *)

Definition RPC_APPLY_AS_FOLLOWER : expr := #0.

Definition RPC_ENTER_NEW_EPOCH : expr := #1.

Definition RPC_APPLY : expr := #2.

Definition RPC_BECOME_LEADER : expr := #3.

(* these clerks hide connection failures, and retry forever *)
Definition singleClerk := struct.decl [
  "cl" :: ptrT;
  "addr" :: uint64T
].

Definition makeSingleClerk: val :=
  rec: "makeSingleClerk" "addr" :=
    let: "ck" := struct.new singleClerk [
      "cl" ::= MakeReconnectingClient "addr"
    ] in
    "ck".

Definition singleClerk__enterNewEpoch: val :=
  rec: "singleClerk__enterNewEpoch" "s" "args" :=
    let: "raw_args" := encodeEnterNewEpochArgs "args" in
    let: "raw_reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := ReconnectingClient__Call (struct.loadF singleClerk "cl" "s") RPC_ENTER_NEW_EPOCH "raw_args" "raw_reply" #500 in
    (if: ("err" = #0)
    then decodeEnterNewEpochReply (![slice.T byteT] "raw_reply")
    else
      struct.new enterNewEpochReply [
        "err" ::= ETimeout
      ]).

Definition singleClerk__applyAsFollower: val :=
  rec: "singleClerk__applyAsFollower" "s" "args" :=
    let: "raw_args" := encodeApplyAsFollowerArgs "args" in
    let: "raw_reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := ReconnectingClient__Call (struct.loadF singleClerk "cl" "s") RPC_APPLY_AS_FOLLOWER "raw_args" "raw_reply" #500 in
    (if: ("err" = #0)
    then decodeApplyAsFollowerReply (![slice.T byteT] "raw_reply")
    else
      struct.new applyAsFollowerReply [
        "err" ::= ETimeout
      ]).

Definition singleClerk__becomeLeader: val :=
  rec: "singleClerk__becomeLeader" "s" :=
    let: "reply" := ref (zero_val (slice.T byteT)) in
    ReconnectingClient__Call (struct.loadF singleClerk "cl" "s") RPC_BECOME_LEADER (NewSlice byteT #0) "reply" #500;;
    #().

Definition singleClerk__apply: val :=
  rec: "singleClerk__apply" "s" "op" :=
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err2" := ReconnectingClient__Call (struct.loadF singleClerk "cl" "s") RPC_APPLY "op" "reply" #500 in
    (if: "err2" ≠ #0
    then (ETimeout, slice.nil)
    else
      let: "r" := decodeApplyReply (![slice.T byteT] "reply") in
      (if: struct.loadF applyReply "err" "r" ≠ ENone
      then (struct.loadF applyReply "err" "r", slice.nil)
      else (ENone, struct.loadF applyReply "ret" "r"))).

(* clerk.go *)

Definition Clerk := struct.decl [
  "cks" :: slice.T ptrT
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "config" :=
    let: "ck" := struct.alloc Clerk (zero_val (struct.t Clerk)) in
    struct.storeF Clerk "cks" "ck" (NewSlice ptrT (slice.len "config"));;
    let: "i" := ref_to uint64T #0 in
    let: "n" := slice.len "config" in
    Skip;;
    (for: (λ: <>, ![uint64T] "i" < "n"); (λ: <>, Skip) := λ: <>,
      SliceSet ptrT (struct.loadF Clerk "cks" "ck") (![uint64T] "i") (makeSingleClerk (SliceGet uint64T "config" (![uint64T] "i")));;
      "i" <-[uint64T] ![uint64T] "i" + #1;;
      Continue);;
    "ck".

(* XXX: not trying to prevent livelock right now. A client op simply starts by
   telling the server to become leader (which it might already be), then it
   tells to apply the op. Concurrent clients trying will easily result in
   livelock, where two nodes keep trying to become leader, but can't stay leader
   for long enough to process even one request. *)
Definition Clerk__Apply: val :=
  rec: "Clerk__Apply" "ck" "op" :=
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := ref (zero_val Error) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "i" := (rand.RandomUint64 #()) `rem` (slice.len (struct.loadF Clerk "cks" "ck")) in
      let: "cl" := SliceGet ptrT (struct.loadF Clerk "cks" "ck") "i" in
      singleClerk__becomeLeader "cl";;
      (* log.Println("became leader") *)
      let: ("0_ret", "1_ret") := singleClerk__apply "cl" "op" in
      "err" <-[Error] "0_ret";;
      "reply" <-[slice.T byteT] "1_ret";;
      (if: (![Error] "err" = ENone)
      then Break
      else
        (* log.Printf("cl.apply(op) returned %d\n", err) *)
        Continue));;
    ![slice.T byteT] "reply".

(* server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "epoch" :: uint64T;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT;
  "clerks" :: slice.T ptrT;
  "isLeader" :: boolT;
  "applyFn" :: (slice.T byteT -> slice.T byteT -> (slice.T byteT * slice.T byteT))%ht
].

Definition Server__applyAsFollower: val :=
  rec: "Server__applyAsFollower" "s" "args" "reply" :=
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: struct.loadF Server "epoch" "s" ≤ struct.loadF applyAsFollowerArgs "epoch" "args"
    then
      struct.storeF Server "isLeader" "s" #false;;
      (if: (struct.loadF Server "acceptedEpoch" "s" = struct.loadF applyAsFollowerArgs "epoch" "args")
      then
        (if: struct.loadF Server "nextIndex" "s" ≤ struct.loadF applyAsFollowerArgs "nextIndex" "args"
        then
          struct.storeF Server "nextIndex" "s" (struct.loadF applyAsFollowerArgs "nextIndex" "args" + #1);;
          struct.storeF Server "state" "s" (struct.loadF applyAsFollowerArgs "state" "args");;
          struct.storeF applyAsFollowerReply "err" "reply" ENone
        else struct.storeF applyAsFollowerReply "err" "reply" ENone)
      else
        struct.storeF Server "acceptedEpoch" "s" (struct.loadF applyAsFollowerArgs "epoch" "args");;
        struct.storeF Server "epoch" "s" (struct.loadF applyAsFollowerArgs "epoch" "args");;
        struct.storeF Server "state" "s" (struct.loadF applyAsFollowerArgs "state" "args");;
        struct.storeF Server "nextIndex" "s" (struct.loadF applyAsFollowerArgs "nextIndex" "args");;
        struct.storeF applyAsFollowerReply "err" "reply" ENone)
    else struct.storeF applyAsFollowerReply "err" "reply" EEpochStale);;
    lock.release (struct.loadF Server "mu" "s");;
    #().

(* FIXME:
   This will vote yes only the first time it's called in an epoch.
   If you have too aggressive of a timeout and end up retrying this, the retry
   might fail because it may be the second execution of enterNewEpoch(epoch) on
   the server.
   Solution: either conservative (maybe double) timeouts, or don't use this for
   leader election, only for coming up with a valid proposal. *)
Definition Server__enterNewEpoch: val :=
  rec: "Server__enterNewEpoch" "s" "args" "reply" :=
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: struct.loadF Server "epoch" "s" ≥ struct.loadF enterNewEpochArgs "epoch" "args"
    then
      lock.release (struct.loadF Server "mu" "s");;
      struct.storeF enterNewEpochReply "err" "reply" EEpochStale;;
      #()
    else
      struct.storeF Server "isLeader" "s" #false;;
      struct.storeF Server "epoch" "s" (struct.loadF enterNewEpochArgs "epoch" "args");;
      struct.storeF enterNewEpochReply "acceptedEpoch" "reply" (struct.loadF Server "acceptedEpoch" "s");;
      struct.storeF enterNewEpochReply "nextIndex" "reply" (struct.loadF Server "nextIndex" "s");;
      struct.storeF enterNewEpochReply "state" "reply" (struct.loadF Server "state" "s");;
      lock.release (struct.loadF Server "mu" "s");;
      #()).

Definition Server__becomeLeader: val :=
  rec: "Server__becomeLeader" "s" :=
    (* log.Println("started trybecomeleader") *)
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: struct.loadF Server "isLeader" "s"
    then
      (* log.Println("already leader") *)
      lock.release (struct.loadF Server "mu" "s");;
      #()
    else
      let: "clerks" := struct.loadF Server "clerks" "s" in
      let: "args" := struct.new enterNewEpochArgs [
        "epoch" ::= struct.loadF Server "epoch" "s" + #1
      ] in
      lock.release (struct.loadF Server "mu" "s");;
      let: "numReplies" := ref_to uint64T #0 in
      let: "replies" := NewSlice ptrT (slice.len "clerks") in
      let: "mu" := lock.new #() in
      let: "numReplies_cond" := lock.newCond "mu" in
      let: "n" := slice.len "clerks" in
      ForSlice ptrT "i" "ck" "clerks"
        (let: "ck" := "ck" in
        let: "i" := "i" in
        Fork (let: "reply" := singleClerk__enterNewEpoch "ck" "args" in
              lock.acquire "mu";;
              "numReplies" <-[uint64T] ![uint64T] "numReplies" + #1;;
              SliceSet ptrT "replies" "i" "reply";;
              (if: #2 * ![uint64T] "numReplies" > "n"
              then lock.condSignal "numReplies_cond"
              else #());;
              lock.release "mu"));;
      lock.acquire "mu";;
      Skip;;
      (for: (λ: <>, #2 * ![uint64T] "numReplies" ≤ "n"); (λ: <>, Skip) := λ: <>,
        lock.condWait "numReplies_cond";;
        Continue);;
      let: "latestReply" := ref (zero_val ptrT) in
      let: "numSuccesses" := ref_to uint64T #0 in
      ForSlice ptrT <> "reply" "replies"
        ((if: "reply" ≠ #null
        then
          (if: (struct.loadF enterNewEpochReply "err" "reply" = ENone)
          then
            (if: (![uint64T] "numSuccesses" = #0)
            then "latestReply" <-[ptrT] "reply"
            else
              (if: struct.loadF enterNewEpochReply "acceptedEpoch" (![ptrT] "latestReply") < struct.loadF enterNewEpochReply "acceptedEpoch" "reply"
              then "latestReply" <-[ptrT] "reply"
              else
                (if: ((struct.loadF enterNewEpochReply "acceptedEpoch" (![ptrT] "latestReply") = struct.loadF enterNewEpochReply "acceptedEpoch" "reply")) && (struct.loadF enterNewEpochReply "nextIndex" "reply" > struct.loadF enterNewEpochReply "nextIndex" (![ptrT] "latestReply"))
                then "latestReply" <-[ptrT] "reply"
                else #())));;
            "numSuccesses" <-[uint64T] ![uint64T] "numSuccesses" + #1
          else #())
        else #()));;
      (if: #2 * ![uint64T] "numSuccesses" > "n"
      then
        (* log.Printf("succeeded becomeleader in epoch %d\n", args.epoch) *)
        lock.acquire (struct.loadF Server "mu" "s");;
        (if: struct.loadF Server "epoch" "s" < struct.loadF enterNewEpochArgs "epoch" "args"
        then
          struct.storeF Server "epoch" "s" (struct.loadF enterNewEpochArgs "epoch" "args");;
          struct.storeF Server "isLeader" "s" #true;;
          struct.storeF Server "acceptedEpoch" "s" (struct.loadF Server "epoch" "s");;
          struct.storeF Server "nextIndex" "s" (struct.loadF enterNewEpochReply "nextIndex" (![ptrT] "latestReply"));;
          struct.storeF Server "state" "s" (struct.loadF enterNewEpochReply "state" (![ptrT] "latestReply"))
        else #());;
        lock.release (struct.loadF Server "mu" "s");;
        lock.release "mu";;
        #()
      else
        lock.release "mu";;
        (* log.Println("failed becomeleader") *)
        #())).

Definition Server__apply: val :=
  rec: "Server__apply" "s" "op" "reply" :=
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: ~ (struct.loadF Server "isLeader" "s")
    then
      lock.release (struct.loadF Server "mu" "s");;
      struct.storeF applyReply "err" "reply" ENotLeader;;
      #()
    else
      let: ("0_ret", "1_ret") := struct.loadF Server "applyFn" "s" (struct.loadF Server "state" "s") "op" in
      struct.storeF Server "state" "s" "0_ret";;
      struct.storeF applyReply "ret" "reply" "1_ret";;
      let: "args" := struct.new applyAsFollowerArgs [
        "epoch" ::= struct.loadF Server "epoch" "s";
        "nextIndex" ::= struct.loadF Server "nextIndex" "s";
        "state" ::= struct.loadF Server "state" "s"
      ] in
      struct.storeF Server "nextIndex" "s" (std.SumAssumeNoOverflow (struct.loadF Server "nextIndex" "s") #1);;
      let: "clerks" := struct.loadF Server "clerks" "s" in
      lock.release (struct.loadF Server "mu" "s");;
      let: "numReplies" := ref_to uint64T #0 in
      let: "replies" := NewSlice ptrT (slice.len "clerks") in
      let: "mu" := lock.new #() in
      let: "numReplies_cond" := lock.newCond "mu" in
      let: "n" := slice.len "clerks" in
      ForSlice ptrT "i" "ck" "clerks"
        (let: "ck" := "ck" in
        let: "i" := "i" in
        Fork (let: "reply" := singleClerk__applyAsFollower "ck" "args" in
              lock.acquire "mu";;
              "numReplies" <-[uint64T] ![uint64T] "numReplies" + #1;;
              SliceSet ptrT "replies" "i" "reply";;
              (if: #2 * ![uint64T] "numReplies" > "n"
              then lock.condSignal "numReplies_cond"
              else #());;
              lock.release "mu"));;
      lock.acquire "mu";;
      Skip;;
      (for: (λ: <>, #2 * ![uint64T] "numReplies" ≤ "n"); (λ: <>, Skip) := λ: <>,
        lock.condWait "numReplies_cond";;
        Continue);;
      let: "numSuccesses" := ref_to uint64T #0 in
      ForSlice ptrT <> "reply" "replies"
        ((if: "reply" ≠ #null
        then
          (if: (struct.loadF applyAsFollowerReply "err" "reply" = ENone)
          then "numSuccesses" <-[uint64T] ![uint64T] "numSuccesses" + #1
          else #())
        else #()));;
      (if: #2 * ![uint64T] "numSuccesses" > "n"
      then
        struct.storeF applyReply "err" "reply" ENone;;
        #()
      else
        struct.storeF applyReply "err" "reply" EEpochStale;;
        #())).

Definition makeServer: val :=
  rec: "makeServer" "fname" "applyFn" "config" :=
    let: "s" := struct.alloc Server (zero_val (struct.t Server)) in
    struct.storeF Server "mu" "s" (lock.new #());;
    struct.storeF Server "state" "s" (NewSlice byteT #0);;
    struct.storeF Server "applyFn" "s" "applyFn";;
    struct.storeF Server "clerks" "s" (NewSlice ptrT (slice.len "config"));;
    let: "n" := slice.len (struct.loadF Server "clerks" "s") in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, ![uint64T] "i" < "n"); (λ: <>, Skip) := λ: <>,
      SliceSet ptrT (struct.loadF Server "clerks" "s") (![uint64T] "i") (makeSingleClerk (SliceGet uint64T "config" (![uint64T] "i")));;
      "i" <-[uint64T] ![uint64T] "i" + #1;;
      Continue);;
    "s".

Definition StartServer: val :=
  rec: "StartServer" "fname" "me" "applyFn" "config" :=
    let: "s" := makeServer "fname" "applyFn" "config" in
    let: "handlers" := NewMap uint64T ((slice.T byteT -> ptrT -> unitT)%ht) #() in
    MapInsert "handlers" RPC_APPLY_AS_FOLLOWER ((λ: "raw_args" "raw_reply",
      let: "reply" := struct.alloc applyAsFollowerReply (zero_val (struct.t applyAsFollowerReply)) in
      let: "args" := decodeApplyAsFollowerArgs "raw_args" in
      Server__applyAsFollower "s" "args" "reply";;
      "raw_reply" <-[slice.T byteT] encodeApplyAsFollowerReply "reply";;
      #()
      ));;
    MapInsert "handlers" RPC_ENTER_NEW_EPOCH ((λ: "raw_args" "raw_reply",
      let: "reply" := struct.alloc enterNewEpochReply (zero_val (struct.t enterNewEpochReply)) in
      let: "args" := decodeEnterNewEpochArgs "raw_args" in
      Server__enterNewEpoch "s" "args" "reply";;
      "raw_reply" <-[slice.T byteT] encodeEnterNewEpochReply "reply";;
      #()
      ));;
    MapInsert "handlers" RPC_APPLY ((λ: "raw_args" "raw_reply",
      let: "reply" := struct.alloc applyReply (zero_val (struct.t applyReply)) in
      Server__apply "s" "raw_args" "reply";;
      "raw_reply" <-[slice.T byteT] encodeApplyReply "reply";;
      #()
      ));;
    MapInsert "handlers" RPC_BECOME_LEADER ((λ: "raw_args" "raw_reply",
      Server__becomeLeader "s";;
      #()
      ));;
    let: "r" := urpc.MakeServer "handlers" in
    urpc.Server__Serve "r" "me";;
    #().
