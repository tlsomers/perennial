(* autogenerated from rpc *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.dist_ffi.

Existing Instances grove_op grove_model grove_ty grove_semantics grove_interp heapG_groveG.
Coercion Var' (s: string) := Var s.

From Goose Require github_com.tchajed.marshal.

Module RPCServer.
  Definition S := struct.decl [
    "handlers" :: mapT ((slice.T byteT -> refT (slice.T byteT) -> unitT)%ht)
  ].
End RPCServer.

Definition RPCServer__rpcHandle: val :=
  rec: "RPCServer__rpcHandle" "srv" "sender" "rpcid" "seqno" "data" :=
    let: "replyData" := NewSlice byteT #0 in
    let: "f" := Fst (MapGet (struct.loadF RPCServer.S "handlers" "srv") "rpcid") in
    "f" "data" "replyData";;
    let: "e" := marshal.NewEnc (#8 + #8 + slice.len "replyData") in
    marshal.Enc__PutInt "e" "seqno";;
    marshal.Enc__PutInt "e" (slice.len "replyData");;
    marshal.Enc__PutBytes "e" "replyData";;
    dist_ffi.Send "sender" (marshal.Enc__Finish "e").

Definition MakeRPCServer: val :=
  rec: "MakeRPCServer" "handlers" :=
    struct.new RPCServer.S [
      "handlers" ::= "handlers"
    ].

Definition RPCServer__Serve: val :=
  rec: "RPCServer__Serve" "srv" "host" "numWorkers" :=
    let: "recv" := dist_ffi.Listen "host" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "i" < "numWorkers"); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
      Fork (RPCServer__readThread "srv" "recv");;
      Continue).

Definition RPCServer__readThread: val :=
  rec: "RPCServer__readThread" "srv" "recv" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "r" := dist_ffi.Receive "recv" in
      (if: struct.get dist_ffi.ErrMsgSender.S "E" "r"
      then Continue
      else
        let: "data" := struct.get dist_ffi.ErrMsgSender.S "M" "r" in
        let: "sender" := struct.get dist_ffi.ErrMsgSender.S "S" "r" in
        let: "d" := marshal.NewDec "data" in
        let: "rpcid" := marshal.Dec__GetInt "d" in
        let: "seqno" := marshal.Dec__GetInt "d" in
        let: "reqLen" := marshal.Dec__GetInt "d" in
        let: "req" := marshal.Dec__GetBytes "d" "reqLen" in
        RPCServer__rpcHandle "srv" "sender" "rpcid" "seqno" "req")).

Module callback.
  Definition S := struct.decl [
    "reply" :: refT (slice.T byteT);
    "done" :: refT boolT;
    "cond" :: condvarRefT
  ].
End callback.

Module RPCClient.
  Definition S := struct.decl [
    "mu" :: lockRefT;
    "send" :: struct.ptrT dist_ffi.Sender.S;
    "seq" :: uint64T;
    "pending" :: mapT (struct.ptrT callback.S)
  ].
End RPCClient.

Definition RPCClient__replyThread: val :=
  rec: "RPCClient__replyThread" "cl" "recv" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "r" := dist_ffi.Receive "recv" in
      (if: struct.get dist_ffi.ErrMsgSender.S "E" "r"
      then Continue
      else
        let: "data" := struct.get dist_ffi.ErrMsgSender.S "M" "r" in
        let: "d" := marshal.NewDec "data" in
        let: "seqno" := marshal.Dec__GetInt "d" in
        let: "replyLen" := marshal.Dec__GetInt "d" in
        let: "reply" := marshal.Dec__GetBytes "d" "replyLen" in
        lock.acquire (struct.loadF RPCClient.S "mu" "cl");;
        let: ("cb", "ok") := MapGet (struct.loadF RPCClient.S "pending" "cl") "seqno" in
        (if: "ok"
        then
          MapDelete (struct.loadF RPCClient.S "pending" "cl") "seqno";;
          struct.loadF callback.S "reply" "cb" <-[slice.T byteT] "reply";;
          struct.loadF callback.S "done" "cb" <-[boolT] #true;;
          lock.condSignal (struct.loadF callback.S "cond" "cb");;
          #()
        else #());;
        lock.release (struct.loadF RPCClient.S "mu" "cl"))).

Definition MakeRPCClient: val :=
  rec: "MakeRPCClient" "host" :=
    let: "cl" := struct.alloc RPCClient.S (zero_val (struct.t RPCClient.S)) in
    let: "recv" := ref (zero_val (refT (struct.t dist_ffi.Receiver.S))) in
    let: "a" := dist_ffi.Connect "host" in
    struct.storeF RPCClient.S "send" "cl" (struct.get dist_ffi.SenderReceiver.S "S" "a");;
    "recv" <-[refT (struct.t dist_ffi.Receiver.S)] struct.get dist_ffi.SenderReceiver.S "R" "a";;
    struct.storeF RPCClient.S "mu" "cl" (lock.new #());;
    struct.storeF RPCClient.S "seq" "cl" #1;;
    struct.storeF RPCClient.S "pending" "cl" (NewMap (struct.ptrT callback.S));;
    Fork (RPCClient__replyThread "cl" (![refT (struct.t dist_ffi.Receiver.S)] "recv"));;
    "cl".

Definition RPCClient__Call: val :=
  rec: "RPCClient__Call" "cl" "rpcid" "args" "reply" :=
    let: "cb" := struct.mk callback.S [
      "reply" ::= "reply";
      "done" ::= ref (zero_val boolT);
      "cond" ::= lock.newCond (struct.loadF RPCClient.S "mu" "cl")
    ] in
    struct.get callback.S "done" "cb" <-[boolT] #false;;
    lock.acquire (struct.loadF RPCClient.S "mu" "cl");;
    let: "seqno" := struct.loadF RPCClient.S "seq" "cl" in
    struct.storeF RPCClient.S "seq" "cl" (struct.loadF RPCClient.S "seq" "cl" + #1);;
    MapInsert (struct.loadF RPCClient.S "pending" "cl") "seqno" "cb";;
    lock.release (struct.loadF RPCClient.S "mu" "cl");;
    let: "e" := marshal.NewEnc (#8 + #8 + #8 + slice.len "args") in
    marshal.Enc__PutInt "e" "rpcid";;
    marshal.Enc__PutInt "e" "seqno";;
    marshal.Enc__PutInt "e" (slice.len "args");;
    marshal.Enc__PutBytes "e" "args";;
    let: "reqData" := marshal.Enc__Finish "e" in
    dist_ffi.Send (struct.loadF RPCClient.S "send" "cl") "reqData";;
    lock.acquire (struct.loadF RPCClient.S "mu" "cl");;
    Skip;;
    (for: (λ: <>, ~ (![boolT] (struct.get callback.S "done" "cb"))); (λ: <>, Skip) := λ: <>,
      lock.condWait (struct.get callback.S "cond" "cb");;
      Continue);;
    lock.release (struct.loadF RPCClient.S "mu" "cl");;
    #false.
