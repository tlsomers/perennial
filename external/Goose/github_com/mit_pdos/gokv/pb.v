(* autogenerated from github.com/mit-pdos/gokv/pb *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.grove_prelude.

From Goose Require github_com.mit_pdos.gokv.urpc.rpc.
From Goose Require github_com.tchajed.marshal.

(* 0_common.go *)

Definition PBConfiguration := struct.decl [
  "replicas" :: slice.T uint64T;
  "primary" :: uint64T
].

Definition EncodePBConfiguration: val :=
  rec: "EncodePBConfiguration" "p" :=
    slice.nil.

Definition DecodePBConfiguration: val :=
  rec: "DecodePBConfiguration" "d" :=
    slice.nil.

(* 1_conf.go *)

Definition VersionedValue := struct.decl [
  "ver" :: uint64T;
  "val" :: slice.T byteT
].

Definition ConfServer := struct.decl [
  "mu" :: lockRefT;
  "kvs" :: mapT (struct.t VersionedValue)
].

Definition CONF_PUT : expr := #1.

Definition CONF_GET : expr := #1.

Definition PutArgs := struct.decl [
  "key" :: uint64T;
  "prevVer" :: uint64T;
  "newVal" :: slice.T byteT
].

(* MARSHAL *)
Definition EncodePutArgs: val :=
  rec: "EncodePutArgs" "args" :=
    let: "enc" := marshal.NewEnc (#8 + #8 + slice.len (struct.loadF PutArgs "newVal" "args")) in
    marshal.Enc__PutInt "enc" (struct.loadF PutArgs "key" "args");;
    marshal.Enc__PutInt "enc" (struct.loadF PutArgs "prevVer" "args");;
    marshal.Enc__PutBytes "enc" (struct.loadF PutArgs "newVal" "args");;
    marshal.Enc__Finish "enc".

(* MARSHAL *)
Definition DecodePutArgs: val :=
  rec: "DecodePutArgs" "data" :=
    let: "dec" := marshal.NewDec "data" in
    let: "args" := struct.alloc PutArgs (zero_val (struct.t PutArgs)) in
    struct.storeF PutArgs "key" "args" (marshal.Dec__GetInt "dec");;
    struct.storeF PutArgs "prevVer" "args" (marshal.Dec__GetInt "dec");;
    struct.storeF PutArgs "newVal" "args" (marshal.Dec__GetBytes "dec" (slice.len "data" - #16));;
    "args".

Definition EncodeVersionedValue: val :=
  rec: "EncodeVersionedValue" "v" :=
    let: "enc" := marshal.NewEnc (#8 + slice.len (struct.loadF VersionedValue "val" "v")) in
    marshal.Enc__PutInt "enc" (struct.loadF VersionedValue "ver" "v");;
    marshal.Enc__PutBytes "enc" (struct.loadF VersionedValue "val" "v");;
    marshal.Enc__Finish "enc".

Definition DecodeVersionedValue: val :=
  rec: "DecodeVersionedValue" "data" :=
    let: "dec" := marshal.NewDec "data" in
    let: "v" := struct.alloc VersionedValue (zero_val (struct.t VersionedValue)) in
    struct.storeF VersionedValue "ver" "v" (marshal.Dec__GetInt "dec");;
    struct.storeF VersionedValue "val" "v" (marshal.Dec__GetBytes "dec" (slice.len "data" - #8));;
    "v".

Definition ConfServer__PutRPC: val :=
  rec: "ConfServer__PutRPC" "s" "args" :=
    lock.acquire (struct.loadF ConfServer "mu" "s");;
    let: (<>, "ok") := MapGet (struct.loadF ConfServer "kvs" "s") (struct.loadF PutArgs "key" "args") in
    (if: "ok" && (struct.get VersionedValue "ver" (Fst (MapGet (struct.loadF ConfServer "kvs" "s") (struct.loadF PutArgs "key" "args"))) = struct.loadF PutArgs "prevVer" "args")
    then
      MapInsert (struct.loadF ConfServer "kvs" "s") (struct.loadF PutArgs "key" "args") (struct.mk VersionedValue [
        "ver" ::= struct.loadF PutArgs "prevVer" "args" + #1;
        "val" ::= struct.loadF PutArgs "newVal" "args"
      ])
    else
      MapInsert (struct.loadF ConfServer "kvs" "s") (struct.loadF PutArgs "key" "args") (struct.mk VersionedValue [
        "ver" ::= #1;
        "val" ::= struct.loadF PutArgs "newVal" "args"
      ]));;
    lock.release (struct.loadF ConfServer "mu" "s");;
    #true.

Definition GetReply := struct.decl [
  "ver" :: uint64T;
  "val" :: slice.T byteT
].

Definition ConfServer__GetRPC: val :=
  rec: "ConfServer__GetRPC" "s" "key" "v" :=
    lock.acquire (struct.loadF ConfServer "mu" "s");;
    struct.store VersionedValue "v" (Fst (MapGet (struct.loadF ConfServer "kvs" "s") "key"));;
    lock.release (struct.loadF ConfServer "mu" "s");;
    #().

Definition ConfServer__Start: val :=
  rec: "ConfServer__Start" "s" :=
    let: "handlers" := NewMap ((slice.T byteT -> refT (slice.T byteT) -> unitT)%ht) in
    MapInsert "handlers" CONF_PUT (λ: "args" "rep",
      (if: ConfServer__PutRPC "s" (DecodePutArgs "args")
      then
        "rep" <-[slice.T byteT] NewSlice byteT #1;;
        #()
      else
        "rep" <-[slice.T byteT] NewSlice byteT #0;;
        #())
      );;
    MapInsert "handlers" CONF_GET (λ: "args" "rep",
      let: "v" := struct.alloc VersionedValue (zero_val (struct.t VersionedValue)) in
      ConfServer__GetRPC "s" (UInt64Get "args") "v";;
      #()
      );;
    #().

Definition ConfClerk := struct.decl [
  "cl" :: struct.ptrT rpc.RPCClient
].

Definition ConfClerk__Put: val :=
  rec: "ConfClerk__Put" "c" "key" "prevVer" "newVal" :=
    let: "raw_reply" := ref (zero_val (slice.T byteT)) in
    let: "raw_args" := EncodePutArgs (struct.new PutArgs [
      "key" ::= "key";
      "prevVer" ::= "prevVer";
      "newVal" ::= "newVal"
    ]) in
    let: "err" := rpc.RPCClient__Call (struct.loadF ConfClerk "cl" "c") CONF_PUT "raw_args" "raw_reply" #100 in
    (if: ("err" = #0)
    then slice.len (![slice.T byteT] "raw_reply") > #0
    else #false).

Definition ConfClerk__Get: val :=
  rec: "ConfClerk__Get" "c" "key" :=
    let: "raw_reply" := ref (zero_val (slice.T byteT)) in
    let: "raw_args" := NewSlice byteT #8 in
    UInt64Put "raw_args" "key";;
    let: "err" := rpc.RPCClient__Call (struct.loadF ConfClerk "cl" "c") CONF_GET "raw_args" "raw_reply" #100 in
    (if: ("err" = #0)
    then DecodeVersionedValue (![slice.T byteT] "raw_reply")
    else slice.nil).

Definition MakeConfClerk: val :=
  rec: "MakeConfClerk" "confServer" :=
    slice.nil.

(* 2_replica_clerk.go *)

Definition AppendArgs := struct.decl [
  "cn" :: uint64T;
  "log" :: slice.T (slice.T byteT);
  "commitIdx" :: uint64T
].

Definition ReplicaClerk := struct.decl [
  "cl" :: struct.ptrT rpc.RPCClient
].

Definition ReplicaClerk__AppendRPC: val :=
  rec: "ReplicaClerk__AppendRPC" "ck" "args" :=
    #false.

(* 3_replica.go *)

Definition LogEntry: ty := slice.T byteT.

Definition ReplicaServer := struct.decl [
  "mu" :: lockRefT;
  "cn" :: uint64T;
  "conf" :: struct.ptrT PBConfiguration;
  "confClerk" :: struct.ptrT ConfClerk;
  "replicaClerks" :: slice.T (struct.ptrT ReplicaClerk);
  "opLog" :: slice.T LogEntry;
  "commitIdx" :: uint64T;
  "isPrimary" :: boolT;
  "matchLog" :: slice.T (slice.T LogEntry)
].

(* This should be invoked locally by services to attempt appending op to the
   log *)
Definition ReplicaServer__StartAppend: val :=
  rec: "ReplicaServer__StartAppend" "s" "op" :=
    lock.acquire (struct.loadF ReplicaServer "mu" "s");;
    (if: struct.loadF ReplicaServer "isPrimary" "s"
    then
      lock.release (struct.loadF ReplicaServer "mu" "s");;
      #false
    else
      struct.storeF ReplicaServer "opLog" "s" (SliceAppend (slice.T byteT) (struct.loadF ReplicaServer "opLog" "s") "op");;
      lock.release (struct.loadF ReplicaServer "mu" "s");;
      #true).

Definition ReplicaServer__Append: val :=
  rec: "ReplicaServer__Append" "s" "op" :=
    lock.acquire (struct.loadF ReplicaServer "mu" "s");;
    (if: struct.loadF ReplicaServer "isPrimary" "s"
    then
      lock.release (struct.loadF ReplicaServer "mu" "s");;
      #false
    else
      struct.storeF ReplicaServer "opLog" "s" (SliceAppend (slice.T byteT) (struct.loadF ReplicaServer "opLog" "s") "op");;
      let: "clerks" := struct.loadF ReplicaServer "replicaClerks" "s" in
      let: "args" := struct.mk AppendArgs [
        "cn" ::= struct.loadF ReplicaServer "cn" "s";
        "log" ::= struct.loadF ReplicaServer "opLog" "s";
        "commitIdx" ::= struct.loadF ReplicaServer "commitIdx" "s"
      ] in
      lock.release (struct.loadF ReplicaServer "mu" "s");;
      ForSlice (refT (struct.t ReplicaClerk)) "i" "ck" "clerks"
        (let: "ck" := "ck" in
        Fork (ReplicaClerk__AppendRPC "ck" "args";;
              lock.acquire (struct.loadF ReplicaServer "mu" "s");;
              (if: (struct.loadF ReplicaServer "cn" "s" = struct.get AppendArgs "cn" "args")
              then
                (if: slice.len (SliceGet (slice.T (slice.T byteT)) (struct.loadF ReplicaServer "matchLog" "s") "i") > slice.len (struct.get AppendArgs "log" "args")
                then SliceSet (slice.T (slice.T byteT)) (struct.loadF ReplicaServer "matchLog" "s") "i" (struct.get AppendArgs "log" "args")
                else #())
              else #());;
              lock.release (struct.loadF ReplicaServer "mu" "s")));;
      #true).

Definition ReplicaServer__GetNextLogEntry: val :=
  rec: "ReplicaServer__GetNextLogEntry" "s" :=
    slice.nil.

Definition ReplicaServer__AppendRPC: val :=
  rec: "ReplicaServer__AppendRPC" "s" "args" :=
    lock.acquire (struct.loadF ReplicaServer "mu" "s");;
    (if: struct.loadF ReplicaServer "cn" "s" ≠ struct.get AppendArgs "cn" "args"
    then
      lock.release (struct.loadF ReplicaServer "mu" "s");;
      #false
    else
      (if: slice.len (struct.get AppendArgs "log" "args") > slice.len (struct.loadF ReplicaServer "opLog" "s")
      then struct.storeF ReplicaServer "opLog" "s" (struct.get AppendArgs "log" "args")
      else #());;
      (if: struct.get AppendArgs "commitIdx" "args" > struct.loadF ReplicaServer "commitIdx" "s"
      then struct.storeF ReplicaServer "commitIdx" "s" (struct.get AppendArgs "commitIdx" "args")
      else #());;
      lock.release (struct.loadF ReplicaServer "mu" "s");;
      #true).

(* used for recovery/adding a new node into the system *)
Definition ReplicaServer__GetLogRPC: val :=
  rec: "ReplicaServer__GetLogRPC" "s" <> "reply" :=
    lock.acquire (struct.loadF ReplicaServer "mu" "s");;
    lock.release (struct.loadF ReplicaServer "mu" "s");;
    #().

Definition StartReplicaServer: val :=
  rec: "StartReplicaServer" "me" "confServer" :=
    let: "s" := struct.alloc ReplicaServer (zero_val (struct.t ReplicaServer)) in
    struct.storeF ReplicaServer "mu" "s" (lock.new #());;
    struct.storeF ReplicaServer "opLog" "s" (NewSlice LogEntry #0);;
    struct.storeF ReplicaServer "commitIdx" "s" #0;;
    struct.storeF ReplicaServer "confClerk" "s" (MakeConfClerk "confServer");;
    let: "v" := ConfClerk__Get (struct.loadF ReplicaServer "confClerk" "s") #0 in
    struct.storeF ReplicaServer "cn" "s" (struct.loadF VersionedValue "ver" "v");;
    struct.storeF ReplicaServer "conf" "s" (DecodePBConfiguration (struct.loadF VersionedValue "val" "v"));;
    struct.storeF ReplicaServer "isPrimary" "s" ("me" = struct.loadF PBConfiguration "primary" (struct.loadF ReplicaServer "conf" "s"));;
    "s".
