(* autogenerated from github.com/mit-pdos/gokv/simplepb/state *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.mit_pdos.gokv.simplepb.e.
From Goose Require github_com.mit_pdos.gokv.simplepb.pb.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* client.go *)

Definition Clerk := struct.decl [
  "cl" :: ptrT
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "host" :=
    struct.new Clerk [
      "cl" ::= pb.MakeClerk "host"
    ].

Definition Clerk__FetchAndAppend: val :=
  rec: "Clerk__FetchAndAppend" "ck" "key" "val" :=
    let: "args" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + slice.len "val")) in
    "args" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "args") "key";;
    "args" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "args") "val";;
    pb.Clerk__Apply (struct.loadF Clerk "cl" "ck") (![slice.T byteT] "args").

(* example.go *)

Definition KVState := struct.decl [
  "kvs" :: mapT (slice.T byteT);
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "sealed" :: boolT;
  "filename" :: stringT
].

Definition Op: ty := slice.T byteT.

(* helper for unmarshalling kvs *)
Definition KVState__decodeKvs: val :=
  rec: "KVState__decodeKvs" "s" "snap_in" :=
    (* log.Println("Decoding encoded state of length: ", len(snap_in)) *)
    let: "snap" := ref_to (slice.T byteT) "snap_in" in
    let: "kvs" := NewMap (slice.T byteT) #() in
    let: ("numEntries", "snap") := marshal.ReadInt (![slice.T byteT] "snap") in
    let: "i" := ref_to uint64T #0 in
    (for: (位: <>, ![uint64T] "i" < "numEntries"); (位: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := 位: <>,
      let: "key" := ref (zero_val uint64T) in
      let: "valLen" := ref (zero_val uint64T) in
      let: "val" := ref (zero_val (slice.T byteT)) in
      let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "snap") in
      "key" <-[uint64T] "0_ret";;
      "snap" <-[slice.T byteT] "1_ret";;
      let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "snap") in
      "valLen" <-[uint64T] "0_ret";;
      "snap" <-[slice.T byteT] "1_ret";;
      "val" <-[slice.T byteT] SliceTake (![slice.T byteT] "snap") (![uint64T] "valLen");;
      "snap" <-[slice.T byteT] SliceSkip byteT (![slice.T byteT] "snap") (![uint64T] "valLen");;
      MapInsert "kvs" (![uint64T] "key") (![slice.T byteT] "val");;
      Continue);;
    "kvs".

Definition KVState__encodeKvs: val :=
  rec: "KVState__encodeKvs" "s" :=
    let: "enc" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (MapLen (struct.loadF KVState "kvs" "s"));;
    MapIter (struct.loadF KVState "kvs" "s") (位: "k" "v",
      "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") "k";;
      "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (slice.len "v");;
      "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") "v");;
    ![slice.T byteT] "enc".

Definition RecoverKVState: val :=
  rec: "RecoverKVState" "fname" :=
    let: "s" := struct.alloc KVState (zero_val (struct.t KVState)) in
    let: "encState" := ref_to (slice.T byteT) (grove_ffi.Read "fname") in
    struct.storeF KVState "filename" "s" "fname";;
    (if: (slice.len (![slice.T byteT] "encState") = #0)
    then
      struct.storeF KVState "epoch" "s" #0;;
      struct.storeF KVState "nextIndex" "s" #0;;
      struct.storeF KVState "sealed" "s" #false;;
      struct.storeF KVState "kvs" "s" (NewMap (slice.T byteT) #())
    else
      let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "encState") in
      struct.storeF KVState "epoch" "s" "0_ret";;
      "encState" <-[slice.T byteT] "1_ret";;
      let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "encState") in
      struct.storeF KVState "nextIndex" "s" "0_ret";;
      "encState" <-[slice.T byteT] "1_ret";;
      let: "sealedInt" := ref (zero_val uint64T) in
      let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "encState") in
      "sealedInt" <-[uint64T] "0_ret";;
      "encState" <-[slice.T byteT] "1_ret";;
      struct.storeF KVState "sealed" "s" (![uint64T] "sealedInt" = #0);;
      struct.storeF KVState "kvs" "s" (KVState__decodeKvs "s" (![slice.T byteT] "encState")));;
    "s".

Definition KVState__getState: val :=
  rec: "KVState__getState" "s" :=
    let: "enc" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF KVState "epoch" "s");;
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF KVState "nextIndex" "s");;
    (if: struct.loadF KVState "sealed" "s"
    then "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") #1
    else "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") #0);;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (KVState__encodeKvs "s");;
    (* log.Println("Size of encoded state", len(enc)) *)
    ![slice.T byteT] "enc".

Definition KVState__MakeDurable: val :=
  rec: "KVState__MakeDurable" "s" :=
    grove_ffi.Write (struct.loadF KVState "filename" "s") (KVState__getState "s");;
    #().

Definition KVState__Apply: val :=
  rec: "KVState__Apply" "s" "op" :=
    let: ("key", "appendVal") := marshal.ReadInt "op" in
    let: "ret" := Fst (MapGet (struct.loadF KVState "kvs" "s") "key") in
    struct.storeF KVState "nextIndex" "s" (struct.loadF KVState "nextIndex" "s" + #1);;
    MapInsert (struct.loadF KVState "kvs" "s") "key" (SliceAppendSlice byteT (Fst (MapGet (struct.loadF KVState "kvs" "s") "key")) "appendVal");;
    KVState__MakeDurable "s";;
    "ret".

Definition KVState__SetStateAndUnseal: val :=
  rec: "KVState__SetStateAndUnseal" "s" "snap_in" "epoch" "nextIndex" :=
    KVState__decodeKvs "s" "snap_in";;
    struct.storeF KVState "epoch" "s" "epoch";;
    struct.storeF KVState "sealed" "s" #false;;
    struct.storeF KVState "nextIndex" "s" "nextIndex";;
    KVState__MakeDurable "s";;
    #().

Definition KVState__GetStateAndSeal: val :=
  rec: "KVState__GetStateAndSeal" "s" :=
    let: "ret" := KVState__encodeKvs "s" in
    struct.storeF KVState "sealed" "s" #true;;
    KVState__MakeDurable "s";;
    "ret".

Definition KVState__EnterEpoch: val :=
  rec: "KVState__EnterEpoch" "s" "epoch" :=
    struct.storeF KVState "epoch" "s" "epoch";;
    KVState__MakeDurable "s";;
    #().

Definition MakeKVStateMachine: val :=
  rec: "MakeKVStateMachine" "initState" :=
    struct.new pb.StateMachine [
      "Apply" ::= KVState__Apply "initState";
      "SetStateAndUnseal" ::= KVState__SetStateAndUnseal "initState";
      "GetStateAndSeal" ::= KVState__GetStateAndSeal "initState"
    ].

Definition KVServer := struct.decl [
  "r" :: ptrT
].

Definition MakeServer: val :=
  rec: "MakeServer" "fname" :=
    let: "s" := struct.alloc KVServer (zero_val (struct.t KVServer)) in
    let: "state" := RecoverKVState "fname" in
    struct.storeF KVServer "r" "s" (pb.MakeServer (MakeKVStateMachine "state") (struct.loadF KVState "nextIndex" "state") (struct.loadF KVState "epoch" "state") (struct.loadF KVState "sealed" "state"));;
    "s".

Definition KVServer__Serve: val :=
  rec: "KVServer__Serve" "s" "me" :=
    pb.Server__Serve (struct.loadF KVServer "r" "s") "me";;
    #().
