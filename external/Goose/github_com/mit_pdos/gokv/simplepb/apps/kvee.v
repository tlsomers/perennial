(* autogenerated from github.com/mit-pdos/gokv/simplepb/apps/kvee *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.mit_pdos.gokv.simplepb.apps.eesm.
From Goose Require github_com.mit_pdos.gokv.simplepb.apps.kv.
From Goose Require github_com.mit_pdos.gokv.simplepb.clerk.
From Goose Require github_com.mit_pdos.gokv.simplepb.simplelog.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* clerk.go *)

Definition Clerk := struct.decl [
  "cl" :: ptrT
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "confHost" :=
    struct.new Clerk [
      "cl" ::= clerk.Make "confHost"
    ].

Definition Clerk__Put: val :=
  rec: "Clerk__Put" "ck" "key" "val" :=
    let: "putArgs" := struct.new kv.PutArgs [
      "Key" ::= "key";
      "Val" ::= "val"
    ] in
    clerk.Clerk__Apply (struct.loadF Clerk "cl" "ck") (kv.EncodePutArgs "putArgs");;
    #().

Definition Clerk__Get: val :=
  rec: "Clerk__Get" "ck" "key" :=
    clerk.Clerk__Apply (struct.loadF Clerk "cl" "ck") (eesm.MakeRequest (kv.EncodeGetArgs "key")).

(* clerkpool.go *)

Definition ClerkPool := struct.decl [
  "mu" :: ptrT;
  "cls" :: slice.T ptrT;
  "confHost" :: uint64T
].

Definition MakeClerkPool: val :=
  rec: "MakeClerkPool" "confHost" :=
    struct.new ClerkPool [
      "mu" ::= lock.new #();
      "cls" ::= NewSlice ptrT #0;
      "confHost" ::= "confHost"
    ].

(* TODO: get rid of stale clerks from the ck.cls list?
   TODO: keep failed clerks out of ck.cls list? Maybe f(cl) can return an
   optional error saying "get rid of cl".
   XXX: what's the performance overhead of function pointer here v.s. manually
   inlining the body each time? *)
Definition ClerkPool__doWithClerk: val :=
  rec: "ClerkPool__doWithClerk" "ck" "f" :=
    lock.acquire (struct.loadF ClerkPool "mu" "ck");;
    let: "cl" := ref (zero_val ptrT) in
    (if: slice.len (struct.loadF ClerkPool "cls" "ck") > #0
    then
      "cl" <-[ptrT] SliceGet ptrT (struct.loadF ClerkPool "cls" "ck") #0;;
      struct.storeF ClerkPool "cls" "ck" (SliceSkip ptrT (struct.loadF ClerkPool "cls" "ck") #1);;
      lock.release (struct.loadF ClerkPool "mu" "ck");;
      "f" (![ptrT] "cl");;
      lock.acquire (struct.loadF ClerkPool "mu" "ck");;
      struct.storeF ClerkPool "cls" "ck" (SliceAppend ptrT (struct.loadF ClerkPool "cls" "ck") (![ptrT] "cl"));;
      lock.release (struct.loadF ClerkPool "mu" "ck");;
      #()
    else
      lock.release (struct.loadF ClerkPool "mu" "ck");;
      "cl" <-[ptrT] MakeClerk (struct.loadF ClerkPool "confHost" "ck");;
      "f" (![ptrT] "cl");;
      lock.acquire (struct.loadF ClerkPool "mu" "ck");;
      struct.storeF ClerkPool "cls" "ck" (SliceAppend ptrT (struct.loadF ClerkPool "cls" "ck") (![ptrT] "cl"));;
      struct.storeF ClerkPool "cls" "ck" (SliceAppend ptrT (struct.loadF ClerkPool "cls" "ck") (![ptrT] "cl"));;
      struct.storeF ClerkPool "cls" "ck" (SliceAppend ptrT (struct.loadF ClerkPool "cls" "ck") (![ptrT] "cl"));;
      struct.storeF ClerkPool "cls" "ck" (SliceAppend ptrT (struct.loadF ClerkPool "cls" "ck") (![ptrT] "cl"));;
      lock.release (struct.loadF ClerkPool "mu" "ck");;
      #()).

Definition ClerkPool__Put: val :=
  rec: "ClerkPool__Put" "ck" "key" "val" :=
    ClerkPool__doWithClerk "ck" ((λ: "ck",
      Clerk__Put "ck" "key" "val";;
      #()
      ));;
    #().

Definition ClerkPool__Get: val :=
  rec: "ClerkPool__Get" "ck" "key" :=
    let: "ret" := ref (zero_val (slice.T byteT)) in
    ClerkPool__doWithClerk "ck" ((λ: "ck",
      "ret" <-[slice.T byteT] Clerk__Get "ck" "key";;
      #()
      ));;
    ![slice.T byteT] "ret".

(* server.go *)

Definition Start: val :=
  rec: "Start" "host" "fname" :=
    simplelog.MakePbServer (eesm.MakeEEKVStateMachine (kv.MakeKVStateMachine #())) "fname";;
    #().
