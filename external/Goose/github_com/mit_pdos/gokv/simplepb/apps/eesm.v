(* autogenerated from github.com/mit-pdos/gokv/simplepb/apps/eesm *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.gokv.map_marshal.
From Goose Require github_com.mit_pdos.gokv.simplepb.clerk.
From Goose Require github_com.mit_pdos.gokv.simplepb.simplelog.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition EEStateMachine := struct.decl [
  "lastSeq" :: mapT uint64T;
  "lastReply" :: mapT (slice.T byteT);
  "nextCID" :: uint64T;
  "sm" :: ptrT
].

Definition OPTYPE_RW : expr := #(U8 0).

Definition OPTYPE_GETFRESHCID : expr := #(U8 1).

Definition OPTYPE_RO : expr := #(U8 2).

Definition EEStateMachine__applyVolatile: val :=
  rec: "EEStateMachine__applyVolatile" "s" "op" :=
    let: "ret" := ref (zero_val (slice.T byteT)) in
    (if: (SliceGet byteT "op" #0 = OPTYPE_GETFRESHCID)
    then
      "ret" <-[slice.T byteT] NewSliceWithCap byteT #0 #8;;
      "ret" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "ret") (struct.loadF EEStateMachine "nextCID" "s");;
      struct.storeF EEStateMachine "nextCID" "s" (struct.loadF EEStateMachine "nextCID" "s" + #1)
    else
      (if: (SliceGet byteT "op" #0 = OPTYPE_RW)
      then
        let: "n" := slice.len "op" in
        let: "enc" := SliceSubslice byteT "op" #1 "n" in
        let: ("cid", "enc2") := marshal.ReadInt "enc" in
        let: ("seq", "realOp") := marshal.ReadInt "enc2" in
        (if: Fst (MapGet (struct.loadF EEStateMachine "lastSeq" "s") "cid") ≥ "seq"
        then "ret" <-[slice.T byteT] Fst (MapGet (struct.loadF EEStateMachine "lastReply" "s") "cid")
        else
          "ret" <-[slice.T byteT] struct.loadF simplelog.InMemoryStateMachine "ApplyVolatile" (struct.loadF EEStateMachine "sm" "s") "realOp";;
          MapInsert (struct.loadF EEStateMachine "lastReply" "s") "cid" (![slice.T byteT] "ret");;
          MapInsert (struct.loadF EEStateMachine "lastSeq" "s") "cid" "seq")
      else
        (if: (SliceGet byteT "op" #0 = OPTYPE_RO)
        then
          let: "n" := slice.len "op" in
          let: "realOp" := SliceSubslice byteT "op" #1 "n" in
          "ret" <-[slice.T byteT] struct.loadF simplelog.InMemoryStateMachine "ApplyVolatile" (struct.loadF EEStateMachine "sm" "s") "realOp"
        else Panic ("unexpected ee op type"))));;
    ![slice.T byteT] "ret".

Definition EEStateMachine__applyReadonly: val :=
  rec: "EEStateMachine__applyReadonly" "s" "op" :=
    let: "ret" := ref (zero_val (slice.T byteT)) in
    (if: (SliceGet byteT "op" #0 = OPTYPE_GETFRESHCID)
    then Panic ("Got GETFRESHCID as a read-only op")
    else
      (if: (SliceGet byteT "op" #0 = OPTYPE_RW)
      then Panic ("Got RW as a read-only op")
      else
        (if: (SliceGet byteT "op" #0 = OPTYPE_RO)
        then
          let: "n" := slice.len "op" in
          let: "realOp" := SliceSubslice byteT "op" #1 "n" in
          "ret" <-[slice.T byteT] struct.loadF simplelog.InMemoryStateMachine "ApplyReadonly" (struct.loadF EEStateMachine "sm" "s") "realOp"
        else Panic ("unexpected ee op type"))));;
    ![slice.T byteT] "ret".

Definition EEStateMachine__getState: val :=
  rec: "EEStateMachine__getState" "s" :=
    let: "appState" := struct.loadF simplelog.InMemoryStateMachine "GetState" (struct.loadF EEStateMachine "sm" "s") #() in
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #0) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF EEStateMachine "nextCID" "s");;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (map_marshal.EncodeMapU64ToU64 (struct.loadF EEStateMachine "lastSeq" "s"));;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (map_marshal.EncodeMapU64ToBytes (struct.loadF EEStateMachine "lastReply" "s"));;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") "appState";;
    ![slice.T byteT] "enc".

Definition EEStateMachine__setState: val :=
  rec: "EEStateMachine__setState" "s" "state" :=
    let: "enc" := ref_to (slice.T byteT) "state" in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF EEStateMachine "nextCID" "s" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := map_marshal.DecodeMapU64ToU64 (![slice.T byteT] "enc") in
    struct.storeF EEStateMachine "lastSeq" "s" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := map_marshal.DecodeMapU64ToBytes (![slice.T byteT] "enc") in
    struct.storeF EEStateMachine "lastReply" "s" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.loadF simplelog.InMemoryStateMachine "SetState" (struct.loadF EEStateMachine "sm" "s") (![slice.T byteT] "enc");;
    #().

Definition MakeEEKVStateMachine: val :=
  rec: "MakeEEKVStateMachine" "sm" :=
    let: "s" := struct.alloc EEStateMachine (zero_val (struct.t EEStateMachine)) in
    struct.storeF EEStateMachine "lastSeq" "s" (NewMap uint64T #());;
    struct.storeF EEStateMachine "lastReply" "s" (NewMap (slice.T byteT) #());;
    struct.storeF EEStateMachine "nextCID" "s" #0;;
    struct.storeF EEStateMachine "sm" "s" "sm";;
    struct.new simplelog.InMemoryStateMachine [
      "ApplyVolatile" ::= EEStateMachine__applyVolatile "s";
      "GetState" ::= (λ: <>,
        EEStateMachine__getState "s"
        );
      "SetState" ::= EEStateMachine__setState "s"
    ].

Definition Clerk := struct.decl [
  "ck" :: ptrT;
  "cid" :: uint64T;
  "seq" :: uint64T
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "confHost" :=
    let: "ck" := struct.alloc Clerk (zero_val (struct.t Clerk)) in
    struct.storeF Clerk "ck" "ck" (clerk.Make "confHost");;
    let: "v" := NewSlice byteT #1 in
    SliceSet byteT "v" #0 OPTYPE_GETFRESHCID;;
    let: "cidEnc" := clerk.Clerk__Apply (struct.loadF Clerk "ck" "ck") "v" in
    let: ("0_ret", "1_ret") := marshal.ReadInt "cidEnc" in
    struct.storeF Clerk "cid" "ck" "0_ret";;
    "1_ret";;
    struct.storeF Clerk "seq" "ck" #1;;
    "ck".

Definition Clerk__ApplyExactlyOnce: val :=
  rec: "Clerk__ApplyExactlyOnce" "ck" "req" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #1 #1) in
    SliceSet byteT (![slice.T byteT] "enc") #0 OPTYPE_RW;;
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF Clerk "cid" "ck");;
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF Clerk "seq" "ck");;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") "req";;
    struct.storeF Clerk "seq" "ck" (std.SumAssumeNoOverflow (struct.loadF Clerk "seq" "ck") #1);;
    clerk.Clerk__Apply (struct.loadF Clerk "ck" "ck") (![slice.T byteT] "enc").

Definition Clerk__ApplyReadonly: val :=
  rec: "Clerk__ApplyReadonly" "ck" "req" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #1 #1) in
    SliceSet byteT (![slice.T byteT] "enc") #0 OPTYPE_RO;;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") "req";;
    clerk.Clerk__ApplyRo (struct.loadF Clerk "ck" "ck") (![slice.T byteT] "enc").
