(* autogenerated from github.com/mit-pdos/gokv/simplepb/pb *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.mit_pdos.gokv.simplepb.e.
From Goose Require github_com.mit_pdos.gokv.urpc.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_marshal.go *)

Definition Op: ty := slice.T byteT.

Definition ApplyArgs := struct.decl [
  "epoch" :: uint64T;
  "index" :: uint64T;
  "op" :: slice.T byteT
].

Definition EncodeApplyArgs: val :=
  rec: "EncodeApplyArgs" "args" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + #8 + slice.len (struct.loadF ApplyArgs "op" "args"))) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF ApplyArgs "epoch" "args");;
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF ApplyArgs "index" "args");;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF ApplyArgs "op" "args");;
    ![slice.T byteT] "enc".

Definition DecodeApplyArgs: val :=
  rec: "DecodeApplyArgs" "enc_args" :=
    let: "enc" := ref_to (slice.T byteT) "enc_args" in
    let: "args" := struct.alloc ApplyArgs (zero_val (struct.t ApplyArgs)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF ApplyArgs "epoch" "args" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF ApplyArgs "index" "args" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF ApplyArgs "op" "args" (![slice.T byteT] "enc");;
    "args".

Definition SetStateArgs := struct.decl [
  "Epoch" :: uint64T;
  "State" :: slice.T byteT
].

Definition EncodeSetStateArgs: val :=
  rec: "EncodeSetStateArgs" "args" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + slice.len (struct.loadF SetStateArgs "State" "args"))) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF SetStateArgs "Epoch" "args");;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF SetStateArgs "State" "args");;
    ![slice.T byteT] "enc".

Definition DecodeSetStateArgs: val :=
  rec: "DecodeSetStateArgs" "enc_args" :=
    let: "enc" := ref_to (slice.T byteT) "enc_args" in
    let: "args" := struct.alloc SetStateArgs (zero_val (struct.t SetStateArgs)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF SetStateArgs "Epoch" "args" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF SetStateArgs "State" "args" (![slice.T byteT] "enc");;
    "args".

Definition GetStateArgs := struct.decl [
  "Epoch" :: uint64T
].

Definition EncodeGetStateArgs: val :=
  rec: "EncodeGetStateArgs" "args" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF GetStateArgs "Epoch" "args");;
    ![slice.T byteT] "enc".

Definition DecodeGetStateArgs: val :=
  rec: "DecodeGetStateArgs" "enc" :=
    let: "args" := struct.alloc GetStateArgs (zero_val (struct.t GetStateArgs)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt "enc" in
    struct.storeF GetStateArgs "Epoch" "args" "0_ret";;
    "1_ret";;
    "args".

Definition GetStateReply := struct.decl [
  "Err" :: uint64T;
  "State" :: slice.T byteT
].

Definition EncodeGetStateReply: val :=
  rec: "EncodeGetStateReply" "reply" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF GetStateReply "Err" "reply");;
    "enc" <-[slice.T byteT] marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF GetStateReply "State" "reply");;
    ![slice.T byteT] "enc".

Definition DecodeGetStateReply: val :=
  rec: "DecodeGetStateReply" "enc_reply" :=
    let: "enc" := ref_to (slice.T byteT) "enc_reply" in
    let: "reply" := struct.alloc GetStateReply (zero_val (struct.t GetStateReply)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF GetStateReply "Err" "reply" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF GetStateReply "State" "reply" (![slice.T byteT] "enc");;
    "reply".

Definition BecomePrimaryArgs := struct.decl [
  "Epoch" :: uint64T;
  "Replicas" :: slice.T uint64T
].

Definition EncodeBecomePrimaryArgs: val :=
  rec: "EncodeBecomePrimaryArgs" "args" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + #8 + #8 * slice.len (struct.loadF BecomePrimaryArgs "Replicas" "args"))) in
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF BecomePrimaryArgs "Epoch" "args");;
    "enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") (slice.len (struct.loadF BecomePrimaryArgs "Replicas" "args"));;
    ForSlice uint64T <> "h" (struct.loadF BecomePrimaryArgs "Replicas" "args")
      ("enc" <-[slice.T byteT] marshal.WriteInt (![slice.T byteT] "enc") "h");;
    ![slice.T byteT] "enc".

Definition DecodeBecomePrimaryArgs: val :=
  rec: "DecodeBecomePrimaryArgs" "enc_args" :=
    let: "enc" := ref_to (slice.T byteT) "enc_args" in
    let: "args" := struct.alloc BecomePrimaryArgs (zero_val (struct.t BecomePrimaryArgs)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF BecomePrimaryArgs "Epoch" "args" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("replicasLen", "enc") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF BecomePrimaryArgs "Replicas" "args" (NewSlice uint64T "replicasLen");;
    ForSlice uint64T "i" <> (struct.loadF BecomePrimaryArgs "Replicas" "args")
      (let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
      SliceSet uint64T (struct.loadF BecomePrimaryArgs "Replicas" "args") "i" "0_ret";;
      "enc" <-[slice.T byteT] "1_ret");;
    "args".

(* clerk.go *)

Definition Clerk := struct.decl [
  "cl" :: ptrT
].

Definition RPC_APPLY : expr := #0.

Definition RPC_SETSTATE : expr := #1.

Definition RPC_GETSTATE : expr := #2.

Definition MakeClerk: val :=
  rec: "MakeClerk" "host" :=
    struct.new Clerk [
      "cl" ::= urpc.MakeClient "host"
    ].

Definition Clerk__Apply: val :=
  rec: "Clerk__Apply" "ck" "args" :=
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := urpc.Client__Call (struct.loadF Clerk "cl" "ck") RPC_APPLY (EncodeApplyArgs "args") "reply" #100 in
    (if: "err" ≠ #0
    then e.Timeout
    else e.DecodeError (![slice.T byteT] "reply")).

Definition Clerk__SetState: val :=
  rec: "Clerk__SetState" "ck" "args" :=
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := urpc.Client__Call (struct.loadF Clerk "cl" "ck") RPC_APPLY (EncodeSetStateArgs "args") "reply" #1000 in
    (if: "err" ≠ #0
    then e.Timeout
    else e.DecodeError (![slice.T byteT] "reply")).

Definition Clerk__GetState: val :=
  rec: "Clerk__GetState" "ck" "args" :=
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := urpc.Client__Call (struct.loadF Clerk "cl" "ck") RPC_APPLY (EncodeGetStateArgs "args") "reply" #1000 in
    (if: "err" ≠ #0
    then
      struct.new GetStateReply [
        "Err" ::= e.Timeout
      ]
    else DecodeGetStateReply (![slice.T byteT] "reply")).

Definition Clerk__BecomePrimary: val :=
  rec: "Clerk__BecomePrimary" "ck" "args" :=
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := urpc.Client__Call (struct.loadF Clerk "cl" "ck") RPC_APPLY (EncodeBecomePrimaryArgs "args") "reply" #100 in
    (if: "err" ≠ #0
    then e.Timeout
    else e.DecodeError (![slice.T byteT] "reply")).

(* server.go *)

Definition StateMachine := struct.decl [
  "Apply" :: (Op -> slice.T byteT)%ht;
  "SetState" :: (slice.T byteT -> unitT)%ht;
  "GetState" :: (unitT -> slice.T byteT)%ht;
  "EnterEpoch" :: (uint64T -> unitT)%ht
].

Definition Server := struct.decl [
  "mu" :: ptrT;
  "epoch" :: uint64T;
  "sm" :: ptrT;
  "nextIndex" :: uint64T;
  "isPrimary" :: boolT;
  "clerks" :: slice.T ptrT
].

(* called on the primary server to apply a new operation. *)
Definition Server__Apply: val :=
  rec: "Server__Apply" "s" "op" :=
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: ~ (struct.loadF Server "isPrimary" "s")
    then
      lock.release (struct.loadF Server "mu" "s");;
      (e.Stale, slice.nil)
    else
      let: "ret" := StateMachine__Apply (struct.loadF Server "sm" "s") "op" in
      let: "nextIndex" := struct.loadF Server "nextIndex" "s" in
      let: "epoch" := struct.loadF Server "epoch" "s" in
      let: "clerks" := struct.loadF Server "clerks" "s" in
      lock.release (struct.loadF Server "mu" "s");;
      let: "wg" := struct.alloc sync.WaitGroup (zero_val (struct.t sync.WaitGroup)) in
      let: "errs" := NewSlice uint64T (slice.len "clerks") in
      let: "args" := struct.new ApplyArgs [
        "epoch" ::= "epoch";
        "index" ::= "nextIndex";
        "op" ::= "op"
      ] in
      ForSlice ptrT "i" "clerk" "clerks"
        (let: "clerk" := "clerk" in
        let: "i" := "i" in
        sync.WaitGroup__Add "wg" #1;;
        Fork (SliceSet uint64T "errs" "i" (Clerk__Apply "clerk" "args")));;
      sync.WaitGroup__Wait "wg";;
      let: "err" := ref_to uint64T e.None in
      ForSlice uint64T <> "err2" "errs"
        (if: "err2" ≠ e.None
        then "err" <-[uint64T] "err2"
        else #());;
      (![uint64T] "err", "ret")).

(* called on backup servers to apply an operation so it is replicated and
   can be considered committed by primary. *)
Definition Server__ApplyAsBackup: val :=
  rec: "Server__ApplyAsBackup" "s" "args" :=
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: Server__epochFence "s" (struct.loadF ApplyArgs "epoch" "args")
    then
      lock.release (struct.loadF Server "mu" "s");;
      e.Stale
    else
      (if: struct.loadF ApplyArgs "index" "args" ≠ struct.loadF Server "nextIndex" "s"
      then
        lock.release (struct.loadF Server "mu" "s");;
        e.OutOfOrder
      else
        StateMachine__Apply (struct.loadF Server "sm" "s") (struct.loadF ApplyArgs "op" "args");;
        struct.storeF Server "nextIndex" "s" (struct.loadF Server "nextIndex" "s" + #1);;
        lock.release (struct.loadF Server "mu" "s");;
        e.None)).

Definition Server__SetState: val :=
  rec: "Server__SetState" "s" "args" :=
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: struct.loadF Server "epoch" "s" ≥ struct.loadF SetStateArgs "Epoch" "args"
    then e.Stale
    else
      StateMachine__SetState (struct.loadF Server "sm" "s") (struct.loadF SetStateArgs "State" "args");;
      lock.release (struct.loadF Server "mu" "s");;
      e.None).

Definition Server__GetState: val :=
  rec: "Server__GetState" "s" "args" :=
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: Server__epochFence "s" (struct.loadF GetStateArgs "Epoch" "args")
    then
      lock.release (struct.loadF Server "mu" "s");;
      struct.new GetStateReply [
        "Err" ::= e.Stale;
        "State" ::= slice.nil
      ]
    else
      let: "ret" := StateMachine__GetState (struct.loadF Server "sm" "s") in
      lock.release (struct.loadF Server "mu" "s");;
      struct.new GetStateReply [
        "Err" ::= e.None;
        "State" ::= "ret"
      ]).

(* returns true iff stale *)
Definition Server__epochFence: val :=
  rec: "Server__epochFence" "s" "epoch" :=
    (if: struct.loadF Server "epoch" "s" < "epoch"
    then
      struct.storeF Server "epoch" "s" "epoch";;
      struct.storeF Server "isPrimary" "s" #false;;
      struct.storeF Server "nextIndex" "s" #0
    else #());;
    struct.loadF Server "epoch" "s" > "epoch".

Definition Server__BecomePrimary: val :=
  rec: "Server__BecomePrimary" "s" "args" :=
    lock.acquire (struct.loadF Server "mu" "s");;
    (if: Server__epochFence "s" (struct.loadF BecomePrimaryArgs "Epoch" "args")
    then
      lock.release (struct.loadF Server "mu" "s");;
      e.Stale
    else
      struct.storeF Server "isPrimary" "s" #true;;
      struct.storeF Server "clerks" "s" (NewSlice ptrT (slice.len (struct.loadF BecomePrimaryArgs "Replicas" "args")));;
      ForSlice ptrT "i" <> (struct.loadF Server "clerks" "s")
        (SliceSet ptrT (struct.loadF Server "clerks" "s") "i" (MakeClerk (SliceGet uint64T (struct.loadF BecomePrimaryArgs "Replicas" "args") "i")));;
      lock.release (struct.loadF Server "mu" "s");;
      e.None).

Definition MakeServer: val :=
  rec: "MakeServer" "sm" "nextIndex" "epoch" :=
    let: "s" := struct.alloc Server (zero_val (struct.t Server)) in
    struct.storeF Server "mu" "s" (lock.new #());;
    struct.storeF Server "epoch" "s" "epoch";;
    struct.storeF Server "sm" "s" "sm";;
    struct.storeF Server "nextIndex" "s" "nextIndex";;
    struct.storeF Server "isPrimary" "s" #false;;
    "s".

Definition Server__Serve: val :=
  rec: "Server__Serve" "s" "me" :=
    let: "handlers" := NewMap ((slice.T byteT -> ptrT -> unitT)%ht) #() in
    MapInsert "handlers" RPC_APPLY (λ: "args" "reply",
      "reply" <-[slice.T byteT] e.EncodeError (Server__ApplyAsBackup "s" (DecodeApplyArgs "args"));;
      #()
      );;
    MapInsert "handlers" RPC_SETSTATE (λ: "args" "reply",
      "reply" <-[slice.T byteT] e.EncodeError (Server__SetState "s" (DecodeSetStateArgs "args"));;
      #()
      );;
    MapInsert "handlers" RPC_GETSTATE (λ: "args" "reply",
      "reply" <-[slice.T byteT] EncodeGetStateReply (Server__GetState "s" (DecodeGetStateArgs "args"));;
      #()
      );;
    let: "rs" := urpc.MakeServer "handlers" in
    urpc.Server__Serve "rs" "me";;
    #().
