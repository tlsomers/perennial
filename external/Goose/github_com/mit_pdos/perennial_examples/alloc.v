(* autogenerated from github.com/mit-pdos/perennial-examples/alloc *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

Module unit.
  Definition S := struct.decl [
  ].
End unit.

Definition AddrSet: ty := mapT (struct.t unit.S).

(* Allocator manages free disk blocks. It does not store its state durably, so
   the caller is responsible for returning its set of free disk blocks on
   recovery. *)
Module Allocator.
  Definition S := struct.decl [
    "m" :: lockRefT;
    "free" :: mapT (struct.t unit.S)
  ].
End Allocator.

Definition FreeRange: val :=
  rec: "FreeRange" "start" "sz" :=
    let: "m" := NewMap (struct.t unit.S) in
    let: "end" := "start" + "sz" in
    let: "i" := ref_to uint64T "start" in
    (for: (位: <>, ![uint64T] "i" < "end"); (位: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := 位: <>,
      MapInsert "m" (![uint64T] "i") (struct.mk unit.S [
      ]);;
      Continue);;
    "m".

Definition New: val :=
  rec: "New" "free" :=
    struct.new Allocator.S [
      "m" ::= lock.new #();
      "free" ::= "free"
    ].

Definition findKey: val :=
  rec: "findKey" "m" :=
    let: "found" := ref_to uint64T #0 in
    let: "ok" := ref_to boolT #false in
    MapIter "m" (位: "k" <>,
      (if: ~ (![boolT] "ok")
      then
        "found" <-[uint64T] "k";;
        "ok" <-[boolT] #true
      else #()));;
    (![uint64T] "found", ![boolT] "ok").

(* Reserve transfers ownership of a free block from the Allocator to the caller *)
Definition Allocator__Reserve: val :=
  rec: "Allocator__Reserve" "a" :=
    lock.acquire (struct.loadF Allocator.S "m" "a");;
    let: ("k", "ok") := findKey (struct.loadF Allocator.S "free" "a") in
    MapDelete (struct.loadF Allocator.S "free" "a") "k";;
    lock.release (struct.loadF Allocator.S "m" "a");;
    ("k", "ok").
