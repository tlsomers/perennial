(* autogenerated from github.com/mit-pdos/perennial-examples/inode *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

From Goose Require github_com.tchajed.marshal.

Definition MaxBlocks : expr := #511.

Module Inode.
  Definition S := struct.decl [
    "d" :: disk.Disk;
    "m" :: lockRefT;
    "addr" :: uint64T;
    "addrs" :: slice.T uint64T
  ].
End Inode.

Definition Open: val :=
  rec: "Open" "d" "addr" :=
    let: "b" := disk.Read "addr" in
    let: "dec" := marshal.NewDec "b" in
    let: "numAddrs" := marshal.Dec__GetInt "dec" in
    let: "addrs" := marshal.Dec__GetInts "dec" "numAddrs" in
    struct.new Inode.S [
      "d" ::= "d";
      "m" ::= lock.new #();
      "addr" ::= "addr";
      "addrs" ::= "addrs"
    ].

(* UsedBlocks returns the addresses allocated to the inode for the purposes
   of recovery. Assumes full ownership of the inode, so does not lock,
   and expects the caller to need only temporary access to the returned slice. *)
Definition Inode__UsedBlocks: val :=
  rec: "Inode__UsedBlocks" "i" :=
    struct.loadF Inode.S "addrs" "i".

Definition Inode__Read: val :=
  rec: "Inode__Read" "i" "off" :=
    lock.acquire (struct.loadF Inode.S "m" "i");;
    (if: "off" ≥ slice.len (struct.loadF Inode.S "addrs" "i")
    then
      lock.release (struct.loadF Inode.S "m" "i");;
      slice.nil
    else
      let: "a" := SliceGet uint64T (struct.loadF Inode.S "addrs" "i") "off" in
      let: "b" := disk.Read "a" in
      lock.release (struct.loadF Inode.S "m" "i");;
      "b").

Definition Inode__Size: val :=
  rec: "Inode__Size" "i" :=
    lock.acquire (struct.loadF Inode.S "m" "i");;
    let: "sz" := slice.len (struct.loadF Inode.S "addrs" "i") in
    lock.release (struct.loadF Inode.S "m" "i");;
    "sz".

Definition Inode__mkHdr: val :=
  rec: "Inode__mkHdr" "i" :=
    let: "enc" := marshal.NewEnc disk.BlockSize in
    marshal.Enc__PutInt "enc" (slice.len (struct.loadF Inode.S "addrs" "i"));;
    marshal.Enc__PutInts "enc" (struct.loadF Inode.S "addrs" "i");;
    let: "hdr" := marshal.Enc__Finish "enc" in
    "hdr".

Definition AppendStatus: ty := byteT.

Definition AppendOk : expr := #(U8 0).

Definition AppendAgain : expr := #(U8 1).

Definition AppendFull : expr := #(U8 2).

(* Append adds a block to the inode.

   Takes ownership of the disk at a on success.

   Returns:
   - AppendOk on success and takes ownership of the allocated block.
   - AppendFull if inode is out of space (and returns the allocated block)
   - AppendAgain if inode needs a metadata block. Call i.Alloc and try again.
   	 Returns the allocated block. *)
Definition Inode__Append: val :=
  rec: "Inode__Append" "i" "a" :=
    lock.acquire (struct.loadF Inode.S "m" "i");;
    (if: slice.len (struct.loadF Inode.S "addrs" "i") ≥ MaxBlocks
    then
      lock.release (struct.loadF Inode.S "m" "i");;
      AppendFull
    else
      struct.storeF Inode.S "addrs" "i" (SliceAppend uint64T (struct.loadF Inode.S "addrs" "i") "a");;
      let: "hdr" := Inode__mkHdr "i" in
      disk.Write (struct.loadF Inode.S "addr" "i") "hdr";;
      lock.release (struct.loadF Inode.S "m" "i");;
      AppendOk).

(* Give a block to the inode for metadata purposes.

   Returns true if the block was consumed. *)
Definition Inode__Alloc: val :=
  rec: "Inode__Alloc" "i" "a" :=
    #false.
