(* autogenerated from github.com/mit-pdos/secure-chat/ktMerkle *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.gokv.urpc.
From Goose Require github_com.mit_pdos.secure_chat.cryptoHelpers.
From Goose Require github_com.mit_pdos.secure_chat.cryptoShim.
From Goose Require github_com.mit_pdos.secure_chat.merkle.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* encoding.go *)

Definition Epoch: ty := uint64T.

Definition Link: ty := slice.T byteT.

Definition Error: ty := uint64T.

Definition ErrNone : expr := #0.

Definition ErrSome : expr := #1.

Definition RpcKeyServUpdateEpoch : expr := #1.

Definition RpcKeyServPut : expr := #2.

Definition RpcKeyServGetIdAtEpoch : expr := #3.

Definition RpcKeyServGetIdLatest : expr := #4.

Definition RpcKeyServGetDigest : expr := #5.

Definition RpcAuditorUpdate : expr := #1.

Definition RpcAuditorGetLink : expr := #2.

Definition CopySlice: val :=
  rec: "CopySlice" "b0" :=
    let: "b1" := NewSlice byteT (slice.len "b0") in
    SliceCopy byteT "b1" "b0";;
    "b1".

Definition SafeReadInt: val :=
  rec: "SafeReadInt" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    (if: (slice.len "b0") < #8
    then (#0, slice.nil, ErrSome)
    else
      let: ("data", "b") := marshal.ReadInt (![slice.T byteT] "b") in
      ("data", ![slice.T byteT] "b", ErrNone)).

Definition SafeReadBytes: val :=
  rec: "SafeReadBytes" "b0" "length" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    (if: (slice.len (![slice.T byteT] "b")) < "length"
    then (slice.nil, slice.nil, ErrSome)
    else
      let: ("data", "b") := marshal.ReadBytes (![slice.T byteT] "b") "length" in
      ("data", ![slice.T byteT] "b", ErrNone)).

Definition WriteBool: val :=
  rec: "WriteBool" "b0" "data" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: "data1" := ref (zero_val uint64T) in
    (if: "data"
    then "data1" <-[uint64T] #1
    else #());;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (![uint64T] "data1"));;
    ![slice.T byteT] "b".

Definition ReadBool: val :=
  rec: "ReadBool" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("data", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (#false, slice.nil, "err")
    else
      let: "data1" := ref (zero_val boolT) in
      (if: "data" ≠ #0
      then "data1" <-[boolT] #true
      else #());;
      (![boolT] "data1", ![slice.T byteT] "b", ErrNone)).

Definition WriteSlice1D: val :=
  rec: "WriteSlice1D" "b0" "data" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (slice.len "data"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") "data");;
    ![slice.T byteT] "b".

Definition WriteSlice2D: val :=
  rec: "WriteSlice2D" "b0" "data" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (slice.len "data"));;
    ForSlice (slice.T byteT) <> "data1" "data"
      ("b" <-[slice.T byteT] (WriteSlice1D (![slice.T byteT] "b") "data1"));;
    ![slice.T byteT] "b".

Definition WriteSlice3D: val :=
  rec: "WriteSlice3D" "b0" "data" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (slice.len "data"));;
    ForSlice (slice.T (slice.T byteT)) <> "data1" "data"
      ("b" <-[slice.T byteT] (WriteSlice2D (![slice.T byteT] "b") "data1"));;
    ![slice.T byteT] "b".

Definition ReadSlice1D: val :=
  rec: "ReadSlice1D" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("length", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, slice.nil, "err")
    else
      let: (("data", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") "length" in
      (if: "err" ≠ ErrNone
      then (slice.nil, slice.nil, "err")
      else ("data", ![slice.T byteT] "b", ErrNone))).

Definition ReadSlice2D: val :=
  rec: "ReadSlice2D" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("length", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, slice.nil, "err")
    else
      let: "data0" := ref (zero_val (slice.T (slice.T byteT))) in
      let: "err0" := ref (zero_val uint64T) in
      let: "i" := ref (zero_val uint64T) in
      Skip;;
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: "data1" := ref (zero_val (slice.T byteT)) in
        let: "err1" := ref (zero_val uint64T) in
        let: (("0_ret", "1_ret"), "2_ret") := ReadSlice1D (![slice.T byteT] "b") in
        "data1" <-[slice.T byteT] "0_ret";;
        "b" <-[slice.T byteT] "1_ret";;
        "err1" <-[uint64T] "2_ret";;
        (if: (![uint64T] "err1") ≠ ErrNone
        then
          "err0" <-[uint64T] (![uint64T] "err1");;
          Continue
        else
          "data0" <-[slice.T (slice.T byteT)] (SliceAppend (slice.T byteT) (![slice.T (slice.T byteT)] "data0") (![slice.T byteT] "data1"));;
          Continue));;
      (if: (![uint64T] "err0") ≠ ErrNone
      then (slice.nil, slice.nil, ![uint64T] "err0")
      else (![slice.T (slice.T byteT)] "data0", ![slice.T byteT] "b", ErrNone))).

Definition ReadSlice3D: val :=
  rec: "ReadSlice3D" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("length", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, slice.nil, "err")
    else
      let: "data0" := ref (zero_val (slice.T (slice.T (slice.T byteT)))) in
      let: "err0" := ref (zero_val uint64T) in
      let: "i" := ref (zero_val uint64T) in
      Skip;;
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: "data1" := ref (zero_val (slice.T (slice.T byteT))) in
        let: "err1" := ref (zero_val uint64T) in
        let: (("0_ret", "1_ret"), "2_ret") := ReadSlice2D (![slice.T byteT] "b") in
        "data1" <-[slice.T (slice.T byteT)] "0_ret";;
        "b" <-[slice.T byteT] "1_ret";;
        "err1" <-[uint64T] "2_ret";;
        (if: (![uint64T] "err1") ≠ ErrNone
        then
          "err0" <-[uint64T] (![uint64T] "err1");;
          Continue
        else
          "data0" <-[slice.T (slice.T (slice.T byteT))] (SliceAppend (slice.T (slice.T byteT)) (![slice.T (slice.T (slice.T byteT))] "data0") (![slice.T (slice.T byteT)] "data1"));;
          Continue));;
      (if: (![uint64T] "err0") ≠ ErrNone
      then (slice.nil, slice.nil, ![uint64T] "err0")
      else (![slice.T (slice.T (slice.T byteT))] "data0", ![slice.T byteT] "b", ErrNone))).

Definition EpochHash := struct.decl [
  "Epoch" :: Epoch;
  "Hash" :: slice.T byteT
].

Definition EpochHash__Encode: val :=
  rec: "EpochHash__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF EpochHash "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF EpochHash "Hash" "o"));;
    ![slice.T byteT] "b".

Definition EpochHash__Decode: val :=
  rec: "EpochHash__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      let: (("hash", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        struct.storeF EpochHash "Epoch" "o" "epoch";;
        struct.storeF EpochHash "Hash" "o" "hash";;
        (![slice.T byteT] "b", ErrNone))).

Definition PutArg := struct.decl [
  "Id" :: slice.T byteT;
  "Val" :: slice.T byteT
].

Definition PutArg__Encode: val :=
  rec: "PutArg__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF PutArg "Id" "o"));;
    "b" <-[slice.T byteT] (WriteSlice1D (![slice.T byteT] "b") (struct.loadF PutArg "Val" "o"));;
    ![slice.T byteT] "b".

Definition PutArg__Decode: val :=
  rec: "PutArg__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("id", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      let: (("val", "b"), "err") := ReadSlice1D (![slice.T byteT] "b") in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        struct.storeF PutArg "Id" "o" "id";;
        struct.storeF PutArg "Val" "o" "val";;
        (![slice.T byteT] "b", ErrNone))).

Definition PutReply := struct.decl [
  "Epoch" :: Epoch;
  "Error" :: Error
].

Definition PutReply__Encode: val :=
  rec: "PutReply__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF PutReply "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF PutReply "Error" "o"));;
    ![slice.T byteT] "b".

Definition PutReply__Decode: val :=
  rec: "PutReply__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      let: (("error", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        struct.storeF PutReply "Epoch" "o" "epoch";;
        struct.storeF PutReply "Error" "o" "error";;
        (![slice.T byteT] "b", ErrNone))).

Definition CallPut: val :=
  rec: "CallPut" "cli" "id" "val" :=
    let: "argB" := PutArg__Encode (struct.new PutArg [
      "Id" ::= "id";
      "Val" ::= "val"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" RpcKeyServPut "argB" "replyB" #100 in
    (if: "err0" ≠ ErrNone
    then (#0, "err0")
    else
      let: "reply" := struct.new PutReply [
      ] in
      let: (<>, "err1") := PutReply__Decode "reply" "replyB" in
      (if: "err1" ≠ ErrNone
      then (#0, "err1")
      else (struct.loadF PutReply "Epoch" "reply", struct.loadF PutReply "Error" "reply"))).

Definition GetIdAtEpochArg := struct.decl [
  "Id" :: slice.T byteT;
  "Epoch" :: Epoch
].

Definition GetIdAtEpochArg__Encode: val :=
  rec: "GetIdAtEpochArg__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF GetIdAtEpochArg "Id" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF GetIdAtEpochArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition GetIdAtEpochArg__Decode: val :=
  rec: "GetIdAtEpochArg__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("id", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      let: (("epoch", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        struct.storeF GetIdAtEpochArg "Id" "o" "id";;
        struct.storeF GetIdAtEpochArg "Epoch" "o" "epoch";;
        (![slice.T byteT] "b", ErrNone))).

Definition GetIdAtEpochReply := struct.decl [
  "Val" :: slice.T byteT;
  "Digest" :: slice.T byteT;
  "ProofTy" :: boolT;
  "Proof" :: slice.T (slice.T (slice.T byteT));
  "Error" :: Error
].

Definition GetIdAtEpochReply__Encode: val :=
  rec: "GetIdAtEpochReply__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (WriteSlice1D (![slice.T byteT] "b") (struct.loadF GetIdAtEpochReply "Val" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF GetIdAtEpochReply "Digest" "o"));;
    "b" <-[slice.T byteT] (WriteBool (![slice.T byteT] "b") (struct.loadF GetIdAtEpochReply "ProofTy" "o"));;
    "b" <-[slice.T byteT] (WriteSlice3D (![slice.T byteT] "b") (struct.loadF GetIdAtEpochReply "Proof" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF GetIdAtEpochReply "Error" "o"));;
    ![slice.T byteT] "b".

Definition GetIdAtEpochReply__Decode: val :=
  rec: "GetIdAtEpochReply__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("val", "b"), "err") := ReadSlice1D (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      let: (("digest", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        let: (("proofTy", "b"), "err") := ReadBool (![slice.T byteT] "b") in
        (if: "err" ≠ ErrNone
        then (slice.nil, "err")
        else
          let: (("proof", "b"), "err") := ReadSlice3D (![slice.T byteT] "b") in
          (if: "err" ≠ ErrNone
          then (slice.nil, "err")
          else
            let: (("error", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
            (if: "err" ≠ ErrNone
            then (slice.nil, "err")
            else
              struct.storeF GetIdAtEpochReply "Val" "o" "val";;
              struct.storeF GetIdAtEpochReply "Digest" "o" "digest";;
              struct.storeF GetIdAtEpochReply "ProofTy" "o" "proofTy";;
              struct.storeF GetIdAtEpochReply "Proof" "o" "proof";;
              struct.storeF GetIdAtEpochReply "Error" "o" "error";;
              (![slice.T byteT] "b", ErrNone)))))).

Definition CallGetIdAtEpoch: val :=
  rec: "CallGetIdAtEpoch" "cli" "id" "epoch" :=
    let: "errReply" := struct.new GetIdAtEpochReply [
    ] in
    let: "argB" := GetIdAtEpochArg__Encode (struct.new GetIdAtEpochArg [
      "Id" ::= "id";
      "Epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" RpcKeyServGetIdAtEpoch "argB" "replyB" #100 in
    (if: "err0" ≠ ErrNone
    then
      struct.storeF GetIdAtEpochReply "Error" "errReply" "err0";;
      "errReply"
    else
      let: "reply" := struct.new GetIdAtEpochReply [
      ] in
      let: (<>, "err1") := GetIdAtEpochReply__Decode "reply" "replyB" in
      (if: "err1" ≠ ErrNone
      then
        struct.storeF GetIdAtEpochReply "Error" "errReply" "err1";;
        "errReply"
      else "reply")).

Definition GetIdLatestArg := struct.decl [
  "Id" :: slice.T byteT
].

Definition GetIdLatestArg__Encode: val :=
  rec: "GetIdLatestArg__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF GetIdLatestArg "Id" "o"));;
    ![slice.T byteT] "b".

Definition GetIdLatestArg__Decode: val :=
  rec: "GetIdLatestArg__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("id", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      struct.storeF GetIdLatestArg "Id" "o" "id";;
      (![slice.T byteT] "b", ErrNone)).

Definition GetIdLatestReply := struct.decl [
  "Epoch" :: Epoch;
  "Val" :: slice.T byteT;
  "Digest" :: slice.T byteT;
  "ProofTy" :: boolT;
  "Proof" :: slice.T (slice.T (slice.T byteT));
  "Error" :: Error
].

Definition GetIdLatestReply__Encode: val :=
  rec: "GetIdLatestReply__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF GetIdLatestReply "Epoch" "o"));;
    "b" <-[slice.T byteT] (WriteSlice1D (![slice.T byteT] "b") (struct.loadF GetIdLatestReply "Val" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF GetIdLatestReply "Digest" "o"));;
    "b" <-[slice.T byteT] (WriteBool (![slice.T byteT] "b") (struct.loadF GetIdLatestReply "ProofTy" "o"));;
    "b" <-[slice.T byteT] (WriteSlice3D (![slice.T byteT] "b") (struct.loadF GetIdLatestReply "Proof" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF GetIdLatestReply "Error" "o"));;
    ![slice.T byteT] "b".

Definition GetIdLatestReply__Decode: val :=
  rec: "GetIdLatestReply__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      let: (("val", "b"), "err") := ReadSlice1D (![slice.T byteT] "b") in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        let: (("digest", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
        (if: "err" ≠ ErrNone
        then (slice.nil, "err")
        else
          let: (("proofTy", "b"), "err") := ReadBool (![slice.T byteT] "b") in
          (if: "err" ≠ ErrNone
          then (slice.nil, "err")
          else
            let: (("proof", "b"), "err") := ReadSlice3D (![slice.T byteT] "b") in
            (if: "err" ≠ ErrNone
            then (slice.nil, "err")
            else
              let: (("error", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
              (if: "err" ≠ ErrNone
              then (slice.nil, "err")
              else
                struct.storeF GetIdLatestReply "Epoch" "o" "epoch";;
                struct.storeF GetIdLatestReply "Val" "o" "val";;
                struct.storeF GetIdLatestReply "Digest" "o" "digest";;
                struct.storeF GetIdLatestReply "ProofTy" "o" "proofTy";;
                struct.storeF GetIdLatestReply "Proof" "o" "proof";;
                struct.storeF GetIdLatestReply "Error" "o" "error";;
                (![slice.T byteT] "b", ErrNone))))))).

Definition CallGetIdLatest: val :=
  rec: "CallGetIdLatest" "cli" "id" :=
    let: "errReply" := struct.new GetIdLatestReply [
    ] in
    let: "argB" := GetIdLatestArg__Encode (struct.new GetIdLatestArg [
      "Id" ::= "id"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" RpcKeyServGetIdLatest "argB" "replyB" #100 in
    (if: "err0" ≠ ErrNone
    then
      struct.storeF GetIdLatestReply "Error" "errReply" "err0";;
      "errReply"
    else
      let: "reply" := struct.new GetIdLatestReply [
      ] in
      let: (<>, "err1") := GetIdLatestReply__Decode "reply" "replyB" in
      (if: "err1" ≠ ErrNone
      then
        struct.storeF GetIdLatestReply "Error" "errReply" "err1";;
        "errReply"
      else "reply")).

Definition GetDigestArg := struct.decl [
  "Epoch" :: Epoch
].

Definition GetDigestArg__Encode: val :=
  rec: "GetDigestArg__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF GetDigestArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition GetDigestArg__Decode: val :=
  rec: "GetDigestArg__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      struct.storeF GetDigestArg "Epoch" "o" "epoch";;
      (![slice.T byteT] "b", ErrNone)).

Definition GetDigestReply := struct.decl [
  "Digest" :: slice.T byteT;
  "Error" :: Error
].

Definition GetDigestReply__Encode: val :=
  rec: "GetDigestReply__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF GetDigestReply "Digest" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF GetDigestReply "Error" "o"));;
    ![slice.T byteT] "b".

Definition GetDigestReply__Decode: val :=
  rec: "GetDigestReply__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("digest", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      let: (("error", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        struct.storeF GetDigestReply "Digest" "o" "digest";;
        struct.storeF GetDigestReply "Error" "o" "error";;
        (![slice.T byteT] "b", ErrNone))).

Definition CallGetDigest: val :=
  rec: "CallGetDigest" "cli" "epoch" :=
    let: "argB" := GetDigestArg__Encode (struct.new GetDigestArg [
      "Epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" RpcKeyServGetDigest "argB" "replyB" #100 in
    (if: "err0" ≠ ErrNone
    then (slice.nil, "err0")
    else
      let: "reply" := struct.new GetDigestReply [
      ] in
      let: (<>, "err1") := GetDigestReply__Decode "reply" "replyB" in
      (if: "err1" ≠ ErrNone
      then (slice.nil, "err1")
      else (struct.loadF GetDigestReply "Digest" "reply", struct.loadF GetDigestReply "Error" "reply"))).

Definition UpdateArg := struct.decl [
  "Digest" :: slice.T byteT
].

Definition UpdateArg__Encode: val :=
  rec: "UpdateArg__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF UpdateArg "Digest" "o"));;
    ![slice.T byteT] "b".

Definition UpdateArg__Decode: val :=
  rec: "UpdateArg__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("digest", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      struct.storeF UpdateArg "Digest" "o" "digest";;
      (![slice.T byteT] "b", ErrNone)).

Definition UpdateReply := struct.decl [
  "Error" :: Error
].

Definition UpdateReply__Encode: val :=
  rec: "UpdateReply__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF UpdateReply "Error" "o"));;
    ![slice.T byteT] "b".

Definition UpdateReply__Decode: val :=
  rec: "UpdateReply__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("error", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      struct.storeF UpdateReply "Error" "o" "error";;
      (![slice.T byteT] "b", ErrNone)).

Definition GetLinkArg := struct.decl [
  "Epoch" :: Epoch
].

Definition GetLinkArg__Encode: val :=
  rec: "GetLinkArg__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF GetLinkArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition CallUpdate: val :=
  rec: "CallUpdate" "cli" "dig" :=
    let: "argB" := UpdateArg__Encode (struct.new UpdateArg [
      "Digest" ::= "dig"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" RpcAuditorUpdate "argB" "replyB" #100 in
    (if: "err0" ≠ ErrNone
    then "err0"
    else
      let: "reply" := struct.new UpdateReply [
      ] in
      let: (<>, "err1") := UpdateReply__Decode "reply" "replyB" in
      (if: "err1" ≠ ErrNone
      then "err1"
      else struct.loadF UpdateReply "Error" "reply")).

Definition GetLinkArg__Decode: val :=
  rec: "GetLinkArg__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      struct.storeF GetLinkArg "Epoch" "o" "epoch";;
      (![slice.T byteT] "b", ErrNone)).

Definition GetLinkReply := struct.decl [
  "Link" :: Link;
  "Sig" :: slice.T byteT;
  "Error" :: Error
].

Definition GetLinkReply__Encode: val :=
  rec: "GetLinkReply__Encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF GetLinkReply "Link" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF GetLinkReply "Sig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF GetLinkReply "Error" "o"));;
    ![slice.T byteT] "b".

Definition GetLinkReply__Decode: val :=
  rec: "GetLinkReply__Decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("link", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.HashLen in
    (if: "err" ≠ ErrNone
    then (slice.nil, "err")
    else
      let: (("sig", "b"), "err") := SafeReadBytes (![slice.T byteT] "b") cryptoShim.SigLen in
      (if: "err" ≠ ErrNone
      then (slice.nil, "err")
      else
        let: (("error", "b"), "err") := SafeReadInt (![slice.T byteT] "b") in
        (if: "err" ≠ ErrNone
        then (slice.nil, "err")
        else
          struct.storeF GetLinkReply "Link" "o" "link";;
          struct.storeF GetLinkReply "Sig" "o" "sig";;
          struct.storeF GetLinkReply "Error" "o" "error";;
          (![slice.T byteT] "b", ErrNone)))).

Definition CallGetLink: val :=
  rec: "CallGetLink" "cli" "epoch" :=
    let: "argB" := GetLinkArg__Encode (struct.new GetLinkArg [
      "Epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" RpcAuditorGetLink "argB" "replyB" #100 in
    (if: "err0" ≠ ErrNone
    then (slice.nil, slice.nil, "err0")
    else
      let: "reply" := struct.new GetLinkReply [
      ] in
      let: (<>, "err1") := GetLinkReply__Decode "reply" "replyB" in
      (if: "err1" ≠ ErrNone
      then (slice.nil, slice.nil, "err1")
      else (struct.loadF GetLinkReply "Link" "reply", struct.loadF GetLinkReply "Sig" "reply", struct.loadF GetLinkReply "Error" "reply"))).

(* main.go *)

Definition KeyServ := struct.decl [
  "Mu" :: ptrT;
  "Trees" :: slice.T ptrT;
  "NextTr" :: ptrT;
  "Chain" :: slice.T Link
].

Definition NewKeyServ: val :=
  rec: "NewKeyServ" <> :=
    let: "s" := struct.new KeyServ [
    ] in
    struct.storeF KeyServ "Mu" "s" (lock.new #());;
    let: "emptyTr" := struct.new merkle.Tree [
    ] in
    struct.storeF KeyServ "Trees" "s" (SliceSingleton "emptyTr");;
    struct.storeF KeyServ "NextTr" "s" (struct.new merkle.Tree [
    ]);;
    struct.storeF KeyServ "Chain" "s" (SliceSingleton (merkle.Tree__Digest "emptyTr"));;
    "s".

Definition CalcNextLink: val :=
  rec: "CalcNextLink" "prevLink" "data" :=
    let: "hr" := ref (zero_val (slice.T byteT)) in
    cryptoHelpers.HasherWrite "hr" "data";;
    cryptoHelpers.HasherWrite "hr" "prevLink";;
    let: "newLink" := cryptoHelpers.HasherSum (![slice.T byteT] "hr") slice.nil in
    "newLink".

Definition ExtendChain: val :=
  rec: "ExtendChain" "chain" "data" :=
    let: "oldChain" := ![slice.T (slice.T byteT)] "chain" in
    let: "prevLink" := ref (zero_val (slice.T byteT)) in
    let: "chainLen" := slice.len "oldChain" in
    (if: "chainLen" > #0
    then "prevLink" <-[slice.T byteT] (SliceGet (slice.T byteT) "oldChain" ("chainLen" - #1))
    else #());;
    let: "newLink" := CalcNextLink (![slice.T byteT] "prevLink") "data" in
    "chain" <-[slice.T (slice.T byteT)] (SliceAppend (slice.T byteT) "oldChain" "newLink");;
    #().

Definition KeyServ__UpdateEpoch: val :=
  rec: "KeyServ__UpdateEpoch" "s" :=
    lock.acquire (struct.loadF KeyServ "Mu" "s");;
    let: "nextTr" := struct.loadF KeyServ "NextTr" "s" in
    let: "dig" := merkle.Tree__Digest "nextTr" in
    ExtendChain (struct.fieldRef KeyServ "Chain" "s") "dig";;
    struct.storeF KeyServ "Trees" "s" (SliceAppend ptrT (struct.loadF KeyServ "Trees" "s") "nextTr");;
    struct.storeF KeyServ "NextTr" "s" (merkle.Tree__DeepCopy "nextTr");;
    lock.release (struct.loadF KeyServ "Mu" "s");;
    #().

Definition KeyServ__Put: val :=
  rec: "KeyServ__Put" "s" "id" "val" :=
    lock.acquire (struct.loadF KeyServ "Mu" "s");;
    let: "nextEpoch" := slice.len (struct.loadF KeyServ "Trees" "s") in
    let: ((<>, <>), "err") := merkle.Tree__Put (struct.loadF KeyServ "NextTr" "s") "id" "val" in
    lock.release (struct.loadF KeyServ "Mu" "s");;
    ("nextEpoch", "err").

Definition KeyServ__GetIdAtEpoch: val :=
  rec: "KeyServ__GetIdAtEpoch" "s" "id" "epoch" :=
    let: "errReply" := struct.new GetIdAtEpochReply [
    ] in
    lock.acquire (struct.loadF KeyServ "Mu" "s");;
    (if: "epoch" ≥ (slice.len (struct.loadF KeyServ "Trees" "s"))
    then
      lock.release (struct.loadF KeyServ "Mu" "s");;
      struct.storeF GetIdAtEpochReply "Error" "errReply" ErrSome;;
      "errReply"
    else
      let: "tr" := SliceGet ptrT (struct.loadF KeyServ "Trees" "s") "epoch" in
      let: "reply" := merkle.Tree__Get "tr" "id" in
      lock.release (struct.loadF KeyServ "Mu" "s");;
      struct.new GetIdAtEpochReply [
        "Val" ::= struct.loadF merkle.GetReply "Val" "reply";
        "Digest" ::= struct.loadF merkle.GetReply "Digest" "reply";
        "ProofTy" ::= struct.loadF merkle.GetReply "ProofTy" "reply";
        "Proof" ::= struct.loadF merkle.GetReply "Proof" "reply";
        "Error" ::= struct.loadF merkle.GetReply "Error" "reply"
      ]).

Definition KeyServ__GetIdLatest: val :=
  rec: "KeyServ__GetIdLatest" "s" "id" :=
    lock.acquire (struct.loadF KeyServ "Mu" "s");;
    let: "lastEpoch" := (slice.len (struct.loadF KeyServ "Trees" "s")) - #1 in
    let: "tr" := SliceGet ptrT (struct.loadF KeyServ "Trees" "s") "lastEpoch" in
    let: "reply" := merkle.Tree__Get "tr" "id" in
    lock.release (struct.loadF KeyServ "Mu" "s");;
    struct.new GetIdLatestReply [
      "Epoch" ::= "lastEpoch";
      "Val" ::= struct.loadF merkle.GetReply "Val" "reply";
      "Digest" ::= struct.loadF merkle.GetReply "Digest" "reply";
      "ProofTy" ::= struct.loadF merkle.GetReply "ProofTy" "reply";
      "Proof" ::= struct.loadF merkle.GetReply "Proof" "reply";
      "Error" ::= struct.loadF merkle.GetReply "Error" "reply"
    ].

Definition KeyServ__GetDigest: val :=
  rec: "KeyServ__GetDigest" "s" "epoch" :=
    lock.acquire (struct.loadF KeyServ "Mu" "s");;
    (if: "epoch" ≥ (slice.len (struct.loadF KeyServ "Trees" "s"))
    then
      lock.release (struct.loadF KeyServ "Mu" "s");;
      (slice.nil, ErrSome)
    else
      let: "tr" := SliceGet ptrT (struct.loadF KeyServ "Trees" "s") "epoch" in
      let: "dig" := merkle.Tree__Digest "tr" in
      lock.release (struct.loadF KeyServ "Mu" "s");;
      ("dig", ErrNone)).

Definition KeyServ__Start: val :=
  rec: "KeyServ__Start" "s" "addr" :=
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "handlers" RpcKeyServUpdateEpoch (λ: "enc_args" "enc_reply",
      KeyServ__UpdateEpoch "s";;
      #()
      );;
    MapInsert "handlers" RpcKeyServPut (λ: "enc_args" "enc_reply",
      let: "args" := struct.new PutArg [
      ] in
      let: (<>, "err0") := PutArg__Decode "args" "enc_args" in
      (if: "err0" ≠ ErrNone
      then
        "enc_reply" <-[slice.T byteT] (PutReply__Encode (struct.new PutReply [
          "Epoch" ::= #0;
          "Error" ::= "err0"
        ]));;
        #()
      else
        let: ("epoch", "err1") := KeyServ__Put "s" (struct.loadF PutArg "Id" "args") (struct.loadF PutArg "Val" "args") in
        "enc_reply" <-[slice.T byteT] (PutReply__Encode (struct.new PutReply [
          "Epoch" ::= "epoch";
          "Error" ::= "err1"
        ]));;
        #())
      );;
    MapInsert "handlers" RpcKeyServGetIdAtEpoch (λ: "enc_args" "enc_reply",
      let: "args" := struct.new GetIdAtEpochArg [
      ] in
      let: (<>, "err0") := GetIdAtEpochArg__Decode "args" "enc_args" in
      (if: "err0" ≠ ErrNone
      then
        let: "reply" := struct.new GetIdAtEpochReply [
        ] in
        struct.storeF GetIdAtEpochReply "Error" "reply" ErrSome;;
        "enc_reply" <-[slice.T byteT] (GetIdAtEpochReply__Encode "reply");;
        #()
      else
        let: "reply" := KeyServ__GetIdAtEpoch "s" (struct.loadF GetIdAtEpochArg "Id" "args") (struct.loadF GetIdAtEpochArg "Epoch" "args") in
        "enc_reply" <-[slice.T byteT] (GetIdAtEpochReply__Encode "reply");;
        #())
      );;
    MapInsert "handlers" RpcKeyServGetIdLatest (λ: "enc_args" "enc_reply",
      let: "args" := struct.new GetIdLatestArg [
      ] in
      let: (<>, "err0") := GetIdLatestArg__Decode "args" "enc_args" in
      (if: "err0" ≠ ErrNone
      then
        let: "reply" := struct.new GetIdLatestReply [
        ] in
        struct.storeF GetIdLatestReply "Error" "reply" ErrSome;;
        "enc_reply" <-[slice.T byteT] (GetIdLatestReply__Encode "reply");;
        #()
      else
        let: "reply" := KeyServ__GetIdLatest "s" (struct.loadF GetIdLatestArg "Id" "args") in
        "enc_reply" <-[slice.T byteT] (GetIdLatestReply__Encode "reply");;
        #())
      );;
    MapInsert "handlers" RpcKeyServGetDigest (λ: "enc_args" "enc_reply",
      let: "args" := struct.new GetDigestArg [
      ] in
      let: (<>, "err0") := GetDigestArg__Decode "args" "enc_args" in
      (if: "err0" ≠ ErrNone
      then
        let: "reply" := struct.new GetDigestReply [
        ] in
        struct.storeF GetDigestReply "Error" "reply" ErrSome;;
        "enc_reply" <-[slice.T byteT] (GetDigestReply__Encode "reply");;
        #()
      else
        let: ("dig", "err1") := KeyServ__GetDigest "s" (struct.loadF GetDigestArg "Epoch" "args") in
        "enc_reply" <-[slice.T byteT] (GetDigestReply__Encode (struct.new GetDigestReply [
          "Digest" ::= "dig";
          "Error" ::= "err1"
        ]));;
        #())
      );;
    urpc.Server__Serve (urpc.MakeServer "handlers") "addr";;
    #().

Definition Auditor := struct.decl [
  "Mu" :: ptrT;
  "Sk" :: struct.t cryptoShim.SignerT;
  "Chain" :: slice.T Link
].

Definition NewAuditor: val :=
  rec: "NewAuditor" "sk" :=
    struct.new Auditor [
      "Mu" ::= lock.new #();
      "Sk" ::= "sk";
      "Chain" ::= slice.nil
    ].

Definition Auditor__Update: val :=
  rec: "Auditor__Update" "a" "dig" :=
    lock.acquire (struct.loadF Auditor "Mu" "a");;
    ExtendChain (struct.fieldRef Auditor "Chain" "a") "dig";;
    lock.release (struct.loadF Auditor "Mu" "a");;
    #().

Definition Auditor__GetLink: val :=
  rec: "Auditor__GetLink" "a" "epoch" :=
    lock.acquire (struct.loadF Auditor "Mu" "a");;
    (if: "epoch" ≥ (slice.len (struct.loadF Auditor "Chain" "a"))
    then
      lock.release (struct.loadF Auditor "Mu" "a");;
      (slice.nil, slice.nil, ErrSome)
    else
      let: "link" := SliceGet (slice.T byteT) (struct.loadF Auditor "Chain" "a") "epoch" in
      let: "encB" := EpochHash__Encode (struct.new EpochHash [
        "Epoch" ::= "epoch";
        "Hash" ::= "link"
      ]) in
      let: "sig" := cryptoShim.Sign (struct.loadF Auditor "Sk" "a") "encB" in
      lock.release (struct.loadF Auditor "Mu" "a");;
      ("link", "sig", ErrNone)).

Definition Auditor__Start: val :=
  rec: "Auditor__Start" "a" "addr" :=
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "handlers" RpcAuditorUpdate (λ: "enc_args" "enc_reply",
      let: "args" := struct.new UpdateArg [
      ] in
      let: (<>, "err0") := UpdateArg__Decode "args" "enc_args" in
      (if: "err0" ≠ ErrNone
      then
        let: "reply" := struct.new UpdateReply [
        ] in
        struct.storeF UpdateReply "Error" "reply" ErrSome;;
        "enc_reply" <-[slice.T byteT] (UpdateReply__Encode "reply");;
        #()
      else
        Auditor__Update "a" (struct.loadF UpdateArg "Digest" "args");;
        "enc_reply" <-[slice.T byteT] (UpdateReply__Encode (struct.new UpdateReply [
          "Error" ::= ErrNone
        ]));;
        #())
      );;
    MapInsert "handlers" RpcAuditorGetLink (λ: "enc_args" "enc_reply",
      let: "args" := struct.new GetLinkArg [
      ] in
      let: (<>, "err0") := GetLinkArg__Decode "args" "enc_args" in
      (if: "err0" ≠ ErrNone
      then
        let: "reply" := struct.new GetLinkReply [
        ] in
        struct.storeF GetLinkReply "Error" "reply" ErrSome;;
        "enc_reply" <-[slice.T byteT] (GetLinkReply__Encode "reply");;
        #()
      else
        let: (("link", "sig"), "err1") := Auditor__GetLink "a" (struct.loadF GetLinkArg "Epoch" "args") in
        "enc_reply" <-[slice.T byteT] (GetLinkReply__Encode (struct.new GetLinkReply [
          "Link" ::= "link";
          "Sig" ::= "sig";
          "Error" ::= "err1"
        ]));;
        #())
      );;
    urpc.Server__Serve (urpc.MakeServer "handlers") "addr";;
    #().

Definition KeyCli := struct.decl [
  "Adtrs" :: slice.T ptrT;
  "AdtrVks" :: slice.T (struct.t cryptoShim.VerifierT);
  "Digs" :: mapT (slice.T byteT);
  "Id" :: slice.T byteT;
  "Serv" :: ptrT;
  "ValEpochs" :: slice.T Epoch;
  "Vals" :: slice.T (slice.T byteT)
].

Definition NewKeyCli: val :=
  rec: "NewKeyCli" "id" "servAddr" "adtrAddrs" "adtrVks" :=
    let: "c" := struct.new KeyCli [
    ] in
    struct.storeF KeyCli "Serv" "c" (urpc.MakeClient "servAddr");;
    let: "adtrs" := ref (zero_val (slice.T ptrT)) in
    ForSlice uint64T <> "addr" "adtrAddrs"
      ("adtrs" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "adtrs") (urpc.MakeClient "addr")));;
    struct.storeF KeyCli "Adtrs" "c" (![slice.T ptrT] "adtrs");;
    struct.storeF KeyCli "AdtrVks" "c" "adtrVks";;
    struct.storeF KeyCli "Digs" "c" (NewMap Epoch (slice.T byteT) #());;
    struct.storeF KeyCli "Id" "c" "id";;
    "c".

(* TODO: what happens if client calls Put twice in an epoch? *)
Definition KeyCli__Put: val :=
  rec: "KeyCli__Put" "c" "val" :=
    let: ("epoch", "err") := CallPut (struct.loadF KeyCli "Serv" "c") (struct.loadF KeyCli "Id" "c") "val" in
    (if: "err" ≠ ErrNone
    then "err"
    else
      struct.storeF KeyCli "ValEpochs" "c" (SliceAppend uint64T (struct.loadF KeyCli "ValEpochs" "c") "epoch");;
      struct.storeF KeyCli "Vals" "c" (SliceAppend (slice.T byteT) (struct.loadF KeyCli "Vals" "c") "val");;
      ErrNone).

Definition KeyCli__Get: val :=
  rec: "KeyCli__Get" "c" "id" :=
    let: "reply" := CallGetIdLatest (struct.loadF KeyCli "Serv" "c") "id" in
    let: "epoch" := struct.loadF GetIdLatestReply "Epoch" "reply" in
    let: "val" := struct.loadF GetIdLatestReply "Val" "reply" in
    let: "dig" := struct.loadF GetIdLatestReply "Digest" "reply" in
    let: "err0" := struct.loadF GetIdLatestReply "Error" "reply" in
    (if: "err0" ≠ ErrNone
    then (#0, slice.nil, "err0")
    else
      let: "err1" := merkle.CheckProof (struct.loadF GetIdLatestReply "ProofTy" "reply") (struct.loadF GetIdLatestReply "Proof" "reply") "id" "val" "dig" in
      (if: "err1" ≠ ErrNone
      then (#0, slice.nil, "err1")
      else
        let: ("origDig", "ok") := MapGet (struct.loadF KeyCli "Digs" "c") "epoch" in
        let: "err2" := ref (zero_val uint64T) in
        (if: "ok"
        then
          (if: (~ (std.BytesEqual "origDig" "dig"))
          then "err2" <-[uint64T] ErrSome
          else #())
        else MapInsert (struct.loadF KeyCli "Digs" "c") "epoch" "dig");;
        ("epoch", "val", ![uint64T] "err2"))).

(* Audited through Epoch idx in retval. *)
Definition KeyCli__Audit: val :=
  rec: "KeyCli__Audit" "c" "adtrId" :=
    let: "link" := ref (zero_val (slice.T byteT)) in
    let: "epoch" := ref (zero_val uint64T) in
    let: "stop" := ref (zero_val boolT) in
    Skip;;
    (for: (λ: <>, (~ (![boolT] "stop"))); (λ: <>, Skip) := λ: <>,
      let: "dig" := ref (zero_val (slice.T byteT)) in
      let: ("dig", "ok0") := MapGet (struct.loadF KeyCli "Digs" "c") (![uint64T] "epoch") in
      (if: (~ "ok0")
      then
        let: ("newDig", "err0") := CallGetDigest (struct.loadF KeyCli "Serv" "c") (![uint64T] "epoch") in
        (if: "err0" ≠ ErrNone
        then "stop" <-[boolT] #true
        else
          MapInsert (struct.loadF KeyCli "Digs" "c") (![uint64T] "epoch") "newDig";;
          "dig" <-[slice.T byteT] "newDig")
      else #());;
      (if: (~ (![boolT] "stop"))
      then
        "link" <-[slice.T byteT] (CalcNextLink (![slice.T byteT] "link") (![slice.T byteT] "dig"));;
        "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
        Continue
      else Continue));;
    (if: (![uint64T] "epoch") = #0
    then (#0, ErrSome)
    else
      "epoch" <-[uint64T] ((![uint64T] "epoch") - #1);;
      let: "adtr" := SliceGet ptrT (struct.loadF KeyCli "Adtrs" "c") "adtrId" in
      let: "adtrVk" := SliceGet (struct.t cryptoShim.VerifierT) (struct.loadF KeyCli "AdtrVks" "c") "adtrId" in
      let: (("adtrLink", "sig"), "err1") := CallGetLink "adtr" (![uint64T] "epoch") in
      (if: "err1" ≠ ErrNone
      then (#0, "err1")
      else
        let: "encB" := EpochHash__Encode (struct.new EpochHash [
          "Epoch" ::= ![uint64T] "epoch";
          "Hash" ::= ![slice.T byteT] "link"
        ]) in
        let: "ok1" := cryptoShim.Verify "adtrVk" "encB" "sig" in
        (if: (~ "ok1")
        then (#0, ErrSome)
        else
          (if: (~ (std.BytesEqual (![slice.T byteT] "link") "adtrLink"))
          then (#0, ErrSome)
          else (![uint64T] "epoch", ErrNone))))).

(* Audited through Epoch idx in retval. *)
Definition KeyCli__SelfAudit: val :=
  rec: "KeyCli__SelfAudit" "c" :=
    let: "id" := struct.loadF KeyCli "Id" "c" in
    let: "numVals" := slice.len (struct.loadF KeyCli "Vals" "c") in
    let: "valIdx" := ref (zero_val uint64T) in
    let: "epoch" := ref (zero_val uint64T) in
    let: "stop" := ref (zero_val boolT) in
    Skip;;
    (for: (λ: <>, (~ (![boolT] "stop"))); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "valIdx") ≠ "numVals"
      then
        let: "epochChange" := SliceGet uint64T (struct.loadF KeyCli "ValEpochs" "c") (![uint64T] "valIdx") in
        (if: (![uint64T] "epoch") = "epochChange"
        then "valIdx" <-[uint64T] ((![uint64T] "valIdx") + #1)
        else #())
      else #());;
      let: "expProofTy" := ref (zero_val boolT) in
      let: "expVal" := ref (zero_val (slice.T byteT)) in
      (if: (![uint64T] "valIdx") ≠ #0
      then
        "expProofTy" <-[boolT] merkle.MembProofTy;;
        "expVal" <-[slice.T byteT] (SliceGet (slice.T byteT) (struct.loadF KeyCli "Vals" "c") ((![uint64T] "valIdx") - #1))
      else #());;
      let: "reply" := CallGetIdAtEpoch (struct.loadF KeyCli "Serv" "c") "id" (![uint64T] "epoch") in
      let: "dig" := struct.loadF GetIdAtEpochReply "Digest" "reply" in
      let: "err0" := struct.loadF GetIdAtEpochReply "Error" "reply" in
      (if: "err0" ≠ ErrNone
      then
        "stop" <-[boolT] #true;;
        Continue
      else
        (if: (struct.loadF GetIdAtEpochReply "ProofTy" "reply") ≠ (![boolT] "expProofTy")
        then
          "stop" <-[boolT] #true;;
          Continue
        else
          let: "err1" := merkle.CheckProof (struct.loadF GetIdAtEpochReply "ProofTy" "reply") (struct.loadF GetIdAtEpochReply "Proof" "reply") "id" (![slice.T byteT] "expVal") "dig" in
          (if: "err1" ≠ ErrNone
          then
            "stop" <-[boolT] #true;;
            Continue
          else
            let: ("origDig", "ok0") := MapGet (struct.loadF KeyCli "Digs" "c") (![uint64T] "epoch") in
            (if: (~ "ok0")
            then MapInsert (struct.loadF KeyCli "Digs" "c") (![uint64T] "epoch") "dig"
            else
              (if: (~ (std.BytesEqual "dig" "origDig"))
              then "stop" <-[boolT] #true
              else #()));;
            (if: (~ (![boolT] "stop"))
            then
              "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
              Continue
            else Continue)))));;
    (if: (![uint64T] "epoch") = #0
    then (#0, ErrSome)
    else
      "epoch" <-[uint64T] ((![uint64T] "epoch") - #1);;
      (![uint64T] "epoch", ErrNone)).

Definition testAgreement: val :=
  rec: "testAgreement" "servAddr" "adtrAddr" :=
    Fork (let: "s" := NewKeyServ #() in
          KeyServ__Start "s" "servAddr");;
    let: ("sk", "vk") := cryptoShim.MakeKeys #() in
    let: "adtrVks" := SliceSingleton "vk" in
    let: "adtrAddrs" := SliceSingleton "adtrAddr" in
    Fork (let: "a" := NewAuditor "sk" in
          Auditor__Start "a" "adtrAddr");;
    time.Sleep #1000000;;
    let: "servCli" := urpc.MakeClient "servAddr" in
    let: "adtrCli" := urpc.MakeClient "adtrAddr" in
    let: "aliceId" := cryptoShim.Hash (StringToBytes #(str"alice")) in
    let: "aliceVal" := StringToBytes #(str"val") in
    let: "aliceCli" := NewKeyCli "aliceId" "servAddr" "adtrAddrs" "adtrVks" in
    let: "err0" := KeyCli__Put "aliceCli" "aliceVal" in
    control.impl.Assume ("err0" = ErrNone);;
    let: "emptyReplyB" := NewSlice byteT #0 in
    let: "err1" := urpc.Client__Call "servCli" RpcKeyServUpdateEpoch slice.nil "emptyReplyB" #100 in
    control.impl.Assume ("err1" = ErrNone);;
    let: ("dig0", "err2") := CallGetDigest "servCli" #0 in
    control.impl.Assume ("err2" = ErrNone);;
    let: ("dig1", "err3") := CallGetDigest "servCli" #0 in
    control.impl.Assume ("err3" = ErrNone);;
    let: "err4" := CallUpdate "adtrCli" "dig0" in
    control.impl.Assume ("err4" = ErrNone);;
    let: "err5" := CallUpdate "adtrCli" "dig1" in
    control.impl.Assume ("err5" = ErrNone);;
    let: "bobId" := cryptoShim.Hash (StringToBytes #(str"bob")) in
    let: "bobCli" := NewKeyCli "bobId" "servAddr" "adtrAddrs" "adtrVks" in
    let: "charlieId" := cryptoShim.Hash (StringToBytes #(str"charlie")) in
    let: "charlieCli" := NewKeyCli "charlieId" "servAddr" "adtrAddrs" "adtrVks" in
    let: (("epoch0", "val0"), "err6") := KeyCli__Get "bobCli" "aliceId" in
    control.impl.Assume ("err6" = ErrNone);;
    let: (("epoch1", "val1"), "err7") := KeyCli__Get "charlieCli" "aliceId" in
    control.impl.Assume ("err7" = ErrNone);;
    let: ("epoch2", "err8") := KeyCli__Audit "bobCli" #0 in
    control.impl.Assume ("err8" = ErrNone);;
    let: ("epoch3", "err9") := KeyCli__Audit "charlieCli" #0 in
    control.impl.Assume ("err9" = ErrNone);;
    (if: (("epoch0" = "epoch1") && ("epoch0" ≤ "epoch2")) && ("epoch1" ≤ "epoch3")
    then
      control.impl.Assert (std.BytesEqual "val0" "val1");;
      #()
    else #()).
