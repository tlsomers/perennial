(* autogenerated from github.com/mit-pdos/secure-chat/ktmerkle *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.gokv.urpc.
From Goose Require github_com.mit_pdos.secure_chat.cryptoffi.
From Goose Require github_com.mit_pdos.secure_chat.cryptoutil.
From Goose Require github_com.mit_pdos.secure_chat.marshalutil.
From Goose Require github_com.mit_pdos.secure_chat.merkle.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* main.go *)

Definition epochTy: ty := uint64T.

Definition linkTy: ty := slice.T byteT.

Definition errorTy: ty := boolT.

Definition okTy: ty := boolT.

Definition errNone : expr := #false.

Definition errSome : expr := #true.

Definition keyServ := struct.decl [
  "sk" :: ed25519.PrivateKey;
  "mu" :: ptrT;
  "trees" :: slice.T ptrT;
  "nextTr" :: ptrT;
  "chain" :: slice.T linkTy
].

Definition newKeyServ: val :=
  rec: "newKeyServ" "sk" :=
    let: "s" := struct.new keyServ [
    ] in
    struct.storeF keyServ "sk" "s" "sk";;
    struct.storeF keyServ "mu" "s" (lock.new #());;
    let: "emptyTr" := struct.new merkle.Tree [
    ] in
    struct.storeF keyServ "trees" "s" (SliceSingleton "emptyTr");;
    struct.storeF keyServ "nextTr" "s" (struct.new merkle.Tree [
    ]);;
    struct.storeF keyServ "chain" "s" (SliceSingleton (merkle.Tree__Digest "emptyTr"));;
    "s".

Definition calcNextLink: val :=
  rec: "calcNextLink" "prevLink" "data" :=
    let: "hr" := ref (zero_val (slice.T byteT)) in
    cryptoutil.HasherWrite "hr" "data";;
    cryptoutil.HasherWrite "hr" "prevLink";;
    let: "newLink" := cryptoutil.HasherSum (![slice.T byteT] "hr") slice.nil in
    "newLink".

Definition extendChain: val :=
  rec: "extendChain" "chain" "data" :=
    let: "oldChain" := ![slice.T (slice.T byteT)] "chain" in
    let: "prevLink" := ref (zero_val (slice.T byteT)) in
    let: "chainLen" := slice.len "oldChain" in
    (if: "chainLen" > #0
    then "prevLink" <-[slice.T byteT] (SliceGet (slice.T byteT) "oldChain" ("chainLen" - #1))
    else #());;
    let: "newLink" := calcNextLink (![slice.T byteT] "prevLink") "data" in
    "chain" <-[slice.T (slice.T byteT)] (SliceAppend (slice.T byteT) "oldChain" "newLink");;
    #().

Definition keyServ__updateEpoch: val :=
  rec: "keyServ__updateEpoch" "s" :=
    lock.acquire (struct.loadF keyServ "mu" "s");;
    let: "nextTr" := struct.loadF keyServ "nextTr" "s" in
    let: "dig" := merkle.Tree__Digest "nextTr" in
    extendChain (struct.fieldRef keyServ "chain" "s") "dig";;
    struct.storeF keyServ "trees" "s" (SliceAppend ptrT (struct.loadF keyServ "trees" "s") "nextTr");;
    struct.storeF keyServ "nextTr" "s" (merkle.Tree__DeepCopy "nextTr");;
    lock.release (struct.loadF keyServ "mu" "s");;
    #().

(* idValEpoch from rpc.go *)

Definition idValEpoch := struct.decl [
  "id" :: slice.T byteT;
  "val" :: slice.T byteT;
  "epoch" :: epochTy
].

Definition idValEpoch__encode: val :=
  rec: "idValEpoch__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF idValEpoch "id" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF idValEpoch "val" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF idValEpoch "epoch" "o"));;
    ![slice.T byteT] "b".

(* Returns the epoch at which this val should be visible. *)
Definition keyServ__put: val :=
  rec: "keyServ__put" "s" "id" "val" :=
    lock.acquire (struct.loadF keyServ "mu" "s");;
    let: "nextEpoch" := slice.len (struct.loadF keyServ "trees" "s") in
    let: ((<>, <>), "err") := merkle.Tree__Put (struct.loadF keyServ "nextTr" "s") "id" "val" in
    let: "enc" := idValEpoch__encode (struct.new idValEpoch [
      "id" ::= "id";
      "val" ::= "val";
      "epoch" ::= "nextEpoch"
    ]) in
    let: "sig" := cryptoffi.Sign (struct.loadF keyServ "sk" "s") "enc" in
    lock.release (struct.loadF keyServ "mu" "s");;
    ("nextEpoch", "sig", "err").

Definition getIdAtEpochReply := struct.decl [
  "val" :: slice.T byteT;
  "digest" :: slice.T byteT;
  "proofTy" :: boolT;
  "proof" :: slice.T (slice.T (slice.T byteT));
  "sig" :: slice.T byteT;
  "error" :: errorTy
].

Definition epochHash := struct.decl [
  "epoch" :: epochTy;
  "hash" :: slice.T byteT
].

Definition epochHash__encode: val :=
  rec: "epochHash__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF epochHash "epoch" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF epochHash "hash" "o"));;
    ![slice.T byteT] "b".

Definition keyServ__getIdAtEpoch: val :=
  rec: "keyServ__getIdAtEpoch" "s" "id" "epoch" :=
    let: "errReply" := struct.new getIdAtEpochReply [
    ] in
    struct.storeF getIdAtEpochReply "error" "errReply" errSome;;
    lock.acquire (struct.loadF keyServ "mu" "s");;
    (if: "epoch" ≥ (slice.len (struct.loadF keyServ "trees" "s"))
    then
      lock.release (struct.loadF keyServ "mu" "s");;
      "errReply"
    else
      let: "tr" := SliceGet ptrT (struct.loadF keyServ "trees" "s") "epoch" in
      let: "reply" := merkle.Tree__Get "tr" "id" in
      let: "enc" := epochHash__encode (struct.new epochHash [
        "epoch" ::= "epoch";
        "hash" ::= struct.loadF merkle.GetReply "Digest" "reply"
      ]) in
      let: "sig" := cryptoffi.Sign (struct.loadF keyServ "sk" "s") "enc" in
      lock.release (struct.loadF keyServ "mu" "s");;
      struct.new getIdAtEpochReply [
        "val" ::= struct.loadF merkle.GetReply "Val" "reply";
        "digest" ::= struct.loadF merkle.GetReply "Digest" "reply";
        "proofTy" ::= struct.loadF merkle.GetReply "ProofTy" "reply";
        "proof" ::= struct.loadF merkle.GetReply "Proof" "reply";
        "sig" ::= "sig";
        "error" ::= struct.loadF merkle.GetReply "Error" "reply"
      ]).

Definition getIdLatestReply := struct.decl [
  "epoch" :: epochTy;
  "val" :: slice.T byteT;
  "digest" :: slice.T byteT;
  "proofTy" :: boolT;
  "proof" :: slice.T (slice.T (slice.T byteT));
  "sig" :: slice.T byteT;
  "error" :: errorTy
].

Definition keyServ__getIdLatest: val :=
  rec: "keyServ__getIdLatest" "s" "id" :=
    lock.acquire (struct.loadF keyServ "mu" "s");;
    let: "lastEpoch" := (slice.len (struct.loadF keyServ "trees" "s")) - #1 in
    let: "tr" := SliceGet ptrT (struct.loadF keyServ "trees" "s") "lastEpoch" in
    let: "reply" := merkle.Tree__Get "tr" "id" in
    let: "enc" := epochHash__encode (struct.new epochHash [
      "epoch" ::= "lastEpoch";
      "hash" ::= struct.loadF merkle.GetReply "Digest" "reply"
    ]) in
    let: "sig" := cryptoffi.Sign (struct.loadF keyServ "sk" "s") "enc" in
    lock.release (struct.loadF keyServ "mu" "s");;
    struct.new getIdLatestReply [
      "epoch" ::= "lastEpoch";
      "val" ::= struct.loadF merkle.GetReply "Val" "reply";
      "digest" ::= struct.loadF merkle.GetReply "Digest" "reply";
      "proofTy" ::= struct.loadF merkle.GetReply "ProofTy" "reply";
      "proof" ::= struct.loadF merkle.GetReply "Proof" "reply";
      "sig" ::= "sig";
      "error" ::= struct.loadF merkle.GetReply "Error" "reply"
    ].

Definition keyServ__getDigest: val :=
  rec: "keyServ__getDigest" "s" "epoch" :=
    lock.acquire (struct.loadF keyServ "mu" "s");;
    (if: "epoch" ≥ (slice.len (struct.loadF keyServ "trees" "s"))
    then
      lock.release (struct.loadF keyServ "mu" "s");;
      (slice.nil, slice.nil, errSome)
    else
      let: "tr" := SliceGet ptrT (struct.loadF keyServ "trees" "s") "epoch" in
      let: "dig" := merkle.Tree__Digest "tr" in
      let: "enc" := epochHash__encode (struct.new epochHash [
        "epoch" ::= "epoch";
        "hash" ::= "dig"
      ]) in
      let: "sig" := cryptoffi.Sign (struct.loadF keyServ "sk" "s") "enc" in
      lock.release (struct.loadF keyServ "mu" "s");;
      ("dig", "sig", errNone)).

Definition auditor := struct.decl [
  "mu" :: ptrT;
  "sk" :: ed25519.PrivateKey;
  "servPk" :: ed25519.PublicKey;
  "chain" :: slice.T linkTy
].

Definition newAuditor: val :=
  rec: "newAuditor" "sk" "servPk" :=
    struct.new auditor [
      "mu" ::= lock.new #();
      "sk" ::= "sk";
      "servPk" ::= "servPk";
      "chain" ::= slice.nil
    ].

Definition auditor__update: val :=
  rec: "auditor__update" "a" "epoch" "dig" "sig" :=
    lock.acquire (struct.loadF auditor "mu" "a");;
    let: "enc" := epochHash__encode (struct.new epochHash [
      "epoch" ::= "epoch";
      "hash" ::= "dig"
    ]) in
    let: "ok" := cryptoffi.Verify (struct.loadF auditor "servPk" "a") "enc" "sig" in
    (if: (~ "ok")
    then
      lock.release (struct.loadF auditor "mu" "a");;
      errSome
    else
      (if: "epoch" ≠ (slice.len (struct.loadF auditor "chain" "a"))
      then
        lock.release (struct.loadF auditor "mu" "a");;
        errSome
      else
        extendChain (struct.fieldRef auditor "chain" "a") "dig";;
        lock.release (struct.loadF auditor "mu" "a");;
        errNone)).

Definition auditor__getLink: val :=
  rec: "auditor__getLink" "a" "epoch" :=
    lock.acquire (struct.loadF auditor "mu" "a");;
    (if: "epoch" ≥ (slice.len (struct.loadF auditor "chain" "a"))
    then
      lock.release (struct.loadF auditor "mu" "a");;
      (slice.nil, slice.nil, errSome)
    else
      let: "link" := SliceGet (slice.T byteT) (struct.loadF auditor "chain" "a") "epoch" in
      let: "enc" := epochHash__encode (struct.new epochHash [
        "epoch" ::= "epoch";
        "hash" ::= "link"
      ]) in
      let: "sig" := cryptoffi.Sign (struct.loadF auditor "sk" "a") "enc" in
      lock.release (struct.loadF auditor "mu" "a");;
      ("link", "sig", errNone)).

Definition keyCli := struct.decl [
  "adtrs" :: slice.T ptrT;
  "adtrPks" :: slice.T ed25519.PublicKey;
  "servPk" :: ed25519.PublicKey;
  "digs" :: mapT (slice.T byteT);
  "id" :: slice.T byteT;
  "serv" :: ptrT;
  "valEpochs" :: slice.T epochTy;
  "vals" :: slice.T (slice.T byteT)
].

Definition newKeyCli: val :=
  rec: "newKeyCli" "id" "servAddr" "adtrAddrs" "adtrPks" "servPk" :=
    let: "serv" := urpc.MakeClient "servAddr" in
    let: "adtrs" := ref (zero_val (slice.T ptrT)) in
    ForSlice uint64T <> "addr" "adtrAddrs"
      ("adtrs" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "adtrs") (urpc.MakeClient "addr")));;
    let: "digs" := NewMap epochTy (slice.T byteT) #() in
    struct.new keyCli [
      "adtrs" ::= ![slice.T ptrT] "adtrs";
      "adtrPks" ::= "adtrPks";
      "servPk" ::= "servPk";
      "digs" ::= "digs";
      "id" ::= "id";
      "serv" ::= "serv";
      "valEpochs" ::= slice.nil;
      "vals" ::= slice.nil
    ].

Definition putArg := struct.decl [
  "id" :: slice.T byteT;
  "val" :: slice.T byteT
].

Definition putArg__encode: val :=
  rec: "putArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF putArg "id" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF putArg "val" "o"));;
    ![slice.T byteT] "b".

Definition rpcKeyServUpdateEpoch : expr := #1.

Definition rpcKeyServPut : expr := #2.

Definition rpcKeyServGetIdAtEpoch : expr := #3.

Definition rpcKeyServGetIdLatest : expr := #4.

Definition rpcKeyServGetDigest : expr := #5.

Definition rpcAuditorUpdate : expr := #1.

Definition rpcAuditorGetLink : expr := #2.

Definition putReply := struct.decl [
  "epoch" :: epochTy;
  "sig" :: slice.T byteT;
  "error" :: errorTy
].

Definition putReply__decode: val :=
  rec: "putReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := marshalutil.SafeReadInt (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("sig", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.SigLen in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
        (if: "err"
        then (slice.nil, "err")
        else
          struct.storeF putReply "sig" "o" "sig";;
          struct.storeF putReply "epoch" "o" "epoch";;
          struct.storeF putReply "error" "o" "error";;
          (![slice.T byteT] "b", errNone)))).

Definition callPut: val :=
  rec: "callPut" "cli" "id" "val" :=
    let: "argB" := putArg__encode (struct.new putArg [
      "id" ::= "id";
      "val" ::= "val"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcKeyServPut "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new putReply [
    ] in
    let: (<>, "err1") := putReply__decode "reply" "replyB" in
    (if: "err1"
    then (#0, slice.nil, "err1")
    else (struct.loadF putReply "epoch" "reply", struct.loadF putReply "sig" "reply", struct.loadF putReply "error" "reply")).

(* verCallPut from ver_rpc.go *)

Definition verCallPut: val :=
  rec: "verCallPut" "cli" "pk" "id" "val" :=
    let: (("epoch", "sig"), "err") := callPut "cli" "id" "val" in
    (if: "err"
    then (#0, "err")
    else
      let: "enc" := idValEpoch__encode (struct.new idValEpoch [
        "id" ::= "id";
        "val" ::= "val";
        "epoch" ::= "epoch"
      ]) in
      let: "ok" := cryptoffi.Verify "pk" "enc" "sig" in
      (if: (~ "ok")
      then (#0, errSome)
      else ("epoch", errNone))).

(* TODO: what happens if client calls put twice in an epoch? *)
Definition keyCli__put: val :=
  rec: "keyCli__put" "c" "val" :=
    let: ("epoch", "err") := verCallPut (struct.loadF keyCli "serv" "c") (struct.loadF keyCli "servPk" "c") (struct.loadF keyCli "id" "c") "val" in
    (if: "err"
    then (#0, "err")
    else
      struct.storeF keyCli "valEpochs" "c" (SliceAppend uint64T (struct.loadF keyCli "valEpochs" "c") "epoch");;
      struct.storeF keyCli "vals" "c" (SliceAppend (slice.T byteT) (struct.loadF keyCli "vals" "c") "val");;
      ("epoch", errNone)).

(* getIdLatestArg from rpc.go *)

Definition getIdLatestArg := struct.decl [
  "id" :: slice.T byteT
].

Definition getIdLatestArg__encode: val :=
  rec: "getIdLatestArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getIdLatestArg "id" "o"));;
    ![slice.T byteT] "b".

Definition getIdLatestReply__decode: val :=
  rec: "getIdLatestReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := marshalutil.SafeReadInt (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("val", "b"), "err") := marshalutil.ReadSlice1D (![slice.T byteT] "b") in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("digest", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.HashLen in
        (if: "err"
        then (slice.nil, "err")
        else
          let: (("proofTy", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
          (if: "err"
          then (slice.nil, "err")
          else
            let: (("proof", "b"), "err") := marshalutil.ReadSlice3D (![slice.T byteT] "b") in
            (if: "err"
            then (slice.nil, "err")
            else
              let: (("sig", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.SigLen in
              (if: "err"
              then (slice.nil, "err")
              else
                let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
                (if: "err"
                then (slice.nil, "err")
                else
                  struct.storeF getIdLatestReply "epoch" "o" "epoch";;
                  struct.storeF getIdLatestReply "val" "o" "val";;
                  struct.storeF getIdLatestReply "digest" "o" "digest";;
                  struct.storeF getIdLatestReply "proofTy" "o" "proofTy";;
                  struct.storeF getIdLatestReply "proof" "o" "proof";;
                  struct.storeF getIdLatestReply "sig" "o" "sig";;
                  struct.storeF getIdLatestReply "error" "o" "error";;
                  (![slice.T byteT] "b", errNone)))))))).

Definition callGetIdLatest: val :=
  rec: "callGetIdLatest" "cli" "id" :=
    let: "errReply" := struct.new getIdLatestReply [
    ] in
    struct.storeF getIdLatestReply "error" "errReply" errSome;;
    let: "argB" := getIdLatestArg__encode (struct.new getIdLatestArg [
      "id" ::= "id"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcKeyServGetIdLatest "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new getIdLatestReply [
    ] in
    let: (<>, "err1") := getIdLatestReply__decode "reply" "replyB" in
    (if: "err1"
    then "errReply"
    else "reply").

(* verCallGetIdLatest from ver_rpc.go *)

Definition verCallGetIdLatest: val :=
  rec: "verCallGetIdLatest" "cli" "pk" "id" :=
    let: "errReply" := struct.new getIdLatestReply [
    ] in
    struct.storeF getIdLatestReply "error" "errReply" errSome;;
    let: "reply" := callGetIdLatest "cli" "id" in
    (if: struct.loadF getIdLatestReply "error" "reply"
    then "errReply"
    else
      let: "enc" := epochHash__encode (struct.new epochHash [
        "epoch" ::= struct.loadF getIdLatestReply "epoch" "reply";
        "hash" ::= struct.loadF getIdLatestReply "digest" "reply"
      ]) in
      let: "ok0" := cryptoffi.Verify "pk" "enc" (struct.loadF getIdLatestReply "sig" "reply") in
      (if: (~ "ok0")
      then "errReply"
      else
        let: "err" := merkle.CheckProof (struct.loadF getIdLatestReply "proofTy" "reply") (struct.loadF getIdLatestReply "proof" "reply") "id" (struct.loadF getIdLatestReply "val" "reply") (struct.loadF getIdLatestReply "digest" "reply") in
        (if: "err"
        then "errReply"
        else "reply"))).

Definition keyCli__get: val :=
  rec: "keyCli__get" "c" "id" :=
    let: "reply" := verCallGetIdLatest (struct.loadF keyCli "serv" "c") (struct.loadF keyCli "servPk" "c") "id" in
    (if: struct.loadF getIdLatestReply "error" "reply"
    then (#0, slice.nil, struct.loadF getIdLatestReply "error" "reply")
    else
      let: ("origDig", "ok") := MapGet (struct.loadF keyCli "digs" "c") (struct.loadF getIdLatestReply "epoch" "reply") in
      (if: "ok" && (~ (std.BytesEqual "origDig" (struct.loadF getIdLatestReply "digest" "reply")))
      then (#0, slice.nil, errSome)
      else
        (if: (~ "ok")
        then MapInsert (struct.loadF keyCli "digs" "c") (struct.loadF getIdLatestReply "epoch" "reply") (struct.loadF getIdLatestReply "digest" "reply")
        else #());;
        (struct.loadF getIdLatestReply "epoch" "reply", struct.loadF getIdLatestReply "val" "reply", errNone))).

(* getDigestArg from rpc.go *)

Definition getDigestArg := struct.decl [
  "epoch" :: epochTy
].

Definition getDigestArg__encode: val :=
  rec: "getDigestArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF getDigestArg "epoch" "o"));;
    ![slice.T byteT] "b".

Definition getDigestReply := struct.decl [
  "digest" :: slice.T byteT;
  "sig" :: slice.T byteT;
  "error" :: errorTy
].

Definition getDigestReply__decode: val :=
  rec: "getDigestReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("digest", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.HashLen in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("sig", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.SigLen in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
        (if: "err"
        then (slice.nil, "err")
        else
          struct.storeF getDigestReply "digest" "o" "digest";;
          struct.storeF getDigestReply "sig" "o" "sig";;
          struct.storeF getDigestReply "error" "o" "error";;
          (![slice.T byteT] "b", errNone)))).

Definition callGetDigest: val :=
  rec: "callGetDigest" "cli" "epoch" :=
    let: "argB" := getDigestArg__encode (struct.new getDigestArg [
      "epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcKeyServGetDigest "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new getDigestReply [
    ] in
    let: (<>, "err1") := getDigestReply__decode "reply" "replyB" in
    (if: "err1"
    then (slice.nil, slice.nil, "err1")
    else (struct.loadF getDigestReply "digest" "reply", struct.loadF getDigestReply "sig" "reply", struct.loadF getDigestReply "error" "reply")).

(* verCallGetDigest from ver_rpc.go *)

Definition verCallGetDigest: val :=
  rec: "verCallGetDigest" "cli" "pk" "epoch" :=
    let: (("dig", "sig"), "err") := callGetDigest "cli" "epoch" in
    (if: "err"
    then (slice.nil, "err")
    else
      let: "enc" := epochHash__encode (struct.new epochHash [
        "epoch" ::= "epoch";
        "hash" ::= "dig"
      ]) in
      let: "ok" := cryptoffi.Verify "pk" "enc" "sig" in
      (if: (~ "ok")
      then (slice.nil, errSome)
      else ("dig", errNone))).

Definition keyCli__getOrFillDig: val :=
  rec: "keyCli__getOrFillDig" "c" "epoch" :=
    let: "dig" := ref (zero_val (slice.T byteT)) in
    let: ("dig", "ok0") := MapGet (struct.loadF keyCli "digs" "c") "epoch" in
    (if: "ok0"
    then (![slice.T byteT] "dig", errNone)
    else
      let: ("newDig", "err") := verCallGetDigest (struct.loadF keyCli "serv" "c") (struct.loadF keyCli "servPk" "c") "epoch" in
      (if: "err"
      then (slice.nil, "err")
      else
        MapInsert (struct.loadF keyCli "digs" "c") "epoch" "newDig";;
        ("newDig", errNone))).

(* getLinkArg from rpc.go *)

Definition getLinkArg := struct.decl [
  "epoch" :: epochTy
].

Definition getLinkArg__encode: val :=
  rec: "getLinkArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF getLinkArg "epoch" "o"));;
    ![slice.T byteT] "b".

Definition getLinkReply := struct.decl [
  "link" :: linkTy;
  "sig" :: slice.T byteT;
  "error" :: errorTy
].

Definition getLinkReply__decode: val :=
  rec: "getLinkReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("link", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.HashLen in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("sig", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.SigLen in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
        (if: "err"
        then (slice.nil, "err")
        else
          struct.storeF getLinkReply "link" "o" "link";;
          struct.storeF getLinkReply "sig" "o" "sig";;
          struct.storeF getLinkReply "error" "o" "error";;
          (![slice.T byteT] "b", errNone)))).

Definition callGetLink: val :=
  rec: "callGetLink" "cli" "epoch" :=
    let: "argB" := getLinkArg__encode (struct.new getLinkArg [
      "epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcAuditorGetLink "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new getLinkReply [
    ] in
    let: (<>, "err1") := getLinkReply__decode "reply" "replyB" in
    (if: "err1"
    then (slice.nil, slice.nil, "err1")
    else (struct.loadF getLinkReply "link" "reply", struct.loadF getLinkReply "sig" "reply", struct.loadF getLinkReply "error" "reply")).

(* verCallGetLink from ver_rpc.go *)

Definition verCallGetLink: val :=
  rec: "verCallGetLink" "cli" "pk" "epoch" :=
    let: (("link", "sig"), "err") := callGetLink "cli" "epoch" in
    (if: "err"
    then (slice.nil, "err")
    else
      let: "enc" := epochHash__encode (struct.new epochHash [
        "epoch" ::= "epoch";
        "hash" ::= "link"
      ]) in
      let: "ok" := cryptoffi.Verify "pk" "enc" "sig" in
      (if: (~ "ok")
      then (slice.nil, errSome)
      else ("link", errNone))).

(* audit through epoch idx exclusive. *)
Definition keyCli__audit: val :=
  rec: "keyCli__audit" "c" "adtrId" :=
    let: "link" := ref (zero_val (slice.T byteT)) in
    let: "epoch" := ref (zero_val uint64T) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("dig", "err0") := keyCli__getOrFillDig "c" (![uint64T] "epoch") in
      (if: "err0"
      then Break
      else
        "link" <-[slice.T byteT] (calcNextLink (![slice.T byteT] "link") "dig");;
        "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
        Continue));;
    (if: (![uint64T] "epoch") = #0
    then (#0, errSome)
    else
      let: "lastEpoch" := (![uint64T] "epoch") - #1 in
      let: "adtr" := SliceGet ptrT (struct.loadF keyCli "adtrs" "c") "adtrId" in
      let: "adtrPk" := SliceGet ed25519.PublicKey (struct.loadF keyCli "adtrPks" "c") "adtrId" in
      let: ("adtrLink", "err1") := verCallGetLink "adtr" "adtrPk" "lastEpoch" in
      (if: "err1"
      then (#0, "err1")
      else
        (if: (~ (std.BytesEqual (![slice.T byteT] "link") "adtrLink"))
        then (#0, errSome)
        else (![uint64T] "epoch", errNone)))).

(* getIdAtEpochArg from rpc.go *)

Definition getIdAtEpochArg := struct.decl [
  "id" :: slice.T byteT;
  "epoch" :: epochTy
].

Definition getIdAtEpochArg__encode: val :=
  rec: "getIdAtEpochArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getIdAtEpochArg "id" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF getIdAtEpochArg "epoch" "o"));;
    ![slice.T byteT] "b".

Definition getIdAtEpochReply__decode: val :=
  rec: "getIdAtEpochReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("val", "b"), "err") := marshalutil.ReadSlice1D (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("digest", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.HashLen in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("proofTy", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
        (if: "err"
        then (slice.nil, "err")
        else
          let: (("proof", "b"), "err") := marshalutil.ReadSlice3D (![slice.T byteT] "b") in
          (if: "err"
          then (slice.nil, "err")
          else
            let: (("sig", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.SigLen in
            (if: "err"
            then (slice.nil, "err")
            else
              let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
              (if: "err"
              then (slice.nil, "err")
              else
                struct.storeF getIdAtEpochReply "val" "o" "val";;
                struct.storeF getIdAtEpochReply "digest" "o" "digest";;
                struct.storeF getIdAtEpochReply "proofTy" "o" "proofTy";;
                struct.storeF getIdAtEpochReply "proof" "o" "proof";;
                struct.storeF getIdAtEpochReply "sig" "o" "sig";;
                struct.storeF getIdAtEpochReply "error" "o" "error";;
                (![slice.T byteT] "b", errNone))))))).

Definition callGetIdAtEpoch: val :=
  rec: "callGetIdAtEpoch" "cli" "id" "epoch" :=
    let: "errReply" := struct.new getIdAtEpochReply [
    ] in
    struct.storeF getIdAtEpochReply "error" "errReply" errSome;;
    let: "argB" := getIdAtEpochArg__encode (struct.new getIdAtEpochArg [
      "id" ::= "id";
      "epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcKeyServGetIdAtEpoch "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new getIdAtEpochReply [
    ] in
    let: (<>, "err1") := getIdAtEpochReply__decode "reply" "replyB" in
    (if: "err1"
    then "errReply"
    else "reply").

(* verCallGetIdAtEpoch from ver_rpc.go *)

Definition verCallGetIdAtEpoch: val :=
  rec: "verCallGetIdAtEpoch" "cli" "pk" "id" "epoch" :=
    let: "errReply" := struct.new getIdAtEpochReply [
    ] in
    struct.storeF getIdAtEpochReply "error" "errReply" errSome;;
    let: "reply" := callGetIdAtEpoch "cli" "id" "epoch" in
    (if: struct.loadF getIdAtEpochReply "error" "reply"
    then "errReply"
    else
      let: "enc" := epochHash__encode (struct.new epochHash [
        "epoch" ::= "epoch";
        "hash" ::= struct.loadF getIdAtEpochReply "digest" "reply"
      ]) in
      let: "ok" := cryptoffi.Verify "pk" "enc" (struct.loadF getIdAtEpochReply "sig" "reply") in
      (if: (~ "ok")
      then "errReply"
      else
        let: "err" := merkle.CheckProof (struct.loadF getIdAtEpochReply "proofTy" "reply") (struct.loadF getIdAtEpochReply "proof" "reply") "id" (struct.loadF getIdAtEpochReply "val" "reply") (struct.loadF getIdAtEpochReply "digest" "reply") in
        (if: "err"
        then "errReply"
        else "reply"))).

Definition keyCli__checkProofWithExpected: val :=
  rec: "keyCli__checkProofWithExpected" "c" "epoch" "expVal" "expProofTy" :=
    let: "id" := struct.loadF keyCli "id" "c" in
    let: "reply" := verCallGetIdAtEpoch (struct.loadF keyCli "serv" "c") (struct.loadF keyCli "servPk" "c") "id" "epoch" in
    (if: struct.loadF getIdAtEpochReply "error" "reply"
    then #false
    else
      (if: (~ (std.BytesEqual (struct.loadF getIdAtEpochReply "val" "reply") "expVal"))
      then #false
      else
        (if: (struct.loadF getIdAtEpochReply "proofTy" "reply") ≠ "expProofTy"
        then #false
        else
          let: ("origDig", "ok") := MapGet (struct.loadF keyCli "digs" "c") "epoch" in
          (if: "ok" && (~ (std.BytesEqual (struct.loadF getIdAtEpochReply "digest" "reply") "origDig"))
          then #false
          else
            (if: (~ "ok")
            then MapInsert (struct.loadF keyCli "digs" "c") "epoch" (struct.loadF getIdAtEpochReply "digest" "reply")
            else #());;
            #true)))).

(* selfAudit through Epoch idx exclusive. *)
Definition keyCli__selfAudit: val :=
  rec: "keyCli__selfAudit" "c" :=
    let: "numVals" := slice.len (struct.loadF keyCli "vals" "c") in
    let: "valIdx" := ref (zero_val uint64T) in
    let: "epoch" := ref (zero_val uint64T) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "valIdx") ≠ "numVals"
      then
        let: "epochChange" := SliceGet uint64T (struct.loadF keyCli "valEpochs" "c") (![uint64T] "valIdx") in
        (if: (![uint64T] "epoch") = "epochChange"
        then "valIdx" <-[uint64T] ((![uint64T] "valIdx") + #1)
        else #())
      else #());;
      let: "expProofTy" := ref (zero_val boolT) in
      let: "expVal" := ref (zero_val (slice.T byteT)) in
      (if: (![uint64T] "valIdx") ≠ #0
      then
        "expProofTy" <-[boolT] merkle.MembProofTy;;
        "expVal" <-[slice.T byteT] (SliceGet (slice.T byteT) (struct.loadF keyCli "vals" "c") ((![uint64T] "valIdx") - #1))
      else #());;
      let: "ok" := keyCli__checkProofWithExpected "c" (![uint64T] "epoch") (![slice.T byteT] "expVal") (![boolT] "expProofTy") in
      (if: (~ "ok")
      then Break
      else
        "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
        Continue));;
    ![uint64T] "epoch".

(* proof.go *)

(* updateArg from rpc.go *)

Definition updateArg := struct.decl [
  "epoch" :: epochTy;
  "digest" :: slice.T byteT;
  "sig" :: slice.T byteT
].

Definition updateArg__encode: val :=
  rec: "updateArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF updateArg "epoch" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF updateArg "digest" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF updateArg "sig" "o"));;
    ![slice.T byteT] "b".

Definition updateReply := struct.decl [
  "error" :: errorTy
].

Definition updateReply__decode: val :=
  rec: "updateReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      struct.storeF updateReply "error" "o" "error";;
      (![slice.T byteT] "b", errNone)).

Definition callUpdate: val :=
  rec: "callUpdate" "cli" "epoch" "dig" "sig" :=
    let: "argB" := updateArg__encode (struct.new updateArg [
      "epoch" ::= "epoch";
      "digest" ::= "dig";
      "sig" ::= "sig"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcAuditorUpdate "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new updateReply [
    ] in
    let: (<>, "err1") := updateReply__decode "reply" "replyB" in
    (if: "err1"
    then "err1"
    else struct.loadF updateReply "error" "reply").

Definition updateAdtrDigs: val :=
  rec: "updateAdtrDigs" "servCli" "adtrCli" :=
    let: "epoch" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: (("dig", "sig"), "err0") := callGetDigest "servCli" (![uint64T] "epoch") in
      (if: "err0"
      then Break
      else
        let: "err1" := callUpdate "adtrCli" (![uint64T] "epoch") "dig" "sig" in
        (if: "err1"
        then Break
        else
          "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
          Continue)));;
    ![uint64T] "epoch".

Definition putArg__decode: val :=
  rec: "putArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("id", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.HashLen in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("val", "b"), "err") := marshalutil.ReadSlice1D (![slice.T byteT] "b") in
      (if: "err"
      then (slice.nil, "err")
      else
        struct.storeF putArg "id" "o" "id";;
        struct.storeF putArg "val" "o" "val";;
        (![slice.T byteT] "b", errNone))).

Definition putReply__encode: val :=
  rec: "putReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF putReply "epoch" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF putReply "sig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteBool (![slice.T byteT] "b") (struct.loadF putReply "error" "o"));;
    ![slice.T byteT] "b".

Definition getIdAtEpochArg__decode: val :=
  rec: "getIdAtEpochArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("id", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.HashLen in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("epoch", "b"), "err") := marshalutil.SafeReadInt (![slice.T byteT] "b") in
      (if: "err"
      then (slice.nil, "err")
      else
        struct.storeF getIdAtEpochArg "id" "o" "id";;
        struct.storeF getIdAtEpochArg "epoch" "o" "epoch";;
        (![slice.T byteT] "b", errNone))).

Definition getIdAtEpochReply__encode: val :=
  rec: "getIdAtEpochReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF getIdAtEpochReply "val" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getIdAtEpochReply "digest" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteBool (![slice.T byteT] "b") (struct.loadF getIdAtEpochReply "proofTy" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF getIdAtEpochReply "proof" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getIdAtEpochReply "sig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteBool (![slice.T byteT] "b") (struct.loadF getIdAtEpochReply "error" "o"));;
    ![slice.T byteT] "b".

Definition getIdLatestArg__decode: val :=
  rec: "getIdLatestArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("id", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.HashLen in
    (if: "err"
    then (slice.nil, "err")
    else
      struct.storeF getIdLatestArg "id" "o" "id";;
      (![slice.T byteT] "b", errNone)).

Definition getIdLatestReply__encode: val :=
  rec: "getIdLatestReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF getIdLatestReply "epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF getIdLatestReply "val" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getIdLatestReply "digest" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteBool (![slice.T byteT] "b") (struct.loadF getIdLatestReply "proofTy" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF getIdLatestReply "proof" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getIdLatestReply "sig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteBool (![slice.T byteT] "b") (struct.loadF getIdLatestReply "error" "o"));;
    ![slice.T byteT] "b".

Definition getDigestArg__decode: val :=
  rec: "getDigestArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := marshalutil.SafeReadInt (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      struct.storeF getDigestArg "epoch" "o" "epoch";;
      (![slice.T byteT] "b", errNone)).

Definition getDigestReply__encode: val :=
  rec: "getDigestReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getDigestReply "digest" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getDigestReply "sig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteBool (![slice.T byteT] "b") (struct.loadF getDigestReply "error" "o"));;
    ![slice.T byteT] "b".

Definition keyServ__start: val :=
  rec: "keyServ__start" "s" "addr" :=
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "handlers" rpcKeyServUpdateEpoch (λ: "enc_args" "enc_reply",
      keyServ__updateEpoch "s";;
      #()
      );;
    MapInsert "handlers" rpcKeyServPut (λ: "enc_args" "enc_reply",
      let: "args" := struct.new putArg [
      ] in
      let: (<>, "err0") := putArg__decode "args" "enc_args" in
      (if: "err0"
      then
        "enc_reply" <-[slice.T byteT] (putReply__encode (struct.new putReply [
          "epoch" ::= #0;
          "error" ::= "err0"
        ]));;
        #()
      else
        let: (("epoch", "sig"), "err1") := keyServ__put "s" (struct.loadF putArg "id" "args") (struct.loadF putArg "val" "args") in
        "enc_reply" <-[slice.T byteT] (putReply__encode (struct.new putReply [
          "epoch" ::= "epoch";
          "sig" ::= "sig";
          "error" ::= "err1"
        ]));;
        #())
      );;
    MapInsert "handlers" rpcKeyServGetIdAtEpoch (λ: "enc_args" "enc_reply",
      let: "args" := struct.new getIdAtEpochArg [
      ] in
      let: (<>, "err0") := getIdAtEpochArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new getIdAtEpochReply [
        ] in
        struct.storeF getIdAtEpochReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (getIdAtEpochReply__encode "reply");;
        #()
      else
        let: "reply" := keyServ__getIdAtEpoch "s" (struct.loadF getIdAtEpochArg "id" "args") (struct.loadF getIdAtEpochArg "epoch" "args") in
        "enc_reply" <-[slice.T byteT] (getIdAtEpochReply__encode "reply");;
        #())
      );;
    MapInsert "handlers" rpcKeyServGetIdLatest (λ: "enc_args" "enc_reply",
      let: "args" := struct.new getIdLatestArg [
      ] in
      let: (<>, "err0") := getIdLatestArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new getIdLatestReply [
        ] in
        struct.storeF getIdLatestReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (getIdLatestReply__encode "reply");;
        #()
      else
        let: "reply" := keyServ__getIdLatest "s" (struct.loadF getIdLatestArg "id" "args") in
        "enc_reply" <-[slice.T byteT] (getIdLatestReply__encode "reply");;
        #())
      );;
    MapInsert "handlers" rpcKeyServGetDigest (λ: "enc_args" "enc_reply",
      let: "args" := struct.new getDigestArg [
      ] in
      let: (<>, "err0") := getDigestArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new getDigestReply [
        ] in
        struct.storeF getDigestReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (getDigestReply__encode "reply");;
        #()
      else
        let: (("dig", "sig"), "err1") := keyServ__getDigest "s" (struct.loadF getDigestArg "epoch" "args") in
        "enc_reply" <-[slice.T byteT] (getDigestReply__encode (struct.new getDigestReply [
          "digest" ::= "dig";
          "sig" ::= "sig";
          "error" ::= "err1"
        ]));;
        #())
      );;
    urpc.Server__Serve (urpc.MakeServer "handlers") "addr";;
    #().

Definition updateArg__decode: val :=
  rec: "updateArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := marshalutil.SafeReadInt (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("digest", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.HashLen in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("sig", "b"), "err") := marshalutil.SafeReadBytes (![slice.T byteT] "b") cryptoffi.SigLen in
        (if: "err"
        then (slice.nil, "err")
        else
          struct.storeF updateArg "epoch" "o" "epoch";;
          struct.storeF updateArg "digest" "o" "digest";;
          struct.storeF updateArg "sig" "o" "sig";;
          (![slice.T byteT] "b", errNone)))).

Definition updateReply__encode: val :=
  rec: "updateReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshalutil.WriteBool (![slice.T byteT] "b") (struct.loadF updateReply "error" "o"));;
    ![slice.T byteT] "b".

Definition getLinkArg__decode: val :=
  rec: "getLinkArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := marshalutil.SafeReadInt (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      struct.storeF getLinkArg "epoch" "o" "epoch";;
      (![slice.T byteT] "b", errNone)).

Definition getLinkReply__encode: val :=
  rec: "getLinkReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getLinkReply "link" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF getLinkReply "sig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteBool (![slice.T byteT] "b") (struct.loadF getLinkReply "error" "o"));;
    ![slice.T byteT] "b".

Definition auditor__start: val :=
  rec: "auditor__start" "a" "addr" :=
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "handlers" rpcAuditorUpdate (λ: "enc_args" "enc_reply",
      let: "args" := struct.new updateArg [
      ] in
      let: (<>, "err0") := updateArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new updateReply [
        ] in
        struct.storeF updateReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (updateReply__encode "reply");;
        #()
      else
        let: "err1" := auditor__update "a" (struct.loadF updateArg "epoch" "args") (struct.loadF updateArg "digest" "args") (struct.loadF updateArg "sig" "args") in
        "enc_reply" <-[slice.T byteT] (updateReply__encode (struct.new updateReply [
          "error" ::= "err1"
        ]));;
        #())
      );;
    MapInsert "handlers" rpcAuditorGetLink (λ: "enc_args" "enc_reply",
      let: "args" := struct.new getLinkArg [
      ] in
      let: (<>, "err0") := getLinkArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new getLinkReply [
        ] in
        struct.storeF getLinkReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (getLinkReply__encode "reply");;
        #()
      else
        let: (("link", "sig"), "err1") := auditor__getLink "a" (struct.loadF getLinkArg "epoch" "args") in
        "enc_reply" <-[slice.T byteT] (getLinkReply__encode (struct.new getLinkReply [
          "link" ::= "link";
          "sig" ::= "sig";
          "error" ::= "err1"
        ]));;
        #())
      );;
    urpc.Server__Serve (urpc.MakeServer "handlers") "addr";;
    #().

Definition testAgreement: val :=
  rec: "testAgreement" "servAddr" "adtrAddr" :=
    let: ("servSk", "servPk") := cryptoffi.MakeKeys #() in
    Fork (let: "s" := newKeyServ "servSk" in
          keyServ__start "s" "servAddr");;
    let: ("adtrSk", "adtrPk") := cryptoffi.MakeKeys #() in
    let: "adtrPks" := SliceSingleton "adtrPk" in
    let: "adtrAddrs" := SliceSingleton "adtrAddr" in
    Fork (let: "a" := newAuditor "adtrSk" "servPk" in
          auditor__start "a" "adtrAddr");;
    time.Sleep #1000000;;
    let: "servCli" := urpc.MakeClient "servAddr" in
    let: "adtrCli" := urpc.MakeClient "adtrAddr" in
    let: "aliceId" := cryptoffi.Hash (StringToBytes #(str"alice")) in
    let: "aliceVal" := StringToBytes #(str"val") in
    let: "aliceCli" := newKeyCli "aliceId" "servAddr" "adtrAddrs" "adtrPks" "servPk" in
    let: (<>, "err0") := keyCli__put "aliceCli" "aliceVal" in
    control.impl.Assume (~ "err0");;
    let: "emptyReplyB" := NewSlice byteT #0 in
    let: "err1" := urpc.Client__Call "servCli" "rpcKeyServUpdateEpoch" slice.nil "emptyReplyB" #100 in
    control.impl.Assume ("err1" = urpc.ErrNone);;
    let: "epochAdtr" := updateAdtrDigs "servCli" "adtrCli" in
    control.impl.Assume ("epochAdtr" = #2);;
    let: "bobId" := cryptoffi.Hash (StringToBytes #(str"bob")) in
    let: "bobCli" := newKeyCli "bobId" "servAddr" "adtrAddrs" "adtrPks" "servPk" in
    let: "charlieId" := cryptoffi.Hash (StringToBytes #(str"charlie")) in
    let: "charlieCli" := newKeyCli "charlieId" "servAddr" "adtrAddrs" "adtrPks" "servPk" in
    let: (("epoch0", "val0"), "err3") := keyCli__get "bobCli" "aliceId" in
    control.impl.Assume (~ "err3");;
    let: (("epoch1", "val1"), "err4") := keyCli__get "charlieCli" "aliceId" in
    control.impl.Assume (~ "err4");;
    let: ("epoch2", "err5") := keyCli__audit "bobCli" #0 in
    control.impl.Assume (~ "err5");;
    let: ("epoch3", "err6") := keyCli__audit "charlieCli" #0 in
    control.impl.Assume (~ "err6");;
    control.impl.Assume ("epoch0" = "epoch1");;
    control.impl.Assume ("epoch0" < "epoch2");;
    control.impl.Assume ("epoch1" < "epoch3");;
    control.impl.Assert (std.BytesEqual "val0" "val1");;
    #().

(* rpc.go *)

(* ver_rpc.go *)
