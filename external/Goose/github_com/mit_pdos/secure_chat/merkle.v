(* autogenerated from github.com/mit-pdos/secure-chat/merkle *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.mit_pdos.secure_chat.merkle.merkle_shim.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition ErrNone : expr := #0.

Definition ErrFound : expr := #1.

Definition ErrNotFound : expr := #2.

Definition ErrBadInput : expr := #3.

Definition ErrPathProof : expr := #4.

Definition HashLen : expr := #32.

Definition NumChildren : expr := #256.

Definition Hasher := struct.decl [
  "B" :: slice.T byteT
].

Definition NewHasher: val :=
  rec: "NewHasher" <> :=
    struct.new Hasher [
    ].

Definition Hasher__Write: val :=
  rec: "Hasher__Write" "h" "b" :=
    ForSlice byteT <> "b" "b"
      (struct.storeF Hasher "B" "h" (SliceAppend byteT (struct.loadF Hasher "B" "h") "b"));;
    #().

Definition Hasher__Sum: val :=
  rec: "Hasher__Sum" "h" "b" :=
    let: "b1" := ref_to (slice.T byteT) "b" in
    let: "hash" := merkle_shim.Hash (struct.loadF Hasher "B" "h") in
    ForSlice byteT <> "byt" "hash"
      ("b1" <-[slice.T byteT] (SliceAppend byteT "b" "byt"));;
    ![slice.T byteT] "b1".

Definition HashSlice2D: val :=
  rec: "HashSlice2D" "b" :=
    let: "h" := NewHasher #() in
    ForSlice (slice.T byteT) <> "b1" "b"
      (Hasher__Write "h" "b1");;
    Hasher__Sum "h" slice.nil.

Definition Node := struct.decl [
  "Val" :: ptrT;
  "hash" :: slice.T byteT;
  "Children" :: slice.T ptrT
].

Definition Node__Hash: val :=
  rec: "Node__Hash" "n" :=
    (if: "n" = #null
    then merkle_shim.Hash slice.nil
    else struct.loadF Node "hash" "n").

Definition HashNodes: val :=
  rec: "HashNodes" "nodeSl" :=
    let: "h" := NewHasher #() in
    ForSlice ptrT <> "n" "nodeSl"
      (Hasher__Write "h" (Node__Hash "n"));;
    Hasher__Sum "h" slice.nil.

Definition CopySlice: val :=
  rec: "CopySlice" "b1" :=
    let: "b2" := NewSlice byteT (slice.len "b1") in
    SliceCopy byteT "b2" "b1";;
    "b2".

Definition BytesEqual: val :=
  rec: "BytesEqual" "b1" "b2" :=
    (if: (slice.len "b1") ≠ (slice.len "b2")
    then #false
    else
      let: "isEq" := ref_to boolT #true in
      ForSlice byteT "i" "b" "b1"
        ((if: "b" ≠ (SliceGet byteT "b2" "i")
        then "isEq" <-[boolT] #false
        else #()));;
      ![boolT] "isEq").

(* "keys" of the tree.
   We use "Id" to differentiate this from the public keys that could be stored
   in the tree. *)
Definition Id := struct.decl [
  "B" :: slice.T byteT
].

(* "vals" of the tree. *)
Definition Val := struct.decl [
  "B" :: slice.T byteT
].

(* These nodes are neither interior nodes nor leaf nodes.
   They'll be specialized after adding them to the tree. *)
Definition NewGenericNode: val :=
  rec: "NewGenericNode" <> :=
    let: "v" := ref (zero_val ptrT) in
    let: "c" := NewSlice ptrT NumChildren in
    struct.new Node [
      "Val" ::= ![ptrT] "v";
      "hash" ::= slice.nil;
      "Children" ::= "c"
    ].

Definition Node__UpdateLeafHash: val :=
  rec: "Node__UpdateLeafHash" "n" :=
    struct.storeF Node "hash" "n" (merkle_shim.Hash (struct.loadF Val "B" (struct.loadF Node "Val" "n")));;
    #().

(* Assumes recursive child hashes are already up-to-date. *)
Definition Node__UpdateInteriorHash: val :=
  rec: "Node__UpdateInteriorHash" "n" :=
    struct.storeF Node "hash" "n" (HashNodes (struct.loadF Node "Children" "n"));;
    #().

Definition Digest := struct.decl [
  "B" :: slice.T byteT
].

(* General proof object.
   Binds an id down the tree to a particular node hash. *)
Definition PathProof := struct.decl [
  "Id" :: ptrT;
  "NodeHash" :: slice.T byteT;
  "Digest" :: ptrT;
  "ChildHashes" :: slice.T (slice.T (slice.T byteT))
].

Definition MembProof := struct.decl [
  "ChildHashes" :: slice.T (slice.T (slice.T byteT))
].

Definition NonmembProof := struct.decl [
  "ChildHashes" :: slice.T (slice.T (slice.T byteT))
].

Definition PathProof__Check: val :=
  rec: "PathProof__Check" "p" :=
    let: "proofLen" := slice.len (struct.loadF Id "B" (struct.loadF PathProof "Id" "p")) in
    let: "posBott" := SliceGet byteT (struct.loadF Id "B" (struct.loadF PathProof "Id" "p")) ("proofLen" - #1) in
    (if: (~ (BytesEqual (struct.loadF PathProof "NodeHash" "p") (SliceGet (slice.T byteT) (SliceGet (slice.T (slice.T byteT)) (struct.loadF PathProof "ChildHashes" "p") ("proofLen" - #1)) "posBott")))
    then ErrPathProof
    else
      let: "err" := ref_to uint64T ErrNone in
      let: "pathIdx" := ref_to uint64T ("proofLen" - #1) in
      (for: (λ: <>, (![uint64T] "pathIdx") ≥ #1); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") - #1)) := λ: <>,
        let: "hChildren" := HashSlice2D (SliceGet (slice.T (slice.T byteT)) (struct.loadF PathProof "ChildHashes" "p") (![uint64T] "pathIdx")) in
        let: "prevIdx" := (![uint64T] "pathIdx") - #1 in
        let: "pos" := SliceGet byteT (struct.loadF Id "B" (struct.loadF PathProof "Id" "p")) "prevIdx" in
        (if: (~ (BytesEqual "hChildren" (SliceGet (slice.T byteT) (SliceGet (slice.T (slice.T byteT)) (struct.loadF PathProof "ChildHashes" "p") "prevIdx") "pos")))
        then
          "err" <-[uint64T] ErrPathProof;;
          Continue
        else Continue));;
      (if: (![uint64T] "err") ≠ ErrNone
      then ![uint64T] "err"
      else
        let: "digest" := HashSlice2D (SliceGet (slice.T (slice.T byteT)) (struct.loadF PathProof "ChildHashes" "p") #0) in
        (if: (~ (BytesEqual "digest" (struct.loadF Digest "B" (struct.loadF PathProof "Digest" "p"))))
        then ErrPathProof
        else ErrNone))).

Definition MembProof__Check: val :=
  rec: "MembProof__Check" "p" "id" "val" "digest" :=
    (if: (slice.len (struct.loadF Id "B" "id")) ≠ HashLen
    then ErrBadInput
    else
      (if: (slice.len (struct.loadF MembProof "ChildHashes" "p")) ≠ HashLen
      then ErrBadInput
      else
        let: "pathProof" := struct.new PathProof [
          "Id" ::= "id";
          "NodeHash" ::= merkle_shim.Hash (struct.loadF Val "B" "val");
          "Digest" ::= "digest";
          "ChildHashes" ::= struct.loadF MembProof "ChildHashes" "p"
        ] in
        PathProof__Check "pathProof")).

Definition NonmembProof__Check: val :=
  rec: "NonmembProof__Check" "p" "id" "digest" :=
    (if: HashLen ≤ (slice.len (struct.loadF NonmembProof "ChildHashes" "p"))
    then ErrBadInput
    else
      let: "idPref" := struct.new Id [
        "B" ::= SliceTake (CopySlice (struct.loadF Id "B" "id")) (slice.len (struct.loadF NonmembProof "ChildHashes" "p"))
      ] in
      let: "pathProof" := struct.new PathProof [
        "Id" ::= "idPref";
        "NodeHash" ::= merkle_shim.Hash slice.nil;
        "Digest" ::= "digest";
        "ChildHashes" ::= struct.loadF NonmembProof "ChildHashes" "p"
      ] in
      PathProof__Check "pathProof").

Definition Tree := struct.decl [
  "Root" :: ptrT
].

Definition NewTree: val :=
  rec: "NewTree" <> :=
    let: "n" := struct.new Node [
    ] in
    struct.storeF Node "Children" "n" (NewSlice ptrT NumChildren);;
    Node__UpdateInteriorHash "n";;
    struct.new Tree [
      "Root" ::= "n"
    ].

Definition Tree__Print: val :=
  rec: "Tree__Print" "t" :=
    let: "qCurr" := ref (zero_val (slice.T ptrT)) in
    let: "qNext" := ref (zero_val (slice.T ptrT)) in
    "qCurr" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "qCurr") (struct.loadF Tree "Root" "t"));;
    Skip;;
    (for: (λ: <>, (slice.len (![slice.T ptrT] "qCurr")) > #0); (λ: <>, Skip) := λ: <>,
      Skip;;
      (for: (λ: <>, (slice.len (![slice.T ptrT] "qCurr")) > #0); (λ: <>, Skip) := λ: <>,
        let: "top" := SliceGet ptrT (![slice.T ptrT] "qCurr") #0 in
        "qCurr" <-[slice.T ptrT] (SliceSkip ptrT (![slice.T ptrT] "qCurr") #1);;
        (if: "top" = #null
        then
          (* log.Print("nil | ") *)
          Continue
        else
          (if: (struct.loadF Node "Val" "top") ≠ #null
          then
            (* log.Print(top.Hash(), top.Val.B, " | ") *)
            #()
          else
            (* log.Print(top.Hash(), " | ") *)
            #());;
          ForSlice ptrT <> "child" (struct.loadF Node "Children" "top")
            ("qNext" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "qNext") "child"));;
          Continue));;
      "qCurr" <-[slice.T ptrT] (![slice.T ptrT] "qNext");;
      "qNext" <-[slice.T ptrT] slice.nil;;
      (* log.Println() *)
      Continue);;
    #().

Definition GetChildHashes: val :=
  rec: "GetChildHashes" "nodePath" :=
    let: "childHashes" := NewSlice (slice.T (slice.T byteT)) (slice.len "nodePath") in
    let: "pathIdx" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "pathIdx") < (slice.len "nodePath")); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") + #1)) := λ: <>,
      let: "treeChildren" := struct.loadF Node "Children" (SliceGet ptrT "nodePath" (![uint64T] "pathIdx")) in
      let: "proofChildren" := NewSlice (slice.T byteT) NumChildren in
      SliceSet (slice.T (slice.T byteT)) "childHashes" (![uint64T] "pathIdx") "proofChildren";;
      let: "childIdx" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "childIdx") < NumChildren); (λ: <>, "childIdx" <-[uint64T] ((![uint64T] "childIdx") + #1)) := λ: <>,
        SliceSet (slice.T byteT) "proofChildren" (![uint64T] "childIdx") (CopySlice (Node__Hash (SliceGet ptrT "treeChildren" (![uint64T] "childIdx"))));;
        Continue);;
      Continue);;
    "childHashes".

Definition Tree__WalkTree: val :=
  rec: "Tree__WalkTree" "t" "id" :=
    let: "nodePath" := ref (zero_val (slice.T ptrT)) in
    "nodePath" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "nodePath") (struct.loadF Tree "Root" "t"));;
    let: "found" := ref_to boolT #true in
    let: "pathIdx" := ref_to uint64T #0 in
    (for: (λ: <>, ((![uint64T] "pathIdx") < HashLen) && (![boolT] "found")); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") + #1)) := λ: <>,
      let: "currNode" := SliceGet ptrT (![slice.T ptrT] "nodePath") (![uint64T] "pathIdx") in
      let: "pos" := SliceGet byteT (struct.loadF Id "B" "id") (![uint64T] "pathIdx") in
      (if: (SliceGet ptrT (struct.loadF Node "Children" "currNode") "pos") = #null
      then
        "found" <-[boolT] #false;;
        Continue
      else
        "nodePath" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "nodePath") (SliceGet ptrT (struct.loadF Node "Children" "currNode") "pos"));;
        Continue));;
    (![slice.T ptrT] "nodePath", ![boolT] "found").

Definition Tree__WalkTreeAddLinks: val :=
  rec: "Tree__WalkTreeAddLinks" "t" "id" :=
    let: "nodePath" := ref (zero_val (slice.T ptrT)) in
    "nodePath" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "nodePath") (struct.loadF Tree "Root" "t"));;
    let: "pathIdx" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "pathIdx") < HashLen); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") + #1)) := λ: <>,
      let: "currNode" := SliceGet ptrT (![slice.T ptrT] "nodePath") (![uint64T] "pathIdx") in
      let: "pos" := SliceGet byteT (struct.loadF Id "B" "id") (![uint64T] "pathIdx") in
      (if: (SliceGet ptrT (struct.loadF Node "Children" "currNode") "pos") = #null
      then SliceSet ptrT (struct.loadF Node "Children" "currNode") "pos" (NewGenericNode #())
      else #());;
      "nodePath" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "nodePath") (SliceGet ptrT (struct.loadF Node "Children" "currNode") "pos"));;
      Continue);;
    ![slice.T ptrT] "nodePath".

Definition Tree__Put: val :=
  rec: "Tree__Put" "t" "id" "v" :=
    (if: (slice.len (struct.loadF Id "B" "id")) ≠ HashLen
    then (slice.nil, slice.nil, ErrBadInput)
    else
      let: "nodePath" := Tree__WalkTreeAddLinks "t" "id" in
      struct.storeF Node "Val" (SliceGet ptrT "nodePath" HashLen) "v";;
      Node__UpdateLeafHash (SliceGet ptrT "nodePath" HashLen);;
      let: "pathIdx" := ref_to uint64T HashLen in
      (for: (λ: <>, (![uint64T] "pathIdx") ≥ #1); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") - #1)) := λ: <>,
        Node__UpdateInteriorHash (SliceGet ptrT "nodePath" ((![uint64T] "pathIdx") - #1));;
        Continue);;
      let: "digest" := struct.new Digest [
        "B" ::= CopySlice (Node__Hash (SliceGet ptrT "nodePath" #0))
      ] in
      let: "proof" := struct.new MembProof [
        "ChildHashes" ::= GetChildHashes (SliceTake "nodePath" HashLen)
      ] in
      ("digest", "proof", ErrNone)).

Definition Tree__Get: val :=
  rec: "Tree__Get" "t" "id" :=
    (if: (slice.len (struct.loadF Id "B" "id")) ≠ HashLen
    then (slice.nil, slice.nil, slice.nil, ErrBadInput)
    else
      let: ("nodePath", "found") := Tree__WalkTree "t" "id" in
      (if: (~ "found")
      then (slice.nil, slice.nil, slice.nil, ErrNotFound)
      else
        let: "val" := struct.new Val [
          "B" ::= CopySlice (struct.loadF Val "B" (struct.loadF Node "Val" (SliceGet ptrT "nodePath" HashLen)))
        ] in
        let: "digest" := struct.new Digest [
          "B" ::= CopySlice (Node__Hash (SliceGet ptrT "nodePath" #0))
        ] in
        let: "proof" := struct.new MembProof [
          "ChildHashes" ::= GetChildHashes (SliceTake "nodePath" HashLen)
        ] in
        ("val", "digest", "proof", ErrNone))).

Definition Tree__GetNil: val :=
  rec: "Tree__GetNil" "t" "id" :=
    (if: (slice.len (struct.loadF Id "B" "id")) ≠ HashLen
    then (slice.nil, slice.nil, ErrBadInput)
    else
      let: ("nodePath", "found") := Tree__WalkTree "t" "id" in
      (if: "found"
      then (slice.nil, slice.nil, ErrFound)
      else
        let: "digest" := struct.new Digest [
          "B" ::= CopySlice (Node__Hash (SliceGet ptrT "nodePath" #0))
        ] in
        let: "proof" := struct.new NonmembProof [
          "ChildHashes" ::= GetChildHashes "nodePath"
        ] in
        ("digest", "proof", ErrNone))).

End code.
