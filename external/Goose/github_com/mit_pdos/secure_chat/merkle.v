(* autogenerated from github.com/mit-pdos/secure-chat/merkle *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.secure_chat.cryptoHelpers.
From Goose Require github_com.mit_pdos.secure_chat.cryptoShim.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition Error: ty := uint64T.

Definition ProofTy: ty := boolT.

Definition ErrNone : expr := #0.

Definition ErrFound : expr := #1.

Definition ErrNotFound : expr := #2.

Definition ErrBadInput : expr := #3.

Definition ErrPathProof : expr := #4.

Definition NumChildren : expr := #256.

Definition EmptyNodeId : expr := #(U8 0).

Definition LeafNodeId : expr := #(U8 1).

Definition InteriorNodeId : expr := #(U8 2).

Definition NonmembProofTy : expr := #false.

Definition MembProofTy : expr := #true.

Definition CopySlice: val :=
  rec: "CopySlice" "b1" :=
    let: "b2" := NewSlice byteT (slice.len "b1") in
    SliceCopy byteT "b2" "b1";;
    "b2".

Definition Id: ty := slice.T byteT.

Definition Val: ty := slice.T byteT.

Definition Node := struct.decl [
  "Val" :: Val;
  "hash" :: slice.T byteT;
  "Children" :: slice.T ptrT
].

(* Hash getter to support hashes of empty (nil) nodes. *)
Definition Node__Hash: val :=
  rec: "Node__Hash" "n" :=
    (if: "n" = #null
    then cryptoShim.Hash (SliceSingleton EmptyNodeId)
    else struct.loadF Node "hash" "n").

Definition Node__DeepCopy: val :=
  rec: "Node__DeepCopy" "n" :=
    (if: "n" = #null
    then slice.nil
    else
      let: "n2" := ref_to ptrT (struct.new Node [
      ]) in
      struct.storeF Node "Val" (![ptrT] "n2") (CopySlice (struct.loadF Node "Val" "n"));;
      struct.storeF Node "hash" (![ptrT] "n2") (CopySlice (struct.loadF Node "hash" "n"));;
      let: "children" := NewSlice ptrT (slice.len (struct.loadF Node "Children" "n")) in
      ForSlice ptrT "i" "c" (struct.loadF Node "Children" "n")
        (SliceSet ptrT "children" "i" (Node__DeepCopy "c"));;
      struct.storeF Node "Children" (![ptrT] "n2") "children";;
      ![ptrT] "n2").

Definition Node__UpdateLeafHash: val :=
  rec: "Node__UpdateLeafHash" "n" :=
    let: "h" := ref (zero_val (slice.T byteT)) in
    cryptoHelpers.HasherWrite "h" (struct.loadF Node "Val" "n");;
    cryptoHelpers.HasherWrite "h" (SliceSingleton LeafNodeId);;
    struct.storeF Node "hash" "n" (cryptoHelpers.HasherSum (![slice.T byteT] "h") slice.nil);;
    #().

(* Assumes recursive child hashes are already up-to-date. *)
Definition Node__UpdateInteriorHash: val :=
  rec: "Node__UpdateInteriorHash" "n" :=
    let: "h" := ref (zero_val (slice.T byteT)) in
    ForSlice ptrT <> "n" (struct.loadF Node "Children" "n")
      (cryptoHelpers.HasherWrite "h" (Node__Hash "n"));;
    cryptoHelpers.HasherWrite "h" (SliceSingleton InteriorNodeId);;
    struct.storeF Node "hash" "n" (cryptoHelpers.HasherSum (![slice.T byteT] "h") slice.nil);;
    #().

(* This node doesn't satisfy the invariant for any logical node.
   It'll be specialized after adding it to the tree. *)
Definition NewGenericNode: val :=
  rec: "NewGenericNode" <> :=
    let: "c" := NewSlice ptrT NumChildren in
    struct.new Node [
      "Val" ::= slice.nil;
      "hash" ::= slice.nil;
      "Children" ::= "c"
    ].

Definition Digest: ty := slice.T byteT.

(* General proof object.
   Binds an id down the tree to a particular node hash. *)
Definition PathProof := struct.decl [
  "Id" :: Id;
  "NodeHash" :: slice.T byteT;
  "Digest" :: Digest;
  "ChildHashes" :: slice.T (slice.T (slice.T byteT))
].

Definition Proof: ty := slice.T (slice.T (slice.T byteT)).

Definition IsValidHashSl: val :=
  rec: "IsValidHashSl" "data" :=
    let: "ok" := ref_to boolT #true in
    ForSlice (slice.T byteT) <> "hash" "data"
      ((if: (slice.len "hash") ≠ cryptoShim.HashLen
      then "ok" <-[boolT] #false
      else #()));;
    ![boolT] "ok".

Definition PathProof__Check: val :=
  rec: "PathProof__Check" "p" :=
    let: "err" := ref_to uint64T ErrNone in
    let: "currHash" := ref_to (slice.T byteT) (struct.loadF PathProof "NodeHash" "p") in
    let: "proofLen" := slice.len (struct.loadF PathProof "ChildHashes" "p") in
    let: "loopIdx" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "loopIdx") < "proofLen"); (λ: <>, "loopIdx" <-[uint64T] ((![uint64T] "loopIdx") + #1)) := λ: <>,
      let: "pathIdx" := ("proofLen" - #1) - (![uint64T] "loopIdx") in
      let: "children" := SliceGet (slice.T (slice.T byteT)) (struct.loadF PathProof "ChildHashes" "p") "pathIdx" in
      (if: (slice.len "children") ≠ (NumChildren - #1)
      then
        "err" <-[uint64T] ErrPathProof;;
        Continue
      else
        (if: (~ (IsValidHashSl "children"))
        then
          "err" <-[uint64T] ErrPathProof;;
          Continue
        else
          let: "pos" := to_u64 (SliceGet byteT (struct.loadF PathProof "Id" "p") "pathIdx") in
          let: "before" := SliceTake "children" "pos" in
          let: "after" := SliceSkip (slice.T byteT) "children" "pos" in
          let: "hr" := ref (zero_val (slice.T byteT)) in
          cryptoHelpers.HasherWriteSl "hr" "before";;
          cryptoHelpers.HasherWrite "hr" (![slice.T byteT] "currHash");;
          cryptoHelpers.HasherWriteSl "hr" "after";;
          cryptoHelpers.HasherWrite "hr" (SliceSingleton InteriorNodeId);;
          "currHash" <-[slice.T byteT] (cryptoHelpers.HasherSum (![slice.T byteT] "hr") slice.nil);;
          Continue)));;
    (if: (![uint64T] "err") ≠ ErrNone
    then ErrPathProof
    else
      (if: (~ (std.BytesEqual (![slice.T byteT] "currHash") (struct.loadF PathProof "Digest" "p")))
      then ErrPathProof
      else ErrNone)).

Definition getLeafNodeHash: val :=
  rec: "getLeafNodeHash" "val" :=
    let: "hr" := ref (zero_val (slice.T byteT)) in
    cryptoHelpers.HasherWrite "hr" "val";;
    cryptoHelpers.HasherWrite "hr" (SliceSingleton LeafNodeId);;
    cryptoHelpers.HasherSum (![slice.T byteT] "hr") slice.nil.

Definition getEmptyNodeHash: val :=
  rec: "getEmptyNodeHash" <> :=
    cryptoShim.Hash (SliceSingleton EmptyNodeId).

Definition CheckProof: val :=
  rec: "CheckProof" "proofTy" "proof" "id" "val" "digest" :=
    (if: (slice.len "proof") > cryptoShim.HashLen
    then ErrBadInput
    else
      (if: (slice.len "id") < (slice.len "proof")
      then ErrBadInput
      else
        let: "idPref" := SliceTake "id" (slice.len "proof") in
        let: "nodeHash" := ref (zero_val (slice.T byteT)) in
        (if: "proofTy" = MembProofTy
        then "nodeHash" <-[slice.T byteT] (getLeafNodeHash "val")
        else "nodeHash" <-[slice.T byteT] (getEmptyNodeHash #()));;
        let: "pathProof" := struct.new PathProof [
          "Id" ::= "idPref";
          "NodeHash" ::= ![slice.T byteT] "nodeHash";
          "Digest" ::= "digest";
          "ChildHashes" ::= "proof"
        ] in
        PathProof__Check "pathProof")).

(* Having a separate Tree type makes the API more clear compared to if it
   was just a Node. *)
Definition Tree := struct.decl [
  "Root" :: ptrT
].

Definition Tree__DeepCopy: val :=
  rec: "Tree__DeepCopy" "t" :=
    struct.new Tree [
      "Root" ::= Node__DeepCopy (struct.loadF Tree "Root" "t")
    ].

Definition Tree__Digest: val :=
  rec: "Tree__Digest" "t" :=
    Node__Hash (struct.loadF Tree "Root" "t").

Definition AppendNode2D: val :=
  rec: "AppendNode2D" "dst" "src" :=
    ForSlice ptrT <> "sl" "src"
      ("dst" <-[slice.T (slice.T byteT)] (SliceAppend (slice.T byteT) (![slice.T (slice.T byteT)] "dst") (CopySlice (Node__Hash "sl"))));;
    #().

Definition GetChildHashes: val :=
  rec: "GetChildHashes" "nodePath" "id" :=
    let: "childHashes" := NewSlice (slice.T (slice.T byteT)) ((slice.len "nodePath") - #1) in
    let: "pathIdx" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "pathIdx") < ((slice.len "nodePath") - #1)); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") + #1)) := λ: <>,
      let: "children" := struct.loadF Node "Children" (SliceGet ptrT "nodePath" (![uint64T] "pathIdx")) in
      let: "pos" := SliceGet byteT "id" (![uint64T] "pathIdx") in
      let: "proofChildren" := ref (zero_val (slice.T (slice.T byteT))) in
      AppendNode2D "proofChildren" (SliceTake "children" "pos");;
      AppendNode2D "proofChildren" (SliceSkip ptrT "children" ("pos" + #(U8 1)));;
      SliceSet (slice.T (slice.T byteT)) "childHashes" (![uint64T] "pathIdx") (![slice.T (slice.T byteT)] "proofChildren");;
      Continue);;
    "childHashes".

(* Get the maximal path corresponding to Id.
   If the full path to a leaf node doesn't exist,
   return the partial path that ends in an empty node. *)
Definition Tree__GetPath: val :=
  rec: "Tree__GetPath" "t" "id" :=
    let: "nodePath" := ref (zero_val (slice.T ptrT)) in
    "nodePath" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "nodePath") (struct.loadF Tree "Root" "t"));;
    (if: (struct.loadF Tree "Root" "t") = #null
    then ![slice.T ptrT] "nodePath"
    else
      let: "stop" := ref_to boolT #false in
      let: "pathIdx" := ref_to uint64T #0 in
      (for: (λ: <>, ((![uint64T] "pathIdx") < cryptoShim.HashLen) && (~ (![boolT] "stop"))); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") + #1)) := λ: <>,
        let: "currNode" := SliceGet ptrT (![slice.T ptrT] "nodePath") (![uint64T] "pathIdx") in
        let: "pos" := SliceGet byteT "id" (![uint64T] "pathIdx") in
        let: "nextNode" := SliceGet ptrT (struct.loadF Node "Children" "currNode") "pos" in
        "nodePath" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "nodePath") "nextNode");;
        (if: "nextNode" = #null
        then
          "stop" <-[boolT] #true;;
          Continue
        else Continue));;
      ![slice.T ptrT] "nodePath").

Definition Tree__GetPathAddNodes: val :=
  rec: "Tree__GetPathAddNodes" "t" "id" :=
    (if: (struct.loadF Tree "Root" "t") = #null
    then struct.storeF Tree "Root" "t" (NewGenericNode #())
    else #());;
    let: "nodePath" := ref (zero_val (slice.T ptrT)) in
    "nodePath" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "nodePath") (struct.loadF Tree "Root" "t"));;
    let: "pathIdx" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "pathIdx") < cryptoShim.HashLen); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") + #1)) := λ: <>,
      let: "currNode" := SliceGet ptrT (![slice.T ptrT] "nodePath") (![uint64T] "pathIdx") in
      let: "pos" := SliceGet byteT "id" (![uint64T] "pathIdx") in
      (if: (SliceGet ptrT (struct.loadF Node "Children" "currNode") "pos") = #null
      then SliceSet ptrT (struct.loadF Node "Children" "currNode") "pos" (NewGenericNode #())
      else #());;
      "nodePath" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "nodePath") (SliceGet ptrT (struct.loadF Node "Children" "currNode") "pos"));;
      Continue);;
    ![slice.T ptrT] "nodePath".

Definition Tree__Put: val :=
  rec: "Tree__Put" "t" "id" "val" :=
    (if: (slice.len "id") ≠ cryptoShim.HashLen
    then (slice.nil, slice.nil, ErrBadInput)
    else
      let: "nodePath" := Tree__GetPathAddNodes "t" "id" in
      struct.storeF Node "Val" (SliceGet ptrT "nodePath" cryptoShim.HashLen) "val";;
      Node__UpdateLeafHash (SliceGet ptrT "nodePath" cryptoShim.HashLen);;
      let: "pathIdx" := ref_to uint64T cryptoShim.HashLen in
      (for: (λ: <>, (![uint64T] "pathIdx") ≥ #1); (λ: <>, "pathIdx" <-[uint64T] ((![uint64T] "pathIdx") - #1)) := λ: <>,
        Node__UpdateInteriorHash (SliceGet ptrT "nodePath" ((![uint64T] "pathIdx") - #1));;
        Continue);;
      let: "digest" := CopySlice (Node__Hash (SliceGet ptrT "nodePath" #0)) in
      let: "proof" := GetChildHashes "nodePath" "id" in
      ("digest", "proof", ErrNone)).

(* Goose doesn't support returning more than 4 vars. *)
Definition GetReply := struct.decl [
  "Val" :: Val;
  "Digest" :: Digest;
  "ProofTy" :: ProofTy;
  "Proof" :: Proof;
  "Error" :: Error
].

(* Return ProofTy vs. having sep funcs bc regardless, would want a proof. *)
Definition Tree__Get: val :=
  rec: "Tree__Get" "t" "id" :=
    let: "errReply" := struct.new GetReply [
    ] in
    (if: (slice.len "id") ≠ cryptoShim.HashLen
    then
      struct.storeF GetReply "Error" "errReply" ErrBadInput;;
      "errReply"
    else
      let: "nodePath" := Tree__GetPath "t" "id" in
      let: "lastNode" := SliceGet ptrT "nodePath" ((slice.len "nodePath") - #1) in
      let: "digest" := CopySlice (Node__Hash (SliceGet ptrT "nodePath" #0)) in
      let: "proof" := GetChildHashes "nodePath" "id" in
      (if: "lastNode" = #null
      then
        struct.new GetReply [
          "Val" ::= slice.nil;
          "Digest" ::= "digest";
          "ProofTy" ::= NonmembProofTy;
          "Proof" ::= "proof";
          "Error" ::= ErrNone
        ]
      else
        let: "val" := CopySlice (struct.loadF Node "Val" "lastNode") in
        struct.new GetReply [
          "Val" ::= "val";
          "Digest" ::= "digest";
          "ProofTy" ::= MembProofTy;
          "Proof" ::= "proof";
          "Error" ::= ErrNone
        ])).

End code.
