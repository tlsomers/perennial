(* autogenerated from github.com/mit-pdos/pav/ktmerkle *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.gokv.urpc.
From Goose Require github_com.mit_pdos.pav.cryptoffi.
From Goose Require github_com.mit_pdos.pav.marshalutil.
From Goose Require github_com.mit_pdos.pav.merkle.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* evidence.go *)

(* epochTy from ktmerkle.go *)

Definition epochTy: ty := uint64T.

Definition linkTy: ty := slice.T byteT.

(* evidServLink is evidence that the server signed two conflicting links,
   either zero or one epochs away. *)
Definition evidServLink := struct.decl [
  "epoch0" :: uint64T;
  "prevLink0" :: slice.T byteT;
  "dig0" :: slice.T byteT;
  "sig0" :: slice.T byteT;
  "epoch1" :: uint64T;
  "prevLink1" :: slice.T byteT;
  "dig1" :: slice.T byteT;
  "sig1" :: slice.T byteT
].

Definition errorTy: ty := boolT.

(* chainSepSome from rpc.go *)

(* rpc: no decode needed. *)
Definition chainSepSome := struct.decl [
  "tag" :: byteT;
  "epoch" :: epochTy;
  "prevLink" :: linkTy;
  "data" :: slice.T byteT
].

(* chainSepSome__encode from rpc.out.go *)

Definition chainSepSome__encode: val :=
  rec: "chainSepSome__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshalutil.WriteByte (![slice.T byteT] "b") #(U8 1));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF chainSepSome "epoch" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF chainSepSome "prevLink" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF chainSepSome "data" "o"));;
    ![slice.T byteT] "b".

(* servSepLink from rpc.go *)

(* rpc: no decode needed. *)
Definition servSepLink := struct.decl [
  "tag" :: byteT;
  "link" :: linkTy
].

(* servSepLink__encode from rpc.out.go *)

Definition servSepLink__encode: val :=
  rec: "servSepLink__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshalutil.WriteByte (![slice.T byteT] "b") #(U8 0));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servSepLink "link" "o"));;
    ![slice.T byteT] "b".

(* check returns an error if the evidence does not check out.
   otherwise, it proves that the server was dishonest. *)
Definition evidServLink__check: val :=
  rec: "evidServLink__check" "e" "servPk" :=
    let: "linkSep0" := chainSepSome__encode (struct.new chainSepSome [
      "epoch" ::= struct.loadF evidServLink "epoch0" "e";
      "prevLink" ::= struct.loadF evidServLink "prevLink0" "e";
      "data" ::= struct.loadF evidServLink "dig0" "e"
    ]) in
    let: "link0" := cryptoffi.Hash "linkSep0" in
    let: "enc0" := servSepLink__encode (struct.new servSepLink [
      "link" ::= "link0"
    ]) in
    let: "ok0" := cryptoffi.PublicKey__Verify "servPk" "enc0" (struct.loadF evidServLink "sig0" "e") in
    (if: (~ "ok0")
    then "errSome"
    else
      let: "linkSep1" := chainSepSome__encode (struct.new chainSepSome [
        "epoch" ::= struct.loadF evidServLink "epoch1" "e";
        "prevLink" ::= struct.loadF evidServLink "prevLink1" "e";
        "data" ::= struct.loadF evidServLink "dig1" "e"
      ]) in
      let: "link1" := cryptoffi.Hash "linkSep1" in
      let: "enc1" := servSepLink__encode (struct.new servSepLink [
        "link" ::= "link1"
      ]) in
      let: "ok1" := cryptoffi.PublicKey__Verify "servPk" "enc1" (struct.loadF evidServLink "sig1" "e") in
      (if: (~ "ok1")
      then "errSome"
      else
        (if: (struct.loadF evidServLink "epoch0" "e") = (struct.loadF evidServLink "epoch1" "e")
        then std.BytesEqual "link0" "link1"
        else
          (if: ((struct.loadF evidServLink "epoch0" "e") + #1) = (struct.loadF evidServLink "epoch1" "e")
          then std.BytesEqual "link0" (struct.loadF evidServLink "prevLink1" "e")
          else "errSome")))).

(* evidServPut is evidence when a server promises to put a value at a certain
   epoch but actually there's a different value (as evidenced by a merkle proof). *)
Definition evidServPut := struct.decl [
  "epoch" :: uint64T;
  "prevLink" :: slice.T byteT;
  "dig" :: slice.T byteT;
  "linkSig" :: slice.T byteT;
  "id" :: slice.T byteT;
  "val0" :: slice.T byteT;
  "putSig" :: slice.T byteT;
  "val1" :: slice.T byteT;
  "proof" :: slice.T (slice.T (slice.T byteT))
].

(* servSepPut from rpc.go *)

(* rpc: no decode needed. *)
Definition servSepPut := struct.decl [
  "tag" :: byteT;
  "epoch" :: epochTy;
  "id" :: slice.T byteT;
  "val" :: slice.T byteT
].

(* servSepPut__encode from rpc.out.go *)

Definition servSepPut__encode: val :=
  rec: "servSepPut__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshalutil.WriteByte (![slice.T byteT] "b") #(U8 1));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF servSepPut "epoch" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servSepPut "id" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF servSepPut "val" "o"));;
    ![slice.T byteT] "b".

Definition evidServPut__check: val :=
  rec: "evidServPut__check" "e" "servPk" :=
    let: "preLink" := chainSepSome__encode (struct.new chainSepSome [
      "epoch" ::= struct.loadF evidServPut "epoch" "e";
      "prevLink" ::= struct.loadF evidServPut "prevLink" "e";
      "data" ::= struct.loadF evidServPut "dig" "e"
    ]) in
    let: "link" := cryptoffi.Hash "preLink" in
    let: "preLinkSig" := servSepLink__encode (struct.new servSepLink [
      "link" ::= "link"
    ]) in
    let: "linkOk" := cryptoffi.PublicKey__Verify "servPk" "preLinkSig" (struct.loadF evidServPut "linkSig" "e") in
    (if: (~ "linkOk")
    then "errSome"
    else
      let: "prePut" := servSepPut__encode (struct.new servSepPut [
        "epoch" ::= struct.loadF evidServPut "epoch" "e";
        "id" ::= struct.loadF evidServPut "id" "e";
        "val" ::= struct.loadF evidServPut "val0" "e"
      ]) in
      let: "putOk" := cryptoffi.PublicKey__Verify "servPk" "prePut" (struct.loadF evidServPut "putSig" "e") in
      (if: (~ "putOk")
      then "errSome"
      else
        let: "err0" := merkle.CheckProof merkle.MembProofTy (struct.loadF evidServPut "proof" "e") (struct.loadF evidServPut "id" "e") (struct.loadF evidServPut "val1" "e") (struct.loadF evidServPut "dig" "e") in
        (if: "err0"
        then "errSome"
        else
          (if: std.BytesEqual (struct.loadF evidServPut "val0" "e") (struct.loadF evidServPut "val1" "e")
          then "errSome"
          else "errNone")))).

(* ktmerkle.go *)

Definition errNone : expr := #false.

Definition errSome : expr := #true.

Definition maxUint64 : expr := (#1 â‰ª #64) - #1.

Definition hashChain: ty := slice.T linkTy.

(* chainSepNone__encode from rpc.out.go *)

Definition chainSepNone__encode: val :=
  rec: "chainSepNone__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshalutil.WriteByte (![slice.T byteT] "b") #(U8 0));;
    ![slice.T byteT] "b".

(* chainSepNone from rpc.go *)

(* rpc: no decode needed. *)
Definition chainSepNone := struct.decl [
  "tag" :: byteT
].

Definition newHashChain: val :=
  rec: "newHashChain" <> :=
    let: "enc" := chainSepNone__encode (struct.new chainSepNone [
    ]) in
    let: "h" := cryptoffi.Hash "enc" in
    let: "c" := ref (zero_val hashChain) in
    "c" <-[hashChain] (SliceAppend (slice.T byteT) (![hashChain] "c") "h");;
    ![hashChain] "c".

Definition hashChain__put: val :=
  rec: "hashChain__put" "c" "data" :=
    let: "chain" := ![hashChain] "c" in
    let: "chainLen" := slice.len "chain" in
    let: "prevLink" := SliceGet (slice.T byteT) "chain" ("chainLen" - #1) in
    let: "linkSep" := chainSepSome__encode (struct.new chainSepSome [
      "epoch" ::= "chainLen" - #1;
      "prevLink" ::= "prevLink";
      "data" ::= "data"
    ]) in
    let: "link" := cryptoffi.Hash "linkSep" in
    "c" <-[hashChain] (SliceAppend (slice.T byteT) "chain" "link");;
    #().

Definition hashChain__getCommit: val :=
  rec: "hashChain__getCommit" "c" "length" :=
    SliceGet (slice.T byteT) "c" "length".

Definition timeEntry := struct.decl [
  "time" :: epochTy;
  "val" :: slice.T byteT;
  "sig" :: slice.T byteT
].

Definition timeSeries: ty := slice.T (struct.t timeEntry).

(* put returns error if given old entry. *)
Definition timeSeries__put: val :=
  rec: "timeSeries__put" "ts" "epoch" "val" "sig" :=
    let: "entries" := ![timeSeries] "ts" in
    let: "length" := slice.len "entries" in
    (if: "length" = #0
    then
      "ts" <-[timeSeries] (SliceAppend (struct.t timeEntry) "entries" (struct.mk timeEntry [
        "time" ::= "epoch";
        "val" ::= "val";
        "sig" ::= "sig"
      ]));;
      errNone
    else
      let: "last" := struct.get timeEntry "time" (SliceGet (struct.t timeEntry) "entries" ("length" - #1)) in
      (if: "epoch" < "last"
      then errSome
      else
        "ts" <-[timeSeries] (SliceAppend (struct.t timeEntry) "entries" (struct.mk timeEntry [
          "time" ::= "epoch";
          "val" ::= "val";
          "sig" ::= "sig"
        ]));;
        errNone)).

(* get returns val, isInit, putPromise sig, isBoundary.
   val is the latest update val for time t.
   if no update happened before t, isInit = false and val = nil.
   if the epoch was an update boundary, isBoundary = true and putPromise is set. *)
Definition timeSeries__get: val :=
  rec: "timeSeries__get" "ts" "epoch" :=
    let: "latest" := ref (zero_val (slice.T byteT)) in
    let: "init" := ref (zero_val boolT) in
    let: "sig" := ref (zero_val (slice.T byteT)) in
    let: "boundary" := ref (zero_val boolT) in
    ForSlice (struct.t timeEntry) <> "te" (![timeSeries] "ts")
      ((if: (struct.get timeEntry "time" "te") â‰¤ "epoch"
      then
        "latest" <-[slice.T byteT] (struct.get timeEntry "val" "te");;
        "init" <-[boolT] #true;;
        "sig" <-[slice.T byteT] (struct.get timeEntry "sig" "te");;
        "boundary" <-[boolT] ((struct.get timeEntry "time" "te") = "epoch")
      else #()));;
    (![slice.T byteT] "latest", ![boolT] "init", ![slice.T byteT] "sig", ![boolT] "boundary").

Definition server := struct.decl [
  "sk" :: cryptoffi.PrivateKey;
  "mu" :: ptrT;
  "trees" :: slice.T ptrT;
  "nextTr" :: ptrT;
  "chain" :: hashChain;
  "linkSigs" :: slice.T (slice.T byteT);
  "changed" :: mapT boolT
].

Definition newServer: val :=
  rec: "newServer" <> :=
    let: ("pk", "sk") := cryptoffi.GenerateKey #() in
    let: "mu" := lock.new #() in
    let: "nextTr" := struct.new merkle.Tree [
    ] in
    let: "changed" := NewMap stringT boolT #() in
    let: "emptyTr" := struct.new merkle.Tree [
    ] in
    let: "trees" := SliceSingleton "emptyTr" in
    let: "chain" := newHashChain #() in
    hashChain__put "chain" (merkle.Tree__Digest "emptyTr");;
    let: "link" := hashChain__getCommit "chain" #1 in
    let: "enc" := servSepLink__encode (struct.new servSepLink [
      "link" ::= "link"
    ]) in
    let: "sig" := cryptoffi.PrivateKey__Sign "sk" "enc" in
    let: "sigs" := ref (zero_val (slice.T (slice.T byteT))) in
    "sigs" <-[slice.T (slice.T byteT)] (SliceAppend (slice.T byteT) (![slice.T (slice.T byteT)] "sigs") "sig");;
    (struct.new server [
       "sk" ::= "sk";
       "mu" ::= "mu";
       "trees" ::= "trees";
       "nextTr" ::= "nextTr";
       "chain" ::= "chain";
       "linkSigs" ::= ![slice.T (slice.T byteT)] "sigs";
       "changed" ::= "changed"
     ], "pk").

Definition server__updateEpoch: val :=
  rec: "server__updateEpoch" "s" :=
    lock.acquire (struct.loadF server "mu" "s");;
    let: "commitTr" := struct.loadF server "nextTr" "s" in
    struct.storeF server "nextTr" "s" (merkle.Tree__DeepCopy "commitTr");;
    struct.storeF server "trees" "s" (SliceAppend ptrT (struct.loadF server "trees" "s") "commitTr");;
    let: "numTrees" := slice.len (struct.loadF server "trees" "s") in
    struct.storeF server "changed" "s" (NewMap stringT boolT #());;
    let: "dig" := merkle.Tree__Digest "commitTr" in
    hashChain__put (struct.loadF server "chain" "s") "dig";;
    let: "link" := hashChain__getCommit (struct.loadF server "chain" "s") "numTrees" in
    let: "enc" := servSepLink__encode (struct.new servSepLink [
      "link" ::= "link"
    ]) in
    let: "sig" := cryptoffi.PrivateKey__Sign (struct.loadF server "sk" "s") "enc" in
    struct.storeF server "linkSigs" "s" (SliceAppend (slice.T byteT) (struct.loadF server "linkSigs" "s") "sig");;
    lock.release (struct.loadF server "mu" "s");;
    #().

Definition servPutReply := struct.decl [
  "putEpoch" :: epochTy;
  "prev2Link" :: linkTy;
  "prevDig" :: slice.T byteT;
  "linkSig" :: slice.T byteT;
  "putSig" :: slice.T byteT;
  "error" :: errorTy
].

(* put schedules a put to be committed at the next epoch update. *)
Definition server__put: val :=
  rec: "server__put" "s" "id" "val" :=
    lock.acquire (struct.loadF server "mu" "s");;
    let: "errReply" := struct.new servPutReply [
    ] in
    struct.storeF servPutReply "error" "errReply" errSome;;
    let: "idS" := StringFromBytes "id" in
    let: ("changed", "ok") := MapGet (struct.loadF server "changed" "s") "idS" in
    (if: "ok" && "changed"
    then
      lock.release (struct.loadF server "mu" "s");;
      "errReply"
    else
      MapInsert (struct.loadF server "changed" "s") "idS" #true;;
      let: ((<>, <>), "err") := merkle.Tree__Put (struct.loadF server "nextTr" "s") "id" "val" in
      (if: "err"
      then
        lock.release (struct.loadF server "mu" "s");;
        "errReply"
      else
        let: "currEpoch" := (slice.len (struct.loadF server "trees" "s")) - #1 in
        let: "prev2Link" := hashChain__getCommit (struct.loadF server "chain" "s") "currEpoch" in
        let: "prevDig" := merkle.Tree__Digest (SliceGet ptrT (struct.loadF server "trees" "s") "currEpoch") in
        let: "linkSig" := SliceGet (slice.T byteT) (struct.loadF server "linkSigs" "s") "currEpoch" in
        let: "putPre" := servSepPut__encode (struct.new servSepPut [
          "epoch" ::= "currEpoch" + #1;
          "id" ::= "id";
          "val" ::= "val"
        ]) in
        let: "putSig" := cryptoffi.PrivateKey__Sign (struct.loadF server "sk" "s") "putPre" in
        lock.release (struct.loadF server "mu" "s");;
        struct.new servPutReply [
          "putEpoch" ::= "currEpoch" + #1;
          "prev2Link" ::= "prev2Link";
          "prevDig" ::= "prevDig";
          "linkSig" ::= "linkSig";
          "putSig" ::= "putSig";
          "error" ::= errNone
        ])).

Definition servGetIdAtReply := struct.decl [
  "prevLink" :: linkTy;
  "dig" :: slice.T byteT;
  "sig" :: slice.T byteT;
  "val" :: slice.T byteT;
  "proofTy" :: boolT;
  "proof" :: slice.T (slice.T (slice.T byteT));
  "error" :: errorTy
].

Definition server__getIdAt: val :=
  rec: "server__getIdAt" "s" "id" "epoch" :=
    lock.acquire (struct.loadF server "mu" "s");;
    let: "errReply" := struct.new servGetIdAtReply [
    ] in
    struct.storeF servGetIdAtReply "error" "errReply" errSome;;
    (if: "epoch" â‰¥ (slice.len (struct.loadF server "trees" "s"))
    then
      lock.release (struct.loadF server "mu" "s");;
      "errReply"
    else
      let: "prevLink" := hashChain__getCommit (struct.loadF server "chain" "s") "epoch" in
      let: "sig" := SliceGet (slice.T byteT) (struct.loadF server "linkSigs" "s") "epoch" in
      let: "reply" := merkle.Tree__Get (SliceGet ptrT (struct.loadF server "trees" "s") "epoch") "id" in
      lock.release (struct.loadF server "mu" "s");;
      struct.new servGetIdAtReply [
        "prevLink" ::= "prevLink";
        "dig" ::= struct.loadF merkle.GetReply "Digest" "reply";
        "sig" ::= "sig";
        "val" ::= struct.loadF merkle.GetReply "Val" "reply";
        "proofTy" ::= struct.loadF merkle.GetReply "ProofTy" "reply";
        "proof" ::= struct.loadF merkle.GetReply "Proof" "reply";
        "error" ::= struct.loadF merkle.GetReply "Error" "reply"
      ]).

Definition servGetLinkReply := struct.decl [
  "prevLink" :: linkTy;
  "dig" :: slice.T byteT;
  "sig" :: slice.T byteT;
  "error" :: errorTy
].

Definition server__getLink: val :=
  rec: "server__getLink" "s" "epoch" :=
    lock.acquire (struct.loadF server "mu" "s");;
    (if: "epoch" â‰¥ (slice.len (struct.loadF server "trees" "s"))
    then
      let: "errReply" := struct.new servGetLinkReply [
      ] in
      struct.storeF servGetLinkReply "error" "errReply" errSome;;
      lock.release (struct.loadF server "mu" "s");;
      "errReply"
    else
      let: "prevLink" := hashChain__getCommit (struct.loadF server "chain" "s") "epoch" in
      let: "dig" := merkle.Tree__Digest (SliceGet ptrT (struct.loadF server "trees" "s") "epoch") in
      let: "sig" := SliceGet (slice.T byteT) (struct.loadF server "linkSigs" "s") "epoch" in
      lock.release (struct.loadF server "mu" "s");;
      struct.new servGetLinkReply [
        "prevLink" ::= "prevLink";
        "dig" ::= "dig";
        "sig" ::= "sig";
        "error" ::= errNone
      ]).

(* auditor is an append-only log of server signed links.
   e.g., the S3 auditor in WhatsApp's deployment. *)
Definition auditor := struct.decl [
  "mu" :: ptrT;
  "sk" :: cryptoffi.PrivateKey;
  "servPk" :: cryptoffi.PublicKey;
  "log" :: slice.T ptrT
].

Definition adtrLinkSigs := struct.decl [
  "prevLink" :: linkTy;
  "dig" :: slice.T byteT;
  "link" :: linkTy;
  "servSig" :: slice.T byteT;
  "adtrSig" :: slice.T byteT
].

Definition newAuditor: val :=
  rec: "newAuditor" "servPk" :=
    let: ("pk", "sk") := cryptoffi.GenerateKey #() in
    (struct.new auditor [
       "mu" ::= lock.new #();
       "sk" ::= "sk";
       "servPk" ::= "servPk";
       "log" ::= slice.nil
     ], "pk").

(* rpc: no decode needed. *)
Definition adtrSepLink := struct.decl [
  "tag" :: byteT;
  "link" :: linkTy
].

(* adtrSepLink__encode from rpc.out.go *)

Definition adtrSepLink__encode: val :=
  rec: "adtrSepLink__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshalutil.WriteByte (![slice.T byteT] "b") #(U8 0));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF adtrSepLink "link" "o"));;
    ![slice.T byteT] "b".

(* put adds a link to the log. it's unspecified how this gets called.
   but we need to verify the sig / epoch to prove correctness under
   an honest server and auditor. *)
Definition auditor__put: val :=
  rec: "auditor__put" "a" "prevLink" "dig" "servSig" :=
    lock.acquire (struct.loadF auditor "mu" "a");;
    let: "epoch" := slice.len (struct.loadF auditor "log" "a") in
    let: "cachedPrevLink" := ref (zero_val (slice.T byteT)) in
    (if: "epoch" = #0
    then
      let: "linkSep" := chainSepNone__encode (struct.new chainSepNone [
      ]) in
      "cachedPrevLink" <-[slice.T byteT] (cryptoffi.Hash "linkSep")
    else "cachedPrevLink" <-[slice.T byteT] (struct.loadF adtrLinkSigs "link" (SliceGet ptrT (struct.loadF auditor "log" "a") ("epoch" - #1))));;
    (if: (~ (std.BytesEqual "prevLink" (![slice.T byteT] "cachedPrevLink")))
    then
      lock.release (struct.loadF auditor "mu" "a");;
      errSome
    else
      let: "linkSep" := chainSepSome__encode (struct.new chainSepSome [
        "epoch" ::= "epoch";
        "prevLink" ::= "prevLink";
        "data" ::= "dig"
      ]) in
      let: "link" := cryptoffi.Hash "linkSep" in
      let: "servSep" := servSepLink__encode (struct.new servSepLink [
        "link" ::= "link"
      ]) in
      let: "servOk" := cryptoffi.PublicKey__Verify (struct.loadF auditor "servPk" "a") "servSep" "servSig" in
      (if: (~ "servOk")
      then
        lock.release (struct.loadF auditor "mu" "a");;
        errSome
      else
        let: "adtrSep" := adtrSepLink__encode (struct.new adtrSepLink [
          "link" ::= "link"
        ]) in
        let: "adtrSig" := cryptoffi.PrivateKey__Sign (struct.loadF auditor "sk" "a") "adtrSep" in
        let: "entry" := struct.new adtrLinkSigs [
          "prevLink" ::= "prevLink";
          "dig" ::= "dig";
          "link" ::= "link";
          "servSig" ::= "servSig";
          "adtrSig" ::= "adtrSig"
        ] in
        struct.storeF auditor "log" "a" (SliceAppend ptrT (struct.loadF auditor "log" "a") "entry");;
        lock.release (struct.loadF auditor "mu" "a");;
        errNone)).

(* adtrGetReply from rpc.go *)

Definition adtrGetReply := struct.decl [
  "prevLink" :: linkTy;
  "dig" :: slice.T byteT;
  "servSig" :: slice.T byteT;
  "adtrSig" :: slice.T byteT;
  "error" :: errorTy
].

(* get returns the signed link at a particular epoch. *)
Definition auditor__get: val :=
  rec: "auditor__get" "a" "epoch" :=
    lock.acquire (struct.loadF auditor "mu" "a");;
    (if: "epoch" â‰¥ (slice.len (struct.loadF auditor "log" "a"))
    then
      let: "errReply" := struct.new adtrGetReply [
      ] in
      struct.storeF adtrGetReply "error" "errReply" errSome;;
      lock.release (struct.loadF auditor "mu" "a");;
      "errReply"
    else
      let: "entry" := SliceGet ptrT (struct.loadF auditor "log" "a") "epoch" in
      lock.release (struct.loadF auditor "mu" "a");;
      struct.new adtrGetReply [
        "prevLink" ::= struct.loadF adtrLinkSigs "prevLink" "entry";
        "dig" ::= struct.loadF adtrLinkSigs "dig" "entry";
        "servSig" ::= struct.loadF adtrLinkSigs "servSig" "entry";
        "adtrSig" ::= struct.loadF adtrLinkSigs "adtrSig" "entry";
        "error" ::= errNone
      ]).

Definition client := struct.decl [
  "id" :: slice.T byteT;
  "myVals" :: timeSeries;
  "links" :: mapT ptrT;
  "serv" :: ptrT;
  "servPk" :: cryptoffi.PublicKey
].

Definition cliSigLink := struct.decl [
  "prevLink" :: linkTy;
  "dig" :: slice.T byteT;
  "sig" :: slice.T byteT;
  "link" :: linkTy
].

Definition newClient: val :=
  rec: "newClient" "id" "servAddr" "servPk" :=
    let: "serv" := urpc.MakeClient "servAddr" in
    let: "digs" := NewMap epochTy ptrT #() in
    struct.new client [
      "id" ::= "id";
      "myVals" ::= slice.nil;
      "links" ::= "digs";
      "serv" ::= "serv";
      "servPk" ::= "servPk"
    ].

Definition client__addLink: val :=
  rec: "client__addLink" "c" "epoch" "prevLink" "dig" "sig" :=
    let: "linkSep" := chainSepSome__encode (struct.new chainSepSome [
      "epoch" ::= "epoch";
      "prevLink" ::= "prevLink";
      "data" ::= "dig"
    ]) in
    let: "link" := cryptoffi.Hash "linkSep" in
    let: "preSig" := servSepLink__encode (struct.new servSepLink [
      "link" ::= "link"
    ]) in
    let: "ok0" := cryptoffi.PublicKey__Verify (struct.loadF client "servPk" "c") "preSig" "sig" in
    (if: (~ "ok0")
    then (slice.nil, errSome)
    else
      let: ("cachedLink", "ok1") := MapGet (struct.loadF client "links" "c") "epoch" in
      (if: "ok1" && (~ (std.BytesEqual (struct.loadF cliSigLink "link" "cachedLink") "link"))
      then
        let: "evid" := struct.new evidServLink [
          "epoch0" ::= "epoch";
          "prevLink0" ::= struct.loadF cliSigLink "prevLink" "cachedLink";
          "dig0" ::= struct.loadF cliSigLink "dig" "cachedLink";
          "sig0" ::= struct.loadF cliSigLink "sig" "cachedLink";
          "epoch1" ::= "epoch";
          "prevLink1" ::= "prevLink";
          "dig1" ::= "dig";
          "sig1" ::= "sig"
        ] in
        ("evid", errSome)
      else
        let: ("cachedPrevLink", "ok2") := MapGet (struct.loadF client "links" "c") ("epoch" - #1) in
        (if: (("epoch" > #0) && "ok2") && (~ (std.BytesEqual (struct.loadF cliSigLink "link" "cachedPrevLink") "prevLink"))
        then
          let: "evid" := struct.new evidServLink [
            "epoch0" ::= "epoch" - #1;
            "prevLink0" ::= struct.loadF cliSigLink "prevLink" "cachedPrevLink";
            "dig0" ::= struct.loadF cliSigLink "dig" "cachedPrevLink";
            "sig0" ::= struct.loadF cliSigLink "sig" "cachedPrevLink";
            "epoch1" ::= "epoch";
            "prevLink1" ::= "prevLink";
            "dig1" ::= "dig";
            "sig1" ::= "sig"
          ] in
          ("evid", errSome)
        else
          let: ("cachedNextLink", "ok3") := MapGet (struct.loadF client "links" "c") ("epoch" + #1) in
          (if: (("epoch" < maxUint64) && "ok3") && (~ (std.BytesEqual "link" (struct.loadF cliSigLink "prevLink" "cachedNextLink")))
          then
            let: "evid" := struct.new evidServLink [
              "epoch0" ::= "epoch";
              "prevLink0" ::= "link";
              "dig0" ::= "dig";
              "sig0" ::= "sig";
              "epoch1" ::= "epoch" + #1;
              "prevLink1" ::= struct.loadF cliSigLink "prevLink" "cachedNextLink";
              "dig1" ::= struct.loadF cliSigLink "dig" "cachedNextLink";
              "sig1" ::= struct.loadF cliSigLink "sig" "cachedNextLink"
            ] in
            ("evid", errSome)
          else
            (if: (~ "ok1")
            then
              MapInsert (struct.loadF client "links" "c") "epoch" (struct.new cliSigLink [
                "prevLink" ::= "prevLink";
                "dig" ::= "dig";
                "sig" ::= "sig";
                "link" ::= "link"
              ])
            else #());;
            (slice.nil, errNone))))).

Definition servPutArg := struct.decl [
  "id" :: slice.T byteT;
  "val" :: slice.T byteT
].

(* servPutArg__encode from rpc.out.go *)

Definition servPutArg__encode: val :=
  rec: "servPutArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servPutArg "id" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF servPutArg "val" "o"));;
    ![slice.T byteT] "b".

(* rpcServPut from rpc_misc.go *)

Definition rpcServUpdateEpoch : expr := #1.

Definition rpcServPut : expr := #2.

Definition rpcServGetIdAt : expr := #3.

Definition rpcServGetDig : expr := #5.

Definition rpcServGetLink : expr := #6.

Definition rpcAdtrPut : expr := #7.

Definition rpcAdtrGet : expr := #8.

(* servPutReply__decode from rpc.out.go *)

Definition servPutReply__decode: val :=
  rec: "servPutReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("putEpoch", "b"), "err") := marshalutil.ReadInt (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("prev2Link", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("prevDig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
        (if: "err"
        then (slice.nil, "err")
        else
          let: (("linkSig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #64 in
          (if: "err"
          then (slice.nil, "err")
          else
            let: (("putSig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #64 in
            (if: "err"
            then (slice.nil, "err")
            else
              let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
              (if: "err"
              then (slice.nil, "err")
              else
                struct.storeF servPutReply "putEpoch" "o" "putEpoch";;
                struct.storeF servPutReply "prev2Link" "o" "prev2Link";;
                struct.storeF servPutReply "prevDig" "o" "prevDig";;
                struct.storeF servPutReply "linkSig" "o" "linkSig";;
                struct.storeF servPutReply "putSig" "o" "putSig";;
                struct.storeF servPutReply "error" "o" "error";;
                (![slice.T byteT] "b", errNone))))))).

(* callServPut from rpc_misc.go *)

Definition callServPut: val :=
  rec: "callServPut" "cli" "id" "val" :=
    let: "argB" := servPutArg__encode (struct.new servPutArg [
      "id" ::= "id";
      "val" ::= "val"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcServPut "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new servPutReply [
    ] in
    let: (<>, "err1") := servPutReply__decode "reply" "replyB" in
    (if: "err1"
    then
      let: "errReply" := struct.new servPutReply [
      ] in
      struct.storeF servPutReply "error" "errReply" "err1";;
      "errReply"
    else "reply").

Definition client__put: val :=
  rec: "client__put" "c" "val" :=
    let: "reply" := callServPut (struct.loadF client "serv" "c") (struct.loadF client "id" "c") "val" in
    (if: struct.loadF servPutReply "error" "reply"
    then (#0, slice.nil, struct.loadF servPutReply "error" "reply")
    else
      let: ("evid", "err0") := client__addLink "c" ((struct.loadF servPutReply "putEpoch" "reply") - #1) (struct.loadF servPutReply "prev2Link" "reply") (struct.loadF servPutReply "prevDig" "reply") (struct.loadF servPutReply "linkSig" "reply") in
      (if: "err0"
      then (#0, "evid", "err0")
      else
        let: "prePut" := servSepPut__encode (struct.new servSepPut [
          "epoch" ::= struct.loadF servPutReply "putEpoch" "reply";
          "id" ::= struct.loadF client "id" "c";
          "val" ::= "val"
        ]) in
        let: "ok" := cryptoffi.PublicKey__Verify (struct.loadF client "servPk" "c") "prePut" (struct.loadF servPutReply "putSig" "reply") in
        (if: (~ "ok")
        then (#0, slice.nil, errSome)
        else
          timeSeries__put (struct.loadF client "myVals" "c") (struct.loadF servPutReply "putEpoch" "reply") "val" (struct.loadF servPutReply "putSig" "reply");;
          (struct.loadF servPutReply "putEpoch" "reply", slice.nil, errNone)))).

(* servGetIdAtArg from rpc.go *)

Definition servGetIdAtArg := struct.decl [
  "id" :: slice.T byteT;
  "epoch" :: epochTy
].

(* servGetIdAtArg__encode from rpc.out.go *)

Definition servGetIdAtArg__encode: val :=
  rec: "servGetIdAtArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servGetIdAtArg "id" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF servGetIdAtArg "epoch" "o"));;
    ![slice.T byteT] "b".

Definition servGetIdAtReply__decode: val :=
  rec: "servGetIdAtReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("prevLink", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("dig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("sig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #64 in
        (if: "err"
        then (slice.nil, "err")
        else
          let: (("val", "b"), "err") := marshalutil.ReadSlice1D (![slice.T byteT] "b") in
          (if: "err"
          then (slice.nil, "err")
          else
            let: (("proofTy", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
            (if: "err"
            then (slice.nil, "err")
            else
              let: (("proof", "b"), "err") := marshalutil.ReadSlice3D (![slice.T byteT] "b") in
              (if: "err"
              then (slice.nil, "err")
              else
                let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
                (if: "err"
                then (slice.nil, "err")
                else
                  struct.storeF servGetIdAtReply "prevLink" "o" "prevLink";;
                  struct.storeF servGetIdAtReply "dig" "o" "dig";;
                  struct.storeF servGetIdAtReply "sig" "o" "sig";;
                  struct.storeF servGetIdAtReply "val" "o" "val";;
                  struct.storeF servGetIdAtReply "proofTy" "o" "proofTy";;
                  struct.storeF servGetIdAtReply "proof" "o" "proof";;
                  struct.storeF servGetIdAtReply "error" "o" "error";;
                  (![slice.T byteT] "b", errNone)))))))).

(* callServGetIdAt from rpc_misc.go *)

Definition callServGetIdAt: val :=
  rec: "callServGetIdAt" "cli" "id" "epoch" :=
    let: "argB" := servGetIdAtArg__encode (struct.new servGetIdAtArg [
      "id" ::= "id";
      "epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcServGetIdAt "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new servGetIdAtReply [
    ] in
    let: (<>, "err1") := servGetIdAtReply__decode "reply" "replyB" in
    (if: "err1"
    then
      let: "errReply" := struct.new servGetIdAtReply [
      ] in
      struct.storeF servGetIdAtReply "error" "errReply" "err1";;
      "errReply"
    else "reply").

(* getAt fetches an id at a particular epoch. *)
Definition client__getAt: val :=
  rec: "client__getAt" "c" "id" "epoch" :=
    let: "reply" := callServGetIdAt (struct.loadF client "serv" "c") "id" "epoch" in
    (if: struct.loadF servGetIdAtReply "error" "reply"
    then (slice.nil, slice.nil, struct.loadF servGetIdAtReply "error" "reply")
    else
      let: "err0" := merkle.CheckProof (struct.loadF servGetIdAtReply "proofTy" "reply") (struct.loadF servGetIdAtReply "proof" "reply") "id" (struct.loadF servGetIdAtReply "val" "reply") (struct.loadF servGetIdAtReply "dig" "reply") in
      (if: "err0"
      then (slice.nil, slice.nil, "err0")
      else
        let: ("evid", "err1") := client__addLink "c" "epoch" (struct.loadF servGetIdAtReply "prevLink" "reply") (struct.loadF servGetIdAtReply "dig" "reply") (struct.loadF servGetIdAtReply "sig" "reply") in
        (if: "err1"
        then (slice.nil, "evid", "err1")
        else (struct.loadF servGetIdAtReply "val" "reply", slice.nil, errNone)))).

(* servGetLinkArg from rpc.go *)

Definition servGetLinkArg := struct.decl [
  "epoch" :: epochTy
].

(* servGetLinkArg__encode from rpc.out.go *)

Definition servGetLinkArg__encode: val :=
  rec: "servGetLinkArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF servGetLinkArg "epoch" "o"));;
    ![slice.T byteT] "b".

Definition servGetLinkReply__decode: val :=
  rec: "servGetLinkReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("prevLink", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("dig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("sig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #64 in
        (if: "err"
        then (slice.nil, "err")
        else
          let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
          (if: "err"
          then (slice.nil, "err")
          else
            struct.storeF servGetLinkReply "prevLink" "o" "prevLink";;
            struct.storeF servGetLinkReply "dig" "o" "dig";;
            struct.storeF servGetLinkReply "sig" "o" "sig";;
            struct.storeF servGetLinkReply "error" "o" "error";;
            (![slice.T byteT] "b", errNone))))).

(* callServGetLink from rpc_misc.go *)

Definition callServGetLink: val :=
  rec: "callServGetLink" "cli" "epoch" :=
    let: "argB" := servGetLinkArg__encode (struct.new servGetLinkArg [
      "epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcServGetLink "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new servGetLinkReply [
    ] in
    let: (<>, "err1") := servGetLinkReply__decode "reply" "replyB" in
    (if: "err1"
    then
      let: "errReply" := struct.new servGetLinkReply [
      ] in
      struct.storeF servGetLinkReply "error" "errReply" "err1";;
      "errReply"
    else "reply").

Definition client__fetchLink: val :=
  rec: "client__fetchLink" "c" "epoch" :=
    let: (<>, "ok0") := MapGet (struct.loadF client "links" "c") "epoch" in
    (if: "ok0"
    then (slice.nil, errNone)
    else
      let: "reply" := callServGetLink (struct.loadF client "serv" "c") "epoch" in
      (if: struct.loadF servGetLinkReply "error" "reply"
      then (slice.nil, struct.loadF servGetLinkReply "error" "reply")
      else
        let: ("evid", "err0") := client__addLink "c" "epoch" (struct.loadF servGetLinkReply "prevLink" "reply") (struct.loadF servGetLinkReply "dig" "reply") (struct.loadF servGetLinkReply "sig" "reply") in
        (if: "err0"
        then ("evid", "err0")
        else (slice.nil, errNone)))).

(* adtrGetArg from rpc.go *)

Definition adtrGetArg := struct.decl [
  "epoch" :: epochTy
].

(* adtrGetArg__encode from rpc.out.go *)

Definition adtrGetArg__encode: val :=
  rec: "adtrGetArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF adtrGetArg "epoch" "o"));;
    ![slice.T byteT] "b".

Definition adtrGetReply__decode: val :=
  rec: "adtrGetReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("prevLink", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("dig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("servSig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #64 in
        (if: "err"
        then (slice.nil, "err")
        else
          let: (("adtrSig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #64 in
          (if: "err"
          then (slice.nil, "err")
          else
            let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
            (if: "err"
            then (slice.nil, "err")
            else
              struct.storeF adtrGetReply "prevLink" "o" "prevLink";;
              struct.storeF adtrGetReply "dig" "o" "dig";;
              struct.storeF adtrGetReply "servSig" "o" "servSig";;
              struct.storeF adtrGetReply "adtrSig" "o" "adtrSig";;
              struct.storeF adtrGetReply "error" "o" "error";;
              (![slice.T byteT] "b", errNone)))))).

(* callAdtrGet from rpc_misc.go *)

Definition callAdtrGet: val :=
  rec: "callAdtrGet" "cli" "epoch" :=
    let: "argB" := adtrGetArg__encode (struct.new adtrGetArg [
      "epoch" ::= "epoch"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcAdtrGet "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new adtrGetReply [
    ] in
    let: (<>, "err1") := adtrGetReply__decode "reply" "replyB" in
    (if: "err1"
    then
      let: "errReply" := struct.new adtrGetReply [
      ] in
      struct.storeF adtrGetReply "error" "errReply" "err1";;
      "errReply"
    else "reply").

(* audit returns epoch idx (exclusive) thru which audit succeeded.
   there could be lots of errors, but currently, we mainly
   return an error if there's evidence.
   TODO: maybe change err handling, in selfCheck as well. *)
Definition client__audit: val :=
  rec: "client__audit" "c" "adtrAddr" "adtrPk" :=
    let: "epoch" := ref (zero_val uint64T) in
    let: "evid" := ref (zero_val ptrT) in
    let: "err" := ref (zero_val boolT) in
    Skip;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      let: ("0_ret", "1_ret") := client__fetchLink "c" (![uint64T] "epoch") in
      "evid" <-[ptrT] "0_ret";;
      "err" <-[boolT] "1_ret";;
      (if: ![boolT] "err"
      then Break
      else
        "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
        Continue));;
    (if: (![uint64T] "epoch") = #0
    then (#0, slice.nil, errSome)
    else
      (if: (![ptrT] "evid") â‰  #null
      then (#0, ![ptrT] "evid", ![boolT] "err")
      else
        let: "lastEpoch" := (![uint64T] "epoch") - #1 in
        let: "lastLink" := Fst (MapGet (struct.loadF client "links" "c") "lastEpoch") in
        let: "adtr" := urpc.MakeClient "adtrAddr" in
        let: "reply" := callAdtrGet "adtr" "lastEpoch" in
        (if: struct.loadF adtrGetReply "error" "reply"
        then (#0, slice.nil, struct.loadF adtrGetReply "error" "reply")
        else
          let: "preAdtrLink" := chainSepSome__encode (struct.new chainSepSome [
            "epoch" ::= "lastEpoch";
            "prevLink" ::= struct.loadF adtrGetReply "prevLink" "reply";
            "data" ::= struct.loadF adtrGetReply "dig" "reply"
          ]) in
          let: "adtrLink" := cryptoffi.Hash "preAdtrLink" in
          let: "preAdtrSig" := adtrSepLink__encode (struct.new adtrSepLink [
            "link" ::= "adtrLink"
          ]) in
          let: "adtrOk" := cryptoffi.PublicKey__Verify "adtrPk" "preAdtrSig" (struct.loadF adtrGetReply "adtrSig" "reply") in
          (if: (~ "adtrOk")
          then (#0, slice.nil, errSome)
          else
            let: "preServSig" := servSepLink__encode (struct.new servSepLink [
              "link" ::= "adtrLink"
            ]) in
            let: "servOk" := cryptoffi.PublicKey__Verify (struct.loadF client "servPk" "c") "preServSig" (struct.loadF adtrGetReply "servSig" "reply") in
            (if: (~ "servOk")
            then (#0, slice.nil, errSome)
            else
              (if: (~ (std.BytesEqual (struct.loadF cliSigLink "link" "lastLink") "adtrLink"))
              then
                let: "evid" := struct.new evidServLink [
                  "epoch0" ::= "lastEpoch";
                  "prevLink0" ::= struct.loadF cliSigLink "prevLink" "lastLink";
                  "dig0" ::= struct.loadF cliSigLink "dig" "lastLink";
                  "sig0" ::= struct.loadF cliSigLink "sig" "lastLink";
                  "epoch1" ::= "lastEpoch";
                  "prevLink1" ::= struct.loadF adtrGetReply "prevLink" "reply";
                  "dig1" ::= struct.loadF adtrGetReply "dig" "reply";
                  "sig1" ::= struct.loadF adtrGetReply "servSig" "reply"
                ] in
                (#0, "evid", errSome)
              else (![uint64T] "epoch", slice.nil, errNone))))))).

Definition client__selfCheckAt: val :=
  rec: "client__selfCheckAt" "c" "epoch" :=
    let: "reply" := callServGetIdAt (struct.loadF client "serv" "c") (struct.loadF client "id" "c") "epoch" in
    (if: struct.loadF servGetIdAtReply "error" "reply"
    then (slice.nil, slice.nil, struct.loadF servGetIdAtReply "error" "reply")
    else
      let: "errMerkle" := merkle.CheckProof (struct.loadF servGetIdAtReply "proofTy" "reply") (struct.loadF servGetIdAtReply "proof" "reply") (struct.loadF client "id" "c") (struct.loadF servGetIdAtReply "val" "reply") (struct.loadF servGetIdAtReply "dig" "reply") in
      (if: "errMerkle"
      then (slice.nil, slice.nil, "errMerkle")
      else
        let: ("linkEvid", "errLink") := client__addLink "c" "epoch" (struct.loadF servGetIdAtReply "prevLink" "reply") (struct.loadF servGetIdAtReply "dig" "reply") (struct.loadF servGetIdAtReply "sig" "reply") in
        (if: "errLink"
        then ("linkEvid", slice.nil, "errLink")
        else
          let: ((("expVal", "expProofTy"), "putSig"), "isBoundary") := timeSeries__get (struct.loadF client "myVals" "c") "epoch" in
          (if: "expProofTy" â‰  (struct.loadF servGetIdAtReply "proofTy" "reply")
          then (slice.nil, slice.nil, errSome)
          else
            (if: (~ (std.BytesEqual "expVal" (struct.loadF servGetIdAtReply "val" "reply")))
            then
              (if: "isBoundary"
              then
                let: "ev" := struct.new evidServPut [
                  "epoch" ::= "epoch";
                  "prevLink" ::= struct.loadF servGetIdAtReply "prevLink" "reply";
                  "dig" ::= struct.loadF servGetIdAtReply "dig" "reply";
                  "linkSig" ::= struct.loadF servGetIdAtReply "sig" "reply";
                  "id" ::= struct.loadF client "id" "c";
                  "val0" ::= "expVal";
                  "putSig" ::= "putSig";
                  "val1" ::= struct.loadF servGetIdAtReply "val" "reply";
                  "proof" ::= struct.loadF servGetIdAtReply "proof" "reply"
                ] in
                (slice.nil, "ev", errSome)
              else (slice.nil, slice.nil, errSome))
            else (slice.nil, slice.nil, errNone)))))).

(* selfCheck returns epoch idx (exclusive) thru which audit succeeded.
   there could be lots of errors, but currently, we mainly
   return an error if there's evidence. *)
Definition client__selfCheck: val :=
  rec: "client__selfCheck" "c" :=
    let: "epoch" := ref (zero_val uint64T) in
    let: "evidLink" := ref (zero_val ptrT) in
    let: "evidPut" := ref (zero_val ptrT) in
    let: "err" := ref (zero_val boolT) in
    Skip;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      let: (("0_ret", "1_ret"), "2_ret") := client__selfCheckAt "c" (![uint64T] "epoch") in
      "evidLink" <-[ptrT] "0_ret";;
      "evidPut" <-[ptrT] "1_ret";;
      "err" <-[boolT] "2_ret";;
      (if: ![boolT] "err"
      then Break
      else
        "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
        Continue));;
    (if: (![uint64T] "epoch") = #0
    then (#0, slice.nil, slice.nil, errSome)
    else
      (if: ((![ptrT] "evidLink") â‰  #null) || ((![ptrT] "evidPut") â‰  #null)
      then (#0, ![ptrT] "evidLink", ![ptrT] "evidPut", ![boolT] "err")
      else (![uint64T] "epoch", slice.nil, slice.nil, errNone))).

(* proof.go *)

Definition helpersTy := struct.decl [
  "servPk" :: cryptoffi.PublicKey
].

(* servPutArg__decode from rpc.out.go *)

Definition servPutArg__decode: val :=
  rec: "servPutArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("id", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("val", "b"), "err") := marshalutil.ReadSlice1D (![slice.T byteT] "b") in
      (if: "err"
      then (slice.nil, "err")
      else
        struct.storeF servPutArg "id" "o" "id";;
        struct.storeF servPutArg "val" "o" "val";;
        (![slice.T byteT] "b", errNone))).

Definition servPutReply__encode: val :=
  rec: "servPutReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF servPutReply "putEpoch" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servPutReply "prev2Link" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servPutReply "prevDig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servPutReply "linkSig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servPutReply "putSig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF servPutReply "error" "o"));;
    ![slice.T byteT] "b".

Definition servGetIdAtArg__decode: val :=
  rec: "servGetIdAtArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("id", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("epoch", "b"), "err") := marshalutil.ReadInt (![slice.T byteT] "b") in
      (if: "err"
      then (slice.nil, "err")
      else
        struct.storeF servGetIdAtArg "id" "o" "id";;
        struct.storeF servGetIdAtArg "epoch" "o" "epoch";;
        (![slice.T byteT] "b", errNone))).

Definition servGetIdAtReply__encode: val :=
  rec: "servGetIdAtReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servGetIdAtReply "prevLink" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servGetIdAtReply "dig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servGetIdAtReply "sig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF servGetIdAtReply "val" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF servGetIdAtReply "proofTy" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF servGetIdAtReply "proof" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF servGetIdAtReply "error" "o"));;
    ![slice.T byteT] "b".

Definition servGetLinkArg__decode: val :=
  rec: "servGetLinkArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := marshalutil.ReadInt (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      struct.storeF servGetLinkArg "epoch" "o" "epoch";;
      (![slice.T byteT] "b", errNone)).

Definition servGetLinkReply__encode: val :=
  rec: "servGetLinkReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servGetLinkReply "prevLink" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servGetLinkReply "dig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF servGetLinkReply "sig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF servGetLinkReply "error" "o"));;
    ![slice.T byteT] "b".

(* server__start from rpc_misc.go *)

Definition server__start: val :=
  rec: "server__start" "s" "addr" :=
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "handlers" rpcServUpdateEpoch (Î»: "enc_args" "enc_reply",
      server__updateEpoch "s";;
      #()
      );;
    MapInsert "handlers" rpcServPut (Î»: "enc_args" "enc_reply",
      let: "args" := struct.new servPutArg [
      ] in
      let: (<>, "err0") := servPutArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new servPutReply [
        ] in
        struct.storeF servPutReply "error" "reply" "err0";;
        "enc_reply" <-[slice.T byteT] (servPutReply__encode "reply");;
        #()
      else
        "enc_reply" <-[slice.T byteT] (servPutReply__encode (server__put "s" (struct.loadF servPutArg "id" "args") (struct.loadF servPutArg "val" "args")));;
        #())
      );;
    MapInsert "handlers" rpcServGetIdAt (Î»: "enc_args" "enc_reply",
      let: "args" := struct.new servGetIdAtArg [
      ] in
      let: (<>, "err0") := servGetIdAtArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new servGetIdAtReply [
        ] in
        struct.storeF servGetIdAtReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (servGetIdAtReply__encode "reply");;
        #()
      else
        "enc_reply" <-[slice.T byteT] (servGetIdAtReply__encode (server__getIdAt "s" (struct.loadF servGetIdAtArg "id" "args") (struct.loadF servGetIdAtArg "epoch" "args")));;
        #())
      );;
    MapInsert "handlers" rpcServGetLink (Î»: "enc_args" "enc_reply",
      let: "args" := struct.new servGetLinkArg [
      ] in
      let: (<>, "err0") := servGetLinkArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new servGetLinkReply [
        ] in
        struct.storeF servGetLinkReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (servGetLinkReply__encode "reply");;
        #()
      else
        "enc_reply" <-[slice.T byteT] (servGetLinkReply__encode (server__getLink "s" (struct.loadF servGetLinkArg "epoch" "args")));;
        #())
      );;
    urpc.Server__Serve (urpc.MakeServer "handlers") "addr";;
    #().

(* adtrPutArg from rpc.go *)

Definition adtrPutArg := struct.decl [
  "prevLink" :: linkTy;
  "dig" :: slice.T byteT;
  "servSig" :: slice.T byteT
].

(* adtrPutArg__decode from rpc.out.go *)

Definition adtrPutArg__decode: val :=
  rec: "adtrPutArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("prevLink", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
    (if: "err"
    then (slice.nil, "err")
    else
      let: (("dig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #32 in
      (if: "err"
      then (slice.nil, "err")
      else
        let: (("servSig", "b"), "err") := marshalutil.ReadBytes (![slice.T byteT] "b") #64 in
        (if: "err"
        then (slice.nil, "err")
        else
          struct.storeF adtrPutArg "prevLink" "o" "prevLink";;
          struct.storeF adtrPutArg "dig" "o" "dig";;
          struct.storeF adtrPutArg "servSig" "o" "servSig";;
          (![slice.T byteT] "b", errNone)))).

(* adtrPutReply from rpc.go *)

Definition adtrPutReply := struct.decl [
  "error" :: errorTy
].

(* adtrPutReply__encode from rpc.out.go *)

Definition adtrPutReply__encode: val :=
  rec: "adtrPutReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF adtrPutReply "error" "o"));;
    ![slice.T byteT] "b".

Definition adtrGetArg__decode: val :=
  rec: "adtrGetArg__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("epoch", "b"), "err") := marshalutil.ReadInt (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      struct.storeF adtrGetArg "epoch" "o" "epoch";;
      (![slice.T byteT] "b", errNone)).

Definition adtrGetReply__encode: val :=
  rec: "adtrGetReply__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF adtrGetReply "prevLink" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF adtrGetReply "dig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF adtrGetReply "servSig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF adtrGetReply "adtrSig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF adtrGetReply "error" "o"));;
    ![slice.T byteT] "b".

(* auditor__start from rpc_misc.go *)

Definition auditor__start: val :=
  rec: "auditor__start" "a" "addr" :=
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "handlers" rpcAdtrPut (Î»: "enc_args" "enc_reply",
      let: "args" := struct.new adtrPutArg [
      ] in
      let: (<>, "err0") := adtrPutArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new adtrPutReply [
        ] in
        struct.storeF adtrPutReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (adtrPutReply__encode "reply");;
        #()
      else
        let: "err1" := auditor__put "a" (struct.loadF adtrPutArg "prevLink" "args") (struct.loadF adtrPutArg "dig" "args") (struct.loadF adtrPutArg "servSig" "args") in
        "enc_reply" <-[slice.T byteT] (adtrPutReply__encode (struct.new adtrPutReply [
          "error" ::= "err1"
        ]));;
        #())
      );;
    MapInsert "handlers" rpcAdtrGet (Î»: "enc_args" "enc_reply",
      let: "args" := struct.new adtrGetArg [
      ] in
      let: (<>, "err0") := adtrGetArg__decode "args" "enc_args" in
      (if: "err0"
      then
        let: "reply" := struct.new adtrGetReply [
        ] in
        struct.storeF adtrGetReply "error" "reply" errSome;;
        "enc_reply" <-[slice.T byteT] (adtrGetReply__encode "reply");;
        #()
      else
        "enc_reply" <-[slice.T byteT] (adtrGetReply__encode (auditor__get "a" (struct.loadF adtrGetArg "epoch" "args")));;
        #())
      );;
    urpc.Server__Serve (urpc.MakeServer "handlers") "addr";;
    #().

(* helpersTy__put from proof.go *)

Definition helpersTy__put: val :=
  rec: "helpersTy__put" "h" "c" "val" :=
    let: (("putEp", "evidAlLink0"), "err0") := client__put "c" "val" in
    (if: "evidAlLink0" â‰  #null
    then
      let: "err" := evidServLink__check "evidAlLink0" (struct.loadF helpersTy "servPk" "h") in
      control.impl.Assert (~ "err")
    else control.impl.Assume (~ "err0"));;
    "putEp".

(* callServUpdateEpoch from rpc_misc.go *)

Definition callServUpdateEpoch: val :=
  rec: "callServUpdateEpoch" "cli" :=
    let: "argB" := NewSlice byteT #0 in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcServUpdateEpoch "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    #().

(* adtrPutArg__encode from rpc.out.go *)

Definition adtrPutArg__encode: val :=
  rec: "adtrPutArg__encode" "o" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF adtrPutArg "prevLink" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF adtrPutArg "dig" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF adtrPutArg "servSig" "o"));;
    ![slice.T byteT] "b".

Definition adtrPutReply__decode: val :=
  rec: "adtrPutReply__decode" "o" "b0" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    let: (("error", "b"), "err") := marshalutil.ReadBool (![slice.T byteT] "b") in
    (if: "err"
    then (slice.nil, "err")
    else
      struct.storeF adtrPutReply "error" "o" "error";;
      (![slice.T byteT] "b", errNone)).

(* callAdtrPut from rpc_misc.go *)

Definition callAdtrPut: val :=
  rec: "callAdtrPut" "cli" "prevLink" "dig" "servSig" :=
    let: "argB" := adtrPutArg__encode (struct.new adtrPutArg [
      "prevLink" ::= "prevLink";
      "dig" ::= "dig";
      "servSig" ::= "servSig"
    ]) in
    let: "replyB" := NewSlice byteT #0 in
    let: "err0" := urpc.Client__Call "cli" rpcAdtrPut "argB" "replyB" #100 in
    control.impl.Assume ("err0" = urpc.ErrNone);;
    let: "reply" := struct.new adtrPutReply [
    ] in
    let: (<>, "err1") := adtrPutReply__decode "reply" "replyB" in
    (if: "err1"
    then "err1"
    else struct.loadF adtrPutReply "error" "reply").

(* updateAdtr from proof.go *)

Definition updateAdtr: val :=
  rec: "updateAdtr" "servCli" "adtrCli" "numEpochs" :=
    let: "i" := ref_to uint64T #0 in
    (for: (Î»: <>, (![uint64T] "i") < "numEpochs"); (Î»: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := Î»: <>,
      let: "reply" := callServGetLink "servCli" (![uint64T] "i") in
      control.impl.Assume (~ (struct.loadF servGetLinkReply "error" "reply"));;
      let: "err" := callAdtrPut "adtrCli" (struct.loadF servGetLinkReply "prevLink" "reply") (struct.loadF servGetLinkReply "dig" "reply") (struct.loadF servGetLinkReply "sig" "reply") in
      control.impl.Assume (~ "err");;
      Continue);;
    #().

Definition helpersTy__selfCheckThru: val :=
  rec: "helpersTy__selfCheckThru" "h" "c" "thru" :=
    let: ((("selfEp", "evidLink"), "evidAlPut"), "err0") := client__selfCheck "c" in
    (if: "evidLink" â‰  #null
    then
      let: "err" := evidServLink__check "evidLink" (struct.loadF helpersTy "servPk" "h") in
      control.impl.Assert (~ "err")
    else
      (if: "evidAlPut" â‰  #null
      then
        let: "err" := evidServPut__check "evidAlPut" (struct.loadF helpersTy "servPk" "h") in
        control.impl.Assert (~ "err")
      else control.impl.Assume (~ "err0")));;
    control.impl.Assume ("thru" < "selfEp");;
    #().

Definition helpersTy__auditThru: val :=
  rec: "helpersTy__auditThru" "h" "c" "adtrAddr" "adtrPk" "thru" :=
    let: (("auditEp", "evidLink"), "err0") := client__audit "c" "adtrAddr" "adtrPk" in
    (if: "evidLink" â‰  #null
    then
      let: "err" := evidServLink__check "evidLink" (struct.loadF helpersTy "servPk" "h") in
      control.impl.Assert (~ "err")
    else control.impl.Assume (~ "err0"));;
    control.impl.Assume ("thru" < "auditEp");;
    #().

Definition helpersTy__getAt: val :=
  rec: "helpersTy__getAt" "h" "c" "id" "epoch" :=
    let: (("retVal", "evidLink"), "err0") := client__getAt "c" "id" "epoch" in
    (if: "evidLink" â‰  #null
    then
      let: "err" := evidServLink__check "evidLink" (struct.loadF helpersTy "servPk" "h") in
      control.impl.Assert (~ "err")
    else control.impl.Assume (~ "err0"));;
    "retVal".

Definition testAgreement: val :=
  rec: "testAgreement" "servAddr" "adtr0Addr" "adtr1Addr" :=
    let: ("serv", "servPk") := newServer #() in
    let: "helpers" := struct.new helpersTy [
      "servPk" ::= "servPk"
    ] in
    Fork (server__start "serv" "servAddr");;
    let: ("adtr0", "adtr0Pk") := newAuditor "servPk" in
    let: ("adtr1", "adtr1Pk") := newAuditor "servPk" in
    Fork (auditor__start "adtr0" "adtr0Addr");;
    Fork (auditor__start "adtr1" "adtr1Addr");;
    time.Sleep #1000000;;
    let: "servCli" := urpc.MakeClient "servAddr" in
    let: "adtr0Cli" := urpc.MakeClient "adtr0Addr" in
    let: "adtr1Cli" := urpc.MakeClient "adtr1Addr" in
    let: "aliceId" := cryptoffi.Hash (StringToBytes #(str"alice")) in
    let: "aliceCli" := newClient "aliceId" "servAddr" "servPk" in
    let: "aliceKey0" := StringToBytes #(str"key") in
    let: "putEp" := helpersTy__put "helpers" "aliceCli" "aliceKey0" in
    callServUpdateEpoch "servCli";;
    updateAdtr "servCli" "adtr0Cli" #2;;
    updateAdtr "servCli" "adtr1Cli" #2;;
    helpersTy__selfCheckThru "helpers" "aliceCli" "putEp";;
    helpersTy__auditThru "helpers" "aliceCli" "adtr0Addr" "adtr0Pk" "putEp";;
    helpersTy__auditThru "helpers" "aliceCli" "adtr1Addr" "adtr1Pk" "putEp";;
    let: "bobId" := cryptoffi.Hash (StringToBytes #(str"bob")) in
    let: "bobCli" := newClient "bobId" "servAddr" "servPk" in
    let: "aliceKey1" := helpersTy__getAt "helpers" "bobCli" "aliceId" "putEp" in
    helpersTy__auditThru "helpers" "bobCli" "adtr0Addr" "adtr0Pk" "putEp";;
    helpersTy__auditThru "helpers" "bobCli" "adtr1Addr" "adtr1Pk" "putEp";;
    control.impl.Assert (std.BytesEqual "aliceKey0" "aliceKey1");;
    #().

(* rpc.go *)

(* rpc.out.go *)

(* Auto-generated from spec "github.com/mit-pdos/pav/ktmerkle/rpc.go"
   using compiler "github.com/mit-pdos/pav/rpc". *)

(* rpc_misc.go *)
