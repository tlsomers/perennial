(* autogenerated from github.com/mit-pdos/pav/merkle *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.pav.cryptoffi.
From Goose Require github_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.

Definition numChildren : expr := #256.

Definition hashesPerProofDepth : expr := (numChildren - #1) * cryptoffi.HashLen.

Definition emptyNodeTag : expr := #(U8 0).

Definition leafNodeTag : expr := #(U8 1).

Definition interiorNodeTag : expr := #(U8 2).

Definition NonmembProofTy : expr := #false.

Definition MembProofTy : expr := #true.

Definition Tree := struct.decl [
  "ctx" :: ptrT;
  "root" :: ptrT
].

Definition node := struct.decl [
  "mapVal" :: slice.T byteT;
  "hash" :: slice.T byteT;
  "children" :: slice.T ptrT
].

(* context is a result of:
   1) for performance reasons, wanting to pre-compute the empty hash.
   2) requiring that all hashes come from program steps.
   3) goose not having init() support. *)
Definition context := struct.decl [
  "emptyHash" :: slice.T byteT
].

(* getHash getter to support hashes of empty (nil) nodes. *)
Definition context__getHash: val :=
  rec: "context__getHash" "ctx" "n" :=
    (if: "n" = #null
    then struct.loadF context "emptyHash" "ctx"
    else struct.loadF node "hash" "n").

Definition Tree__Digest: val :=
  rec: "Tree__Digest" "t" :=
    context__getHash (struct.loadF Tree "ctx" "t") (struct.loadF Tree "root" "t").

Definition newInteriorNode: val :=
  rec: "newInteriorNode" <> :=
    let: "c" := NewSlice ptrT numChildren in
    struct.new node [
      "children" ::= "c"
    ].

Definition compLeafNodeHash: val :=
  rec: "compLeafNodeHash" "mapVal" :=
    let: "b" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 ((slice.len "mapVal") + #1)) in
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") "mapVal");;
    "b" <-[slice.T byteT] (SliceAppend byteT (![slice.T byteT] "b") leafNodeTag);;
    cryptoffi.Hash (![slice.T byteT] "b").

(* Assumes recursive child hashes are already up-to-date.
   uses and returns hash buf, to allow for its re-use. *)
Definition context__updInteriorHash: val :=
  rec: "context__updInteriorHash" "ctx" "b" "n" :=
    let: "b0" := ref_to (slice.T byteT) "b" in
    ForSlice ptrT <> "child" (struct.loadF node "children" "n")
      ("b0" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b0") (context__getHash "ctx" "child")));;
    "b0" <-[slice.T byteT] (SliceAppend byteT (![slice.T byteT] "b0") interiorNodeTag);;
    struct.storeF node "hash" "n" (cryptoffi.Hash (![slice.T byteT] "b0"));;
    ![slice.T byteT] "b0".

Definition context__getProof: val :=
  rec: "context__getProof" "ctx" "root" "label" :=
    let: "proof" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (cryptoffi.HashLen * hashesPerProofDepth)) in
    let: "currNode" := ref_to ptrT "root" in
    let: "depth" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, ((![uint64T] "depth") < cryptoffi.HashLen) && ((![ptrT] "currNode") ≠ #null)); (λ: <>, Skip) := λ: <>,
      let: "children" := struct.loadF node "children" (![ptrT] "currNode") in
      let: "pos" := to_u64 (SliceGet byteT "label" (![uint64T] "depth")) in
      ForSlice ptrT <> "n" (SliceTake "children" "pos")
        ("proof" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "proof") (context__getHash "ctx" "n")));;
      "currNode" <-[ptrT] (SliceGet ptrT (struct.loadF node "children" (![ptrT] "currNode")) "pos");;
      ForSlice ptrT <> "n" (SliceSkip ptrT "children" ("pos" + #1))
        ("proof" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "proof") (context__getHash "ctx" "n")));;
      "depth" <-[uint64T] ((![uint64T] "depth") + #1);;
      Continue);;
    ![slice.T byteT] "proof".

(* Put returns the digest, proof, and error. *)
Definition Tree__Put: val :=
  rec: "Tree__Put" "t" "label" "mapVal" :=
    (if: (slice.len "label") ≠ cryptoffi.HashLen
    then (slice.nil, slice.nil, #true)
    else
      let: "interiors" := ref_to (slice.T ptrT) (NewSliceWithCap ptrT #0 cryptoffi.HashLen) in
      (if: (struct.loadF Tree "root" "t") = #null
      then struct.storeF Tree "root" "t" (newInteriorNode #())
      else #());;
      "interiors" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "interiors") (struct.loadF Tree "root" "t"));;
      let: "n" := cryptoffi.HashLen - #1 in
      let: "depth" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "depth") < "n"); (λ: <>, "depth" <-[uint64T] ((![uint64T] "depth") + #1)) := λ: <>,
        let: "currNode" := SliceGet ptrT (![slice.T ptrT] "interiors") (![uint64T] "depth") in
        let: "pos" := to_u64 (SliceGet byteT "label" (![uint64T] "depth")) in
        (if: (SliceGet ptrT (struct.loadF node "children" "currNode") "pos") = #null
        then SliceSet ptrT (struct.loadF node "children" "currNode") "pos" (newInteriorNode #())
        else #());;
        "interiors" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "interiors") (SliceGet ptrT (struct.loadF node "children" "currNode") "pos"));;
        Continue);;
      let: "lastInterior" := SliceGet ptrT (![slice.T ptrT] "interiors") (cryptoffi.HashLen - #1) in
      let: "lastPos" := to_u64 (SliceGet byteT "label" (cryptoffi.HashLen - #1)) in
      SliceSet ptrT (struct.loadF node "children" "lastInterior") "lastPos" (struct.new node [
        "mapVal" ::= "mapVal";
        "hash" ::= compLeafNodeHash "mapVal"
      ]);;
      let: "loopBuf" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 ((numChildren * cryptoffi.HashLen) + #1)) in
      let: "depth" := ref_to uint64T cryptoffi.HashLen in
      Skip;;
      (for: (λ: <>, (![uint64T] "depth") ≥ #1); (λ: <>, Skip) := λ: <>,
        "loopBuf" <-[slice.T byteT] (context__updInteriorHash (struct.loadF Tree "ctx" "t") (![slice.T byteT] "loopBuf") (SliceGet ptrT (![slice.T ptrT] "interiors") ((![uint64T] "depth") - #1)));;
        "loopBuf" <-[slice.T byteT] (SliceTake (![slice.T byteT] "loopBuf") #0);;
        "depth" <-[uint64T] ((![uint64T] "depth") - #1);;
        Continue);;
      let: "dig" := context__getHash (struct.loadF Tree "ctx" "t") (struct.loadF Tree "root" "t") in
      let: "proof" := context__getProof (struct.loadF Tree "ctx" "t") (struct.loadF Tree "root" "t") "label" in
      ("dig", "proof", #false)).

(* getPath fetches including the leaf node.
   if the path doesn't exist, it terminates in an empty node. *)
Definition getPath: val :=
  rec: "getPath" "root" "label" :=
    let: "currNode" := ref_to ptrT "root" in
    let: "depth" := ref_to uint64T #0 in
    (for: (λ: <>, ((![uint64T] "depth") < cryptoffi.HashLen) && ((![ptrT] "currNode") ≠ #null)); (λ: <>, "depth" <-[uint64T] ((![uint64T] "depth") + #1)) := λ: <>,
      let: "pos" := to_u64 (SliceGet byteT "label" (![uint64T] "depth")) in
      "currNode" <-[ptrT] (SliceGet ptrT (struct.loadF node "children" (![ptrT] "currNode")) "pos");;
      Continue);;
    ![ptrT] "currNode".

(* Get returns the mapVal, digest, proofTy, proof, and error.
   return ProofTy vs. having sep funcs bc regardless, would want a proof. *)
Definition Tree__Get: val :=
  rec: "Tree__Get" "t" "label" :=
    (if: (slice.len "label") ≠ cryptoffi.HashLen
    then (slice.nil, slice.nil, #false, slice.nil, #true)
    else
      let: "lastNode" := getPath (struct.loadF Tree "root" "t") "label" in
      let: "dig" := context__getHash (struct.loadF Tree "ctx" "t") (struct.loadF Tree "root" "t") in
      let: "proof" := context__getProof (struct.loadF Tree "ctx" "t") (struct.loadF Tree "root" "t") "label" in
      (if: "lastNode" = #null
      then (slice.nil, "dig", NonmembProofTy, "proof", #false)
      else
        let: "val" := struct.loadF node "mapVal" "lastNode" in
        ("val", "dig", MembProofTy, "proof", #false))).

Definition compEmptyNodeHash: val :=
  rec: "compEmptyNodeHash" <> :=
    cryptoffi.Hash (SliceSingleton emptyNodeTag).

Definition newCtx: val :=
  rec: "newCtx" <> :=
    struct.new context [
      "emptyHash" ::= compEmptyNodeHash #()
    ].

Definition NewTree: val :=
  rec: "NewTree" <> :=
    struct.new Tree [
      "ctx" ::= newCtx #()
    ].

(* CheckProof returns an error if the proof is invalid. *)
Definition CheckProof: val :=
  rec: "CheckProof" "proofTy" "proof" "label" "mapVal" "dig" :=
    let: "proofLen" := slice.len "proof" in
    (if: ("proofLen" `rem` hashesPerProofDepth) ≠ #0
    then #true
    else
      let: "proofDepth" := "proofLen" `quot` hashesPerProofDepth in
      (if: "proofDepth" > cryptoffi.HashLen
      then #true
      else
        (if: (slice.len "label") ≠ cryptoffi.HashLen
        then #true
        else
          let: "labelPref" := SliceTake "label" "proofDepth" in
          let: "nodeHash" := ref (zero_val (slice.T byteT)) in
          (if: "proofTy"
          then "nodeHash" <-[slice.T byteT] (compLeafNodeHash "mapVal")
          else "nodeHash" <-[slice.T byteT] (compEmptyNodeHash #()));;
          let: "loopErr" := ref_to boolT #false in
          let: "loopCurrHash" := ref_to (slice.T byteT) (![slice.T byteT] "nodeHash") in
          let: "loopBuf" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 ((numChildren * cryptoffi.HashLen) + #1)) in
          let: "loopIdx" := ref_to uint64T #0 in
          Skip;;
          (for: (λ: <>, (![uint64T] "loopIdx") < "proofDepth"); (λ: <>, "loopIdx" <-[uint64T] ((![uint64T] "loopIdx") + #1)) := λ: <>,
            let: "depth" := ("proofDepth" - #1) - (![uint64T] "loopIdx") in
            let: "begin" := "depth" * hashesPerProofDepth in
            let: "middle" := "begin" + ((to_u64 (SliceGet byteT "labelPref" "depth")) * cryptoffi.HashLen) in
            let: "end" := ("depth" + #1) * hashesPerProofDepth in
            "loopBuf" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "loopBuf") (SliceSubslice byteT "proof" "begin" "middle"));;
            "loopBuf" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "loopBuf") (![slice.T byteT] "loopCurrHash"));;
            "loopBuf" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "loopBuf") (SliceSubslice byteT "proof" "middle" "end"));;
            "loopBuf" <-[slice.T byteT] (SliceAppend byteT (![slice.T byteT] "loopBuf") interiorNodeTag);;
            "loopCurrHash" <-[slice.T byteT] (cryptoffi.Hash (![slice.T byteT] "loopBuf"));;
            "loopBuf" <-[slice.T byteT] (SliceTake (![slice.T byteT] "loopBuf") #0);;
            Continue);;
          (if: ![boolT] "loopErr"
          then #true
          else
            (if: (~ (std.BytesEqual (![slice.T byteT] "loopCurrHash") "dig"))
            then #true
            else #false))))).

End code.
