(* autogenerated from github.com/mit-pdos/pav/kt *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.pav.advrpc.
From Goose Require github_com.mit_pdos.pav.cryptoffi.
From Goose Require github_com.mit_pdos.pav.marshalutil.
From Goose Require github_com.mit_pdos.pav.merkle.
From Goose Require github_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.

(* auditor.go *)

Definition Auditor := struct.decl [
  "mu" :: ptrT;
  "sk" :: cryptoffi.PrivateKey;
  "keyMap" :: ptrT;
  "histInfo" :: slice.T ptrT
].

(* MapValPre from serde.go *)

Definition MapValPre := struct.decl [
  "Epoch" :: uint64T;
  "PkComm" :: slice.T byteT
].

(* MapValPreDecode from serde.out.go *)

Definition MapValPreDecode: val :=
  rec: "MapValPreDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new MapValPre [
           "Epoch" ::= "a1";
           "PkComm" ::= "a2"
         ], "b2", #false))).

Definition Auditor__checkOneUpd: val :=
  rec: "Auditor__checkOneUpd" "a" "nextEpoch" "mapLabel" "mapVal" :=
    let: "getReply" := merkle.Tree__Get (struct.loadF Auditor "keyMap" "a") "mapLabel" in
    (if: (struct.loadF merkle.GetReply "Error" "getReply") || (struct.loadF merkle.GetReply "ProofTy" "getReply")
    then #true
    else
      let: (("valPre", <>), "err1") := MapValPreDecode "mapVal" in
      (if: "err1" || ((struct.loadF MapValPre "Epoch" "valPre") ≠ "nextEpoch")
      then #true
      else #false)).

(* checkUpd checks that updates are okay to apply, and errors on fail. *)
Definition Auditor__checkUpd: val :=
  rec: "Auditor__checkUpd" "a" "upd" :=
    let: "nextEpoch" := slice.len (struct.loadF Auditor "histInfo" "a") in
    let: "err0" := ref (zero_val boolT) in
    MapIter "upd" (λ: "mapLabel" "mapVal",
      (if: Auditor__checkOneUpd "a" "nextEpoch" (StringToBytes "mapLabel") "mapVal"
      then "err0" <-[boolT] #true
      else #()));;
    ![boolT] "err0".

(* applyUpd applies updates. *)
Definition Auditor__applyUpd: val :=
  rec: "Auditor__applyUpd" "a" "upd" :=
    MapIter "upd" (λ: "label" "val",
      let: ((<>, <>), "err0") := merkle.Tree__Put (struct.loadF Auditor "keyMap" "a") (StringToBytes "label") "val" in
      control.impl.Assert (~ "err0"));;
    #().

(* UpdateProof from serde.go *)

Definition UpdateProof := struct.decl [
  "Updates" :: mapT (slice.T byteT);
  "Sig" :: slice.T byteT
].

Definition PreSigDig := struct.decl [
  "Epoch" :: uint64T;
  "Dig" :: slice.T byteT
].

(* PreSigDigEncode from serde.out.go *)

Definition PreSigDigEncode: val :=
  rec: "PreSigDigEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF PreSigDig "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF PreSigDig "Dig" "o"));;
    ![slice.T byteT] "b".

(* AdtrEpochInfo from serde.go *)

Definition AdtrEpochInfo := struct.decl [
  "Dig" :: slice.T byteT;
  "ServSig" :: slice.T byteT;
  "AdtrSig" :: slice.T byteT
].

(* Update checks new epoch updates, applies them, and rets err on fail. *)
Definition Auditor__Update: val :=
  rec: "Auditor__Update" "a" "proof" :=
    Mutex__Lock (struct.loadF Auditor "mu" "a");;
    let: "nextEpoch" := slice.len (struct.loadF Auditor "histInfo" "a") in
    (if: Auditor__checkUpd "a" (struct.loadF UpdateProof "Updates" "proof")
    then
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      #true
    else
      Auditor__applyUpd "a" (struct.loadF UpdateProof "Updates" "proof");;
      let: "dig" := merkle.Tree__Digest (struct.loadF Auditor "keyMap" "a") in
      let: "preSig" := struct.new PreSigDig [
        "Epoch" ::= "nextEpoch";
        "Dig" ::= "dig"
      ] in
      let: "preSigByt" := PreSigDigEncode (NewSlice byteT #0) "preSig" in
      let: "sig" := cryptoffi.PrivateKey__Sign (struct.loadF Auditor "sk" "a") "preSigByt" in
      let: "newInfo" := struct.new AdtrEpochInfo [
        "Dig" ::= "dig";
        "ServSig" ::= struct.loadF UpdateProof "Sig" "proof";
        "AdtrSig" ::= "sig"
      ] in
      struct.storeF Auditor "histInfo" "a" (SliceAppend ptrT (struct.loadF Auditor "histInfo" "a") "newInfo");;
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      #false).

(* Get returns the auditor's known link for a particular epoch,
   and errs on fail. *)
Definition Auditor__Get: val :=
  rec: "Auditor__Get" "a" "epoch" :=
    Mutex__Lock (struct.loadF Auditor "mu" "a");;
    let: "numEpochs" := slice.len (struct.loadF Auditor "histInfo" "a") in
    (if: "epoch" ≥ "numEpochs"
    then
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      (struct.new AdtrEpochInfo [
       ], #true)
    else
      let: "info" := SliceGet ptrT (struct.loadF Auditor "histInfo" "a") "epoch" in
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      ("info", #false)).

Definition newAuditor: val :=
  rec: "newAuditor" <> :=
    let: "mu" := newMutex #() in
    let: ("pk", "sk") := cryptoffi.GenerateKey #() in
    let: "m" := struct.new merkle.Tree [
    ] in
    (struct.new Auditor [
       "mu" ::= "mu";
       "sk" ::= "sk";
       "keyMap" ::= "m"
     ], "pk").

(* client.go *)

Definition Client := struct.decl [
  "uid" :: uint64T;
  "nextVer" :: uint64T;
  "servCli" :: ptrT;
  "servSigPk" :: cryptoffi.PublicKey;
  "servVrfPk" :: ptrT;
  "seenDigs" :: mapT ptrT;
  "nextEpoch" :: uint64T
].

(* clientErr abstracts errors in the KT client.
   maybe there's an error. if so, maybe there's irrefutable evidence. *)
Definition clientErr := struct.decl [
  "evid" :: ptrT;
  "err" :: boolT
].

(* SigDig from serde.go *)

Definition SigDig := struct.decl [
  "Epoch" :: uint64T;
  "Dig" :: slice.T byteT;
  "Sig" :: slice.T byteT
].

(* CheckSigDig from evidence.go *)

(* Check rets err if signed dig does not validate. *)
Definition CheckSigDig: val :=
  rec: "CheckSigDig" "o" "pk" :=
    let: "pre" := struct.new PreSigDig [
      "Epoch" ::= struct.loadF SigDig "Epoch" "o";
      "Dig" ::= struct.loadF SigDig "Dig" "o"
    ] in
    let: "preByt" := PreSigDigEncode (NewSlice byteT #0) "pre" in
    (~ (cryptoffi.PublicKey__Verify "pk" "preByt" (struct.loadF SigDig "Sig" "o"))).

(* Evid is evidence that the server signed two conflicting digs. *)
Definition Evid := struct.decl [
  "sigDig0" :: ptrT;
  "sigDig1" :: ptrT
].

(* checkDig checks for freshness and prior vals, and evid / err on fail. *)
Definition Client__checkDig: val :=
  rec: "Client__checkDig" "c" "dig" :=
    let: "stdErr" := struct.new clientErr [
      "evid" ::= slice.nil;
      "err" ::= #true
    ] in
    let: "err0" := CheckSigDig "dig" (struct.loadF Client "servSigPk" "c") in
    (if: "err0"
    then "stdErr"
    else
      let: ("seenDig", "ok0") := MapGet (struct.loadF Client "seenDigs" "c") (struct.loadF SigDig "Epoch" "dig") in
      (if: "ok0"
      then
        (if: (~ (std.BytesEqual (struct.loadF SigDig "Dig" "seenDig") (struct.loadF SigDig "Dig" "dig")))
        then
          let: "evid" := struct.new Evid [
            "sigDig0" ::= "dig";
            "sigDig1" ::= "seenDig"
          ] in
          struct.new clientErr [
            "evid" ::= "evid";
            "err" ::= #true
          ]
        else
          struct.new clientErr [
            "evid" ::= slice.nil;
            "err" ::= #false
          ])
      else
        (if: ((struct.loadF Client "nextEpoch" "c") ≠ #0) && ((struct.loadF SigDig "Epoch" "dig") < ((struct.loadF Client "nextEpoch" "c") - #1))
        then "stdErr"
        else
          (if: ((struct.loadF Client "nextEpoch" "c") + #1) = #0
          then "stdErr"
          else
            MapInsert (struct.loadF Client "seenDigs" "c") (struct.loadF SigDig "Epoch" "dig") "dig";;
            struct.storeF Client "nextEpoch" "c" ((struct.loadF SigDig "Epoch" "dig") + #1);;
            struct.new clientErr [
              "evid" ::= slice.nil;
              "err" ::= #false
            ])))).

(* MapLabelPre from serde.go *)

Definition MapLabelPre := struct.decl [
  "Uid" :: uint64T;
  "Ver" :: uint64T
].

(* MapLabelPreEncode from serde.out.go *)

Definition MapLabelPreEncode: val :=
  rec: "MapLabelPreEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapLabelPre "Uid" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapLabelPre "Ver" "o"));;
    ![slice.T byteT] "b".

(* checkVrfProof errors on fail.
   TODO: if VRF pubkey is bad, does VRF.Verify still mean something? *)
Definition Client__checkVrf: val :=
  rec: "Client__checkVrf" "c" "uid" "ver" "label" "proof" :=
    let: "pre" := struct.new MapLabelPre [
      "Uid" ::= "uid";
      "Ver" ::= "ver"
    ] in
    let: "preByt" := MapLabelPreEncode (NewSlice byteT #0) "pre" in
    (~ (cryptoffi.VrfPublicKey__Verify (struct.loadF Client "servVrfPk" "c") "preByt" "label" "proof")).

(* Memb from serde.go *)

Definition Memb := struct.decl [
  "Label" :: slice.T byteT;
  "VrfProof" :: slice.T byteT;
  "EpochAdded" :: uint64T;
  "CommOpen" :: ptrT;
  "MerkProof" :: slice.T (slice.T (slice.T byteT))
].

Definition PkCommOpen := struct.decl [
  "Pk" :: slice.T byteT;
  "R" :: slice.T byteT
].

(* PkCommOpenEncode from serde.out.go *)

Definition PkCommOpenEncode: val :=
  rec: "PkCommOpenEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF PkCommOpen "Pk" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF PkCommOpen "R" "o"));;
    ![slice.T byteT] "b".

Definition MapValPreEncode: val :=
  rec: "MapValPreEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapValPre "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MapValPre "PkComm" "o"));;
    ![slice.T byteT] "b".

(* compMapVal from server.go *)

Definition compMapVal: val :=
  rec: "compMapVal" "epoch" "open" :=
    let: "openByt" := PkCommOpenEncode (NewSlice byteT #0) "open" in
    let: "comm" := cryptoffi.Hash "openByt" in
    let: "v" := struct.new MapValPre [
      "Epoch" ::= "epoch";
      "PkComm" ::= "comm"
    ] in
    let: "vByt" := MapValPreEncode (NewSlice byteT #0) "v" in
    "vByt".

(* checkMemb errors on fail. *)
Definition Client__checkMemb: val :=
  rec: "Client__checkMemb" "c" "uid" "ver" "dig" "memb" :=
    (if: Client__checkVrf "c" "uid" "ver" (struct.loadF Memb "Label" "memb") (struct.loadF Memb "VrfProof" "memb")
    then #true
    else
      let: "mapVal" := compMapVal (struct.loadF Memb "EpochAdded" "memb") (struct.loadF Memb "CommOpen" "memb") in
      merkle.CheckProof #true (struct.loadF Memb "MerkProof" "memb") (struct.loadF Memb "Label" "memb") "mapVal" "dig").

(* MembHide from serde.go *)

Definition MembHide := struct.decl [
  "Label" :: slice.T byteT;
  "VrfProof" :: slice.T byteT;
  "MapVal" :: slice.T byteT;
  "MerkProof" :: slice.T (slice.T (slice.T byteT))
].

(* checkMembHide errors on fail. *)
Definition Client__checkMembHide: val :=
  rec: "Client__checkMembHide" "c" "uid" "ver" "dig" "memb" :=
    (if: Client__checkVrf "c" "uid" "ver" (struct.loadF MembHide "Label" "memb") (struct.loadF MembHide "VrfProof" "memb")
    then #true
    else merkle.CheckProof #true (struct.loadF MembHide "MerkProof" "memb") (struct.loadF MembHide "Label" "memb") (struct.loadF MembHide "MapVal" "memb") "dig").

(* checkHist errors on fail. *)
Definition Client__checkHist: val :=
  rec: "Client__checkHist" "c" "uid" "dig" "membs" :=
    let: "err0" := ref (zero_val boolT) in
    ForSlice ptrT "ver0" "memb" "membs"
      (let: "ver" := "ver0" in
      (if: Client__checkMembHide "c" "uid" "ver" "dig" "memb"
      then "err0" <-[boolT] #true
      else #()));;
    ![boolT] "err0".

Definition NonMemb := struct.decl [
  "Label" :: slice.T byteT;
  "VrfProof" :: slice.T byteT;
  "MerkProof" :: slice.T (slice.T (slice.T byteT))
].

(* checkNonMemb errors on fail. *)
Definition Client__checkNonMemb: val :=
  rec: "Client__checkNonMemb" "c" "uid" "ver" "dig" "nonMemb" :=
    (if: Client__checkVrf "c" "uid" "ver" (struct.loadF NonMemb "Label" "nonMemb") (struct.loadF NonMemb "VrfProof" "nonMemb")
    then #true
    else merkle.CheckProof #false (struct.loadF NonMemb "MerkProof" "nonMemb") (struct.loadF NonMemb "Label" "nonMemb") slice.nil "dig").

Definition ServerPutArg := struct.decl [
  "Uid" :: uint64T;
  "Pk" :: slice.T byteT
].

(* ServerPutArgEncode from serde.out.go *)

Definition ServerPutArgEncode: val :=
  rec: "ServerPutArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerPutArg "Uid" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF ServerPutArg "Pk" "o"));;
    ![slice.T byteT] "b".

(* ServerPutRpc from rpc.go *)

Definition ServerPutRpc : expr := #0.

Definition ServerGetRpc : expr := #1.

Definition ServerSelfMonRpc : expr := #2.

Definition ServerAuditRpc : expr := #3.

Definition AdtrUpdateRpc : expr := #0.

Definition AdtrGetRpc : expr := #1.

(* SigDigDecode from serde.out.go *)

Definition SigDigDecode: val :=
  rec: "SigDigDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice1D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new SigDig [
             "Epoch" ::= "a1";
             "Dig" ::= "a2";
             "Sig" ::= "a3"
           ], "b3", #false)))).

Definition PkCommOpenDecode: val :=
  rec: "PkCommOpenDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new PkCommOpen [
           "Pk" ::= "a1";
           "R" ::= "a2"
         ], "b2", #false))).

Definition MembDecode: val :=
  rec: "MembDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadInt "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          let: (("a4", "b4"), "err4") := PkCommOpenDecode "b3" in
          (if: "err4"
          then (slice.nil, slice.nil, #true)
          else
            let: (("a5", "b5"), "err5") := marshalutil.ReadSlice3D "b4" in
            (if: "err5"
            then (slice.nil, slice.nil, #true)
            else
              (struct.new Memb [
                 "Label" ::= "a1";
                 "VrfProof" ::= "a2";
                 "EpochAdded" ::= "a3";
                 "CommOpen" ::= "a4";
                 "MerkProof" ::= "a5"
               ], "b5", #false)))))).

Definition NonMembDecode: val :=
  rec: "NonMembDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice3D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new NonMemb [
             "Label" ::= "a1";
             "VrfProof" ::= "a2";
             "MerkProof" ::= "a3"
           ], "b3", #false)))).

(* ServerPutReply from serde.go *)

Definition ServerPutReply := struct.decl [
  "Dig" :: ptrT;
  "Latest" :: ptrT;
  "Bound" :: ptrT
].

(* ServerPutReplyDecode from serde.out.go *)

Definition ServerPutReplyDecode: val :=
  rec: "ServerPutReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := MembDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := NonMembDecode "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new ServerPutReply [
             "Dig" ::= "a1";
             "Latest" ::= "a2";
             "Bound" ::= "a3"
           ], "b3", #false)))).

(* callServPut from rpc.go *)

Definition callServPut: val :=
  rec: "callServPut" "c" "uid" "pk" :=
    let: "arg" := struct.new ServerPutArg [
      "Uid" ::= "uid";
      "Pk" ::= "pk"
    ] in
    let: "argByt" := ServerPutArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerPutRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerPutReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, slice.nil, #true)
      else (struct.loadF ServerPutReply "Dig" "reply", struct.loadF ServerPutReply "Latest" "reply", struct.loadF ServerPutReply "Bound" "reply", #false))).

(* Put rets the epoch at which the key was put, and evid / error on fail. *)
Definition Client__Put: val :=
  rec: "Client__Put" "c" "pk" :=
    let: "stdErr" := struct.new clientErr [
      "evid" ::= slice.nil;
      "err" ::= #true
    ] in
    let: ((("dig", "latest"), "bound"), "err0") := callServPut (struct.loadF Client "servCli" "c") (struct.loadF Client "uid" "c") "pk" in
    (if: "err0"
    then (#0, "stdErr")
    else
      let: "err1" := Client__checkDig "c" "dig" in
      (if: struct.loadF clientErr "err" "err1"
      then (#0, "err1")
      else
        (if: Client__checkMemb "c" (struct.loadF Client "uid" "c") (struct.loadF Client "nextVer" "c") (struct.loadF SigDig "Dig" "dig") "latest"
        then (#0, "stdErr")
        else
          (if: (struct.loadF SigDig "Epoch" "dig") ≠ (struct.loadF Memb "EpochAdded" "latest")
          then (#0, "stdErr")
          else
            (if: (~ (std.BytesEqual "pk" (struct.loadF PkCommOpen "Pk" (struct.loadF Memb "CommOpen" "latest"))))
            then (#0, "stdErr")
            else
              (if: Client__checkNonMemb "c" (struct.loadF Client "uid" "c") ((struct.loadF Client "nextVer" "c") + #1) (struct.loadF SigDig "Dig" "dig") "bound"
              then (#0, "stdErr")
              else
                struct.storeF Client "nextVer" "c" ((struct.loadF Client "nextVer" "c") + #1);;
                (struct.loadF SigDig "Epoch" "dig", struct.new clientErr [
                   "evid" ::= slice.nil;
                   "err" ::= #false
                 ]))))))).

(* ServerGetArg from serde.go *)

Definition ServerGetArg := struct.decl [
  "Uid" :: uint64T
].

(* ServerGetArgEncode from serde.out.go *)

Definition ServerGetArgEncode: val :=
  rec: "ServerGetArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerGetArg "Uid" "o"));;
    ![slice.T byteT] "b".

Definition MembHideDecode: val :=
  rec: "MembHideDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice1D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          let: (("a4", "b4"), "err4") := marshalutil.ReadSlice3D "b3" in
          (if: "err4"
          then (slice.nil, slice.nil, #true)
          else
            (struct.new MembHide [
               "Label" ::= "a1";
               "VrfProof" ::= "a2";
               "MapVal" ::= "a3";
               "MerkProof" ::= "a4"
             ], "b4", #false))))).

(* MembHideSlice1DDecode from serde_misc.go *)

Definition MembHideSlice1DDecode: val :=
  rec: "MembHideSlice1DDecode" "b0" :=
    let: (("length", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: "loopO" := ref_to (slice.T ptrT) (NewSliceWithCap ptrT #0 "length") in
      let: "loopErr" := ref (zero_val boolT) in
      let: "loopB" := ref_to (slice.T byteT) "b1" in
      let: "i" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: (("a2", "loopB1"), "err2") := MembHideDecode (![slice.T byteT] "loopB") in
        "loopB" <-[slice.T byteT] "loopB1";;
        (if: "err2"
        then
          "loopErr" <-[boolT] #true;;
          Break
        else
          "loopO" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "loopO") "a2");;
          Continue));;
      (if: ![boolT] "loopErr"
      then (slice.nil, slice.nil, #true)
      else (![slice.T ptrT] "loopO", ![slice.T byteT] "loopB", #false))).

(* ServerGetReply from serde.go *)

Definition ServerGetReply := struct.decl [
  "Dig" :: ptrT;
  "Hist" :: slice.T ptrT;
  "IsReg" :: boolT;
  "Latest" :: ptrT;
  "Bound" :: ptrT
].

(* ServerGetReplyDecode from serde.out.go *)

Definition ServerGetReplyDecode: val :=
  rec: "ServerGetReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := MembHideSlice1DDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadBool "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          let: (("a4", "b4"), "err4") := MembDecode "b3" in
          (if: "err4"
          then (slice.nil, slice.nil, #true)
          else
            let: (("a5", "b5"), "err5") := NonMembDecode "b4" in
            (if: "err5"
            then (slice.nil, slice.nil, #true)
            else
              (struct.new ServerGetReply [
                 "Dig" ::= "a1";
                 "Hist" ::= "a2";
                 "IsReg" ::= "a3";
                 "Latest" ::= "a4";
                 "Bound" ::= "a5"
               ], "b5", #false)))))).

(* callServGet from rpc.go *)

Definition callServGet: val :=
  rec: "callServGet" "c" "uid" :=
    let: "arg" := struct.new ServerGetArg [
      "Uid" ::= "uid"
    ] in
    let: "argByt" := ServerGetArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerGetRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, #false, slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerGetReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, #false, slice.nil, slice.nil, #true)
      else (struct.loadF ServerGetReply "Dig" "reply", struct.loadF ServerGetReply "Hist" "reply", struct.loadF ServerGetReply "IsReg" "reply", struct.loadF ServerGetReply "Latest" "reply", struct.loadF ServerGetReply "Bound" "reply", #false))).

(* Get returns if the pk was registered, the pk, and the epoch
   at which it was seen, or an error / evid.
   Note: interaction of isReg and hist is a potential source of bugs.
   e.g., if don't track vers properly, bound could be off.
   e.g., if don't check isReg alignment with hist, could have fraud non-exis key. *)
Definition Client__Get: val :=
  rec: "Client__Get" "c" "uid" :=
    let: "stdErr" := struct.new clientErr [
      "evid" ::= slice.nil;
      "err" ::= #true
    ] in
    let: ((((("dig", "hist"), "isReg"), "latest"), "bound"), "err0") := callServGet (struct.loadF Client "servCli" "c") "uid" in
    (if: "err0"
    then (#false, slice.nil, #0, "stdErr")
    else
      let: "err1" := Client__checkDig "c" "dig" in
      (if: struct.loadF clientErr "err" "err1"
      then (#false, slice.nil, #0, "err1")
      else
        (if: Client__checkHist "c" "uid" (struct.loadF SigDig "Dig" "dig") "hist"
        then (#false, slice.nil, #0, "stdErr")
        else
          let: "numHistVers" := slice.len "hist" in
          (if: ("numHistVers" > #0) && (~ "isReg")
          then (#false, slice.nil, #0, "stdErr")
          else
            (if: "isReg" && (Client__checkMemb "c" "uid" "numHistVers" (struct.loadF SigDig "Dig" "dig") "latest")
            then (#false, slice.nil, #0, "stdErr")
            else
              let: "boundVer" := ref (zero_val uint64T) in
              (if: "isReg"
              then "boundVer" <-[uint64T] ("numHistVers" + #1)
              else #());;
              (if: Client__checkNonMemb "c" "uid" (![uint64T] "boundVer") (struct.loadF SigDig "Dig" "dig") "bound"
              then (#false, slice.nil, #0, "stdErr")
              else
                ("isReg", struct.loadF PkCommOpen "Pk" (struct.loadF Memb "CommOpen" "latest"), struct.loadF SigDig "Epoch" "dig", struct.new clientErr [
                   "evid" ::= slice.nil;
                   "err" ::= #false
                 ]))))))).

(* ServerSelfMonArg from serde.go *)

Definition ServerSelfMonArg := struct.decl [
  "Uid" :: uint64T
].

(* ServerSelfMonArgEncode from serde.out.go *)

Definition ServerSelfMonArgEncode: val :=
  rec: "ServerSelfMonArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerSelfMonArg "Uid" "o"));;
    ![slice.T byteT] "b".

(* ServerSelfMonReply from serde.go *)

Definition ServerSelfMonReply := struct.decl [
  "Dig" :: ptrT;
  "Bound" :: ptrT
].

(* ServerSelfMonReplyDecode from serde.out.go *)

Definition ServerSelfMonReplyDecode: val :=
  rec: "ServerSelfMonReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := NonMembDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerSelfMonReply [
           "Dig" ::= "a1";
           "Bound" ::= "a2"
         ], "b2", #false))).

(* callServSelfMon from rpc.go *)

Definition callServSelfMon: val :=
  rec: "callServSelfMon" "c" "uid" :=
    let: "arg" := struct.new ServerSelfMonArg [
      "Uid" ::= "uid"
    ] in
    let: "argByt" := ServerSelfMonArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerSelfMonRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerSelfMonReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, #true)
      else (struct.loadF ServerSelfMonReply "Dig" "reply", struct.loadF ServerSelfMonReply "Bound" "reply", #false))).

(* SelfMon self-monitors for the client's own key, and returns the epoch
   through which it succeeds, or evid / error on fail. *)
Definition Client__SelfMon: val :=
  rec: "Client__SelfMon" "c" :=
    let: "stdErr" := struct.new clientErr [
      "evid" ::= slice.nil;
      "err" ::= #true
    ] in
    let: (("dig", "bound"), "err0") := callServSelfMon (struct.loadF Client "servCli" "c") (struct.loadF Client "uid" "c") in
    (if: "err0"
    then (#0, "stdErr")
    else
      let: "err1" := Client__checkDig "c" "dig" in
      (if: struct.loadF clientErr "err" "err1"
      then (#0, "err1")
      else
        (if: Client__checkNonMemb "c" (struct.loadF Client "uid" "c") (struct.loadF Client "nextVer" "c") (struct.loadF SigDig "Dig" "dig") "bound"
        then (#0, "stdErr")
        else
          (struct.loadF SigDig "Epoch" "dig", struct.new clientErr [
             "evid" ::= slice.nil;
             "err" ::= #false
           ])))).

(* AdtrGetArg from serde.go *)

Definition AdtrGetArg := struct.decl [
  "Epoch" :: uint64T
].

(* AdtrGetArgEncode from serde.out.go *)

Definition AdtrGetArgEncode: val :=
  rec: "AdtrGetArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF AdtrGetArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition AdtrEpochInfoDecode: val :=
  rec: "AdtrEpochInfoDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice1D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new AdtrEpochInfo [
             "Dig" ::= "a1";
             "ServSig" ::= "a2";
             "AdtrSig" ::= "a3"
           ], "b3", #false)))).

(* AdtrGetReply from serde.go *)

Definition AdtrGetReply := struct.decl [
  "X" :: ptrT;
  "Err" :: boolT
].

(* AdtrGetReplyDecode from serde.out.go *)

Definition AdtrGetReplyDecode: val :=
  rec: "AdtrGetReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := AdtrEpochInfoDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadBool "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new AdtrGetReply [
           "X" ::= "a1";
           "Err" ::= "a2"
         ], "b2", #false))).

(* callAdtrGet from rpc.go *)

Definition callAdtrGet: val :=
  rec: "callAdtrGet" "c" "epoch" :=
    let: "arg" := struct.new AdtrGetArg [
      "Epoch" ::= "epoch"
    ] in
    let: "argByt" := AdtrGetArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" AdtrGetRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, #true)
    else
      let: (("reply", <>), "err1") := AdtrGetReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, #true)
      else (struct.loadF AdtrGetReply "X" "reply", struct.loadF AdtrGetReply "Err" "reply"))).

(* auditEpoch checks a single epoch against an auditor, and evid / error on fail.
   pre-cond: we've seen this epoch. *)
Definition Client__auditEpoch: val :=
  rec: "Client__auditEpoch" "c" "epoch" "adtrCli" "adtrPk" :=
    let: "stdErr" := struct.new clientErr [
      "evid" ::= slice.nil;
      "err" ::= #true
    ] in
    let: ("adtrInfo", "err0") := callAdtrGet "adtrCli" "epoch" in
    (if: "err0"
    then "stdErr"
    else
      let: "servDig" := struct.new SigDig [
        "Epoch" ::= "epoch";
        "Dig" ::= struct.loadF AdtrEpochInfo "Dig" "adtrInfo";
        "Sig" ::= struct.loadF AdtrEpochInfo "ServSig" "adtrInfo"
      ] in
      let: "adtrDig" := struct.new SigDig [
        "Epoch" ::= "epoch";
        "Dig" ::= struct.loadF AdtrEpochInfo "Dig" "adtrInfo";
        "Sig" ::= struct.loadF AdtrEpochInfo "AdtrSig" "adtrInfo"
      ] in
      (if: CheckSigDig "servDig" (struct.loadF Client "servSigPk" "c")
      then "stdErr"
      else
        (if: CheckSigDig "adtrDig" "adtrPk"
        then "stdErr"
        else
          let: ("seenDig", "ok0") := MapGet (struct.loadF Client "seenDigs" "c") "epoch" in
          control.impl.Assert "ok0";;
          (if: (~ (std.BytesEqual (struct.loadF AdtrEpochInfo "Dig" "adtrInfo") (struct.loadF SigDig "Dig" "seenDig")))
          then
            let: "evid" := struct.new Evid [
              "sigDig0" ::= "servDig";
              "sigDig1" ::= "seenDig"
            ] in
            struct.new clientErr [
              "evid" ::= "evid";
              "err" ::= #true
            ]
          else
            struct.new clientErr [
              "evid" ::= slice.nil;
              "err" ::= #false
            ])))).

Definition Client__Audit: val :=
  rec: "Client__Audit" "c" "adtrAddr" "adtrPk" :=
    let: "adtrCli" := advrpc.Dial "adtrAddr" in
    let: "err0" := ref_to ptrT (struct.new clientErr [
      "evid" ::= slice.nil;
      "err" ::= #false
    ]) in
    MapIter (struct.loadF Client "seenDigs" "c") (λ: "ep" <>,
      let: "err1" := Client__auditEpoch "c" "ep" "adtrCli" "adtrPk" in
      (if: struct.loadF clientErr "err" "err1"
      then "err0" <-[ptrT] "err1"
      else #()));;
    ![ptrT] "err0".

Definition newClient: val :=
  rec: "newClient" "uid" "servAddr" "servSigPk" "servVrfPk" :=
    let: "c" := advrpc.Dial "servAddr" in
    let: "digs" := NewMap uint64T ptrT #() in
    struct.new Client [
      "uid" ::= "uid";
      "servCli" ::= "c";
      "servSigPk" ::= "servSigPk";
      "servVrfPk" ::= "servVrfPk";
      "seenDigs" ::= "digs"
    ].

(* evidence.go *)

(* Check returns an error if the evidence does not check out.
   otherwise, it proves that the server was dishonest. *)
Definition Evid__Check: val :=
  rec: "Evid__Check" "e" "servPk" :=
    let: "err0" := CheckSigDig (struct.loadF Evid "sigDig0" "e") "servPk" in
    (if: "err0"
    then #true
    else
      let: "err1" := CheckSigDig (struct.loadF Evid "sigDig1" "e") "servPk" in
      (if: "err1"
      then #true
      else
        (if: (struct.loadF SigDig "Epoch" (struct.loadF Evid "sigDig0" "e")) ≠ (struct.loadF SigDig "Epoch" (struct.loadF Evid "sigDig1" "e"))
        then #true
        else std.BytesEqual (struct.loadF SigDig "Dig" (struct.loadF Evid "sigDig0" "e")) (struct.loadF SigDig "Dig" (struct.loadF Evid "sigDig1" "e"))))).

(* history.go *)

Definition HistEntry := struct.decl [
  "Epoch" :: uint64T;
  "HistVal" :: slice.T byteT
].

(* GetHist searches hist at the epoch and rets the latest val, or false
   if there's no registered val. *)
Definition GetHist: val :=
  rec: "GetHist" "o" "epoch" :=
    let: "isReg" := ref (zero_val boolT) in
    let: "val" := ref (zero_val (slice.T byteT)) in
    ForSlice ptrT <> "e" "o"
      ((if: (struct.loadF HistEntry "Epoch" "e") ≤ "epoch"
      then
        "isReg" <-[boolT] #true;;
        "val" <-[slice.T byteT] (struct.loadF HistEntry "HistVal" "e")
      else #()));;
    (![boolT] "isReg", ![slice.T byteT] "val").

(* rpc.go *)

(* ServerPutArgDecode from serde.out.go *)

Definition ServerPutArgDecode: val :=
  rec: "ServerPutArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerPutArg [
           "Uid" ::= "a1";
           "Pk" ::= "a2"
         ], "b2", #false))).

(* Server from server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "sigSk" :: cryptoffi.PrivateKey;
  "vrfSk" :: ptrT;
  "keyMap" :: ptrT;
  "histInfo" :: slice.T ptrT;
  "pkCommOpens" :: mapT ptrT;
  "nextVers" :: mapT uint64T
].

(* compMapLabel rets mapLabel (VRF(uid || ver)) and a VRF proof. *)
Definition compMapLabel: val :=
  rec: "compMapLabel" "uid" "ver" "sk" :=
    let: "l" := struct.new MapLabelPre [
      "Uid" ::= "uid";
      "Ver" ::= "ver"
    ] in
    let: "lByt" := MapLabelPreEncode (NewSlice byteT #0) "l" in
    let: ("h", "p") := cryptoffi.VrfPrivateKey__Hash "sk" "lByt" in
    ("h", "p").

(* genValComm rets mapVal (epoch || commitment) and a commitment opening,
   where commitment = Hash(pk || randBytes). *)
Definition genValComm: val :=
  rec: "genValComm" "epoch" "pk" :=
    let: "r" := cryptoffi.RandBytes (#2 * cryptoffi.HashLen) in
    let: "open" := struct.new PkCommOpen [
      "Pk" ::= "pk";
      "R" ::= "r"
    ] in
    (compMapVal "epoch" "open", "open").

Definition servEpochInfo := struct.decl [
  "updates" :: mapT (slice.T byteT);
  "dig" :: slice.T byteT;
  "sig" :: slice.T byteT
].

Definition Server__getDig: val :=
  rec: "Server__getDig" "s" :=
    let: "numEpochs" := slice.len (struct.loadF Server "histInfo" "s") in
    let: "lastInfo" := SliceGet ptrT (struct.loadF Server "histInfo" "s") ("numEpochs" - #1) in
    struct.new SigDig [
      "Epoch" ::= "numEpochs" - #1;
      "Dig" ::= struct.loadF servEpochInfo "dig" "lastInfo";
      "Sig" ::= struct.loadF servEpochInfo "sig" "lastInfo"
    ].

(* getMemb pre-cond that (uid, ver) in-bounds. *)
Definition Server__getMemb: val :=
  rec: "Server__getMemb" "s" "uid" "ver" :=
    let: ("label", "vrfProof") := compMapLabel "uid" "ver" (struct.loadF Server "vrfSk" "s") in
    let: "getReply" := merkle.Tree__Get (struct.loadF Server "keyMap" "s") "label" in
    control.impl.Assert (~ (struct.loadF merkle.GetReply "Error" "getReply"));;
    control.impl.Assert (struct.loadF merkle.GetReply "ProofTy" "getReply");;
    let: (("valPre", <>), "err0") := MapValPreDecode (struct.loadF merkle.GetReply "Val" "getReply") in
    control.impl.Assert (~ "err0");;
    let: ("open", "ok0") := MapGet (struct.loadF Server "pkCommOpens" "s") (StringFromBytes "label") in
    control.impl.Assert "ok0";;
    struct.new Memb [
      "Label" ::= "label";
      "VrfProof" ::= "vrfProof";
      "EpochAdded" ::= struct.loadF MapValPre "Epoch" "valPre";
      "CommOpen" ::= "open";
      "MerkProof" ::= struct.loadF merkle.GetReply "Proof" "getReply"
    ].

(* getLatest pre-cond that uid has some versions. *)
Definition Server__getLatest: val :=
  rec: "Server__getLatest" "s" "uid" :=
    let: "nextVer" := Fst (MapGet (struct.loadF Server "nextVers" "s") "uid") in
    control.impl.Assert ("nextVer" ≠ #0);;
    let: "latVer" := "nextVer" - #1 in
    Server__getMemb "s" "uid" "latVer".

Definition Server__getBound: val :=
  rec: "Server__getBound" "s" "uid" :=
    let: "nextVer" := Fst (MapGet (struct.loadF Server "nextVers" "s") "uid") in
    let: ("nextLabel", "nextVrfProof") := compMapLabel "uid" "nextVer" (struct.loadF Server "vrfSk" "s") in
    let: "nextReply" := merkle.Tree__Get (struct.loadF Server "keyMap" "s") "nextLabel" in
    control.impl.Assert (~ (struct.loadF merkle.GetReply "Error" "nextReply"));;
    control.impl.Assert (~ (struct.loadF merkle.GetReply "ProofTy" "nextReply"));;
    struct.new NonMemb [
      "Label" ::= "nextLabel";
      "VrfProof" ::= "nextVrfProof";
      "MerkProof" ::= struct.loadF merkle.GetReply "Proof" "nextReply"
    ].

Definition Server__Put: val :=
  rec: "Server__Put" "s" "uid" "pk" :=
    Mutex__Lock (struct.loadF Server "mu" "s");;
    let: "ver" := Fst (MapGet (struct.loadF Server "nextVers" "s") "uid") in
    let: ("label", <>) := compMapLabel "uid" "ver" (struct.loadF Server "vrfSk" "s") in
    let: "nextEpoch" := slice.len (struct.loadF Server "histInfo" "s") in
    let: ("val", "open") := genValComm "nextEpoch" "pk" in
    let: (("dig", <>), "err0") := merkle.Tree__Put (struct.loadF Server "keyMap" "s") "label" "val" in
    control.impl.Assert (~ "err0");;
    MapInsert (struct.loadF Server "pkCommOpens" "s") (StringFromBytes "label") "open";;
    MapInsert (struct.loadF Server "nextVers" "s") "uid" (std.SumAssumeNoOverflow "ver" #1);;
    let: "updates" := NewMap stringT (slice.T byteT) #() in
    MapInsert "updates" (StringFromBytes "label") "val";;
    let: "preSig" := struct.new PreSigDig [
      "Epoch" ::= "nextEpoch";
      "Dig" ::= "dig"
    ] in
    let: "preSigByt" := PreSigDigEncode (NewSlice byteT #0) "preSig" in
    let: "sig" := cryptoffi.PrivateKey__Sign (struct.loadF Server "sigSk" "s") "preSigByt" in
    let: "newInfo" := struct.new servEpochInfo [
      "updates" ::= "updates";
      "dig" ::= "dig";
      "sig" ::= "sig"
    ] in
    struct.storeF Server "histInfo" "s" (SliceAppend ptrT (struct.loadF Server "histInfo" "s") "newInfo");;
    let: "sigDig" := Server__getDig "s" in
    let: "latest" := Server__getLatest "s" "uid" in
    let: "bound" := Server__getBound "s" "uid" in
    Mutex__Unlock (struct.loadF Server "mu" "s");;
    ("sigDig", "latest", "bound").

(* SigDigEncode from serde.out.go *)

Definition SigDigEncode: val :=
  rec: "SigDigEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF SigDig "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF SigDig "Dig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF SigDig "Sig" "o"));;
    ![slice.T byteT] "b".

Definition MembEncode: val :=
  rec: "MembEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF Memb "Label" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF Memb "VrfProof" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF Memb "EpochAdded" "o"));;
    "b" <-[slice.T byteT] (PkCommOpenEncode (![slice.T byteT] "b") (struct.loadF Memb "CommOpen" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF Memb "MerkProof" "o"));;
    ![slice.T byteT] "b".

Definition NonMembEncode: val :=
  rec: "NonMembEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF NonMemb "Label" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF NonMemb "VrfProof" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF NonMemb "MerkProof" "o"));;
    ![slice.T byteT] "b".

Definition ServerPutReplyEncode: val :=
  rec: "ServerPutReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Dig" "o"));;
    "b" <-[slice.T byteT] (MembEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Latest" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Bound" "o"));;
    ![slice.T byteT] "b".

Definition ServerGetArgDecode: val :=
  rec: "ServerGetArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerGetArg [
         "Uid" ::= "a1"
       ], "b1", #false)).

(* Server__getMembHide from server.go *)

(* getMembHide pre-cond that (uid, ver) in-bounds. *)
Definition Server__getMembHide: val :=
  rec: "Server__getMembHide" "s" "uid" "ver" :=
    let: ("label", "vrfProof") := compMapLabel "uid" "ver" (struct.loadF Server "vrfSk" "s") in
    let: "getReply" := merkle.Tree__Get (struct.loadF Server "keyMap" "s") "label" in
    control.impl.Assert (~ (struct.loadF merkle.GetReply "Error" "getReply"));;
    control.impl.Assert (struct.loadF merkle.GetReply "ProofTy" "getReply");;
    struct.new MembHide [
      "Label" ::= "label";
      "VrfProof" ::= "vrfProof";
      "MapVal" ::= struct.loadF merkle.GetReply "Val" "getReply";
      "MerkProof" ::= struct.loadF merkle.GetReply "Proof" "getReply"
    ].

Definition Server__getHist: val :=
  rec: "Server__getHist" "s" "uid" :=
    let: "membs" := ref (zero_val (slice.T ptrT)) in
    let: "nextVer" := Fst (MapGet (struct.loadF Server "nextVers" "s") "uid") in
    (if: "nextVer" = #0
    then ![slice.T ptrT] "membs"
    else
      let: "latVer" := "nextVer" - #1 in
      let: "ver" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "ver") < "latVer"); (λ: <>, "ver" <-[uint64T] ((![uint64T] "ver") + #1)) := λ: <>,
        "membs" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "membs") (Server__getMembHide "s" "uid" (![uint64T] "ver")));;
        Continue);;
      ![slice.T ptrT] "membs").

(* Get rets, among others, whether the uid has been registered,
   and if so, a complete latest memb proof. *)
Definition Server__Get: val :=
  rec: "Server__Get" "s" "uid" :=
    Mutex__Lock (struct.loadF Server "mu" "s");;
    let: "dig" := Server__getDig "s" in
    let: "hist" := Server__getHist "s" "uid" in
    let: "bound" := Server__getBound "s" "uid" in
    let: "nextVer" := Fst (MapGet (struct.loadF Server "nextVers" "s") "uid") in
    (if: "nextVer" = #0
    then
      Mutex__Unlock (struct.loadF Server "mu" "s");;
      ("dig", "hist", #false, struct.new Memb [
         "CommOpen" ::= struct.new PkCommOpen [
         ]
       ], "bound")
    else
      let: "latest" := Server__getLatest "s" "uid" in
      Mutex__Unlock (struct.loadF Server "mu" "s");;
      ("dig", "hist", #true, "latest", "bound")).

(* MembHideEncode from serde.out.go *)

Definition MembHideEncode: val :=
  rec: "MembHideEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MembHide "Label" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MembHide "VrfProof" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MembHide "MapVal" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF MembHide "MerkProof" "o"));;
    ![slice.T byteT] "b".

(* MembHideSlice1DEncode from serde_misc.go *)

Definition MembHideSlice1DEncode: val :=
  rec: "MembHideSlice1DEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (slice.len "o"));;
    ForSlice ptrT <> "e" "o"
      ("b" <-[slice.T byteT] (MembHideEncode (![slice.T byteT] "b") "e"));;
    ![slice.T byteT] "b".

(* ServerGetReplyEncode from serde.out.go *)

Definition ServerGetReplyEncode: val :=
  rec: "ServerGetReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Dig" "o"));;
    "b" <-[slice.T byteT] (MembHideSlice1DEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Hist" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF ServerGetReply "IsReg" "o"));;
    "b" <-[slice.T byteT] (MembEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Latest" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Bound" "o"));;
    ![slice.T byteT] "b".

Definition ServerSelfMonArgDecode: val :=
  rec: "ServerSelfMonArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerSelfMonArg [
         "Uid" ::= "a1"
       ], "b1", #false)).

(* Server__SelfMon from server.go *)

Definition Server__SelfMon: val :=
  rec: "Server__SelfMon" "s" "uid" :=
    Mutex__Lock (struct.loadF Server "mu" "s");;
    let: "dig" := Server__getDig "s" in
    let: "bound" := Server__getBound "s" "uid" in
    Mutex__Unlock (struct.loadF Server "mu" "s");;
    ("dig", "bound").

(* ServerSelfMonReplyEncode from serde.out.go *)

Definition ServerSelfMonReplyEncode: val :=
  rec: "ServerSelfMonReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerSelfMonReply "Dig" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerSelfMonReply "Bound" "o"));;
    ![slice.T byteT] "b".

(* ServerAuditArg from serde.go *)

Definition ServerAuditArg := struct.decl [
  "Epoch" :: uint64T
].

(* ServerAuditArgDecode from serde.out.go *)

Definition ServerAuditArgDecode: val :=
  rec: "ServerAuditArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerAuditArg [
         "Epoch" ::= "a1"
       ], "b1", #false)).

(* Server__Audit from server.go *)

(* Audit returns an err on fail. *)
Definition Server__Audit: val :=
  rec: "Server__Audit" "s" "epoch" :=
    Mutex__Lock (struct.loadF Server "mu" "s");;
    (if: "epoch" ≥ (slice.len (struct.loadF Server "histInfo" "s"))
    then
      Mutex__Unlock (struct.loadF Server "mu" "s");;
      (struct.new UpdateProof [
         "Updates" ::= NewMap stringT (slice.T byteT) #()
       ], #true)
    else
      let: "info" := SliceGet ptrT (struct.loadF Server "histInfo" "s") "epoch" in
      Mutex__Unlock (struct.loadF Server "mu" "s");;
      let: "p" := struct.new UpdateProof [
        "Updates" ::= struct.loadF servEpochInfo "updates" "info";
        "Sig" ::= struct.loadF servEpochInfo "sig" "info"
      ] in
      ("p", #false)).

(* ServerAuditReply from serde.go *)

Definition ServerAuditReply := struct.decl [
  "P" :: ptrT;
  "Err" :: boolT
].

(* MapstringSlbyteEncode from serde_misc.go *)

Definition MapstringSlbyteEncode: val :=
  rec: "MapstringSlbyteEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (MapLen "o"));;
    MapIter "o" (λ: "k" "v",
      "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (StringToBytes "k"));;
      "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") "v"));;
    ![slice.T byteT] "b".

(* UpdateProofEncode from serde.out.go *)

Definition UpdateProofEncode: val :=
  rec: "UpdateProofEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (MapstringSlbyteEncode (![slice.T byteT] "b") (struct.loadF UpdateProof "Updates" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF UpdateProof "Sig" "o"));;
    ![slice.T byteT] "b".

Definition ServerAuditReplyEncode: val :=
  rec: "ServerAuditReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (UpdateProofEncode (![slice.T byteT] "b") (struct.loadF ServerAuditReply "P" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF ServerAuditReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition newRpcServer: val :=
  rec: "newRpcServer" "s" :=
    let: "h" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "h" ServerPutRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerPutArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: (("ret0", "ret1"), "ret2") := Server__Put "s" (struct.loadF ServerPutArg "Uid" "argObj") (struct.loadF ServerPutArg "Pk" "argObj") in
        let: "replyObj" := struct.new ServerPutReply [
          "Dig" ::= "ret0";
          "Latest" ::= "ret1";
          "Bound" ::= "ret2"
        ] in
        "reply" <-[slice.T byteT] (ServerPutReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerGetRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerGetArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: (((("ret0", "ret1"), "ret2"), "ret3"), "ret4") := Server__Get "s" (struct.loadF ServerGetArg "Uid" "argObj") in
        let: "replyObj" := struct.new ServerGetReply [
          "Dig" ::= "ret0";
          "Hist" ::= "ret1";
          "IsReg" ::= "ret2";
          "Latest" ::= "ret3";
          "Bound" ::= "ret4"
        ] in
        "reply" <-[slice.T byteT] (ServerGetReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerSelfMonRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerSelfMonArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Server__SelfMon "s" (struct.loadF ServerSelfMonArg "Uid" "argObj") in
        let: "replyObj" := struct.new ServerSelfMonReply [
          "Dig" ::= "ret0";
          "Bound" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (ServerSelfMonReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerAuditRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerAuditArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Server__Audit "s" (struct.loadF ServerAuditArg "Epoch" "argObj") in
        let: "replyObj" := struct.new ServerAuditReply [
          "P" ::= "ret0";
          "Err" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (ServerAuditReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    advrpc.NewServer "h".

(* MapstringSlbyteDecode from serde_misc.go *)

Definition MapstringSlbyteDecode: val :=
  rec: "MapstringSlbyteDecode" "b0" :=
    let: (("length", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: "loopO" := NewMap stringT (slice.T byteT) #() in
      let: "loopErr" := ref (zero_val boolT) in
      let: "loopB" := ref_to (slice.T byteT) "b1" in
      let: "i" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: (("a2", "loopB1"), "err2") := marshalutil.ReadSlice1D (![slice.T byteT] "loopB") in
        "loopB" <-[slice.T byteT] "loopB1";;
        (if: "err2"
        then
          "loopErr" <-[boolT] #true;;
          Break
        else
          let: (("a3", "loopB2"), "err3") := marshalutil.ReadSlice1D (![slice.T byteT] "loopB") in
          "loopB" <-[slice.T byteT] "loopB2";;
          (if: "err3"
          then
            "loopErr" <-[boolT] #true;;
            Break
          else
            MapInsert "loopO" (StringFromBytes "a2") "a3";;
            Continue)));;
      (if: ![boolT] "loopErr"
      then (slice.nil, slice.nil, #true)
      else ("loopO", ![slice.T byteT] "loopB", #false))).

(* UpdateProofDecode from serde.out.go *)

Definition UpdateProofDecode: val :=
  rec: "UpdateProofDecode" "b0" :=
    let: (("a1", "b1"), "err1") := MapstringSlbyteDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new UpdateProof [
           "Updates" ::= "a1";
           "Sig" ::= "a2"
         ], "b2", #false))).

(* AdtrUpdateArg from serde.go *)

Definition AdtrUpdateArg := struct.decl [
  "P" :: ptrT
].

(* AdtrUpdateArgDecode from serde.out.go *)

Definition AdtrUpdateArgDecode: val :=
  rec: "AdtrUpdateArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := UpdateProofDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrUpdateArg [
         "P" ::= "a1"
       ], "b1", #false)).

(* AdtrUpdateReply from serde.go *)

Definition AdtrUpdateReply := struct.decl [
  "Err" :: boolT
].

(* AdtrUpdateReplyEncode from serde.out.go *)

Definition AdtrUpdateReplyEncode: val :=
  rec: "AdtrUpdateReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF AdtrUpdateReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition AdtrGetArgDecode: val :=
  rec: "AdtrGetArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrGetArg [
         "Epoch" ::= "a1"
       ], "b1", #false)).

Definition AdtrEpochInfoEncode: val :=
  rec: "AdtrEpochInfoEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "Dig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "ServSig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "AdtrSig" "o"));;
    ![slice.T byteT] "b".

Definition AdtrGetReplyEncode: val :=
  rec: "AdtrGetReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (AdtrEpochInfoEncode (![slice.T byteT] "b") (struct.loadF AdtrGetReply "X" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF AdtrGetReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition newRpcAuditor: val :=
  rec: "newRpcAuditor" "a" :=
    let: "h" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "h" AdtrUpdateRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := AdtrUpdateArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: "ret0" := Auditor__Update "a" (struct.loadF AdtrUpdateArg "P" "argObj") in
        let: "replyObj" := struct.new AdtrUpdateReply [
          "Err" ::= "ret0"
        ] in
        "reply" <-[slice.T byteT] (AdtrUpdateReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" AdtrGetRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := AdtrGetArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Auditor__Get "a" (struct.loadF AdtrGetArg "Epoch" "argObj") in
        let: "replyObj" := struct.new AdtrGetReply [
          "X" ::= "ret0";
          "Err" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (AdtrGetReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    advrpc.NewServer "h".

Definition ServerAuditArgEncode: val :=
  rec: "ServerAuditArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerAuditArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition ServerAuditReplyDecode: val :=
  rec: "ServerAuditReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := UpdateProofDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadBool "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerAuditReply [
           "P" ::= "a1";
           "Err" ::= "a2"
         ], "b2", #false))).

Definition callServAudit: val :=
  rec: "callServAudit" "c" "epoch" :=
    let: "arg" := struct.new ServerAuditArg [
      "Epoch" ::= "epoch"
    ] in
    let: "argByt" := ServerAuditArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerAuditRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerAuditReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, #true)
      else (struct.loadF ServerAuditReply "P" "reply", struct.loadF ServerAuditReply "Err" "reply"))).

Definition AdtrUpdateArgEncode: val :=
  rec: "AdtrUpdateArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (UpdateProofEncode (![slice.T byteT] "b") (struct.loadF AdtrUpdateArg "P" "o"));;
    ![slice.T byteT] "b".

Definition AdtrUpdateReplyDecode: val :=
  rec: "AdtrUpdateReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadBool "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrUpdateReply [
         "Err" ::= "a1"
       ], "b1", #false)).

Definition callAdtrUpdate: val :=
  rec: "callAdtrUpdate" "c" "proof" :=
    let: "arg" := struct.new AdtrUpdateArg [
      "P" ::= "proof"
    ] in
    let: "argByt" := AdtrUpdateArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" AdtrUpdateRpc "argByt" "replyByt" in
    (if: "err0"
    then #true
    else
      let: (("reply", <>), "err1") := AdtrUpdateReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then #true
      else struct.loadF AdtrUpdateReply "Err" "reply")).

(* serde.go *)

(* serde.out.go *)

(* Auto-generated from spec "github.com/mit-pdos/pav/kt/serde.go"
   using compiler "github.com/mit-pdos/pav/serde". *)

Definition PreSigDigDecode: val :=
  rec: "PreSigDigDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new PreSigDig [
           "Epoch" ::= "a1";
           "Dig" ::= "a2"
         ], "b2", #false))).

Definition MapLabelPreDecode: val :=
  rec: "MapLabelPreDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadInt "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new MapLabelPre [
           "Uid" ::= "a1";
           "Ver" ::= "a2"
         ], "b2", #false))).

(* serde_misc.go *)

(* server.go *)

Definition newServer: val :=
  rec: "newServer" <> :=
    let: "mu" := newMutex #() in
    let: ("sigPk", "sigSk") := cryptoffi.GenerateKey #() in
    let: ("vrfPk", "vrfSk") := cryptoffi.VrfGenerateKey #() in
    let: "m" := struct.new merkle.Tree [
    ] in
    let: "opens" := NewMap stringT ptrT #() in
    let: "vers" := NewMap uint64T uint64T #() in
    let: "dig" := merkle.Tree__Digest "m" in
    let: "updates" := NewMap stringT (slice.T byteT) #() in
    let: "preSig" := struct.new PreSigDig [
      "Epoch" ::= #0;
      "Dig" ::= "dig"
    ] in
    let: "preSigByt" := PreSigDigEncode (NewSlice byteT #0) "preSig" in
    let: "sig" := cryptoffi.PrivateKey__Sign "sigSk" "preSigByt" in
    let: "newInfo" := struct.new servEpochInfo [
      "updates" ::= "updates";
      "dig" ::= "dig";
      "sig" ::= "sig"
    ] in
    let: "hist" := ref (zero_val (slice.T ptrT)) in
    "hist" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "hist") "newInfo");;
    (struct.new Server [
       "mu" ::= "mu";
       "sigSk" ::= "sigSk";
       "vrfSk" ::= "vrfSk";
       "keyMap" ::= "m";
       "histInfo" ::= ![slice.T ptrT] "hist";
       "pkCommOpens" ::= "opens";
       "nextVers" ::= "vers"
     ], "sigPk", "vrfPk").

(* test.go *)

Definition aliceUid : expr := #0.

Definition bobUid : expr := #1.

(* setupParams from testhelpers.go *)

Definition setupParams := struct.decl [
  "servAddr" :: uint64T;
  "servSigPk" :: cryptoffi.PublicKey;
  "servVrfPk" :: ptrT;
  "adtrAddrs" :: slice.T uint64T;
  "adtrPks" :: slice.T cryptoffi.PublicKey
].

(* alice from test.go *)

Definition alice := struct.decl [
  "cli" :: ptrT;
  "hist" :: slice.T ptrT
].

Definition bob := struct.decl [
  "cli" :: ptrT;
  "epoch" :: uint64T;
  "isReg" :: boolT;
  "alicePk" :: slice.T byteT
].

Definition alice__run: val :=
  rec: "alice__run" "a" :=
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #20); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      time.Sleep #5000000;;
      let: "pk" := SliceSingleton #(U8 1) in
      let: ("epoch", "err0") := Client__Put (struct.loadF alice "cli" "a") "pk" in
      control.impl.Assume (~ (struct.loadF clientErr "err" "err0"));;
      struct.storeF alice "hist" "a" (SliceAppend ptrT (struct.loadF alice "hist" "a") (struct.new HistEntry [
        "Epoch" ::= "epoch";
        "HistVal" ::= "pk"
      ]));;
      Continue);;
    #().

Definition bob__run: val :=
  rec: "bob__run" "b" :=
    time.Sleep #120000000;;
    let: ((("isReg", "pk"), "epoch"), "err0") := Client__Get (struct.loadF bob "cli" "b") aliceUid in
    control.impl.Assume (~ (struct.loadF clientErr "err" "err0"));;
    struct.storeF bob "epoch" "b" "epoch";;
    struct.storeF bob "isReg" "b" "isReg";;
    struct.storeF bob "alicePk" "b" "pk";;
    #().

(* mkRpcClients from testhelpers.go *)

Definition mkRpcClients: val :=
  rec: "mkRpcClients" "addrs" :=
    let: "c" := ref (zero_val (slice.T ptrT)) in
    ForSlice uint64T <> "addr" "addrs"
      (let: "cli" := advrpc.Dial "addr" in
      "c" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "c") "cli"));;
    ![slice.T ptrT] "c".

Definition updAdtrsOnce: val :=
  rec: "updAdtrsOnce" "upd" "adtrs" :=
    ForSlice ptrT <> "cli" "adtrs"
      (let: "err" := callAdtrUpdate "cli" "upd" in
      control.impl.Assume (~ "err"));;
    #().

Definition updAdtrsAll: val :=
  rec: "updAdtrsAll" "servAddr" "adtrAddrs" :=
    let: "servCli" := advrpc.Dial "servAddr" in
    let: "adtrs" := mkRpcClients "adtrAddrs" in
    let: "epoch" := ref (zero_val uint64T) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("upd", "err") := callServAudit "servCli" (![uint64T] "epoch") in
      (if: "err"
      then Break
      else
        updAdtrsOnce "upd" "adtrs";;
        "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
        Continue));;
    #().

Definition doAudits: val :=
  rec: "doAudits" "cli" "adtrAddrs" "adtrPks" :=
    let: "numAdtrs" := slice.len "adtrAddrs" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "numAdtrs"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "addr" := SliceGet uint64T "adtrAddrs" (![uint64T] "i") in
      let: "pk" := SliceGet cryptoffi.PublicKey "adtrPks" (![uint64T] "i") in
      let: "err" := Client__Audit "cli" "addr" "pk" in
      control.impl.Assume (~ (struct.loadF clientErr "err" "err"));;
      Continue);;
    #().

(* testAll from test.go *)

Definition testAll: val :=
  rec: "testAll" "setup" :=
    let: "aliceCli" := newClient aliceUid (struct.loadF setupParams "servAddr" "setup") (struct.loadF setupParams "servSigPk" "setup") (struct.loadF setupParams "servVrfPk" "setup") in
    let: "alice" := struct.new alice [
      "cli" ::= "aliceCli"
    ] in
    let: "bobCli" := newClient bobUid (struct.loadF setupParams "servAddr" "setup") (struct.loadF setupParams "servSigPk" "setup") (struct.loadF setupParams "servVrfPk" "setup") in
    let: "bob" := struct.new bob [
      "cli" ::= "bobCli"
    ] in
    let: "wg" := waitgroup.New #() in
    waitgroup.Add "wg" #1;;
    waitgroup.Add "wg" #1;;
    Fork (alice__run "alice";;
          waitgroup.Done "wg");;
    Fork (bob__run "bob";;
          waitgroup.Done "wg");;
    waitgroup.Wait "wg";;
    let: ("selfMonEp", "err0") := Client__SelfMon (struct.loadF alice "cli" "alice") in
    control.impl.Assume (~ (struct.loadF clientErr "err" "err0"));;
    control.impl.Assume ((struct.loadF bob "epoch" "bob") ≤ "selfMonEp");;
    updAdtrsAll (struct.loadF setupParams "servAddr" "setup") (struct.loadF setupParams "adtrAddrs" "setup");;
    doAudits (struct.loadF alice "cli" "alice") (struct.loadF setupParams "adtrAddrs" "setup") (struct.loadF setupParams "adtrPks" "setup");;
    doAudits (struct.loadF bob "cli" "bob") (struct.loadF setupParams "adtrAddrs" "setup") (struct.loadF setupParams "adtrPks" "setup");;
    let: ("isReg", "alicePk") := GetHist (struct.loadF alice "hist" "alice") (struct.loadF bob "epoch" "bob") in
    control.impl.Assert ("isReg" = (struct.loadF bob "isReg" "bob"));;
    (if: "isReg"
    then
      control.impl.Assert (std.BytesEqual "alicePk" (struct.loadF bob "alicePk" "bob"));;
      #()
    else #()).

(* setup from testhelpers.go *)

(* setup starts server and auditors. it's mainly a logical convenience.
   it consolidates the external parties, letting us more easily describe
   different adversary configs. *)
Definition setup: val :=
  rec: "setup" "servAddr" "adtrAddrs" :=
    let: (("serv", "servSigPk"), "servVrfPk") := newServer #() in
    let: "servRpc" := newRpcServer "serv" in
    advrpc.Server__Serve "servRpc" "servAddr";;
    let: "adtrPks" := ref (zero_val (slice.T cryptoffi.PublicKey)) in
    ForSlice uint64T <> "adtrAddr" "adtrAddrs"
      (let: ("adtr", "adtrPk") := newAuditor #() in
      let: "adtrRpc" := newRpcAuditor "adtr" in
      advrpc.Server__Serve "adtrRpc" "adtrAddr";;
      "adtrPks" <-[slice.T cryptoffi.PublicKey] (SliceAppend cryptoffi.PublicKey (![slice.T cryptoffi.PublicKey] "adtrPks") "adtrPk"));;
    time.Sleep #1000000;;
    struct.new setupParams [
      "servAddr" ::= "servAddr";
      "servSigPk" ::= "servSigPk";
      "servVrfPk" ::= "servVrfPk";
      "adtrAddrs" ::= "adtrAddrs";
      "adtrPks" ::= ![slice.T cryptoffi.PublicKey] "adtrPks"
    ].

Definition testAllFull: val :=
  rec: "testAllFull" "servAddr" "adtrAddrs" :=
    testAll (setup "servAddr" "adtrAddrs");;
    #().

(* testhelpers.go *)

End code.
