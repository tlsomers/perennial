(* autogenerated from github.com/mit-pdos/pav/kt *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.pav.advrpc.
From Goose Require github_com.mit_pdos.pav.cryptoffi.
From Goose Require github_com.mit_pdos.pav.marshalutil.
From Goose Require github_com.mit_pdos.pav.merkle.
From Goose Require github_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.

(* auditor.go *)

Definition Auditor := struct.decl [
  "mu" :: ptrT;
  "sk" :: ptrT;
  "keyMap" :: ptrT;
  "histInfo" :: slice.T ptrT
].

(* MapValPre from serde.go *)

Definition MapValPre := struct.decl [
  "Epoch" :: uint64T;
  "PkCommit" :: slice.T byteT
].

(* MapValPreDecode from serde.out.go *)

Definition MapValPreDecode: val :=
  rec: "MapValPreDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new MapValPre [
           "Epoch" ::= "a1";
           "PkCommit" ::= "a2"
         ], "b2", #false))).

Definition Auditor__checkOneUpd: val :=
  rec: "Auditor__checkOneUpd" "a" "nextEpoch" "mapLabel" "mapVal" :=
    let: "getReply" := merkle.Tree__Get (struct.loadF Auditor "keyMap" "a") "mapLabel" in
    (if: (struct.loadF merkle.GetReply "Error" "getReply") || (struct.loadF merkle.GetReply "ProofTy" "getReply")
    then #true
    else
      let: (("valPre", <>), "err1") := MapValPreDecode "mapVal" in
      (if: "err1" || ((struct.loadF MapValPre "Epoch" "valPre") ≠ "nextEpoch")
      then #true
      else #false)).

(* checkUpd checks that updates are okay to apply, and errors on fail. *)
Definition Auditor__checkUpd: val :=
  rec: "Auditor__checkUpd" "a" "upd" :=
    let: "nextEpoch" := slice.len (struct.loadF Auditor "histInfo" "a") in
    let: "err0" := ref (zero_val boolT) in
    MapIter "upd" (λ: "mapLabel" "mapVal",
      (if: Auditor__checkOneUpd "a" "nextEpoch" (StringToBytes "mapLabel") "mapVal"
      then "err0" <-[boolT] #true
      else #()));;
    ![boolT] "err0".

(* applyUpd applies updates. *)
Definition Auditor__applyUpd: val :=
  rec: "Auditor__applyUpd" "a" "upd" :=
    MapIter "upd" (λ: "label" "val",
      let: ((<>, <>), "err0") := merkle.Tree__Put (struct.loadF Auditor "keyMap" "a") (StringToBytes "label") "val" in
      control.impl.Assert (~ "err0"));;
    #().

(* UpdateProof from serde.go *)

Definition UpdateProof := struct.decl [
  "Updates" :: mapT (slice.T byteT);
  "Sig" :: slice.T byteT
].

Definition PreSigDig := struct.decl [
  "Epoch" :: uint64T;
  "Dig" :: slice.T byteT
].

(* PreSigDigEncode from serde.out.go *)

Definition PreSigDigEncode: val :=
  rec: "PreSigDigEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF PreSigDig "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF PreSigDig "Dig" "o"));;
    ![slice.T byteT] "b".

(* AdtrEpochInfo from serde.go *)

Definition AdtrEpochInfo := struct.decl [
  "Dig" :: slice.T byteT;
  "ServSig" :: slice.T byteT;
  "AdtrSig" :: slice.T byteT
].

(* Update checks new epoch updates, applies them, and rets err on fail. *)
Definition Auditor__Update: val :=
  rec: "Auditor__Update" "a" "proof" :=
    Mutex__Lock (struct.loadF Auditor "mu" "a");;
    let: "nextEpoch" := slice.len (struct.loadF Auditor "histInfo" "a") in
    (if: Auditor__checkUpd "a" (struct.loadF UpdateProof "Updates" "proof")
    then
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      #true
    else
      Auditor__applyUpd "a" (struct.loadF UpdateProof "Updates" "proof");;
      let: "dig" := merkle.Tree__Digest (struct.loadF Auditor "keyMap" "a") in
      let: "preSig" := struct.new PreSigDig [
        "Epoch" ::= "nextEpoch";
        "Dig" ::= "dig"
      ] in
      let: "preSigByt" := PreSigDigEncode (NewSlice byteT #0) "preSig" in
      let: "sig" := cryptoffi.SigPrivateKey__Sign (struct.loadF Auditor "sk" "a") "preSigByt" in
      let: "newInfo" := struct.new AdtrEpochInfo [
        "Dig" ::= "dig";
        "ServSig" ::= struct.loadF UpdateProof "Sig" "proof";
        "AdtrSig" ::= "sig"
      ] in
      struct.storeF Auditor "histInfo" "a" (SliceAppend ptrT (struct.loadF Auditor "histInfo" "a") "newInfo");;
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      #false).

(* Get returns the auditor's known link for a particular epoch,
   and errs on fail. *)
Definition Auditor__Get: val :=
  rec: "Auditor__Get" "a" "epoch" :=
    Mutex__Lock (struct.loadF Auditor "mu" "a");;
    let: "numEpochs" := slice.len (struct.loadF Auditor "histInfo" "a") in
    (if: "epoch" ≥ "numEpochs"
    then
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      (struct.new AdtrEpochInfo [
       ], #true)
    else
      let: "info" := SliceGet ptrT (struct.loadF Auditor "histInfo" "a") "epoch" in
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      ("info", #false)).

Definition NewAuditor: val :=
  rec: "NewAuditor" <> :=
    let: "mu" := newMutex #() in
    let: ("pk", "sk") := cryptoffi.SigGenerateKey #() in
    let: "m" := struct.new merkle.Tree [
    ] in
    (struct.new Auditor [
       "mu" ::= "mu";
       "sk" ::= "sk";
       "keyMap" ::= "m"
     ], "pk").

(* client.go *)

Definition Client := struct.decl [
  "uid" :: uint64T;
  "nextVer" :: uint64T;
  "servCli" :: ptrT;
  "servSigPk" :: cryptoffi.SigPublicKey;
  "servVrfPk" :: ptrT;
  "seenDigs" :: mapT ptrT;
  "nextEpoch" :: uint64T
].

(* ClientErr abstracts errors in the KT client.
   maybe there's an error. if so, maybe there's irrefutable evidence. *)
Definition ClientErr := struct.decl [
  "Evid" :: ptrT;
  "Err" :: boolT
].

(* SigDig from serde.go *)

Definition SigDig := struct.decl [
  "Epoch" :: uint64T;
  "Dig" :: slice.T byteT;
  "Sig" :: slice.T byteT
].

(* CheckSigDig from evidence.go *)

(* Check rets err if signed dig does not validate. *)
Definition CheckSigDig: val :=
  rec: "CheckSigDig" "o" "pk" :=
    let: "pre" := struct.new PreSigDig [
      "Epoch" ::= struct.loadF SigDig "Epoch" "o";
      "Dig" ::= struct.loadF SigDig "Dig" "o"
    ] in
    let: "preByt" := PreSigDigEncode (NewSlice byteT #0) "pre" in
    cryptoffi.SigPublicKey__Verify "pk" "preByt" (struct.loadF SigDig "Sig" "o").

(* Evid is evidence that the server signed two conflicting digs. *)
Definition Evid := struct.decl [
  "sigDig0" :: ptrT;
  "sigDig1" :: ptrT
].

Definition checkDig: val :=
  rec: "checkDig" "servSigPk" "seenDigs" "dig" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: "err0" := CheckSigDig "dig" "servSigPk" in
    (if: "err0"
    then "stdErr"
    else
      (if: (~ (std.SumNoOverflow (struct.loadF SigDig "Epoch" "dig") #1))
      then "stdErr"
      else
        let: ("seenDig", "ok0") := MapGet "seenDigs" (struct.loadF SigDig "Epoch" "dig") in
        (if: "ok0" && (~ (std.BytesEqual (struct.loadF SigDig "Dig" "seenDig") (struct.loadF SigDig "Dig" "dig")))
        then
          let: "evid" := struct.new Evid [
            "sigDig0" ::= "dig";
            "sigDig1" ::= "seenDig"
          ] in
          struct.new ClientErr [
            "Evid" ::= "evid";
            "Err" ::= #true
          ]
        else
          struct.new ClientErr [
            "Err" ::= #false
          ]))).

(* MapLabelPre from serde.go *)

Definition MapLabelPre := struct.decl [
  "Uid" :: uint64T;
  "Ver" :: uint64T
].

(* MapLabelPreEncode from serde.out.go *)

Definition MapLabelPreEncode: val :=
  rec: "MapLabelPreEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapLabelPre "Uid" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapLabelPre "Ver" "o"));;
    ![slice.T byteT] "b".

(* checkLabel checks the vrf proof, computes the label, and errors on fail. *)
Definition checkLabel: val :=
  rec: "checkLabel" "servVrfPk" "uid" "ver" "proof" :=
    let: "pre" := struct.new MapLabelPre [
      "Uid" ::= "uid";
      "Ver" ::= "ver"
    ] in
    let: "preByt" := MapLabelPreEncode (NewSlice byteT #0) "pre" in
    cryptoffi.VrfPublicKey__Verify "servVrfPk" "preByt" "proof".

(* Memb from serde.go *)

Definition Memb := struct.decl [
  "LabelProof" :: slice.T byteT;
  "EpochAdded" :: uint64T;
  "PkOpen" :: ptrT;
  "MerkProof" :: slice.T (slice.T (slice.T byteT))
].

Definition CommitOpen := struct.decl [
  "Val" :: slice.T byteT;
  "Rand" :: slice.T byteT
].

(* CommitOpenEncode from serde.out.go *)

Definition CommitOpenEncode: val :=
  rec: "CommitOpenEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF CommitOpen "Val" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF CommitOpen "Rand" "o"));;
    ![slice.T byteT] "b".

Definition MapValPreEncode: val :=
  rec: "MapValPreEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapValPre "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MapValPre "PkCommit" "o"));;
    ![slice.T byteT] "b".

(* compMapVal from server.go *)

(* compMapVal rets mapVal (epoch || Hash(pk || rand)). *)
Definition compMapVal: val :=
  rec: "compMapVal" "epoch" "pkOpen" :=
    let: "openByt" := CommitOpenEncode (NewSlice byteT #0) "pkOpen" in
    let: "commit" := cryptoffi.Hash "openByt" in
    let: "v" := struct.new MapValPre [
      "Epoch" ::= "epoch";
      "PkCommit" ::= "commit"
    ] in
    MapValPreEncode (NewSlice byteT #0) "v".

(* checkMemb errors on fail. *)
Definition checkMemb: val :=
  rec: "checkMemb" "servVrfPk" "uid" "ver" "dig" "memb" :=
    let: ("label", "err") := checkLabel "servVrfPk" "uid" "ver" (struct.loadF Memb "LabelProof" "memb") in
    (if: "err"
    then #true
    else
      let: "mapVal" := compMapVal (struct.loadF Memb "EpochAdded" "memb") (struct.loadF Memb "PkOpen" "memb") in
      merkle.CheckProof #true (struct.loadF Memb "MerkProof" "memb") "label" "mapVal" "dig").

(* MembHide from serde.go *)

Definition MembHide := struct.decl [
  "LabelProof" :: slice.T byteT;
  "MapVal" :: slice.T byteT;
  "MerkProof" :: slice.T (slice.T (slice.T byteT))
].

(* checkMembHide errors on fail. *)
Definition checkMembHide: val :=
  rec: "checkMembHide" "servVrfPk" "uid" "ver" "dig" "memb" :=
    let: ("label", "err") := checkLabel "servVrfPk" "uid" "ver" (struct.loadF MembHide "LabelProof" "memb") in
    (if: "err"
    then #true
    else merkle.CheckProof #true (struct.loadF MembHide "MerkProof" "memb") "label" (struct.loadF MembHide "MapVal" "memb") "dig").

(* checkHist errors on fail. *)
Definition checkHist: val :=
  rec: "checkHist" "servVrfPk" "uid" "dig" "membs" :=
    let: "err0" := ref (zero_val boolT) in
    ForSlice ptrT "ver" "memb" "membs"
      ((if: checkMembHide "servVrfPk" "uid" "ver" "dig" "memb"
      then "err0" <-[boolT] #true
      else #()));;
    ![boolT] "err0".

Definition NonMemb := struct.decl [
  "LabelProof" :: slice.T byteT;
  "MerkProof" :: slice.T (slice.T (slice.T byteT))
].

(* checkNonMemb errors on fail. *)
Definition checkNonMemb: val :=
  rec: "checkNonMemb" "servVrfPk" "uid" "ver" "dig" "nonMemb" :=
    let: ("label", "err") := checkLabel "servVrfPk" "uid" "ver" (struct.loadF NonMemb "LabelProof" "nonMemb") in
    (if: "err"
    then #true
    else merkle.CheckProof #false (struct.loadF NonMemb "MerkProof" "nonMemb") "label" slice.nil "dig").

Definition ServerPutArg := struct.decl [
  "Uid" :: uint64T;
  "Pk" :: slice.T byteT
].

(* ServerPutArgEncode from serde.out.go *)

Definition ServerPutArgEncode: val :=
  rec: "ServerPutArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerPutArg "Uid" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF ServerPutArg "Pk" "o"));;
    ![slice.T byteT] "b".

(* ServerPutRpc from rpc.go *)

Definition ServerPutRpc : expr := #0.

Definition ServerGetRpc : expr := #1.

Definition ServerSelfMonRpc : expr := #2.

Definition ServerAuditRpc : expr := #3.

Definition AdtrUpdateRpc : expr := #0.

Definition AdtrGetRpc : expr := #1.

(* SigDigDecode from serde.out.go *)

Definition SigDigDecode: val :=
  rec: "SigDigDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice1D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new SigDig [
             "Epoch" ::= "a1";
             "Dig" ::= "a2";
             "Sig" ::= "a3"
           ], "b3", #false)))).

Definition CommitOpenDecode: val :=
  rec: "CommitOpenDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new CommitOpen [
           "Val" ::= "a1";
           "Rand" ::= "a2"
         ], "b2", #false))).

Definition MembDecode: val :=
  rec: "MembDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadInt "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := CommitOpenDecode "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          let: (("a4", "b4"), "err4") := marshalutil.ReadSlice3D "b3" in
          (if: "err4"
          then (slice.nil, slice.nil, #true)
          else
            (struct.new Memb [
               "LabelProof" ::= "a1";
               "EpochAdded" ::= "a2";
               "PkOpen" ::= "a3";
               "MerkProof" ::= "a4"
             ], "b4", #false))))).

Definition NonMembDecode: val :=
  rec: "NonMembDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice3D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new NonMemb [
           "LabelProof" ::= "a1";
           "MerkProof" ::= "a2"
         ], "b2", #false))).

(* ServerPutReply from serde.go *)

Definition ServerPutReply := struct.decl [
  "Dig" :: ptrT;
  "Latest" :: ptrT;
  "Bound" :: ptrT
].

(* ServerPutReplyDecode from serde.out.go *)

Definition ServerPutReplyDecode: val :=
  rec: "ServerPutReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := MembDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := NonMembDecode "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new ServerPutReply [
             "Dig" ::= "a1";
             "Latest" ::= "a2";
             "Bound" ::= "a3"
           ], "b3", #false)))).

(* CallServPut from rpc.go *)

Definition CallServPut: val :=
  rec: "CallServPut" "c" "uid" "pk" :=
    let: "arg" := struct.new ServerPutArg [
      "Uid" ::= "uid";
      "Pk" ::= "pk"
    ] in
    let: "argByt" := ServerPutArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerPutRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerPutReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, slice.nil, #true)
      else (struct.loadF ServerPutReply "Dig" "reply", struct.loadF ServerPutReply "Latest" "reply", struct.loadF ServerPutReply "Bound" "reply", #false))).

(* Put rets the epoch at which the key was put, and evid / error on fail. *)
Definition Client__Put: val :=
  rec: "Client__Put" "c" "pk" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: ((("dig", "latest"), "bound"), "err0") := CallServPut (struct.loadF Client "servCli" "c") (struct.loadF Client "uid" "c") "pk" in
    (if: "err0"
    then (#0, "stdErr")
    else
      let: "err1" := checkDig (struct.loadF Client "servSigPk" "c") (struct.loadF Client "seenDigs" "c") "dig" in
      (if: struct.loadF ClientErr "Err" "err1"
      then (#0, "err1")
      else
        (if: (struct.loadF SigDig "Epoch" "dig") < (struct.loadF Client "nextEpoch" "c")
        then (#0, "stdErr")
        else
          (if: checkMemb (struct.loadF Client "servVrfPk" "c") (struct.loadF Client "uid" "c") (struct.loadF Client "nextVer" "c") (struct.loadF SigDig "Dig" "dig") "latest"
          then (#0, "stdErr")
          else
            (if: (struct.loadF SigDig "Epoch" "dig") ≠ (struct.loadF Memb "EpochAdded" "latest")
            then (#0, "stdErr")
            else
              (if: (~ (std.BytesEqual "pk" (struct.loadF CommitOpen "Val" (struct.loadF Memb "PkOpen" "latest"))))
              then (#0, "stdErr")
              else
                (if: checkNonMemb (struct.loadF Client "servVrfPk" "c") (struct.loadF Client "uid" "c") ((struct.loadF Client "nextVer" "c") + #1) (struct.loadF SigDig "Dig" "dig") "bound"
                then (#0, "stdErr")
                else
                  MapInsert (struct.loadF Client "seenDigs" "c") (struct.loadF SigDig "Epoch" "dig") "dig";;
                  struct.storeF Client "nextEpoch" "c" ((struct.loadF SigDig "Epoch" "dig") + #1);;
                  struct.storeF Client "nextVer" "c" (std.SumAssumeNoOverflow (struct.loadF Client "nextVer" "c") #1);;
                  (struct.loadF SigDig "Epoch" "dig", struct.new ClientErr [
                     "Err" ::= #false
                   ])))))))).

(* ServerGetArg from serde.go *)

Definition ServerGetArg := struct.decl [
  "Uid" :: uint64T
].

(* ServerGetArgEncode from serde.out.go *)

Definition ServerGetArgEncode: val :=
  rec: "ServerGetArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerGetArg "Uid" "o"));;
    ![slice.T byteT] "b".

Definition MembHideDecode: val :=
  rec: "MembHideDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice3D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new MembHide [
             "LabelProof" ::= "a1";
             "MapVal" ::= "a2";
             "MerkProof" ::= "a3"
           ], "b3", #false)))).

(* MembHideSlice1DDecode from serde_misc.go *)

Definition MembHideSlice1DDecode: val :=
  rec: "MembHideSlice1DDecode" "b0" :=
    let: (("length", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: "loopO" := ref_to (slice.T ptrT) (NewSliceWithCap ptrT #0 "length") in
      let: "loopErr" := ref (zero_val boolT) in
      let: "loopB" := ref_to (slice.T byteT) "b1" in
      let: "i" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: (("a2", "loopB1"), "err2") := MembHideDecode (![slice.T byteT] "loopB") in
        "loopB" <-[slice.T byteT] "loopB1";;
        (if: "err2"
        then
          "loopErr" <-[boolT] #true;;
          Break
        else
          "loopO" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "loopO") "a2");;
          Continue));;
      (if: ![boolT] "loopErr"
      then (slice.nil, slice.nil, #true)
      else (![slice.T ptrT] "loopO", ![slice.T byteT] "loopB", #false))).

(* ServerGetReply from serde.go *)

Definition ServerGetReply := struct.decl [
  "Dig" :: ptrT;
  "Hist" :: slice.T ptrT;
  "IsReg" :: boolT;
  "Latest" :: ptrT;
  "Bound" :: ptrT
].

(* ServerGetReplyDecode from serde.out.go *)

Definition ServerGetReplyDecode: val :=
  rec: "ServerGetReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := MembHideSlice1DDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadBool "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          let: (("a4", "b4"), "err4") := MembDecode "b3" in
          (if: "err4"
          then (slice.nil, slice.nil, #true)
          else
            let: (("a5", "b5"), "err5") := NonMembDecode "b4" in
            (if: "err5"
            then (slice.nil, slice.nil, #true)
            else
              (struct.new ServerGetReply [
                 "Dig" ::= "a1";
                 "Hist" ::= "a2";
                 "IsReg" ::= "a3";
                 "Latest" ::= "a4";
                 "Bound" ::= "a5"
               ], "b5", #false)))))).

(* CallServGet from rpc.go *)

Definition CallServGet: val :=
  rec: "CallServGet" "c" "uid" :=
    let: "arg" := struct.new ServerGetArg [
      "Uid" ::= "uid"
    ] in
    let: "argByt" := ServerGetArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerGetRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, #false, slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerGetReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, #false, slice.nil, slice.nil, #true)
      else (struct.loadF ServerGetReply "Dig" "reply", struct.loadF ServerGetReply "Hist" "reply", struct.loadF ServerGetReply "IsReg" "reply", struct.loadF ServerGetReply "Latest" "reply", struct.loadF ServerGetReply "Bound" "reply", #false))).

(* Get returns if the pk was registered, the pk, and the epoch
   at which it was seen, or an error / evid.
   Note: interaction of isReg and hist is a potential source of bugs.
   e.g., if don't track vers properly, bound could be off.
   e.g., if don't check isReg alignment with hist, could have fraud non-exis key. *)
Definition Client__Get: val :=
  rec: "Client__Get" "c" "uid" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: ((((("dig", "hist"), "isReg"), "latest"), "bound"), "err0") := CallServGet (struct.loadF Client "servCli" "c") "uid" in
    (if: "err0"
    then (#false, slice.nil, #0, "stdErr")
    else
      let: "err1" := checkDig (struct.loadF Client "servSigPk" "c") (struct.loadF Client "seenDigs" "c") "dig" in
      (if: struct.loadF ClientErr "Err" "err1"
      then (#false, slice.nil, #0, "err1")
      else
        (if: ((struct.loadF Client "nextEpoch" "c") ≠ #0) && ((struct.loadF SigDig "Epoch" "dig") < ((struct.loadF Client "nextEpoch" "c") - #1))
        then (#false, slice.nil, #0, "stdErr")
        else
          (if: checkHist (struct.loadF Client "servVrfPk" "c") "uid" (struct.loadF SigDig "Dig" "dig") "hist"
          then (#false, slice.nil, #0, "stdErr")
          else
            let: "numHistVers" := slice.len "hist" in
            (if: ("numHistVers" > #0) && (~ "isReg")
            then (#false, slice.nil, #0, "stdErr")
            else
              (if: "isReg" && (checkMemb (struct.loadF Client "servVrfPk" "c") "uid" "numHistVers" (struct.loadF SigDig "Dig" "dig") "latest")
              then (#false, slice.nil, #0, "stdErr")
              else
                let: "boundVer" := ref (zero_val uint64T) in
                (if: "isReg"
                then "boundVer" <-[uint64T] ("numHistVers" + #1)
                else #());;
                (if: checkNonMemb (struct.loadF Client "servVrfPk" "c") "uid" (![uint64T] "boundVer") (struct.loadF SigDig "Dig" "dig") "bound"
                then (#false, slice.nil, #0, "stdErr")
                else
                  MapInsert (struct.loadF Client "seenDigs" "c") (struct.loadF SigDig "Epoch" "dig") "dig";;
                  struct.storeF Client "nextEpoch" "c" ((struct.loadF SigDig "Epoch" "dig") + #1);;
                  ("isReg", struct.loadF CommitOpen "Val" (struct.loadF Memb "PkOpen" "latest"), struct.loadF SigDig "Epoch" "dig", struct.new ClientErr [
                     "Err" ::= #false
                   ])))))))).

(* ServerSelfMonArg from serde.go *)

Definition ServerSelfMonArg := struct.decl [
  "Uid" :: uint64T
].

(* ServerSelfMonArgEncode from serde.out.go *)

Definition ServerSelfMonArgEncode: val :=
  rec: "ServerSelfMonArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerSelfMonArg "Uid" "o"));;
    ![slice.T byteT] "b".

(* ServerSelfMonReply from serde.go *)

Definition ServerSelfMonReply := struct.decl [
  "Dig" :: ptrT;
  "Bound" :: ptrT
].

(* ServerSelfMonReplyDecode from serde.out.go *)

Definition ServerSelfMonReplyDecode: val :=
  rec: "ServerSelfMonReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := NonMembDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerSelfMonReply [
           "Dig" ::= "a1";
           "Bound" ::= "a2"
         ], "b2", #false))).

(* CallServSelfMon from rpc.go *)

Definition CallServSelfMon: val :=
  rec: "CallServSelfMon" "c" "uid" :=
    let: "arg" := struct.new ServerSelfMonArg [
      "Uid" ::= "uid"
    ] in
    let: "argByt" := ServerSelfMonArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerSelfMonRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerSelfMonReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, #true)
      else (struct.loadF ServerSelfMonReply "Dig" "reply", struct.loadF ServerSelfMonReply "Bound" "reply", #false))).

(* SelfMon self-monitors for the client's own key, and returns the epoch
   through which it succeeds, or evid / error on fail. *)
Definition Client__SelfMon: val :=
  rec: "Client__SelfMon" "c" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: (("dig", "bound"), "err0") := CallServSelfMon (struct.loadF Client "servCli" "c") (struct.loadF Client "uid" "c") in
    (if: "err0"
    then (#0, "stdErr")
    else
      let: "err1" := checkDig (struct.loadF Client "servSigPk" "c") (struct.loadF Client "seenDigs" "c") "dig" in
      (if: struct.loadF ClientErr "Err" "err1"
      then (#0, "err1")
      else
        (if: ((struct.loadF Client "nextEpoch" "c") ≠ #0) && ((struct.loadF SigDig "Epoch" "dig") < ((struct.loadF Client "nextEpoch" "c") - #1))
        then (#0, "stdErr")
        else
          (if: checkNonMemb (struct.loadF Client "servVrfPk" "c") (struct.loadF Client "uid" "c") (struct.loadF Client "nextVer" "c") (struct.loadF SigDig "Dig" "dig") "bound"
          then (#0, "stdErr")
          else
            MapInsert (struct.loadF Client "seenDigs" "c") (struct.loadF SigDig "Epoch" "dig") "dig";;
            struct.storeF Client "nextEpoch" "c" ((struct.loadF SigDig "Epoch" "dig") + #1);;
            (struct.loadF SigDig "Epoch" "dig", struct.new ClientErr [
               "Err" ::= #false
             ]))))).

(* AdtrGetArg from serde.go *)

Definition AdtrGetArg := struct.decl [
  "Epoch" :: uint64T
].

(* AdtrGetArgEncode from serde.out.go *)

Definition AdtrGetArgEncode: val :=
  rec: "AdtrGetArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF AdtrGetArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition AdtrEpochInfoDecode: val :=
  rec: "AdtrEpochInfoDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice1D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new AdtrEpochInfo [
             "Dig" ::= "a1";
             "ServSig" ::= "a2";
             "AdtrSig" ::= "a3"
           ], "b3", #false)))).

(* AdtrGetReply from serde.go *)

Definition AdtrGetReply := struct.decl [
  "X" :: ptrT;
  "Err" :: boolT
].

(* AdtrGetReplyDecode from serde.out.go *)

Definition AdtrGetReplyDecode: val :=
  rec: "AdtrGetReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := AdtrEpochInfoDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadBool "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new AdtrGetReply [
           "X" ::= "a1";
           "Err" ::= "a2"
         ], "b2", #false))).

(* CallAdtrGet from rpc.go *)

Definition CallAdtrGet: val :=
  rec: "CallAdtrGet" "c" "epoch" :=
    let: "arg" := struct.new AdtrGetArg [
      "Epoch" ::= "epoch"
    ] in
    let: "argByt" := AdtrGetArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" AdtrGetRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, #true)
    else
      let: (("reply", <>), "err1") := AdtrGetReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, #true)
      else (struct.loadF AdtrGetReply "X" "reply", struct.loadF AdtrGetReply "Err" "reply"))).

(* auditEpoch checks a single epoch against an auditor, and evid / error on fail. *)
Definition auditEpoch: val :=
  rec: "auditEpoch" "seenDig" "servSigPk" "adtrCli" "adtrPk" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: ("adtrInfo", "err0") := CallAdtrGet "adtrCli" (struct.loadF SigDig "Epoch" "seenDig") in
    (if: "err0"
    then "stdErr"
    else
      let: "servDig" := struct.new SigDig [
        "Epoch" ::= struct.loadF SigDig "Epoch" "seenDig";
        "Dig" ::= struct.loadF AdtrEpochInfo "Dig" "adtrInfo";
        "Sig" ::= struct.loadF AdtrEpochInfo "ServSig" "adtrInfo"
      ] in
      let: "adtrDig" := struct.new SigDig [
        "Epoch" ::= struct.loadF SigDig "Epoch" "seenDig";
        "Dig" ::= struct.loadF AdtrEpochInfo "Dig" "adtrInfo";
        "Sig" ::= struct.loadF AdtrEpochInfo "AdtrSig" "adtrInfo"
      ] in
      (if: CheckSigDig "servDig" "servSigPk"
      then "stdErr"
      else
        (if: CheckSigDig "adtrDig" "adtrPk"
        then "stdErr"
        else
          (if: (~ (std.BytesEqual (struct.loadF AdtrEpochInfo "Dig" "adtrInfo") (struct.loadF SigDig "Dig" "seenDig")))
          then
            let: "evid" := struct.new Evid [
              "sigDig0" ::= "servDig";
              "sigDig1" ::= "seenDig"
            ] in
            struct.new ClientErr [
              "Evid" ::= "evid";
              "Err" ::= #true
            ]
          else
            struct.new ClientErr [
              "Err" ::= #false
            ])))).

Definition Client__Audit: val :=
  rec: "Client__Audit" "c" "adtrAddr" "adtrPk" :=
    let: "adtrCli" := advrpc.Dial "adtrAddr" in
    let: "err0" := ref_to ptrT (struct.new ClientErr [
      "Err" ::= #false
    ]) in
    MapIter (struct.loadF Client "seenDigs" "c") (λ: <> "dig",
      let: "err1" := auditEpoch "dig" (struct.loadF Client "servSigPk" "c") "adtrCli" "adtrPk" in
      (if: struct.loadF ClientErr "Err" "err1"
      then "err0" <-[ptrT] "err1"
      else #()));;
    ![ptrT] "err0".

Definition NewClient: val :=
  rec: "NewClient" "uid" "servAddr" "servSigPk" "servVrfPk" :=
    let: "c" := advrpc.Dial "servAddr" in
    let: "pk" := cryptoffi.VrfPublicKeyDecode "servVrfPk" in
    let: "digs" := NewMap uint64T ptrT #() in
    struct.new Client [
      "uid" ::= "uid";
      "servCli" ::= "c";
      "servSigPk" ::= "servSigPk";
      "servVrfPk" ::= "pk";
      "seenDigs" ::= "digs"
    ].

(* evidence.go *)

(* Check returns an error if the evidence does not check out.
   otherwise, it proves that the server was dishonest. *)
Definition Evid__Check: val :=
  rec: "Evid__Check" "e" "servPk" :=
    let: "err0" := CheckSigDig (struct.loadF Evid "sigDig0" "e") "servPk" in
    (if: "err0"
    then #true
    else
      let: "err1" := CheckSigDig (struct.loadF Evid "sigDig1" "e") "servPk" in
      (if: "err1"
      then #true
      else
        (if: (struct.loadF SigDig "Epoch" (struct.loadF Evid "sigDig0" "e")) ≠ (struct.loadF SigDig "Epoch" (struct.loadF Evid "sigDig1" "e"))
        then #true
        else std.BytesEqual (struct.loadF SigDig "Dig" (struct.loadF Evid "sigDig0" "e")) (struct.loadF SigDig "Dig" (struct.loadF Evid "sigDig1" "e"))))).

(* history.go *)

Definition HistEntry := struct.decl [
  "Epoch" :: uint64T;
  "HistVal" :: slice.T byteT
].

(* GetHist searches hist at the epoch and rets the latest val, or false
   if there's no registered val. *)
Definition GetHist: val :=
  rec: "GetHist" "o" "epoch" :=
    let: "isReg" := ref (zero_val boolT) in
    let: "val" := ref (zero_val (slice.T byteT)) in
    ForSlice ptrT <> "e" "o"
      ((if: (struct.loadF HistEntry "Epoch" "e") ≤ "epoch"
      then
        "isReg" <-[boolT] #true;;
        "val" <-[slice.T byteT] (struct.loadF HistEntry "HistVal" "e")
      else #()));;
    (![boolT] "isReg", ![slice.T byteT] "val").

(* rpc.go *)

(* ServerPutArgDecode from serde.out.go *)

Definition ServerPutArgDecode: val :=
  rec: "ServerPutArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerPutArg [
           "Uid" ::= "a1";
           "Pk" ::= "a2"
         ], "b2", #false))).

(* Server from server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "sigSk" :: ptrT;
  "vrfSk" :: ptrT;
  "keyMap" :: ptrT;
  "histInfo" :: slice.T ptrT;
  "pkCommOpens" :: mapT ptrT;
  "labelCache" :: mapT (slice.T ptrT)
].

(* compMapLabel rets mapLabel (VRF(uid || ver)) and a VRF proof. *)
Definition compMapLabel: val :=
  rec: "compMapLabel" "uid" "ver" "sk" :=
    let: "l" := struct.new MapLabelPre [
      "Uid" ::= "uid";
      "Ver" ::= "ver"
    ] in
    let: "lByt" := MapLabelPreEncode (NewSlice byteT #0) "l" in
    let: ("h", "p") := cryptoffi.VrfPrivateKey__Hash "sk" "lByt" in
    ("h", "p").

Definition vrfCache := struct.decl [
  "hash" :: slice.T byteT;
  "proof" :: slice.T byteT
].

(* getUidLabelCache gets the label cache for a particular uid,
   guaranteeing ≥1 cached versions. *)
Definition getUidLabelCache: val :=
  rec: "getUidLabelCache" "cache" "uid" "sk" :=
    let: ("labels", "ok") := MapGet "cache" "uid" in
    (if: "ok"
    then
      control.impl.Assert ((slice.len "labels") ≥ #1);;
      "labels"
    else
      let: ("label", "proof") := compMapLabel "uid" #0 "sk" in
      let: "init" := SliceSingleton (struct.mk vrfCache [
        "hash" ::= "label";
        "proof" ::= "proof"
      ]) in
      MapInsert "cache" "uid" "init";;
      "init").

(* genCommitOpen generates a commitment opening for val. *)
Definition genCommitOpen: val :=
  rec: "genCommitOpen" "val" :=
    let: "r" := cryptoffi.RandBytes (#2 * cryptoffi.HashLen) in
    struct.new CommitOpen [
      "Val" ::= "val";
      "Rand" ::= "r"
    ].

Definition servEpochInfo := struct.decl [
  "updates" :: mapT (slice.T byteT);
  "dig" :: slice.T byteT;
  "sig" :: slice.T byteT
].

(* updHist updates hist at a particular epoch with some new entries
   and a new dig, signing the update with sk. *)
Definition updHist: val :=
  rec: "updHist" "hist" "epoch" "upd" "dig" "sk" :=
    let: "preSig" := struct.new PreSigDig [
      "Epoch" ::= "epoch";
      "Dig" ::= "dig"
    ] in
    let: "preSigByt" := PreSigDigEncode (NewSlice byteT #0) "preSig" in
    let: "sig" := cryptoffi.SigPrivateKey__Sign "sk" "preSigByt" in
    let: "newInfo" := struct.new servEpochInfo [
      "updates" ::= "upd";
      "dig" ::= "dig";
      "sig" ::= "sig"
    ] in
    (SliceAppend ptrT "hist" "newInfo", struct.new SigDig [
       "Epoch" ::= "epoch";
       "Dig" ::= "dig";
       "Sig" ::= "sig"
     ]).

Definition Server__Put: val :=
  rec: "Server__Put" "s" "uid" "pk" :=
    Mutex__Lock (struct.loadF Server "mu" "s");;
    let: "labels" := getUidLabelCache (struct.loadF Server "labelCache" "s") "uid" (struct.loadF Server "vrfSk" "s") in
    let: "boundVer" := slice.len "labels" in
    let: "latLabel" := SliceGet ptrT "labels" ("boundVer" - #1) in
    let: ("boundLabel", "boundLabelProof") := compMapLabel "uid" "boundVer" (struct.loadF Server "vrfSk" "s") in
    MapInsert (struct.loadF Server "labelCache" "s") "uid" (SliceAppend ptrT "labels" (struct.new vrfCache [
      "hash" ::= "boundLabel";
      "proof" ::= "boundLabelProof"
    ]));;
    let: "nextEpoch" := slice.len (struct.loadF Server "histInfo" "s") in
    let: "open" := genCommitOpen "pk" in
    MapInsert (struct.loadF Server "pkCommOpens" "s") (StringFromBytes (struct.loadF vrfCache "hash" "latLabel")) "open";;
    let: "mapVal" := compMapVal "nextEpoch" "open" in
    let: (("dig", "latestProof"), "err0") := merkle.Tree__Put (struct.loadF Server "keyMap" "s") (struct.loadF vrfCache "hash" "latLabel") "mapVal" in
    control.impl.Assert (~ "err0");;
    let: "latest" := struct.new Memb [
      "LabelProof" ::= struct.loadF vrfCache "proof" "latLabel";
      "EpochAdded" ::= "nextEpoch";
      "PkOpen" ::= "open";
      "MerkProof" ::= "latestProof"
    ] in
    let: "upd" := NewMap stringT (slice.T byteT) #() in
    MapInsert "upd" (StringFromBytes (struct.loadF vrfCache "hash" "latLabel")) "mapVal";;
    let: ("newHist", "sigDig") := updHist (struct.loadF Server "histInfo" "s") "nextEpoch" "upd" "dig" (struct.loadF Server "sigSk" "s") in
    struct.storeF Server "histInfo" "s" "newHist";;
    let: "boundReply" := merkle.Tree__Get (struct.loadF Server "keyMap" "s") "boundLabel" in
    control.impl.Assert (~ (struct.loadF merkle.GetReply "Error" "boundReply"));;
    control.impl.Assert (~ (struct.loadF merkle.GetReply "ProofTy" "boundReply"));;
    let: "bound" := struct.new NonMemb [
      "LabelProof" ::= "boundLabelProof";
      "MerkProof" ::= struct.loadF merkle.GetReply "Proof" "boundReply"
    ] in
    Mutex__Unlock (struct.loadF Server "mu" "s");;
    ("sigDig", "latest", "bound").

(* SigDigEncode from serde.out.go *)

Definition SigDigEncode: val :=
  rec: "SigDigEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF SigDig "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF SigDig "Dig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF SigDig "Sig" "o"));;
    ![slice.T byteT] "b".

Definition MembEncode: val :=
  rec: "MembEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF Memb "LabelProof" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF Memb "EpochAdded" "o"));;
    "b" <-[slice.T byteT] (CommitOpenEncode (![slice.T byteT] "b") (struct.loadF Memb "PkOpen" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF Memb "MerkProof" "o"));;
    ![slice.T byteT] "b".

Definition NonMembEncode: val :=
  rec: "NonMembEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF NonMemb "LabelProof" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF NonMemb "MerkProof" "o"));;
    ![slice.T byteT] "b".

Definition ServerPutReplyEncode: val :=
  rec: "ServerPutReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Dig" "o"));;
    "b" <-[slice.T byteT] (MembEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Latest" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Bound" "o"));;
    ![slice.T byteT] "b".

Definition ServerGetArgDecode: val :=
  rec: "ServerGetArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerGetArg [
         "Uid" ::= "a1"
       ], "b1", #false)).

(* getDig from server.go *)

Definition getDig: val :=
  rec: "getDig" "hist" :=
    let: "numEpochs" := slice.len "hist" in
    let: "lastInfo" := SliceGet ptrT "hist" ("numEpochs" - #1) in
    struct.new SigDig [
      "Epoch" ::= "numEpochs" - #1;
      "Dig" ::= struct.loadF servEpochInfo "dig" "lastInfo";
      "Sig" ::= struct.loadF servEpochInfo "sig" "lastInfo"
    ].

Definition getHist: val :=
  rec: "getHist" "keyMap" "labels" :=
    let: "numRegVers" := (slice.len "labels") - #1 in
    (if: "numRegVers" = #0
    then slice.nil
    else
      let: "hist" := ref_to (slice.T ptrT) (NewSliceWithCap ptrT #0 ("numRegVers" - #1)) in
      let: "ver" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "ver") < ("numRegVers" - #1)); (λ: <>, "ver" <-[uint64T] ((![uint64T] "ver") + #1)) := λ: <>,
        let: "label" := SliceGet ptrT "labels" (![uint64T] "ver") in
        let: "reply" := merkle.Tree__Get "keyMap" (struct.loadF vrfCache "hash" "label") in
        control.impl.Assert (~ (struct.loadF merkle.GetReply "Error" "reply"));;
        control.impl.Assert (struct.loadF merkle.GetReply "ProofTy" "reply");;
        "hist" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "hist") (struct.new MembHide [
          "LabelProof" ::= struct.loadF vrfCache "proof" "label";
          "MapVal" ::= struct.loadF merkle.GetReply "Val" "reply";
          "MerkProof" ::= struct.loadF merkle.GetReply "Proof" "reply"
        ]));;
        Continue);;
      ![slice.T ptrT] "hist").

(* getLatest returns whether a val was registered, and if so, a merkle proof. *)
Definition getLatest: val :=
  rec: "getLatest" "keyMap" "labels" "opens" :=
    let: "numRegVers" := (slice.len "labels") - #1 in
    (if: "numRegVers" = #0
    then
      (#false, struct.new Memb [
         "PkOpen" ::= struct.new CommitOpen [
         ]
       ])
    else
      let: "label" := SliceGet ptrT "labels" ("numRegVers" - #1) in
      let: "reply" := merkle.Tree__Get "keyMap" (struct.loadF vrfCache "hash" "label") in
      control.impl.Assert (~ (struct.loadF merkle.GetReply "Error" "reply"));;
      control.impl.Assert (struct.loadF merkle.GetReply "ProofTy" "reply");;
      let: (("valPre", <>), "err0") := MapValPreDecode (struct.loadF merkle.GetReply "Val" "reply") in
      control.impl.Assert (~ "err0");;
      let: ("open", "ok0") := MapGet "opens" (StringFromBytes (struct.loadF vrfCache "hash" "label")) in
      control.impl.Assert "ok0";;
      (#true, struct.new Memb [
         "LabelProof" ::= struct.loadF vrfCache "proof" "label";
         "EpochAdded" ::= struct.loadF MapValPre "Epoch" "valPre";
         "PkOpen" ::= "open";
         "MerkProof" ::= struct.loadF merkle.GetReply "Proof" "reply"
       ])).

Definition getBound: val :=
  rec: "getBound" "keyMap" "labels" :=
    let: "boundVer" := (slice.len "labels") - #1 in
    let: "label" := SliceGet ptrT "labels" "boundVer" in
    let: "reply" := merkle.Tree__Get "keyMap" (struct.loadF vrfCache "hash" "label") in
    control.impl.Assert (~ (struct.loadF merkle.GetReply "Error" "reply"));;
    control.impl.Assert (~ (struct.loadF merkle.GetReply "ProofTy" "reply"));;
    struct.new NonMemb [
      "LabelProof" ::= struct.loadF vrfCache "proof" "label";
      "MerkProof" ::= struct.loadF merkle.GetReply "Proof" "reply"
    ].

(* Get returns a complete history proof for the uid.
   if the uid is not yet registered, it returns a trivial memb proof for
   for the latest version. *)
Definition Server__Get: val :=
  rec: "Server__Get" "s" "uid" :=
    Mutex__Lock (struct.loadF Server "mu" "s");;
    let: "dig" := getDig (struct.loadF Server "histInfo" "s") in
    let: "labels" := getUidLabelCache (struct.loadF Server "labelCache" "s") "uid" (struct.loadF Server "vrfSk" "s") in
    let: "hist" := getHist (struct.loadF Server "keyMap" "s") "labels" in
    let: ("isReg", "latest") := getLatest (struct.loadF Server "keyMap" "s") "labels" (struct.loadF Server "pkCommOpens" "s") in
    let: "bound" := getBound (struct.loadF Server "keyMap" "s") "labels" in
    Mutex__Unlock (struct.loadF Server "mu" "s");;
    ("dig", "hist", "isReg", "latest", "bound").

(* MembHideEncode from serde.out.go *)

Definition MembHideEncode: val :=
  rec: "MembHideEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MembHide "LabelProof" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MembHide "MapVal" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice3D (![slice.T byteT] "b") (struct.loadF MembHide "MerkProof" "o"));;
    ![slice.T byteT] "b".

(* MembHideSlice1DEncode from serde_misc.go *)

Definition MembHideSlice1DEncode: val :=
  rec: "MembHideSlice1DEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (slice.len "o"));;
    ForSlice ptrT <> "e" "o"
      ("b" <-[slice.T byteT] (MembHideEncode (![slice.T byteT] "b") "e"));;
    ![slice.T byteT] "b".

(* ServerGetReplyEncode from serde.out.go *)

Definition ServerGetReplyEncode: val :=
  rec: "ServerGetReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Dig" "o"));;
    "b" <-[slice.T byteT] (MembHideSlice1DEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Hist" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF ServerGetReply "IsReg" "o"));;
    "b" <-[slice.T byteT] (MembEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Latest" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Bound" "o"));;
    ![slice.T byteT] "b".

Definition ServerSelfMonArgDecode: val :=
  rec: "ServerSelfMonArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerSelfMonArg [
         "Uid" ::= "a1"
       ], "b1", #false)).

(* Server__SelfMon from server.go *)

Definition Server__SelfMon: val :=
  rec: "Server__SelfMon" "s" "uid" :=
    Mutex__Lock (struct.loadF Server "mu" "s");;
    let: "dig" := getDig (struct.loadF Server "histInfo" "s") in
    let: "labels" := getUidLabelCache (struct.loadF Server "labelCache" "s") "uid" (struct.loadF Server "vrfSk" "s") in
    let: "bound" := getBound (struct.loadF Server "keyMap" "s") "labels" in
    Mutex__Unlock (struct.loadF Server "mu" "s");;
    ("dig", "bound").

(* ServerSelfMonReplyEncode from serde.out.go *)

Definition ServerSelfMonReplyEncode: val :=
  rec: "ServerSelfMonReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerSelfMonReply "Dig" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerSelfMonReply "Bound" "o"));;
    ![slice.T byteT] "b".

(* ServerAuditArg from serde.go *)

Definition ServerAuditArg := struct.decl [
  "Epoch" :: uint64T
].

(* ServerAuditArgDecode from serde.out.go *)

Definition ServerAuditArgDecode: val :=
  rec: "ServerAuditArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerAuditArg [
         "Epoch" ::= "a1"
       ], "b1", #false)).

(* Server__Audit from server.go *)

(* Audit returns an err on fail. *)
Definition Server__Audit: val :=
  rec: "Server__Audit" "s" "epoch" :=
    Mutex__Lock (struct.loadF Server "mu" "s");;
    (if: "epoch" ≥ (slice.len (struct.loadF Server "histInfo" "s"))
    then
      Mutex__Unlock (struct.loadF Server "mu" "s");;
      (struct.new UpdateProof [
         "Updates" ::= NewMap stringT (slice.T byteT) #()
       ], #true)
    else
      let: "info" := SliceGet ptrT (struct.loadF Server "histInfo" "s") "epoch" in
      Mutex__Unlock (struct.loadF Server "mu" "s");;
      (struct.new UpdateProof [
         "Updates" ::= struct.loadF servEpochInfo "updates" "info";
         "Sig" ::= struct.loadF servEpochInfo "sig" "info"
       ], #false)).

(* ServerAuditReply from serde.go *)

Definition ServerAuditReply := struct.decl [
  "P" :: ptrT;
  "Err" :: boolT
].

(* MapstringSlbyteEncode from serde_misc.go *)

Definition MapstringSlbyteEncode: val :=
  rec: "MapstringSlbyteEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (MapLen "o"));;
    MapIter "o" (λ: "k" "v",
      "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (StringToBytes "k"));;
      "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") "v"));;
    ![slice.T byteT] "b".

(* UpdateProofEncode from serde.out.go *)

Definition UpdateProofEncode: val :=
  rec: "UpdateProofEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (MapstringSlbyteEncode (![slice.T byteT] "b") (struct.loadF UpdateProof "Updates" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF UpdateProof "Sig" "o"));;
    ![slice.T byteT] "b".

Definition ServerAuditReplyEncode: val :=
  rec: "ServerAuditReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (UpdateProofEncode (![slice.T byteT] "b") (struct.loadF ServerAuditReply "P" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF ServerAuditReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition NewRpcServer: val :=
  rec: "NewRpcServer" "s" :=
    let: "h" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "h" ServerPutRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerPutArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: (("ret0", "ret1"), "ret2") := Server__Put "s" (struct.loadF ServerPutArg "Uid" "argObj") (struct.loadF ServerPutArg "Pk" "argObj") in
        let: "replyObj" := struct.new ServerPutReply [
          "Dig" ::= "ret0";
          "Latest" ::= "ret1";
          "Bound" ::= "ret2"
        ] in
        "reply" <-[slice.T byteT] (ServerPutReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerGetRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerGetArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: (((("ret0", "ret1"), "ret2"), "ret3"), "ret4") := Server__Get "s" (struct.loadF ServerGetArg "Uid" "argObj") in
        let: "replyObj" := struct.new ServerGetReply [
          "Dig" ::= "ret0";
          "Hist" ::= "ret1";
          "IsReg" ::= "ret2";
          "Latest" ::= "ret3";
          "Bound" ::= "ret4"
        ] in
        "reply" <-[slice.T byteT] (ServerGetReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerSelfMonRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerSelfMonArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Server__SelfMon "s" (struct.loadF ServerSelfMonArg "Uid" "argObj") in
        let: "replyObj" := struct.new ServerSelfMonReply [
          "Dig" ::= "ret0";
          "Bound" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (ServerSelfMonReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerAuditRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerAuditArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Server__Audit "s" (struct.loadF ServerAuditArg "Epoch" "argObj") in
        let: "replyObj" := struct.new ServerAuditReply [
          "P" ::= "ret0";
          "Err" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (ServerAuditReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    advrpc.NewServer "h".

(* MapstringSlbyteDecode from serde_misc.go *)

Definition MapstringSlbyteDecode: val :=
  rec: "MapstringSlbyteDecode" "b0" :=
    let: (("length", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: "loopO" := NewMap stringT (slice.T byteT) #() in
      let: "loopErr" := ref (zero_val boolT) in
      let: "loopB" := ref_to (slice.T byteT) "b1" in
      let: "i" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: (("a2", "loopB1"), "err2") := marshalutil.ReadSlice1D (![slice.T byteT] "loopB") in
        "loopB" <-[slice.T byteT] "loopB1";;
        (if: "err2"
        then
          "loopErr" <-[boolT] #true;;
          Break
        else
          let: (("a3", "loopB2"), "err3") := marshalutil.ReadSlice1D (![slice.T byteT] "loopB") in
          "loopB" <-[slice.T byteT] "loopB2";;
          (if: "err3"
          then
            "loopErr" <-[boolT] #true;;
            Break
          else
            MapInsert "loopO" (StringFromBytes "a2") "a3";;
            Continue)));;
      (if: ![boolT] "loopErr"
      then (slice.nil, slice.nil, #true)
      else ("loopO", ![slice.T byteT] "loopB", #false))).

(* UpdateProofDecode from serde.out.go *)

Definition UpdateProofDecode: val :=
  rec: "UpdateProofDecode" "b0" :=
    let: (("a1", "b1"), "err1") := MapstringSlbyteDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new UpdateProof [
           "Updates" ::= "a1";
           "Sig" ::= "a2"
         ], "b2", #false))).

(* AdtrUpdateArg from serde.go *)

Definition AdtrUpdateArg := struct.decl [
  "P" :: ptrT
].

(* AdtrUpdateArgDecode from serde.out.go *)

Definition AdtrUpdateArgDecode: val :=
  rec: "AdtrUpdateArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := UpdateProofDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrUpdateArg [
         "P" ::= "a1"
       ], "b1", #false)).

(* AdtrUpdateReply from serde.go *)

Definition AdtrUpdateReply := struct.decl [
  "Err" :: boolT
].

(* AdtrUpdateReplyEncode from serde.out.go *)

Definition AdtrUpdateReplyEncode: val :=
  rec: "AdtrUpdateReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF AdtrUpdateReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition AdtrGetArgDecode: val :=
  rec: "AdtrGetArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrGetArg [
         "Epoch" ::= "a1"
       ], "b1", #false)).

Definition AdtrEpochInfoEncode: val :=
  rec: "AdtrEpochInfoEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "Dig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "ServSig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "AdtrSig" "o"));;
    ![slice.T byteT] "b".

Definition AdtrGetReplyEncode: val :=
  rec: "AdtrGetReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (AdtrEpochInfoEncode (![slice.T byteT] "b") (struct.loadF AdtrGetReply "X" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF AdtrGetReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition NewRpcAuditor: val :=
  rec: "NewRpcAuditor" "a" :=
    let: "h" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "h" AdtrUpdateRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := AdtrUpdateArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: "ret0" := Auditor__Update "a" (struct.loadF AdtrUpdateArg "P" "argObj") in
        let: "replyObj" := struct.new AdtrUpdateReply [
          "Err" ::= "ret0"
        ] in
        "reply" <-[slice.T byteT] (AdtrUpdateReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" AdtrGetRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := AdtrGetArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Auditor__Get "a" (struct.loadF AdtrGetArg "Epoch" "argObj") in
        let: "replyObj" := struct.new AdtrGetReply [
          "X" ::= "ret0";
          "Err" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (AdtrGetReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    advrpc.NewServer "h".

Definition ServerAuditArgEncode: val :=
  rec: "ServerAuditArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerAuditArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition ServerAuditReplyDecode: val :=
  rec: "ServerAuditReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := UpdateProofDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadBool "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerAuditReply [
           "P" ::= "a1";
           "Err" ::= "a2"
         ], "b2", #false))).

Definition CallServAudit: val :=
  rec: "CallServAudit" "c" "epoch" :=
    let: "arg" := struct.new ServerAuditArg [
      "Epoch" ::= "epoch"
    ] in
    let: "argByt" := ServerAuditArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerAuditRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerAuditReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, #true)
      else (struct.loadF ServerAuditReply "P" "reply", struct.loadF ServerAuditReply "Err" "reply"))).

Definition AdtrUpdateArgEncode: val :=
  rec: "AdtrUpdateArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (UpdateProofEncode (![slice.T byteT] "b") (struct.loadF AdtrUpdateArg "P" "o"));;
    ![slice.T byteT] "b".

Definition AdtrUpdateReplyDecode: val :=
  rec: "AdtrUpdateReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadBool "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrUpdateReply [
         "Err" ::= "a1"
       ], "b1", #false)).

Definition CallAdtrUpdate: val :=
  rec: "CallAdtrUpdate" "c" "proof" :=
    let: "arg" := struct.new AdtrUpdateArg [
      "P" ::= "proof"
    ] in
    let: "argByt" := AdtrUpdateArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" AdtrUpdateRpc "argByt" "replyByt" in
    (if: "err0"
    then #true
    else
      let: (("reply", <>), "err1") := AdtrUpdateReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then #true
      else struct.loadF AdtrUpdateReply "Err" "reply")).

(* serde.go *)

(* serde.out.go *)

(* Auto-generated from spec "github.com/mit-pdos/pav/kt/serde.go"
   using compiler "github.com/mit-pdos/pav/serde". *)

Definition PreSigDigDecode: val :=
  rec: "PreSigDigDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new PreSigDig [
           "Epoch" ::= "a1";
           "Dig" ::= "a2"
         ], "b2", #false))).

Definition MapLabelPreDecode: val :=
  rec: "MapLabelPreDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadInt "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new MapLabelPre [
           "Uid" ::= "a1";
           "Ver" ::= "a2"
         ], "b2", #false))).

(* serde_misc.go *)

(* server.go *)

Definition NewServer: val :=
  rec: "NewServer" <> :=
    let: "mu" := newMutex #() in
    let: ("sigPk", "sigSk") := cryptoffi.SigGenerateKey #() in
    let: ("vrfPk", "vrfSk") := cryptoffi.VrfGenerateKey #() in
    let: "m" := struct.new merkle.Tree [
    ] in
    let: ("hist", <>) := updHist slice.nil #0 (NewMap stringT (slice.T byteT) #()) (merkle.Tree__Digest "m") "sigSk" in
    let: "opens" := NewMap stringT ptrT #() in
    let: "labelCache" := NewMap uint64T (slice.T ptrT) #() in
    (struct.new Server [
       "mu" ::= "mu";
       "sigSk" ::= "sigSk";
       "vrfSk" ::= "vrfSk";
       "keyMap" ::= "m";
       "histInfo" ::= "hist";
       "pkCommOpens" ::= "opens";
       "labelCache" ::= "labelCache"
     ], "sigPk", "vrfPk").

End code.
