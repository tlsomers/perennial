(* autogenerated from github.com/mit-pdos/tulip/util *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.

Definition NextAligned: val :=
  rec: "NextAligned" "current" "interval" "low" :=
    let: "delta" := ref (zero_val uint64T) in
    let: "rem" := "current" `rem` "interval" in
    (if: "rem" < "low"
    then "delta" <-[uint64T] ("low" - "rem")
    else "delta" <-[uint64T] (("interval" + "low") - "rem"));;
    std.SumAssumeNoOverflow "current" (![uint64T] "delta").

Definition swap: val :=
  rec: "swap" "ns" "i" "j" :=
    let: "tmp" := SliceGet uint64T "ns" "i" in
    SliceSet uint64T "ns" "i" (SliceGet uint64T "ns" "j");;
    SliceSet uint64T "ns" "j" "tmp";;
    #().

Definition Sort: val :=
  rec: "Sort" "ns" :=
    let: "i" := ref_to uint64T #1 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (slice.len "ns")); (λ: <>, Skip) := λ: <>,
      let: "j" := ref_to uint64T (![uint64T] "i") in
      Skip;;
      (for: (λ: <>, (![uint64T] "j") > #0); (λ: <>, Skip) := λ: <>,
        (if: (SliceGet uint64T "ns" ((![uint64T] "j") - #1)) ≤ (SliceGet uint64T "ns" (![uint64T] "j"))
        then Break
        else
          swap "ns" ((![uint64T] "j") - #1) (![uint64T] "j");;
          "j" <-[uint64T] ((![uint64T] "j") - #1);;
          Continue));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    #().

Definition CountBoolMap: val :=
  rec: "CountBoolMap" "m" "b" :=
    let: "n" := ref_to uint64T #0 in
    MapIter "m" (λ: <> "v",
      (if: "v" = "b"
      then "n" <-[uint64T] (std.SumAssumeNoOverflow (![uint64T] "n") #1)
      else #()));;
    ![uint64T] "n".

Definition EncodeString: val :=
  rec: "EncodeString" "bs" "str" :=
    let: "bs1" := marshal.WriteInt "bs" (StringLength "str") in
    let: "data" := marshal.WriteBytes "bs1" (StringToBytes "str") in
    "data".

Definition EncodeStrings: val :=
  rec: "EncodeStrings" "bs" "strs" :=
    let: "data" := ref_to (slice.T byteT) (marshal.WriteInt "bs" (slice.len "strs")) in
    ForSlice stringT <> "s" "strs"
      ("data" <-[slice.T byteT] (EncodeString (![slice.T byteT] "data") "s"));;
    ![slice.T byteT] "data".

Definition DecodeString: val :=
  rec: "DecodeString" "bs" :=
    let: ("sz", "bs1") := marshal.ReadInt "bs" in
    let: ("bsr", "data") := marshal.ReadBytes "bs1" "sz" in
    (StringFromBytes "bsr", "data").

Definition DecodeStrings: val :=
  rec: "DecodeStrings" "bs" :=
    let: ("n", "bs1") := marshal.ReadInt "bs" in
    let: "data" := ref_to (slice.T byteT) "bs1" in
    let: "ents" := ref_to (slice.T stringT) (NewSliceWithCap stringT #0 "n") in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, Skip) := λ: <>,
      let: ("s", "bsloop") := DecodeString (![slice.T byteT] "data") in
      "ents" <-[slice.T stringT] (SliceAppend stringT (![slice.T stringT] "ents") "s");;
      "data" <-[slice.T byteT] "bsloop";;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    (![slice.T stringT] "ents", ![slice.T byteT] "data").

End code.
