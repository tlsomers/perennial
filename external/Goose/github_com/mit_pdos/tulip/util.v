(* autogenerated from github.com/mit-pdos/tulip/util *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.

Definition NextAligned: val :=
  rec: "NextAligned" "current" "interval" "low" :=
    let: "delta" := ref (zero_val uint64T) in
    let: "rem" := "current" `rem` "interval" in
    (if: "rem" < "low"
    then "delta" <-[uint64T] ("low" - "rem")
    else "delta" <-[uint64T] (("interval" + "low") - "rem"));;
    std.SumAssumeNoOverflow "current" (![uint64T] "delta").

Definition swap: val :=
  rec: "swap" "ns" "i" "j" :=
    let: "tmp" := SliceGet uint64T "ns" "i" in
    SliceSet uint64T "ns" "i" (SliceGet uint64T "ns" "j");;
    SliceSet uint64T "ns" "j" "tmp";;
    #().

Definition Sort: val :=
  rec: "Sort" "ns" :=
    let: "i" := ref_to uint64T #1 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (slice.len "ns")); (λ: <>, Skip) := λ: <>,
      let: "j" := ref_to uint64T (![uint64T] "i") in
      Skip;;
      (for: (λ: <>, (![uint64T] "j") > #0); (λ: <>, Skip) := λ: <>,
        (if: (SliceGet uint64T "ns" ((![uint64T] "j") - #1)) ≤ (SliceGet uint64T "ns" (![uint64T] "j"))
        then Break
        else
          swap "ns" ((![uint64T] "j") - #1) (![uint64T] "j");;
          "j" <-[uint64T] ((![uint64T] "j") - #1);;
          Continue));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    #().

Definition EncodeString: val :=
  rec: "EncodeString" "bs" "str" :=
    let: "data" := ref_to (slice.T byteT) "bs" in
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") (StringLength "str"));;
    "data" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "data") (StringToBytes "str"));;
    ![slice.T byteT] "data".

Definition EncodeStrings: val :=
  rec: "EncodeStrings" "bs" "strs" :=
    let: "data" := ref_to (slice.T byteT) "bs" in
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") (slice.len "strs"));;
    ForSlice stringT <> "s" "strs"
      ("data" <-[slice.T byteT] (EncodeString (![slice.T byteT] "data") "s"));;
    ![slice.T byteT] "data".

Definition DecodeString: val :=
  rec: "DecodeString" "bs" :=
    let: "data" := ref_to (slice.T byteT) "bs" in
    let: ("sz", "data") := marshal.ReadInt (![slice.T byteT] "data") in
    let: ("bsr", "data") := marshal.ReadBytes (![slice.T byteT] "data") "sz" in
    (StringFromBytes "bsr", ![slice.T byteT] "data").

Definition DecodeStrings: val :=
  rec: "DecodeStrings" "bs" :=
    let: "data" := ref_to (slice.T byteT) "bs" in
    let: ("n", "data") := marshal.ReadInt (![slice.T byteT] "data") in
    let: "ents" := ref_to (slice.T stringT) (NewSliceWithCap stringT #0 "n") in
    let: "i" := ref_to uint64T #0 in
    let: "s" := ref (zero_val stringT) in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, Skip) := λ: <>,
      let: ("0_ret", "1_ret") := DecodeString (![slice.T byteT] "data") in
      "s" <-[stringT] "0_ret";;
      "data" <-[slice.T byteT] "1_ret";;
      "ents" <-[slice.T stringT] (SliceAppend stringT (![slice.T stringT] "ents") (![stringT] "s"));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    (![slice.T stringT] "ents", ![slice.T byteT] "data").

End code.
