(* autogenerated from github.com/mit-pdos/tulip/replica *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.tulip.backup.
From Goose Require github_com.mit_pdos.tulip.index.
From Goose Require github_com.mit_pdos.tulip.tulip.
From Goose Require github_com.mit_pdos.tulip.txnlog.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition PrepareProposal := struct.decl [
  "rank" :: uint64T;
  "dec" :: boolT
].

Definition PrepareStatusEntry := struct.decl [
  "rankl" :: uint64T;
  "prep" :: struct.t PrepareProposal
].

Definition Replica := struct.decl [
  "mu" :: ptrT;
  "rid" :: uint64T;
  "txnlog" :: ptrT;
  "lsna" :: uint64T;
  "prepm" :: mapT (slice.T (struct.t tulip.WriteEntry));
  "ptgsm" :: mapT (slice.T uint64T);
  "pstbl" :: mapT (struct.t PrepareStatusEntry);
  "txntbl" :: mapT boolT;
  "ptsm" :: mapT uint64T;
  "sptsm" :: mapT uint64T;
  "idx" :: ptrT;
  "rps" :: mapT uint64T;
  "leader" :: uint64T
].

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @terminated: Whether txn @ts has terminated (committed or aborted). *)
Definition Replica__queryTxnTermination: val :=
  rec: "Replica__queryTxnTermination" "rp" "ts" :=
    let: (<>, "terminated") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    "terminated".

Definition Replica__QueryTxnTermination: val :=
  rec: "Replica__QueryTxnTermination" "rp" "ts" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "terminated" := Replica__queryTxnTermination "rp" "ts" in
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "terminated".

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @ok: If @true, this transaction is committed. *)
Definition Replica__Commit: val :=
  rec: "Replica__Commit" "rp" "ts" "pwrs" :=
    let: "committed" := Replica__QueryTxnTermination "rp" "ts" in
    (if: "committed"
    then #true
    else
      let: ("lsn", "term") := txnlog.TxnLog__SubmitCommit (struct.loadF Replica "txnlog" "rp") "ts" "pwrs" in
      (if: "lsn" = #0
      then #false
      else
        let: "safe" := txnlog.TxnLog__WaitUntilSafe (struct.loadF Replica "txnlog" "rp") "lsn" "term" in
        (if: (~ "safe")
        then #false
        else #true))).

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @ok: If @true, this transaction is aborted. *)
Definition Replica__Abort: val :=
  rec: "Replica__Abort" "rp" "ts" :=
    let: "aborted" := Replica__QueryTxnTermination "rp" "ts" in
    (if: "aborted"
    then #true
    else
      let: ("lsn", "term") := txnlog.TxnLog__SubmitAbort (struct.loadF Replica "txnlog" "rp") "ts" in
      (if: "lsn" = #0
      then #false
      else
        let: "safe" := txnlog.TxnLog__WaitUntilSafe (struct.loadF Replica "txnlog" "rp") "lsn" "term" in
        (if: (~ "safe")
        then #false
        else #true))).

Definition Replica__readableKey: val :=
  rec: "Replica__readableKey" "rp" "ts" "key" :=
    let: "pts" := Fst (MapGet (struct.loadF Replica "ptsm" "rp") "key") in
    (if: ("pts" ≠ #0) && ("pts" ≤ "ts")
    then #false
    else #true).

Definition Replica__bumpKey: val :=
  rec: "Replica__bumpKey" "rp" "ts" "key" :=
    let: "spts" := Fst (MapGet (struct.loadF Replica "sptsm" "rp") "key") in
    (if: "ts" ≤ "spts"
    then #false
    else
      MapInsert (struct.loadF Replica "sptsm" "rp") "key" "ts";;
      #true).

Definition Replica__logRead: val :=
  rec: "Replica__logRead" "rp" "ts" "key" :=
    #().

(* Arguments:
   @ts: Transaction timestamp.
   @key: Key to be read.

   Return values:
   @ver: If @ver.Timestamp = 0, then this is a fast-path read---the value at @ts
   has been determined to be @ver.Value. Otherwise, this is a slow-path read,
   the replica promises not to accept prepare requests from transactions that
   modifies this tuple and whose timestamp lies within @ver.Timestamp and @ts.

   @ok: @ver is meaningful iff @ok is true.

   Design note:

   1. It might seem redundant and inefficient to call @tpl.ReadVersion twice for
   each @rp.Read, but the point is that the first one is called without holding
   the global replica lock, which improves the latency for a fast-read, and
   throughput for non-conflicting fast-reads. An alternative design is to remove
   the first part at all, which favors slow-reads.

   2. Right now the index is still a global lock; ideally we should also shard
   the index lock as done in vMVCC. However, the index lock should be held
   relatively short compared to the replica lock, so the performance impact
   should be less. *)
Definition Replica__Read: val :=
  rec: "Replica__Read" "rp" "ts" "key" :=
    let: "tpl" := index.Index__GetTuple (struct.loadF Replica "idx" "rp") "key" in
    let: "verfast" := tuple.Tuple__ReadVersion "tpl" "ts" in
    (if: (struct.get tulip.Version "Timestamp" "verfast") = #0
    then ("verfast", #true)
    else
      Mutex__Lock (struct.loadF Replica "mu" "rp");;
      let: "ok" := Replica__readableKey "rp" "ts" "key" in
      (if: (~ "ok")
      then
        Mutex__Unlock (struct.loadF Replica "mu" "rp");;
        (struct.mk tulip.Version [
         ], #false)
      else
        let: "ver" := tuple.Tuple__ReadVersion "tpl" "ts" in
        (if: (struct.get tulip.Version "Timestamp" "ver") = #0
        then
          Mutex__Unlock (struct.loadF Replica "mu" "rp");;
          ("ver", #true)
        else
          let: "bumped" := Replica__bumpKey "rp" "ts" "key" in
          (if: "bumped"
          then Replica__logRead "rp" "ts" "key"
          else #());;
          Mutex__Unlock (struct.loadF Replica "mu" "rp");;
          ("ver", #true)))).

Definition Replica__writableKey: val :=
  rec: "Replica__writableKey" "rp" "ts" "key" :=
    let: "pts" := Fst (MapGet (struct.loadF Replica "ptsm" "rp") "key") in
    (if: "pts" ≠ #0
    then #false
    else
      let: "spts" := Fst (MapGet (struct.loadF Replica "sptsm" "rp") "key") in
      (if: "ts" < "spts"
      then #false
      else #true)).

Definition Replica__acquireKey: val :=
  rec: "Replica__acquireKey" "rp" "ts" "key" :=
    MapInsert (struct.loadF Replica "ptsm" "rp") "key" "ts";;
    MapInsert (struct.loadF Replica "sptsm" "rp") "key" ("ts" + #1);;
    #().

Definition Replica__acquire: val :=
  rec: "Replica__acquire" "rp" "ts" "pwrs" :=
    let: "pos" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "pos") < (slice.len "pwrs")); (λ: <>, Skip) := λ: <>,
      let: "ent" := SliceGet (struct.t tulip.WriteEntry) "pwrs" (![uint64T] "pos") in
      let: "writable" := Replica__writableKey "rp" "ts" (struct.get tulip.WriteEntry "Key" "ent") in
      (if: (~ "writable")
      then Break
      else
        "pos" <-[uint64T] ((![uint64T] "pos") + #1);;
        Continue));;
    (if: (![uint64T] "pos") < (slice.len "pwrs")
    then #false
    else
      ForSlice (struct.t tulip.WriteEntry) <> "ent" "pwrs"
        (Replica__acquireKey "rp" "ts" (struct.get tulip.WriteEntry "Key" "ent"));;
      #true).

(* Arguments:
   @ts: Transaction timestamp.
   @pwrs: Write set of transaction @ts.
   @ptgs: Participant groups of transaction @ts.

   Return values:
   @error: Error code. *)
Definition Replica__validate: val :=
  rec: "Replica__validate" "rp" "ts" "pwrs" "ptgs" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then tulip.REPLICA_COMMITTED_TXN
      else tulip.REPLICA_ABORTED_TXN)
    else
      let: (<>, "validated") := MapGet (struct.loadF Replica "prepm" "rp") "ts" in
      (if: "validated"
      then tulip.REPLICA_OK
      else
        let: "acquired" := Replica__acquire "rp" "ts" "pwrs" in
        (if: (~ "acquired")
        then tulip.REPLICA_FAILED_VALIDATION
        else
          MapInsert (struct.loadF Replica "prepm" "rp") "ts" "pwrs";;
          tulip.REPLICA_OK))).

(* Keep alive coordinator for @ts at @rank. *)
Definition Replica__refresh: val :=
  rec: "Replica__refresh" "rp" "ts" "rank" :=
    #().

Definition Replica__Validate: val :=
  rec: "Replica__Validate" "rp" "ts" "rank" "pwrs" "ptgs" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__validate "rp" "ts" "pwrs" "ptgs" in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

Definition Replica__probe: val :=
  rec: "Replica__probe" "rp" "ts" :=
    let: ("ps", "ok") := MapGet (struct.loadF Replica "pstbl" "rp") "ts" in
    let: "pp" := struct.get PrepareStatusEntry "prep" "ps" in
    (struct.get PrepareStatusEntry "rankl" "ps", struct.get PrepareProposal "rank" "pp", struct.get PrepareProposal "dec" "pp", "ok").

Definition Replica__accept: val :=
  rec: "Replica__accept" "rp" "ts" "rank" "dec" :=
    let: "pp" := struct.mk PrepareProposal [
      "rank" ::= "rank";
      "dec" ::= "dec"
    ] in
    let: "psnew" := struct.mk PrepareStatusEntry [
      "rankl" ::= "rank" + #1;
      "prep" ::= "pp"
    ] in
    MapInsert (struct.loadF Replica "pstbl" "rp") "ts" "psnew";;
    #().

(* Arguments:
   @ts: Transaction timestamp.

   @pwrs: Transaction write set.

   Return values:

   @error: Error code. *)
Definition Replica__fastPrepare: val :=
  rec: "Replica__fastPrepare" "rp" "ts" "pwrs" "ptgs" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then tulip.REPLICA_COMMITTED_TXN
      else tulip.REPLICA_ABORTED_TXN)
    else
      let: (((<>, "rank"), "dec"), "ok") := Replica__probe "rp" "ts" in
      (if: "ok"
      then
        (if: #0 < "rank"
        then tulip.REPLICA_STALE_COORDINATOR
        else
          (if: (~ "dec")
          then tulip.REPLICA_FAILED_VALIDATION
          else tulip.REPLICA_OK))
      else
        let: (<>, "validated") := MapGet (struct.loadF Replica "prepm" "rp") "ts" in
        (if: "validated"
        then tulip.REPLICA_STALE_COORDINATOR
        else
          let: "acquired" := Replica__acquire "rp" "ts" "pwrs" in
          Replica__accept "rp" "ts" #0 "acquired";;
          (if: (~ "acquired")
          then tulip.REPLICA_FAILED_VALIDATION
          else
            MapInsert (struct.loadF Replica "prepm" "rp") "ts" "pwrs";;
            tulip.REPLICA_OK)))).

Definition Replica__FastPrepare: val :=
  rec: "Replica__FastPrepare" "rp" "ts" "pwrs" "ptgs" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__fastPrepare "rp" "ts" "pwrs" "ptgs" in
    Replica__refresh "rp" "ts" #0;;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

(* Accept the prepare decision for @ts at @rank, if @rank is most recent.

   Arguments:
   @ts: Transaction timestamp.
   @rank: Coordinator rank.
   @dec: Prepared or unprepared.

   Return values:
   @error: Error code. *)
Definition Replica__tryAccept: val :=
  rec: "Replica__tryAccept" "rp" "ts" "rank" "dec" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then tulip.REPLICA_COMMITTED_TXN
      else tulip.REPLICA_ABORTED_TXN)
    else
      let: ((("rankl", <>), <>), "ok") := Replica__probe "rp" "ts" in
      (if: "ok" && ("rank" < "rankl")
      then tulip.REPLICA_STALE_COORDINATOR
      else
        Replica__accept "rp" "ts" "rank" "dec";;
        tulip.REPLICA_OK)).

Definition Replica__Prepare: val :=
  rec: "Replica__Prepare" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__tryAccept "rp" "ts" "rank" #true in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

Definition Replica__Unprepare: val :=
  rec: "Replica__Unprepare" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__tryAccept "rp" "ts" "rank" #false in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

Definition Replica__inquire: val :=
  rec: "Replica__inquire" "rp" "ts" "rank" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then
        (struct.mk PrepareProposal [
         ], #false, slice.nil, tulip.REPLICA_COMMITTED_TXN)
      else
        (struct.mk PrepareProposal [
         ], #false, slice.nil, tulip.REPLICA_ABORTED_TXN))
    else
      let: ("ps", "ok") := MapGet (struct.loadF Replica "pstbl" "rp") "ts" in
      (if: "ok" && ("rank" ≤ (struct.get PrepareStatusEntry "rankl" "ps"))
      then
        (struct.mk PrepareProposal [
         ], #false, slice.nil, tulip.REPLICA_INVALID_RANK)
      else
        let: "pp" := struct.get PrepareStatusEntry "prep" "ps" in
        let: "psnew" := struct.mk PrepareStatusEntry [
          "rankl" ::= "rank";
          "prep" ::= "pp"
        ] in
        MapInsert (struct.loadF Replica "pstbl" "rp") "ts" "psnew";;
        let: ("pwrs", "vd") := MapGet (struct.loadF Replica "prepm" "rp") "ts" in
        ("pp", "vd", "pwrs", tulip.REPLICA_OK))).

Definition Replica__Inquire: val :=
  rec: "Replica__Inquire" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: ((("pp", "vd"), "pwrs"), "res") := Replica__inquire "rp" "ts" "rank" in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    ("pp", "vd", "pwrs", "res").

Definition Replica__query: val :=
  rec: "Replica__query" "rp" "ts" "rank" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then tulip.REPLICA_COMMITTED_TXN
      else tulip.REPLICA_ABORTED_TXN)
    else
      let: ((("rankl", <>), <>), "ok") := Replica__probe "rp" "ts" in
      (if: "ok" && ("rank" < "rankl")
      then tulip.REPLICA_STALE_COORDINATOR
      else tulip.REPLICA_OK)).

Definition Replica__Query: val :=
  rec: "Replica__Query" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__query "rp" "ts" "rank" in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

Definition Replica__Refresh: val :=
  rec: "Replica__Refresh" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    #().

Definition Replica__multiwrite: val :=
  rec: "Replica__multiwrite" "rp" "ts" "pwrs" :=
    ForSlice (struct.t tulip.WriteEntry) <> "ent" "pwrs"
      (let: "key" := struct.get tulip.WriteEntry "Key" "ent" in
      let: "value" := struct.get tulip.WriteEntry "Value" "ent" in
      let: "tpl" := index.Index__GetTuple (struct.loadF Replica "idx" "rp") "key" in
      (if: struct.get tulip.Value "Present" "value"
      then tuple.Tuple__AppendVersion "tpl" "ts" (struct.get tulip.Value "Content" "value")
      else tuple.Tuple__KillVersion "tpl" "ts"));;
    #().

Definition Replica__releaseKey: val :=
  rec: "Replica__releaseKey" "rp" "key" :=
    MapDelete (struct.loadF Replica "ptsm" "rp") "key";;
    #().

Definition Replica__release: val :=
  rec: "Replica__release" "rp" "pwrs" :=
    ForSlice (struct.t tulip.WriteEntry) <> "ent" "pwrs"
      (let: "key" := struct.get tulip.WriteEntry "Key" "ent" in
      Replica__releaseKey "rp" "key");;
    #().

Definition Replica__applyCommit: val :=
  rec: "Replica__applyCommit" "rp" "ts" "pwrs" :=
    let: "committed" := Replica__queryTxnTermination "rp" "ts" in
    (if: "committed"
    then #()
    else
      Replica__multiwrite "rp" "ts" "pwrs";;
      MapInsert (struct.loadF Replica "txntbl" "rp") "ts" #true;;
      let: (<>, "prepared") := MapGet (struct.loadF Replica "prepm" "rp") "ts" in
      (if: "prepared"
      then
        Replica__release "rp" "pwrs";;
        MapDelete (struct.loadF Replica "prepm" "rp") "ts";;
        #()
      else #())).

Definition Replica__applyAbort: val :=
  rec: "Replica__applyAbort" "rp" "ts" :=
    let: "aborted" := Replica__queryTxnTermination "rp" "ts" in
    (if: "aborted"
    then #()
    else
      MapInsert (struct.loadF Replica "txntbl" "rp") "ts" #false;;
      let: ("pwrs", "prepared") := MapGet (struct.loadF Replica "prepm" "rp") "ts" in
      (if: "prepared"
      then
        Replica__release "rp" "pwrs";;
        MapDelete (struct.loadF Replica "prepm" "rp") "ts";;
        #()
      else #())).

Definition Replica__apply: val :=
  rec: "Replica__apply" "rp" "cmd" :=
    (if: (struct.get txnlog.Cmd "Kind" "cmd") = #0
    then #()
    else
      (if: (struct.get txnlog.Cmd "Kind" "cmd") = #1
      then
        Replica__applyCommit "rp" (struct.get txnlog.Cmd "Timestamp" "cmd") (struct.get txnlog.Cmd "PartialWrites" "cmd");;
        #()
      else
        Replica__applyAbort "rp" (struct.get txnlog.Cmd "Timestamp" "cmd");;
        #())).

Definition Replica__Start: val :=
  rec: "Replica__Start" "rp" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "lsn" := std.SumAssumeNoOverflow (struct.loadF Replica "lsna" "rp") #1 in
      let: ("cmd", "ok") := txnlog.TxnLog__Lookup (struct.loadF Replica "txnlog" "rp") "lsn" in
      (if: (~ "ok")
      then
        Mutex__Unlock (struct.loadF Replica "mu" "rp");;
        time.Sleep (#1 * #1000000);;
        Mutex__Lock (struct.loadF Replica "mu" "rp");;
        Continue
      else
        Replica__apply "rp" "cmd";;
        struct.storeF Replica "lsna" "rp" "lsn";;
        Continue));;
    #().

Definition Replica__StartBackupTxnCoordinator: val :=
  rec: "Replica__StartBackupTxnCoordinator" "rp" "ts" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "ps" := Fst (MapGet (struct.loadF Replica "pstbl" "rp") "ts") in
    let: "rank" := (struct.get PrepareStatusEntry "rankl" "ps") + #1 in
    let: "ptgs" := Fst (MapGet (struct.loadF Replica "ptgsm" "rp") "ts") in
    let: "tcoord" := backup.MkBackupTxnCoordinator "ts" "rank" "ptgs" (struct.loadF Replica "rps" "rp") (struct.loadF Replica "leader" "rp") in
    backup.BackupTxnCoordinator__ConnectAll "tcoord";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    backup.BackupTxnCoordinator__Finalize "tcoord";;
    #().
