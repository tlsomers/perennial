(* autogenerated from github.com/mit-pdos/tulip/backup *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.mit_pdos.tulip.message.
From Goose Require github_com.mit_pdos.tulip.params.
From Goose Require github_com.mit_pdos.tulip.quorum.
From Goose Require github_com.mit_pdos.tulip.tulip.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition BackupGroupCoordinator := struct.decl [
  "rps" :: mapT uint64T;
  "mu" :: ptrT;
  "cv" :: ptrT;
  "leader" :: uint64T;
  "gpp" :: ptrT;
  "conns" :: mapT grove_ffi.Connection
].

Definition PrepareProposal := struct.decl [
  "rank" :: uint64T;
  "dec" :: boolT
].

(* A note on relationship between @phase and @pwrsok/@pwrs: Ideally, we should
   construct an invariant saying that if @phase is VALIDATING, PREPARING, or
   PREPARED, then @pwrsok = true (and @pwrs is available). But before figuring
   out the right invariant, we added some redundant checks (i.e., ones that
   should never fail) to make the proof happy (see calls of @gcoord.GetPwrs). *)
Definition BackupGroupPreparer := struct.decl [
  "nrps" :: uint64T;
  "phase" :: uint64T;
  "pwrsok" :: boolT;
  "pwrs" :: mapT (struct.t tulip.Value);
  "pps" :: mapT (struct.t PrepareProposal);
  "resps" :: mapT boolT
].

Definition BGPP_INQUIRING : expr := #0.

Definition BGPP_VALIDATING : expr := #1.

Definition BGPP_PREPARING : expr := #2.

Definition BGPP_UNPREPARING : expr := #3.

Definition BGPP_PREPARED : expr := #4.

Definition BGPP_COMMITTED : expr := #5.

Definition BGPP_ABORTED : expr := #6.

Definition BGPP_STOPPED : expr := #7.

Definition BGPP_INQUIRE : expr := #0.

Definition BGPP_VALIDATE : expr := #1.

Definition BGPP_PREPARE : expr := #2.

Definition BGPP_UNPREPARE : expr := #3.

Definition BGPP_REFRESH : expr := #4.

(* Argument:
   @rid: ID of the replica to which a new action is performed.

   Return value:
   @action: Next action to perform. *)
Definition BackupGroupPreparer__action: val :=
  rec: "BackupGroupPreparer__action" "gpp" "rid" :=
    (if: (struct.loadF BackupGroupPreparer "phase" "gpp") = BGPP_INQUIRING
    then
      let: (<>, "inquired") := MapGet (struct.loadF BackupGroupPreparer "pps" "gpp") "rid" in
      (if: (~ "inquired")
      then BGPP_INQUIRE
      else BGPP_REFRESH)
    else
      (if: (struct.loadF BackupGroupPreparer "phase" "gpp") = BGPP_VALIDATING
      then
        let: (<>, "inquired") := MapGet (struct.loadF BackupGroupPreparer "pps" "gpp") "rid" in
        (if: (~ "inquired")
        then BGPP_INQUIRE
        else
          let: (<>, "validated") := MapGet (struct.loadF BackupGroupPreparer "resps" "gpp") "rid" in
          (if: (~ "validated")
          then BGPP_VALIDATE
          else BGPP_REFRESH))
      else
        (if: (struct.loadF BackupGroupPreparer "phase" "gpp") = BGPP_PREPARING
        then
          let: (<>, "prepared") := MapGet (struct.loadF BackupGroupPreparer "resps" "gpp") "rid" in
          (if: (~ "prepared")
          then BGPP_PREPARE
          else BGPP_REFRESH)
        else
          (if: (struct.loadF BackupGroupPreparer "phase" "gpp") = BGPP_UNPREPARING
          then
            let: (<>, "unprepared") := MapGet (struct.loadF BackupGroupPreparer "resps" "gpp") "rid" in
            (if: (~ "unprepared")
            then BGPP_UNPREPARE
            else BGPP_REFRESH)
          else BGPP_REFRESH)))).

Definition BackupGroupCoordinator__NextPrepareAction: val :=
  rec: "BackupGroupCoordinator__NextPrepareAction" "gcoord" "rid" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: "a" := BackupGroupPreparer__action (struct.loadF BackupGroupCoordinator "gpp" "gcoord") "rid" in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    "a".

Definition BackupGroupPreparer__finalized: val :=
  rec: "BackupGroupPreparer__finalized" "gpp" :=
    BGPP_COMMITTED ≤ (struct.loadF BackupGroupPreparer "phase" "gpp").

Definition BackupGroupCoordinator__Finalized: val :=
  rec: "BackupGroupCoordinator__Finalized" "gcoord" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: "done" := BackupGroupPreparer__finalized (struct.loadF BackupGroupCoordinator "gpp" "gcoord") in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    "done".

Definition BackupGroupCoordinator__SendInquire: val :=
  rec: "BackupGroupCoordinator__SendInquire" "gcoord" "rid" "ts" "rank" :=
    #().

Definition BackupGroupPreparer__getPwrs: val :=
  rec: "BackupGroupPreparer__getPwrs" "gpp" :=
    (struct.loadF BackupGroupPreparer "pwrs" "gpp", struct.loadF BackupGroupPreparer "pwrsok" "gpp").

Definition BackupGroupCoordinator__GetPwrs: val :=
  rec: "BackupGroupCoordinator__GetPwrs" "gcoord" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: ("pwrs", "ok") := BackupGroupPreparer__getPwrs (struct.loadF BackupGroupCoordinator "gpp" "gcoord") in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    ("pwrs", "ok").

Definition BackupGroupCoordinator__SendValidate: val :=
  rec: "BackupGroupCoordinator__SendValidate" "gcoord" "rid" "ts" "rank" "pwrs" "ptgs" :=
    #().

Definition BackupGroupCoordinator__SendPrepare: val :=
  rec: "BackupGroupCoordinator__SendPrepare" "gcoord" "rid" "ts" "rank" :=
    #().

Definition BackupGroupCoordinator__SendUnprepare: val :=
  rec: "BackupGroupCoordinator__SendUnprepare" "gcoord" "rid" "ts" "rank" :=
    #().

Definition BackupGroupCoordinator__SendRefresh: val :=
  rec: "BackupGroupCoordinator__SendRefresh" "gcoord" "rid" "ts" "rank" :=
    #().

Definition BackupGroupCoordinator__PrepareSession: val :=
  rec: "BackupGroupCoordinator__PrepareSession" "gcoord" "rid" "ts" "rank" "ptgs" :=
    let: "act" := ref_to uint64T (BackupGroupCoordinator__NextPrepareAction "gcoord" "rid") in
    Skip;;
    (for: (λ: <>, (~ (BackupGroupCoordinator__Finalized "gcoord"))); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "act") = BGPP_INQUIRE
      then BackupGroupCoordinator__SendInquire "gcoord" "rid" "ts" "rank"
      else
        (if: (![uint64T] "act") = BGPP_VALIDATE
        then
          let: ("pwrs", "ok") := BackupGroupCoordinator__GetPwrs "gcoord" in
          (if: "ok"
          then BackupGroupCoordinator__SendValidate "gcoord" "rid" "ts" "rank" "pwrs" "ptgs"
          else BackupGroupCoordinator__SendInquire "gcoord" "rid" "ts" "rank")
        else
          (if: (![uint64T] "act") = BGPP_PREPARE
          then BackupGroupCoordinator__SendPrepare "gcoord" "rid" "ts" "rank"
          else
            (if: (![uint64T] "act") = BGPP_UNPREPARE
            then BackupGroupCoordinator__SendUnprepare "gcoord" "rid" "ts" "rank"
            else
              (if: (![uint64T] "act") = BGPP_REFRESH
              then BackupGroupCoordinator__SendRefresh "gcoord" "rid" "ts" "rank"
              else #())))));;
      (if: (![uint64T] "act") = BGPP_REFRESH
      then time.Sleep params.NS_SEND_REFRESH
      else time.Sleep params.NS_RESEND_PREPARE);;
      "act" <-[uint64T] (BackupGroupCoordinator__NextPrepareAction "gcoord" "rid");;
      Continue);;
    #().

Definition BackupGroupPreparer__ready: val :=
  rec: "BackupGroupPreparer__ready" "gpp" :=
    BGPP_PREPARED ≤ (struct.loadF BackupGroupPreparer "phase" "gpp").

Definition BackupGroupPreparer__getPhase: val :=
  rec: "BackupGroupPreparer__getPhase" "gpp" :=
    struct.loadF BackupGroupPreparer "phase" "gpp".

Definition BackupGroupCoordinator__WaitUntilPrepareDone: val :=
  rec: "BackupGroupCoordinator__WaitUntilPrepareDone" "gcoord" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    Skip;;
    (for: (λ: <>, (~ (BackupGroupPreparer__ready (struct.loadF BackupGroupCoordinator "gpp" "gcoord")))); (λ: <>, Skip) := λ: <>,
      Cond__Wait (struct.loadF BackupGroupCoordinator "cv" "gcoord");;
      Continue);;
    let: "phase" := BackupGroupPreparer__getPhase (struct.loadF BackupGroupCoordinator "gpp" "gcoord") in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    (if: "phase" = BGPP_STOPPED
    then (tulip.TXN_PREPARED, #false)
    else
      (if: "phase" = BGPP_COMMITTED
      then (tulip.TXN_COMMITTED, #true)
      else
        (if: "phase" = BGPP_ABORTED
        then (tulip.TXN_ABORTED, #true)
        else (tulip.TXN_PREPARED, #true)))).

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @status: Transaction status.
   @valid: If true, the prepare process goes through without encountering a more
   recent coordinator. @status is meaningful iff @valid is true.

   @Prepare blocks until the prepare decision (one of prepared, committed,
   aborted) is made, or a higher-ranked backup coordinator is up. *)
Definition BackupGroupCoordinator__Prepare: val :=
  rec: "BackupGroupCoordinator__Prepare" "gcoord" "ts" "rank" "ptgs" :=
    MapIter (struct.loadF BackupGroupCoordinator "rps" "gcoord") (λ: "ridloop" <>,
      let: "rid" := "ridloop" in
      Fork (BackupGroupCoordinator__PrepareSession "gcoord" "rid" "ts" "rank" "ptgs"));;
    let: ("status", "valid") := BackupGroupCoordinator__WaitUntilPrepareDone "gcoord" in
    ("status", "valid").

Definition BackupGroupCoordinator__GetLeader: val :=
  rec: "BackupGroupCoordinator__GetLeader" "gcoord" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: "leader" := struct.loadF BackupGroupCoordinator "leader" "gcoord" in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    "leader".

Definition BackupGroupCoordinator__SendCommit: val :=
  rec: "BackupGroupCoordinator__SendCommit" "gcoord" "rid" "ts" "pwrs" :=
    #().

Definition BackupGroupCoordinator__ChangeLeader: val :=
  rec: "BackupGroupCoordinator__ChangeLeader" "gcoord" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: "leader" := ((struct.loadF BackupGroupCoordinator "leader" "gcoord") + #1) `rem` (MapLen (struct.loadF BackupGroupCoordinator "rps" "gcoord")) in
    struct.storeF BackupGroupCoordinator "leader" "gcoord" "leader";;
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    "leader".

Definition BackupGroupCoordinator__Commit: val :=
  rec: "BackupGroupCoordinator__Commit" "gcoord" "ts" :=
    let: "leader" := ref_to uint64T (BackupGroupCoordinator__GetLeader "gcoord") in
    Skip;;
    (for: (λ: <>, (~ (BackupGroupCoordinator__Finalized "gcoord"))); (λ: <>, Skip) := λ: <>,
      let: ("pwrs", "ok") := BackupGroupCoordinator__GetPwrs "gcoord" in
      (if: (~ "ok")
      then Break
      else
        BackupGroupCoordinator__SendCommit "gcoord" (![uint64T] "leader") "ts" "pwrs";;
        time.Sleep params.NS_RESEND_COMMIT;;
        "leader" <-[uint64T] (BackupGroupCoordinator__ChangeLeader "gcoord");;
        Continue));;
    #().

Definition BackupGroupCoordinator__SendAbort: val :=
  rec: "BackupGroupCoordinator__SendAbort" "gcoord" "rid" "ts" :=
    #().

Definition BackupGroupCoordinator__Abort: val :=
  rec: "BackupGroupCoordinator__Abort" "gcoord" "ts" :=
    let: "leader" := ref_to uint64T (BackupGroupCoordinator__GetLeader "gcoord") in
    Skip;;
    (for: (λ: <>, (~ (BackupGroupCoordinator__Finalized "gcoord"))); (λ: <>, Skip) := λ: <>,
      BackupGroupCoordinator__SendAbort "gcoord" (![uint64T] "leader") "ts";;
      time.Sleep params.NS_RESEND_ABORT;;
      "leader" <-[uint64T] (BackupGroupCoordinator__ChangeLeader "gcoord");;
      Continue);;
    #().

Definition BackupGroupCoordinator__GetConnection: val :=
  rec: "BackupGroupCoordinator__GetConnection" "gcoord" "rid" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: ("conn", "ok") := MapGet (struct.loadF BackupGroupCoordinator "conns" "gcoord") "rid" in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    ("conn", "ok").

Definition BackupGroupCoordinator__Connect: val :=
  rec: "BackupGroupCoordinator__Connect" "gcoord" "rid" :=
    let: "addr" := Fst (MapGet (struct.loadF BackupGroupCoordinator "rps" "gcoord") "rid") in
    let: "ret" := grove_ffi.Connect "addr" in
    (if: (~ (struct.get grove_ffi.ConnectRet "Err" "ret"))
    then
      Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
      MapInsert (struct.loadF BackupGroupCoordinator "conns" "gcoord") "rid" (struct.get grove_ffi.ConnectRet "Connection" "ret");;
      Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
      #true
    else #false).

Definition BackupGroupCoordinator__Receive: val :=
  rec: "BackupGroupCoordinator__Receive" "gcoord" "rid" :=
    let: ("conn", "ok") := BackupGroupCoordinator__GetConnection "gcoord" "rid" in
    (if: (~ "ok")
    then
      BackupGroupCoordinator__Connect "gcoord" "rid";;
      (slice.nil, #false)
    else
      let: "ret" := grove_ffi.Receive "conn" in
      (if: struct.get grove_ffi.ReceiveRet "Err" "ret"
      then
        BackupGroupCoordinator__Connect "gcoord" "rid";;
        (slice.nil, #false)
      else (struct.get grove_ffi.ReceiveRet "Data" "ret", #true))).

Definition BackupGroupPreparer__tryResign: val :=
  rec: "BackupGroupPreparer__tryResign" "gpp" "res" :=
    (if: BGPP_PREPARED ≤ (struct.loadF BackupGroupPreparer "phase" "gpp")
    then #true
    else
      (if: "res" = tulip.REPLICA_COMMITTED_TXN
      then
        struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_COMMITTED;;
        #true
      else
        (if: "res" = tulip.REPLICA_ABORTED_TXN
        then
          struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_ABORTED;;
          #true
        else
          (if: "res" = tulip.REPLICA_STALE_COORDINATOR
          then
            struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_STOPPED;;
            #true
          else #false)))).

Definition BackupGroupPreparer__cquorum: val :=
  rec: "BackupGroupPreparer__cquorum" "gpp" "n" :=
    (quorum.ClassicQuorum (struct.loadF BackupGroupPreparer "nrps" "gpp")) ≤ "n".

(* Return value:
   @latest: The latest non-fast proposal if @latest.rank > 0; @gpp.pps
   contain only fast proposals if @latest.rank == 0. *)
Definition BackupGroupPreparer__latestProposal: val :=
  rec: "BackupGroupPreparer__latestProposal" "gpp" :=
    let: "latest" := ref (zero_val (struct.t PrepareProposal)) in
    MapIter (struct.loadF BackupGroupPreparer "pps" "gpp") (λ: <> "pp",
      (if: (struct.get PrepareProposal "rank" (![struct.t PrepareProposal] "latest")) < (struct.get PrepareProposal "rank" "pp")
      then "latest" <-[struct.t PrepareProposal] "pp"
      else #()));;
    ![struct.t PrepareProposal] "latest".

(* Return value:
   @nprep: The number of fast unprepares collected in @gpp.pps. *)
Definition BackupGroupPreparer__countFastUnprepare: val :=
  rec: "BackupGroupPreparer__countFastUnprepare" "gpp" :=
    let: "nprep" := ref (zero_val uint64T) in
    MapIter (struct.loadF BackupGroupPreparer "pps" "gpp") (λ: <> "pp",
      (if: ((struct.get PrepareProposal "rank" "pp") = #0) && (~ (struct.get PrepareProposal "dec" "pp"))
      then "nprep" <-[uint64T] ((![uint64T] "nprep") + #1)
      else #()));;
    ![uint64T] "nprep".

Definition BackupGroupPreparer__hcquorum: val :=
  rec: "BackupGroupPreparer__hcquorum" "gpp" "n" :=
    (quorum.Half (quorum.ClassicQuorum (struct.loadF BackupGroupPreparer "nrps" "gpp"))) ≤ "n".

Definition BackupGroupPreparer__processInquireResult: val :=
  rec: "BackupGroupPreparer__processInquireResult" "gpp" "rid" "pp" "vd" "pwrs" "res" :=
    (if: BackupGroupPreparer__tryResign "gpp" "res"
    then #()
    else
      (if: ((struct.loadF BackupGroupPreparer "phase" "gpp") = BGPP_PREPARING) || ((struct.loadF BackupGroupPreparer "phase" "gpp") = BGPP_UNPREPARING)
      then #()
      else
        MapInsert (struct.loadF BackupGroupPreparer "pps" "gpp") "rid" "pp";;
        (if: "vd"
        then
          struct.storeF BackupGroupPreparer "pwrsok" "gpp" #true;;
          struct.storeF BackupGroupPreparer "pwrs" "gpp" "pwrs";;
          MapInsert (struct.loadF BackupGroupPreparer "resps" "gpp") "rid" #true
        else #());;
        let: "n" := MapLen (struct.loadF BackupGroupPreparer "pps" "gpp") in
        (if: (~ (BackupGroupPreparer__cquorum "gpp" "n"))
        then #()
        else
          let: "latest" := BackupGroupPreparer__latestProposal "gpp" in
          (if: (struct.get PrepareProposal "rank" "latest") ≠ #0
          then
            (if: struct.get PrepareProposal "dec" "latest"
            then struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_PREPARING
            else struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_UNPREPARING);;
            #()
          else
            let: "nfu" := BackupGroupPreparer__countFastUnprepare "gpp" in
            (if: BackupGroupPreparer__hcquorum "gpp" "nfu"
            then
              struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_UNPREPARING;;
              #()
            else
              let: "nvd" := MapLen (struct.loadF BackupGroupPreparer "resps" "gpp") in
              (if: BackupGroupPreparer__cquorum "gpp" "nvd"
              then
                struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_PREPARING;;
                #()
              else
                struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_VALIDATING;;
                #())))))).

Definition BackupGroupPreparer__processValidateResult: val :=
  rec: "BackupGroupPreparer__processValidateResult" "gpp" "rid" "res" :=
    (if: BackupGroupPreparer__tryResign "gpp" "res"
    then #()
    else
      (if: (struct.loadF BackupGroupPreparer "phase" "gpp") ≠ BGPP_VALIDATING
      then #()
      else
        (if: "res" = tulip.REPLICA_FAILED_VALIDATION
        then #()
        else
          MapInsert (struct.loadF BackupGroupPreparer "resps" "gpp") "rid" #true;;
          let: "nvd" := MapLen (struct.loadF BackupGroupPreparer "resps" "gpp") in
          (if: BackupGroupPreparer__cquorum "gpp" "nvd"
          then
            struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_PREPARING;;
            #()
          else #())))).

Definition BackupGroupPreparer__processPrepareResult: val :=
  rec: "BackupGroupPreparer__processPrepareResult" "gpp" "rid" "res" :=
    (if: BackupGroupPreparer__tryResign "gpp" "res"
    then #()
    else
      MapInsert (struct.loadF BackupGroupPreparer "resps" "gpp") "rid" #true;;
      let: "n" := MapLen (struct.loadF BackupGroupPreparer "resps" "gpp") in
      (if: BackupGroupPreparer__cquorum "gpp" "n"
      then
        struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_PREPARED;;
        #()
      else #())).

Definition BackupGroupPreparer__processUnprepareResult: val :=
  rec: "BackupGroupPreparer__processUnprepareResult" "gpp" "rid" "res" :=
    (if: BackupGroupPreparer__tryResign "gpp" "res"
    then #()
    else
      MapInsert (struct.loadF BackupGroupPreparer "resps" "gpp") "rid" #true;;
      let: "n" := MapLen (struct.loadF BackupGroupPreparer "resps" "gpp") in
      (if: BackupGroupPreparer__cquorum "gpp" "n"
      then
        struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_ABORTED;;
        #()
      else #())).

Definition BackupGroupPreparer__stop: val :=
  rec: "BackupGroupPreparer__stop" "gpp" :=
    struct.storeF BackupGroupPreparer "phase" "gpp" BGPP_STOPPED;;
    #().

Definition BackupGroupPreparer__processFinalizationResult: val :=
  rec: "BackupGroupPreparer__processFinalizationResult" "gpp" "res" :=
    (if: "res" = tulip.REPLICA_WRONG_LEADER
    then #()
    else
      BackupGroupPreparer__stop "gpp";;
      #()).

Definition BackupGroupCoordinator__ResultSession: val :=
  rec: "BackupGroupCoordinator__ResultSession" "gcoord" "rid" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("data", "ok") := BackupGroupCoordinator__Receive "gcoord" "rid" in
      (if: (~ "ok")
      then
        time.Sleep params.NS_RECONNECT;;
        Continue
      else
        let: "msg" := message.DecodeTxnResponse "data" in
        let: "kind" := struct.get message.TxnResponse "Kind" "msg" in
        Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
        let: "gpp" := struct.loadF BackupGroupCoordinator "gpp" "gcoord" in
        (if: "kind" = message.MSG_TXN_INQUIRE
        then
          let: "pp" := struct.mk PrepareProposal [
            "rank" ::= struct.get message.TxnResponse "Rank" "msg";
            "dec" ::= struct.get message.TxnResponse "Prepared" "msg"
          ] in
          BackupGroupPreparer__processInquireResult "gpp" "rid" "pp" (struct.get message.TxnResponse "Validated" "msg") (struct.get message.TxnResponse "PartialWrites" "msg") (struct.get message.TxnResponse "Result" "msg")
        else
          (if: "kind" = message.MSG_TXN_VALIDATE
          then BackupGroupPreparer__processValidateResult "gpp" "rid" (struct.get message.TxnResponse "Result" "msg")
          else
            (if: "kind" = message.MSG_TXN_PREPARE
            then BackupGroupPreparer__processPrepareResult "gpp" "rid" (struct.get message.TxnResponse "Result" "msg")
            else
              (if: "kind" = message.MSG_TXN_UNPREPARE
              then BackupGroupPreparer__processUnprepareResult "gpp" "rid" (struct.get message.TxnResponse "Result" "msg")
              else
                (if: "kind" = message.MSG_TXN_REFRESH
                then #()
                else
                  (if: ("kind" = message.MSG_TXN_COMMIT) || ("kind" = message.MSG_TXN_ABORT)
                  then BackupGroupPreparer__processFinalizationResult "gpp" (struct.get message.TxnResponse "Result" "msg")
                  else #()))))));;
        Cond__Signal (struct.loadF BackupGroupCoordinator "cv" "gcoord");;
        Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
        Continue));;
    #().

Definition BackupGroupCoordinator__Send: val :=
  rec: "BackupGroupCoordinator__Send" "gcoord" "rid" "data" :=
    let: ("conn", "ok") := BackupGroupCoordinator__GetConnection "gcoord" "rid" in
    (if: (~ "ok")
    then BackupGroupCoordinator__Connect "gcoord" "rid"
    else #());;
    let: "err" := grove_ffi.Send "conn" "data" in
    (if: "err"
    then
      BackupGroupCoordinator__Connect "gcoord" "rid";;
      #()
    else #()).

Definition BackupGroupCoordinator__ConnectAll: val :=
  rec: "BackupGroupCoordinator__ConnectAll" "gcoord" :=
    MapIter (struct.loadF BackupGroupCoordinator "rps" "gcoord") (λ: <> "rid",
      BackupGroupCoordinator__Connect "gcoord" "rid");;
    #().

Definition BackupGroupPreparer__fquorum: val :=
  rec: "BackupGroupPreparer__fquorum" "gpp" "n" :=
    (quorum.FastQuorum (struct.loadF BackupGroupPreparer "nrps" "gpp")) ≤ "n".

Definition BackupGroupPreparer__processQueryResult: val :=
  rec: "BackupGroupPreparer__processQueryResult" "gpp" "rid" "res" :=
    BackupGroupPreparer__tryResign "gpp" "res";;
    #().

Definition BackupTxnCoordinator := struct.decl [
  "ts" :: uint64T;
  "rank" :: uint64T;
  "ptgs" :: slice.T uint64T;
  "gcoords" :: mapT ptrT
].

Definition MkBackupTxnCoordinator: val :=
  rec: "MkBackupTxnCoordinator" "ts" "rank" "ptgs" "rps" "leader" :=
    let: "gcoords" := NewMap uint64T ptrT #() in
    ForSlice uint64T <> "gid" "ptgs"
      (let: "gpp" := struct.new BackupGroupPreparer [
        "nrps" ::= MapLen "rps";
        "phase" ::= BGPP_INQUIRING;
        "pwrsok" ::= #false;
        "pps" ::= NewMap uint64T (struct.t PrepareProposal) #();
        "resps" ::= NewMap uint64T boolT #()
      ] in
      let: "mu" := newMutex #() in
      let: "cv" := NewCond "mu" in
      let: "gcoord" := struct.new BackupGroupCoordinator [
        "rps" ::= "rps";
        "mu" ::= "mu";
        "cv" ::= "cv";
        "leader" ::= "leader";
        "gpp" ::= "gpp";
        "conns" ::= NewMap uint64T grove_ffi.Connection #()
      ] in
      MapInsert "gcoords" "gid" "gcoord");;
    let: "tcoord" := struct.new BackupTxnCoordinator [
      "ts" ::= "ts";
      "rank" ::= "rank";
      "ptgs" ::= "ptgs";
      "gcoords" ::= "gcoords"
    ] in
    "tcoord".

(* @Connect tries to create connections with all the replicas in each
   participant group. *)
Definition BackupTxnCoordinator__ConnectAll: val :=
  rec: "BackupTxnCoordinator__ConnectAll" "tcoord" :=
    MapIter (struct.loadF BackupTxnCoordinator "gcoords" "tcoord") (λ: <> "gcoord",
      BackupGroupCoordinator__ConnectAll "gcoord");;
    #().

Definition BackupTxnCoordinator__stabilize: val :=
  rec: "BackupTxnCoordinator__stabilize" "tcoord" :=
    let: "mu" := newMutex #() in
    let: "cv" := NewCond "mu" in
    let: "nr" := ref_to uint64T #0 in
    let: "np" := ref_to uint64T #0 in
    let: "st" := ref_to uint64T tulip.TXN_PREPARED in
    let: "vd" := ref_to boolT #true in
    MapIter (struct.loadF BackupTxnCoordinator "gcoords" "tcoord") (λ: <> "gcoordloop",
      let: "gcoord" := "gcoordloop" in
      Fork (let: ("stg", "vdg") := BackupGroupCoordinator__Prepare "gcoord" (struct.loadF BackupTxnCoordinator "ts" "tcoord") (struct.loadF BackupTxnCoordinator "rank" "tcoord") (struct.loadF BackupTxnCoordinator "ptgs" "tcoord") in
            Mutex__Lock "mu";;
            "nr" <-[uint64T] ((![uint64T] "nr") + #1);;
            (if: (~ "vdg")
            then "vd" <-[boolT] #false
            else
              (if: "stg" = tulip.TXN_PREPARED
              then "np" <-[uint64T] ((![uint64T] "np") + #1)
              else "st" <-[uint64T] "stg"));;
            Mutex__Unlock "mu";;
            Cond__Signal "cv"));;
    Mutex__Lock "mu";;
    Skip;;
    (for: (λ: <>, (![boolT] "vd") && ((![uint64T] "nr") ≠ (MapLen (struct.loadF BackupTxnCoordinator "gcoords" "tcoord")))); (λ: <>, Skip) := λ: <>,
      Cond__Wait "cv";;
      Continue);;
    let: "status" := ![uint64T] "st" in
    let: "valid" := ![boolT] "vd" in
    Mutex__Unlock "mu";;
    ("status", "valid").

Definition BackupTxnCoordinator__commit: val :=
  rec: "BackupTxnCoordinator__commit" "tcoord" :=
    MapIter (struct.loadF BackupTxnCoordinator "gcoords" "tcoord") (λ: <> "gcoordloop",
      let: "gcoord" := "gcoordloop" in
      Fork (BackupGroupCoordinator__Commit "gcoord" (struct.loadF BackupTxnCoordinator "ts" "tcoord")));;
    #().

Definition BackupTxnCoordinator__abort: val :=
  rec: "BackupTxnCoordinator__abort" "tcoord" :=
    MapIter (struct.loadF BackupTxnCoordinator "gcoords" "tcoord") (λ: <> "gcoordloop",
      let: "gcoord" := "gcoordloop" in
      Fork (BackupGroupCoordinator__Abort "gcoord" (struct.loadF BackupTxnCoordinator "ts" "tcoord")));;
    #().

(* Top-level method of backup transaction coordinator. *)
Definition BackupTxnCoordinator__Finalize: val :=
  rec: "BackupTxnCoordinator__Finalize" "tcoord" :=
    let: ("status", "valid") := BackupTxnCoordinator__stabilize "tcoord" in
    (if: (~ "valid")
    then #()
    else
      (if: "status" = tulip.TXN_ABORTED
      then
        BackupTxnCoordinator__abort "tcoord";;
        #()
      else
        BackupTxnCoordinator__commit "tcoord";;
        #())).
