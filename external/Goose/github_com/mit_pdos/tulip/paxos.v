(* autogenerated from github.com/mit-pdos/tulip/paxos *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.mit_pdos.tulip.params.
From Goose Require github_com.mit_pdos.tulip.quorum.
From Goose Require github_com.mit_pdos.tulip.util.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition Paxos := struct.decl [
  "nidme" :: uint64T;
  "peers" :: slice.T uint64T;
  "addrm" :: mapT uint64T;
  "sc" :: uint64T;
  "mu" :: ptrT;
  "hb" :: boolT;
  "termc" :: uint64T;
  "terml" :: uint64T;
  "log" :: slice.T stringT;
  "lsnc" :: uint64T;
  "iscand" :: boolT;
  "isleader" :: boolT;
  "termp" :: uint64T;
  "entsp" :: slice.T stringT;
  "respp" :: mapT boolT;
  "lsnpeers" :: mapT uint64T;
  "conns" :: mapT grove_ffi.Connection
].

Definition MAX_NODES : expr := #16.

Definition Paxos__leading: val :=
  rec: "Paxos__leading" "px" :=
    struct.loadF Paxos "isleader" "px".

Definition Paxos__Submit: val :=
  rec: "Paxos__Submit" "px" "v" :=
    Mutex__Lock (struct.loadF Paxos "mu" "px");;
    (if: (~ (Paxos__leading "px"))
    then
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      (#0, #0)
    else
      let: "lsn" := slice.len (struct.loadF Paxos "log" "px") in
      struct.storeF Paxos "log" "px" (SliceAppend stringT (struct.loadF Paxos "log" "px") "v");;
      let: "term" := struct.loadF Paxos "termc" "px" in
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      ("lsn", "term")).

Definition Paxos__Lookup: val :=
  rec: "Paxos__Lookup" "px" "lsn" :=
    Mutex__Lock (struct.loadF Paxos "mu" "px");;
    (if: (struct.loadF Paxos "lsnc" "px") ≤ "lsn"
    then
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      (#(str""), #false)
    else
      let: "v" := SliceGet stringT (struct.loadF Paxos "log" "px") "lsn" in
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      ("v", #true)).

(* Return values:
   1. @term: New term in which this node attempts to be the leader.
   2. @lsn: LSN after which log entries whose committedness is yet known, and
   hence the content need to be resolved through the leader-election phase. *)
Definition Paxos__nominate: val :=
  rec: "Paxos__nominate" "px" :=
    let: "term" := util.NextAligned (struct.loadF Paxos "termc" "px") MAX_NODES (struct.loadF Paxos "nidme" "px") in
    struct.storeF Paxos "termc" "px" "term";;
    struct.storeF Paxos "isleader" "px" #false;;
    let: "lsn" := struct.loadF Paxos "lsnc" "px" in
    let: "ents" := NewSlice stringT ((slice.len (struct.loadF Paxos "log" "px")) - "lsn") in
    SliceCopy stringT "ents" (SliceSkip stringT (struct.loadF Paxos "log" "px") "lsn");;
    struct.storeF Paxos "iscand" "px" #true;;
    struct.storeF Paxos "termp" "px" (struct.loadF Paxos "terml" "px");;
    struct.storeF Paxos "entsp" "px" "ents";;
    struct.storeF Paxos "respp" "px" (NewMap uint64T boolT #());;
    MapInsert (struct.loadF Paxos "respp" "px") (struct.loadF Paxos "nidme" "px") #true;;
    (* fmt.Printf("[paxos %d] Become a candidate in %d with log: %v\n",
       	px.nidme, px.termc, px.log) *)
    ("term", "lsn").

Definition Paxos__stepdown: val :=
  rec: "Paxos__stepdown" "px" "term" :=
    struct.storeF Paxos "termc" "px" "term";;
    struct.storeF Paxos "iscand" "px" #false;;
    struct.storeF Paxos "isleader" "px" #false;;
    #().

(* Argument:
   1. @lsn: LSN after which log entries whose committedness is yet known, and
   hence the content need to be resolved through the leader-election phase.

   Return values:
   1. @terml: Log term of this node (which is also the largest accepted term
   before @px.termc).
   2. @ents: All entries after @lsn. *)
Definition Paxos__prepare: val :=
  rec: "Paxos__prepare" "px" "lsn" :=
    (if: (slice.len (struct.loadF Paxos "log" "px")) ≤ "lsn"
    then (struct.loadF Paxos "terml" "px", NewSlice stringT #0)
    else
      let: "ents" := NewSlice stringT ((slice.len (struct.loadF Paxos "log" "px")) - "lsn") in
      SliceCopy stringT "ents" (SliceSkip stringT (struct.loadF Paxos "log" "px") "lsn");;
      (struct.loadF Paxos "terml" "px", "ents")).

Definition Paxos__collect: val :=
  rec: "Paxos__collect" "px" "nid" "term" "ents" :=
    let: (<>, "recved") := MapGet (struct.loadF Paxos "respp" "px") "nid" in
    (if: "recved"
    then #()
    else
      (if: "term" < (struct.loadF Paxos "termp" "px")
      then
        MapInsert (struct.loadF Paxos "respp" "px") "nid" #true;;
        #()
      else
        (if: ("term" = (struct.loadF Paxos "termp" "px")) && ((slice.len "ents") ≤ (slice.len (struct.loadF Paxos "entsp" "px")))
        then
          MapInsert (struct.loadF Paxos "respp" "px") "nid" #true;;
          #()
        else
          struct.storeF Paxos "termp" "px" "term";;
          struct.storeF Paxos "entsp" "px" "ents";;
          MapInsert (struct.loadF Paxos "respp" "px") "nid" #true;;
          #()))).

Definition Paxos__cquorum: val :=
  rec: "Paxos__cquorum" "px" "n" :=
    (quorum.ClassicQuorum (struct.loadF Paxos "sc" "px")) ≤ "n".

Definition Paxos__ascend: val :=
  rec: "Paxos__ascend" "px" :=
    (if: (~ (Paxos__cquorum "px" (MapLen (struct.loadF Paxos "respp" "px"))))
    then #()
    else
      struct.storeF Paxos "log" "px" (SliceAppendSlice stringT (SliceTake (struct.loadF Paxos "log" "px") (struct.loadF Paxos "lsnc" "px")) (struct.loadF Paxos "entsp" "px"));;
      struct.storeF Paxos "terml" "px" (struct.loadF Paxos "termc" "px");;
      struct.storeF Paxos "iscand" "px" #false;;
      struct.storeF Paxos "isleader" "px" #true;;
      struct.storeF Paxos "lsnpeers" "px" (NewMap uint64T uint64T #());;
      (* fmt.Printf("[paxos %d] Become a leader in %d with log: %v\n",
         	px.nidme, px.termc, px.log) *)
      #()).

Definition Paxos__obtain: val :=
  rec: "Paxos__obtain" "px" "nid" :=
    let: ("lsne", "ok") := MapGet (struct.loadF Paxos "lsnpeers" "px") "nid" in
    (if: (~ "ok")
    then (slice.len (struct.loadF Paxos "log" "px"), NewSlice stringT #0)
    else
      let: "ents" := NewSlice stringT ((slice.len (struct.loadF Paxos "log" "px")) - "lsne") in
      SliceCopy stringT "ents" (SliceSkip stringT (struct.loadF Paxos "log" "px") "lsne");;
      ("lsne", "ents")).

(* Arguments:
   1. @lsn: LSN at which @ents start.
   2. @term: Term to which @ents belong.
   3. @ents: Log entries.

   Return values:
   1. @lsna: LSN up to which log consistency at term @term is established. *)
Definition Paxos__accept: val :=
  rec: "Paxos__accept" "px" "lsn" "term" "ents" :=
    (if: "term" ≠ (struct.loadF Paxos "terml" "px")
    then
      (if: (struct.loadF Paxos "lsnc" "px") ≠ "lsn"
      then struct.loadF Paxos "lsnc" "px"
      else
        struct.storeF Paxos "log" "px" (SliceTake (struct.loadF Paxos "log" "px") "lsn");;
        struct.storeF Paxos "log" "px" (SliceAppendSlice stringT (struct.loadF Paxos "log" "px") "ents");;
        struct.storeF Paxos "terml" "px" "term";;
        let: "lsna" := slice.len (struct.loadF Paxos "log" "px") in
        (* fmt.Printf("[paxos %d] Accept entries in %d up to %d: %v\n",
           	px.nidme, px.terml, lsna, px.log) *)
        "lsna")
    else
      let: "nents" := slice.len (struct.loadF Paxos "log" "px") in
      (if: ("nents" < "lsn") || (("lsn" + (slice.len "ents")) ≤ "nents")
      then "nents"
      else
        struct.storeF Paxos "log" "px" (SliceTake (struct.loadF Paxos "log" "px") "lsn");;
        struct.storeF Paxos "log" "px" (SliceAppendSlice stringT (struct.loadF Paxos "log" "px") "ents");;
        let: "lsna" := slice.len (struct.loadF Paxos "log" "px") in
        (* fmt.Printf("[paxos %d] Accept entries in %d up to %d: %v\n",
           	px.nidme, px.terml, lsna, px.log) *)
        "lsna")).

Definition Paxos__commit: val :=
  rec: "Paxos__commit" "px" "lsn" :=
    (if: "lsn" ≤ (struct.loadF Paxos "lsnc" "px")
    then #()
    else
      (if: (slice.len (struct.loadF Paxos "log" "px")) < "lsn"
      then
        struct.storeF Paxos "lsnc" "px" (slice.len (struct.loadF Paxos "log" "px"));;
        (* fmt.Printf("[paxos %d] Commit entries up to %d\n", px.nidme, px.lsnc) *)
        #()
      else
        struct.storeF Paxos "lsnc" "px" "lsn";;
        (* fmt.Printf("[paxos %d] Commit entries up to %d\n", px.nidme, px.lsnc) *)
        #())).

(* @learn monotonically increase the commit LSN @px.lsnc in term @term to @lsn. *)
Definition Paxos__learn: val :=
  rec: "Paxos__learn" "px" "lsn" "term" :=
    (if: "term" ≠ (struct.loadF Paxos "terml" "px")
    then #()
    else
      Paxos__commit "px" "lsn";;
      #()).

Definition Paxos__forward: val :=
  rec: "Paxos__forward" "px" "nid" "lsn" :=
    let: ("lsnpeer", "ok") := MapGet (struct.loadF Paxos "lsnpeers" "px") "nid" in
    (if: (~ "ok") || ("lsnpeer" < "lsn")
    then
      MapInsert (struct.loadF Paxos "lsnpeers" "px") "nid" "lsn";;
      (* fmt.Printf("[paxos %d] Advance peer %d matching LSN to %d\n",
         	px.nidme, nid, lsn) *)
      #true
    else #false).

Definition Paxos__push: val :=
  rec: "Paxos__push" "px" :=
    (if: (~ (Paxos__cquorum "px" ((MapLen (struct.loadF Paxos "lsnpeers" "px")) + #1)))
    then (#0, #false)
    else
      let: "lsns" := ref_to (slice.T uint64T) (NewSliceWithCap uint64T #0 (struct.loadF Paxos "sc" "px")) in
      MapIter (struct.loadF Paxos "lsnpeers" "px") (λ: <> "lsn",
        "lsns" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "lsns") "lsn"));;
      util.Sort (![slice.T uint64T] "lsns");;
      let: "lsn" := SliceGet uint64T (![slice.T uint64T] "lsns") ((slice.len (![slice.T uint64T] "lsns")) - ((struct.loadF Paxos "sc" "px") `quot` #2)) in
      (if: "lsn" < (struct.loadF Paxos "lsnc" "px")
      then (#0, #false)
      else ("lsn", #true))).

Definition Paxos__gttermc: val :=
  rec: "Paxos__gttermc" "px" "term" :=
    (struct.loadF Paxos "termc" "px") < "term".

Definition Paxos__lttermc: val :=
  rec: "Paxos__lttermc" "px" "term" :=
    "term" < (struct.loadF Paxos "termc" "px").

Definition Paxos__latest: val :=
  rec: "Paxos__latest" "px" :=
    (struct.loadF Paxos "termc" "px") = (struct.loadF Paxos "terml" "px").

Definition Paxos__gettermc: val :=
  rec: "Paxos__gettermc" "px" :=
    struct.loadF Paxos "termc" "px".

Definition Paxos__getlsnc: val :=
  rec: "Paxos__getlsnc" "px" :=
    struct.loadF Paxos "lsnc" "px".

Definition Paxos__nominated: val :=
  rec: "Paxos__nominated" "px" :=
    struct.loadF Paxos "iscand" "px".

Definition Paxos__resethb: val :=
  rec: "Paxos__resethb" "px" :=
    struct.storeF Paxos "hb" "px" #false;;
    #().

Definition Paxos__heartbeat: val :=
  rec: "Paxos__heartbeat" "px" :=
    struct.storeF Paxos "hb" "px" #true;;
    #().

Definition Paxos__heartbeated: val :=
  rec: "Paxos__heartbeated" "px" :=
    struct.loadF Paxos "hb" "px".

Definition MSG_PREPARE : expr := #0.

Definition MSG_ACCEPT : expr := #1.

Definition EncodeAcceptRequest: val :=
  rec: "EncodeAcceptRequest" "term" "lsnc" "lsne" "ents" :=
    let: "data" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #64) in
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") MSG_ACCEPT);;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "term");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "lsnc");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "lsne");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") (slice.len "ents"));;
    ForSlice stringT <> "ent" "ents"
      ("data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") (StringLength "ent"));;
      "data" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "data") (StringToBytes "ent")));;
    ![slice.T byteT] "data".

Definition Paxos__GetConnection: val :=
  rec: "Paxos__GetConnection" "px" "nid" :=
    Mutex__Lock (struct.loadF Paxos "mu" "px");;
    let: ("conn", "ok") := MapGet (struct.loadF Paxos "conns" "px") "nid" in
    Mutex__Unlock (struct.loadF Paxos "mu" "px");;
    ("conn", "ok").

Definition Paxos__Connect: val :=
  rec: "Paxos__Connect" "px" "nid" :=
    let: "addr" := Fst (MapGet (struct.loadF Paxos "addrm" "px") "nid") in
    let: "ret" := grove_ffi.Connect "addr" in
    (if: (~ (struct.get grove_ffi.ConnectRet "Err" "ret"))
    then
      (* fmt.Printf("[paxos %d] Connect to peer %d.\n", px.nidme, nid) *)
      Mutex__Lock (struct.loadF Paxos "mu" "px");;
      MapInsert (struct.loadF Paxos "conns" "px") "nid" (struct.get grove_ffi.ConnectRet "Connection" "ret");;
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      #true
    else #false).

Definition Paxos__Send: val :=
  rec: "Paxos__Send" "px" "nid" "data" :=
    let: ("conn", "ok") := Paxos__GetConnection "px" "nid" in
    (if: (~ "ok")
    then
      Paxos__Connect "px" "nid";;
      #()
    else
      let: "err" := grove_ffi.Send "conn" "data" in
      (if: "err"
      then
        Paxos__Connect "px" "nid";;
        #()
      else #())).

Definition Paxos__LeaderSession: val :=
  rec: "Paxos__LeaderSession" "px" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      time.Sleep params.NS_BATCH_INTERVAL;;
      Mutex__Lock (struct.loadF Paxos "mu" "px");;
      (if: (~ (Paxos__leading "px"))
      then
        Mutex__Unlock (struct.loadF Paxos "mu" "px");;
        Continue
      else
        ForSlice uint64T <> "nidloop" (struct.loadF Paxos "peers" "px")
          (let: "nid" := "nidloop" in
          let: ("lsne", "ents") := Paxos__obtain "px" "nid" in
          let: "termc" := Paxos__gettermc "px" in
          let: "lsnc" := Paxos__getlsnc "px" in
          Fork (let: "data" := EncodeAcceptRequest "termc" "lsnc" "lsne" "ents" in
                Paxos__Send "px" "nid" "data"));;
        Mutex__Unlock (struct.loadF Paxos "mu" "px");;
        Continue));;
    #().

Definition EncodePrepareRequest: val :=
  rec: "EncodePrepareRequest" "term" "lsnc" :=
    let: "data" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #24) in
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") MSG_PREPARE);;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "term");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "lsnc");;
    ![slice.T byteT] "data".

Definition Paxos__ElectionSession: val :=
  rec: "Paxos__ElectionSession" "px" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "delta" := (rand.RandomUint64 #()) `rem` params.NS_ELECTION_TIMEOUT_DELTA in
      time.Sleep (params.NS_ELECTION_TIMEOUT_BASE + "delta");;
      Mutex__Lock (struct.loadF Paxos "mu" "px");;
      (if: Paxos__leading "px"
      then
        Mutex__Unlock (struct.loadF Paxos "mu" "px");;
        Continue
      else
        (if: Paxos__heartbeated "px"
        then
          Paxos__resethb "px";;
          Mutex__Unlock (struct.loadF Paxos "mu" "px");;
          Continue
        else
          let: "termc" := ref (zero_val uint64T) in
          let: "lsnc" := ref (zero_val uint64T) in
          (if: Paxos__nominated "px"
          then
            "termc" <-[uint64T] (Paxos__gettermc "px");;
            "lsnc" <-[uint64T] (Paxos__getlsnc "px")
          else
            let: ("0_ret", "1_ret") := Paxos__nominate "px" in
            "termc" <-[uint64T] "0_ret";;
            "lsnc" <-[uint64T] "1_ret");;
          Mutex__Unlock (struct.loadF Paxos "mu" "px");;
          ForSlice uint64T <> "nidloop" (struct.loadF Paxos "peers" "px")
            (let: "nid" := "nidloop" in
            Fork (let: "data" := EncodePrepareRequest (![uint64T] "termc") (![uint64T] "lsnc") in
                  Paxos__Send "px" "nid" "data"));;
          Continue)));;
    #().

Definition Paxos__Receive: val :=
  rec: "Paxos__Receive" "px" "nid" :=
    let: ("conn", "ok") := Paxos__GetConnection "px" "nid" in
    (if: (~ "ok")
    then
      Paxos__Connect "px" "nid";;
      (slice.nil, #false)
    else
      let: "ret" := grove_ffi.Receive "conn" in
      (if: struct.get grove_ffi.ReceiveRet "Err" "ret"
      then
        Paxos__Connect "px" "nid";;
        (slice.nil, #false)
      else (struct.get grove_ffi.ReceiveRet "Data" "ret", #true))).

(* [REQUEST-VOTE, NodeID, Term, EntriesTerm, Entries]
   [APPEND-ENTRIES, NodeID, Term, MatchedLSN] *)
Definition PaxosResponse := struct.decl [
  "Kind" :: uint64T;
  "NodeID" :: uint64T;
  "Term" :: uint64T;
  "EntriesTerm" :: uint64T;
  "Entries" :: slice.T stringT;
  "MatchedLSN" :: uint64T
].

Definition DecodePrepareResponse: val :=
  rec: "DecodePrepareResponse" "data" :=
    let: ("nid", "data") := marshal.ReadInt "data" in
    let: ("term", "data") := marshal.ReadInt "data" in
    let: ("terma", "data") := marshal.ReadInt "data" in
    let: ("n", "data") := marshal.ReadInt "data" in
    let: "ents" := ref_to (slice.T stringT) (NewSliceWithCap stringT #0 "n") in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, Skip) := λ: <>,
      let: ("sz", "data") := marshal.ReadInt "data" in
      let: ("bs", "data") := marshal.ReadBytes "data" "sz" in
      "ents" <-[slice.T stringT] (SliceAppend stringT (![slice.T stringT] "ents") (StringFromBytes "bs"));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    struct.mk PaxosResponse [
      "Kind" ::= MSG_PREPARE;
      "NodeID" ::= "nid";
      "Term" ::= "term";
      "EntriesTerm" ::= "terma";
      "Entries" ::= ![slice.T stringT] "ents"
    ].

Definition DecodeAcceptResponse: val :=
  rec: "DecodeAcceptResponse" "data" :=
    let: ("nid", "data") := marshal.ReadInt "data" in
    let: ("term", "data") := marshal.ReadInt "data" in
    let: ("lsn", "data") := marshal.ReadInt "data" in
    struct.mk PaxosResponse [
      "Kind" ::= MSG_ACCEPT;
      "NodeID" ::= "nid";
      "Term" ::= "term";
      "MatchedLSN" ::= "lsn"
    ].

Definition DecodeResponse: val :=
  rec: "DecodeResponse" "data" :=
    let: ("kind", "data") := marshal.ReadInt "data" in
    let: "resp" := ref (zero_val (struct.t PaxosResponse)) in
    (if: "kind" = MSG_PREPARE
    then "resp" <-[struct.t PaxosResponse] (DecodePrepareResponse "data")
    else
      (if: "kind" = MSG_ACCEPT
      then "resp" <-[struct.t PaxosResponse] (DecodeAcceptResponse "data")
      else #()));;
    ![struct.t PaxosResponse] "resp".

Definition Paxos__ResponseSession: val :=
  rec: "Paxos__ResponseSession" "px" "nid" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("data", "ok") := Paxos__Receive "px" "nid" in
      (if: (~ "ok")
      then
        time.Sleep params.NS_RECONNECT;;
        Continue
      else
        let: "resp" := DecodeResponse "data" in
        let: "kind" := struct.get PaxosResponse "Kind" "resp" in
        Mutex__Lock (struct.loadF Paxos "mu" "px");;
        (if: Paxos__lttermc "px" (struct.get PaxosResponse "Term" "resp")
        then
          Mutex__Unlock (struct.loadF Paxos "mu" "px");;
          Continue
        else
          (if: Paxos__gttermc "px" (struct.get PaxosResponse "Term" "resp")
          then
            Paxos__stepdown "px" (struct.get PaxosResponse "Term" "resp");;
            Mutex__Unlock (struct.loadF Paxos "mu" "px");;
            Continue
          else
            (if: "kind" = MSG_PREPARE
            then
              (if: (~ (Paxos__nominated "px"))
              then
                Mutex__Unlock (struct.loadF Paxos "mu" "px");;
                Continue
              else
                Paxos__collect "px" (struct.get PaxosResponse "NodeID" "resp") (struct.get PaxosResponse "EntriesTerm" "resp") (struct.get PaxosResponse "Entries" "resp");;
                Paxos__ascend "px";;
                Mutex__Unlock (struct.loadF Paxos "mu" "px");;
                Continue)
            else
              (if: "kind" = MSG_ACCEPT
              then
                (if: (~ (Paxos__leading "px"))
                then
                  Mutex__Unlock (struct.loadF Paxos "mu" "px");;
                  Continue
                else
                  (if: (struct.get PaxosResponse "NodeID" "resp") = (struct.loadF Paxos "nidme" "px")
                  then
                    Mutex__Unlock (struct.loadF Paxos "mu" "px");;
                    Continue
                  else
                    let: "forwarded" := Paxos__forward "px" (struct.get PaxosResponse "NodeID" "resp") (struct.get PaxosResponse "MatchedLSN" "resp") in
                    (if: (~ "forwarded")
                    then
                      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
                      Continue
                    else
                      let: ("lsnc", "pushed") := Paxos__push "px" in
                      (if: (~ "pushed")
                      then
                        Mutex__Unlock (struct.loadF Paxos "mu" "px");;
                        Continue
                      else
                        Paxos__commit "px" "lsnc";;
                        Mutex__Unlock (struct.loadF Paxos "mu" "px");;
                        Continue))))
              else Continue))))));;
    #().

(* [REQUEST-VOTE, Term, CommittedLSN]
   [APPEND-ENTRIES, Term, CommittedLSN, LSNEntries, Entries] *)
Definition PaxosRequest := struct.decl [
  "Kind" :: uint64T;
  "Term" :: uint64T;
  "CommittedLSN" :: uint64T;
  "EntriesLSN" :: uint64T;
  "Entries" :: slice.T stringT
].

Definition DecodePrepareRequest: val :=
  rec: "DecodePrepareRequest" "data" :=
    let: ("term", "data") := marshal.ReadInt "data" in
    let: ("lsnc", "data") := marshal.ReadInt "data" in
    struct.mk PaxosRequest [
      "Kind" ::= MSG_PREPARE;
      "Term" ::= "term";
      "CommittedLSN" ::= "lsnc"
    ].

Definition DecodeAcceptRequest: val :=
  rec: "DecodeAcceptRequest" "data" :=
    let: ("term", "data") := marshal.ReadInt "data" in
    let: ("lsnc", "data") := marshal.ReadInt "data" in
    let: ("lsne", "data") := marshal.ReadInt "data" in
    let: ("n", "data") := marshal.ReadInt "data" in
    let: "ents" := ref_to (slice.T stringT) (NewSliceWithCap stringT #0 "n") in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, Skip) := λ: <>,
      let: ("sz", "data") := marshal.ReadInt "data" in
      let: ("bs", "data") := marshal.ReadBytes "data" "sz" in
      "ents" <-[slice.T stringT] (SliceAppend stringT (![slice.T stringT] "ents") (StringFromBytes "bs"));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    struct.mk PaxosRequest [
      "Kind" ::= MSG_ACCEPT;
      "Term" ::= "term";
      "CommittedLSN" ::= "lsnc";
      "EntriesLSN" ::= "lsne";
      "Entries" ::= ![slice.T stringT] "ents"
    ].

Definition DecodeRequest: val :=
  rec: "DecodeRequest" "data" :=
    let: ("kind", "data") := marshal.ReadInt "data" in
    let: "req" := ref (zero_val (struct.t PaxosRequest)) in
    (if: "kind" = MSG_PREPARE
    then "req" <-[struct.t PaxosRequest] (DecodePrepareRequest "data")
    else
      (if: "kind" = MSG_ACCEPT
      then "req" <-[struct.t PaxosRequest] (DecodeAcceptRequest "data")
      else #()));;
    ![struct.t PaxosRequest] "req".

Definition EncodePrepareResponse: val :=
  rec: "EncodePrepareResponse" "nid" "term" "terma" "ents" :=
    let: "data" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #64) in
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") MSG_PREPARE);;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "nid");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "term");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "terma");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") (slice.len "ents"));;
    ForSlice stringT <> "ent" "ents"
      ("data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") (StringLength "ent"));;
      "data" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "data") (StringToBytes "ent")));;
    ![slice.T byteT] "data".

Definition EncodeAcceptResponse: val :=
  rec: "EncodeAcceptResponse" "nid" "term" "lsn" :=
    let: "data" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #32) in
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") MSG_ACCEPT);;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "nid");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "term");;
    "data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "lsn");;
    ![slice.T byteT] "data".

Definition Paxos__RequestSession: val :=
  rec: "Paxos__RequestSession" "px" "conn" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "ret" := grove_ffi.Receive "conn" in
      (if: struct.get grove_ffi.ReceiveRet "Err" "ret"
      then Break
      else
        let: "req" := DecodeRequest (struct.get grove_ffi.ReceiveRet "Data" "ret") in
        let: "kind" := struct.get PaxosRequest "Kind" "req" in
        Mutex__Lock (struct.loadF Paxos "mu" "px");;
        (if: Paxos__lttermc "px" (struct.get PaxosRequest "Term" "req")
        then
          Mutex__Unlock (struct.loadF Paxos "mu" "px");;
          Continue
        else
          Paxos__stepdown "px" (struct.get PaxosRequest "Term" "req");;
          Paxos__heartbeat "px";;
          let: "termc" := Paxos__gettermc "px" in
          (if: "kind" = MSG_PREPARE
          then
            (if: Paxos__latest "px"
            then
              Mutex__Unlock (struct.loadF Paxos "mu" "px");;
              Continue
            else
              let: ("terml", "ents") := Paxos__prepare "px" (struct.get PaxosRequest "CommittedLSN" "req") in
              Mutex__Unlock (struct.loadF Paxos "mu" "px");;
              let: "data" := EncodePrepareResponse (struct.loadF Paxos "nidme" "px") "termc" "terml" "ents" in
              grove_ffi.Send "conn" "data";;
              Continue)
          else
            (if: "kind" = MSG_ACCEPT
            then
              let: "lsn" := Paxos__accept "px" (struct.get PaxosRequest "EntriesLSN" "req") (struct.get PaxosRequest "Term" "req") (struct.get PaxosRequest "Entries" "req") in
              Paxos__learn "px" (struct.get PaxosRequest "CommittedLSN" "req") (struct.get PaxosRequest "Term" "req");;
              Mutex__Unlock (struct.loadF Paxos "mu" "px");;
              let: "data" := EncodeAcceptResponse (struct.loadF Paxos "nidme" "px") "termc" "lsn" in
              grove_ffi.Send "conn" "data";;
              Continue
            else Continue)))));;
    #().

Definition Paxos__Serve: val :=
  rec: "Paxos__Serve" "px" :=
    let: "addrme" := Fst (MapGet (struct.loadF Paxos "addrm" "px") (struct.loadF Paxos "nidme" "px")) in
    let: "ls" := grove_ffi.Listen "addrme" in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "conn" := grove_ffi.Accept "ls" in
      Fork (Paxos__RequestSession "px" "conn");;
      Continue);;
    #().

Definition Paxos__ConnectAll: val :=
  rec: "Paxos__ConnectAll" "px" :=
    ForSlice uint64T <> "nid" (struct.loadF Paxos "peers" "px")
      (Paxos__Connect "px" "nid");;
    #().

Definition mkPaxos: val :=
  rec: "mkPaxos" "nidme" "termc" "terml" "lsnc" "log" "addrm" :=
    let: "sc" := MapLen "addrm" in
    let: "peers" := ref_to (slice.T uint64T) (NewSliceWithCap uint64T #0 ("sc" - #1)) in
    MapIter "addrm" (λ: "nid" <>,
      (if: "nid" ≠ "nidme"
      then "peers" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "peers") "nid")
      else #()));;
    let: "px" := struct.new Paxos [
      "nidme" ::= "nidme";
      "peers" ::= ![slice.T uint64T] "peers";
      "addrm" ::= "addrm";
      "sc" ::= "sc";
      "mu" ::= newMutex #();
      "hb" ::= #false;
      "termc" ::= "termc";
      "terml" ::= "terml";
      "log" ::= "log";
      "lsnc" ::= "lsnc";
      "iscand" ::= #false;
      "isleader" ::= #false;
      "conns" ::= NewMap uint64T grove_ffi.Connection #()
    ] in
    "px".

Definition resume: val :=
  rec: "resume" <> :=
    (#0, #0, #0, NewSlice stringT #0).

Definition Start: val :=
  rec: "Start" "nidme" "addrm" :=
    control.impl.Assume (#1 < (MapLen "addrm"));;
    let: (<>, "ok") := MapGet "addrm" "nidme" in
    control.impl.Assume "ok";;
    control.impl.Assume ("nidme" < MAX_NODES);;
    let: ((("termc", "terml"), "lsnc"), "log") := resume #() in
    let: "px" := mkPaxos "nidme" "termc" "terml" "lsnc" "log" "addrm" in
    Fork (Paxos__Serve "px");;
    Fork (Paxos__LeaderSession "px");;
    Fork (Paxos__ElectionSession "px");;
    ForSlice uint64T <> "nidloop" (struct.loadF Paxos "peers" "px")
      (let: "nid" := "nidloop" in
      Fork (Paxos__ResponseSession "px" "nid"));;
    "px".
