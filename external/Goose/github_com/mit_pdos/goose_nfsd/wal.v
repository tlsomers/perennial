(* autogenerated from github.com/mit-pdos/goose-nfsd/wal *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

From Goose Require github_com.mit_pdos.goose_nfsd.common.
From Goose Require github_com.mit_pdos.goose_nfsd.fake_bcache.bcache.
From Goose Require github_com.mit_pdos.goose_nfsd.util.
From Goose Require github_com.tchajed.marshal.

(* 0waldefs.go *)

(*  wal implements write-ahead logging

    The layout of log:
    [ installed writes | logged writes | in-memory/logged | unstable in-memory ]
     ^                   ^               ^                  ^
     0                   memStart        diskEnd            nextDiskEnd

    Blocks in the range [diskEnd, nextDiskEnd) are in the process of
    being logged.  Blocks in unstable are unstably committed (i.e.,
    written by NFS Write with the unstable flag and they can be lost
    on crash). Later transactions may absorb them (e.g., a later NFS
    write may update the same inode or indirect block).  The code
    implements a policy of postponing writing unstable blocks to disk
    as long as possible to maximize the chance of absorption (i.e.,
    commitWait or log is full).  It may better to start logging
    earlier. *)

(* space for the end position *)
Definition HDRMETA : expr := #8.

Definition HDRADDRS : expr := disk.BlockSize - HDRMETA `quot` #8.

Definition LOGSZ : expr := HDRADDRS.

(* 2 for log header *)
Definition LOGDISKBLOCKS : expr := HDRADDRS + #2.

Definition LogPosition: ty := uint64T.

Definition LOGHDR : expr := #0.

Definition LOGHDR2 : expr := #1.

Definition LOGSTART : expr := #2.

Module BlockData.
  Definition S := struct.decl [
    "bn" :: common.Bnum;
    "blk" :: disk.blockT
  ].
End BlockData.

Definition MkBlockData: val :=
  λ: "bn" "blk",
    let: "b" := struct.mk BlockData.S [
      "bn" ::= "bn";
      "blk" ::= "blk"
    ] in
    "b".

Module Walog.
  Definition S := struct.decl [
    "memLock" :: lockRefT;
    "d" :: struct.ptrT bcache.Bcache.S;
    "condLogger" :: condvarRefT;
    "condInstall" :: condvarRefT;
    "memLog" :: slice.T (struct.t BlockData.S);
    "memStart" :: LogPosition;
    "diskEnd" :: LogPosition;
    "nextDiskEnd" :: LogPosition;
    "shutdown" :: boolT;
    "nthread" :: uint64T;
    "condShut" :: condvarRefT;
    "memLogMap" :: mapT LogPosition
  ].
End Walog.

(* On-disk header in the first block of the log *)
Module hdr.
  Definition S := struct.decl [
    "end" :: LogPosition;
    "addrs" :: slice.T common.Bnum
  ].
End hdr.

Definition decodeHdr: val :=
  λ: "blk",
    let: "h" := struct.new hdr.S [
      "end" ::= #0;
      "addrs" ::= slice.nil
    ] in
    let: "dec" := marshal.NewDec "blk" in
    struct.storeF hdr.S "end" "h" (marshal.Dec__GetInt "dec");;
    struct.storeF hdr.S "addrs" "h" (marshal.Dec__GetInts "dec" HDRADDRS);;
    "h".

Definition encodeHdr: val :=
  λ: "h",
    let: "enc" := marshal.NewEnc disk.BlockSize in
    marshal.Enc__PutInt "enc" (struct.get hdr.S "end" "h");;
    marshal.Enc__PutInts "enc" (struct.get hdr.S "addrs" "h");;
    marshal.Enc__Finish "enc".

(* On-disk header in the second block of the log *)
Module hdr2.
  Definition S := struct.decl [
    "start" :: LogPosition
  ].
End hdr2.

Definition decodeHdr2: val :=
  λ: "blk",
    let: "h" := struct.new hdr2.S [
      "start" ::= #0
    ] in
    let: "dec" := marshal.NewDec "blk" in
    struct.storeF hdr2.S "start" "h" (marshal.Dec__GetInt "dec");;
    "h".

Definition encodeHdr2: val :=
  λ: "h",
    let: "enc" := marshal.NewEnc disk.BlockSize in
    marshal.Enc__PutInt "enc" (struct.get hdr2.S "start" "h");;
    marshal.Enc__Finish "enc".

Definition Walog__writeHdr: val :=
  λ: "l" "h",
    let: "blk" := encodeHdr (struct.load hdr.S "h") in
    bcache.Bcache__Write (struct.loadF Walog.S "d" "l") LOGHDR "blk".

Definition Walog__readHdr: val :=
  λ: "l",
    let: "blk" := bcache.Bcache__Read (struct.loadF Walog.S "d" "l") LOGHDR in
    let: "h" := decodeHdr "blk" in
    "h".

Definition Walog__writeHdr2: val :=
  λ: "l" "h",
    let: "blk" := encodeHdr2 (struct.load hdr2.S "h") in
    bcache.Bcache__Write (struct.loadF Walog.S "d" "l") LOGHDR2 "blk".

Definition Walog__readHdr2: val :=
  λ: "l",
    let: "blk" := bcache.Bcache__Read (struct.loadF Walog.S "d" "l") LOGHDR2 in
    let: "h" := decodeHdr2 "blk" in
    "h".

Definition posToDiskAddr: val :=
  λ: "pos",
    LOGSTART + "pos" `rem` LOGSZ.

Definition Walog__LogSz: val :=
  λ: "l",
    common.HDRADDRS.

(* installer.go *)

Definition Walog__cutMemLog: val :=
  λ: "l" "installEnd",
    ForSlice (struct.t BlockData.S) "i" "blk" (SliceTake (struct.loadF Walog.S "memLog" "l") ("installEnd" - struct.loadF Walog.S "memStart" "l"))
      (let: "pos" := "installEnd" + "i" in
      let: "blkno" := struct.get BlockData.S "bn" "blk" in
      let: ("oldPos", "ok") := MapGet (struct.loadF Walog.S "memLogMap" "l") "blkno" in
      (if: "ok" && ("oldPos" = "pos")
      then
        util.DPrintf #5 (#(str"memLogMap: del %d %d
        ")) "blkno" "oldPos";;
        MapDelete (struct.loadF Walog.S "memLogMap" "l") "blkno"
      else #()));;
    struct.storeF Walog.S "memLog" "l" (SliceSkip (struct.t BlockData.S) (struct.loadF Walog.S "memLog" "l") ("installEnd" - struct.loadF Walog.S "memStart" "l"));;
    struct.storeF Walog.S "memStart" "l" "installEnd".

(* installBlocks installs the updates in bufs to the data region

   Does not hold the memLock, but expects exclusive ownership of the data
   region. *)
Definition Walog__installBlocks: val :=
  λ: "l" "bufs",
    ForSlice (struct.t BlockData.S) "i" "buf" "bufs"
      (let: "blkno" := struct.get BlockData.S "bn" "buf" in
      let: "blk" := struct.get BlockData.S "blk" "buf" in
      util.DPrintf #5 (#(str"installBlocks: write log block %d to %d
      ")) "i" "blkno";;
      bcache.Bcache__Write (struct.loadF Walog.S "d" "l") "blkno" "blk").

(* logInstall installs one on-disk transaction from the disk log to the data
   region.

   Returns (blkCount, installEnd)

   blkCount is the number of blocks installed (only used for liveness)

   installEnd is the new last position installed to the data region (only used
   for debugging)

   Installer holds memLock
   XXX absorb *)
Definition Walog__logInstall: val :=
  λ: "l",
    let: "installEnd" := struct.loadF Walog.S "diskEnd" "l" in
    let: "bufs" := SliceTake (struct.loadF Walog.S "memLog" "l") ("installEnd" - struct.loadF Walog.S "memStart" "l") in
    (if: (slice.len "bufs" = #0)
    then (#0, "installEnd")
    else
      lock.release (struct.loadF Walog.S "memLock" "l");;
      util.DPrintf #5 (#(str"logInstall up to %d
      ")) "installEnd";;
      Walog__installBlocks "l" "bufs";;
      let: "h" := struct.new hdr2.S [
        "start" ::= "installEnd"
      ] in
      Walog__writeHdr2 "l" "h";;
      lock.acquire (struct.loadF Walog.S "memLock" "l");;
      (if: "installEnd" < struct.loadF Walog.S "memStart" "l"
      then
        Panic "logInstall";;
        #()
      else #());;
      Walog__cutMemLog "l" "installEnd";;
      lock.condBroadcast (struct.loadF Walog.S "condInstall" "l");;
      (slice.len "bufs", "installEnd")).

(* installer installs blocks from the on-disk log to their home location. *)
Definition Walog__installer: val :=
  λ: "l",
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    struct.storeF Walog.S "nthread" "l" (struct.loadF Walog.S "nthread" "l" + #1);;
    Skip;;
    (for: (λ: <>, ~ (struct.loadF Walog.S "shutdown" "l")); (λ: <>, Skip) := λ: <>,
      let: ("blkcount", "txn") := Walog__logInstall "l" in
      (if: "blkcount" > #0
      then
        util.DPrintf #5 (#(str"Installed till txn %d
        ")) "txn"
      else lock.condWait (struct.loadF Walog.S "condInstall" "l"));;
      Continue);;
    util.DPrintf #1 (#(str"installer: shutdown
    "));;
    struct.storeF Walog.S "nthread" "l" (struct.loadF Walog.S "nthread" "l" - #1);;
    lock.condSignal (struct.loadF Walog.S "condShut" "l");;
    lock.release (struct.loadF Walog.S "memLock" "l").

(* logger.go *)

(* logBlocks writes bufs to the end of the circular log

   Requires diskend to reflect the on-disk log, but otherwise operates without
   holding any locks (with exclusive ownership of the on-disk log).

   The caller is responsible for updating both the disk and memory copy of
   diskEnd. *)
Definition Walog__logBlocks: val :=
  λ: "l" "diskEnd" "bufs",
    ForSlice (struct.t BlockData.S) "i" "buf" "bufs"
      (let: "pos" := "diskEnd" + "i" in
      let: "blk" := struct.get BlockData.S "blk" "buf" in
      let: "blkno" := struct.get BlockData.S "bn" "buf" in
      util.DPrintf #5 (#(str"logBlocks: %d to log block %d
      ")) "blkno" "pos";;
      bcache.Bcache__Write (struct.loadF Walog.S "d" "l") (posToDiskAddr "pos") "blk").

(* logAppend appends to the log, if it can find transactions to append.

   It grabs the new writes in memory and not on disk through l.
   nextDiskEnd; if there are any such writes, it commits them atomically.

   assumes caller holds memLock

   Returns true if it made progress (for liveness, not important for
   correctness). *)
Definition Walog__logAppend: val :=
  λ: "l",
    Skip;;
    (for: (λ: <>, slice.len (struct.loadF Walog.S "memLog" "l") > LOGSZ); (λ: <>, Skip) := λ: <>,
      lock.condWait (struct.loadF Walog.S "condInstall" "l");;
      Continue);;
    let: "memstart" := struct.loadF Walog.S "memStart" "l" in
    let: "memlog" := struct.loadF Walog.S "memLog" "l" in
    let: "newDiskEnd" := struct.loadF Walog.S "nextDiskEnd" "l" in
    let: "diskEnd" := struct.loadF Walog.S "diskEnd" "l" in
    let: "newbufs" := SliceSubslice (struct.t BlockData.S) "memlog" ("diskEnd" - "memstart") ("newDiskEnd" - "memstart") in
    (if: (slice.len "newbufs" = #0)
    then #false
    else
      lock.release (struct.loadF Walog.S "memLock" "l");;
      Walog__logBlocks "l" "diskEnd" "newbufs";;
      let: "addrs" := NewSlice common.Bnum HDRADDRS in
      ForSlice (struct.t BlockData.S) "i" "buf" (SliceTake "memlog" ("newDiskEnd" - "memstart"))
        (let: "pos" := "memstart" + "i" in
        SliceSet uint64T "addrs" ("pos" `rem` LOGSZ) (struct.get BlockData.S "bn" "buf"));;
      let: "newh" := struct.new hdr.S [
        "end" ::= "newDiskEnd";
        "addrs" ::= "addrs"
      ] in
      Walog__writeHdr "l" "newh";;
      bcache.Bcache__Barrier (struct.loadF Walog.S "d" "l");;
      lock.acquire (struct.loadF Walog.S "memLock" "l");;
      struct.storeF Walog.S "diskEnd" "l" "newDiskEnd";;
      lock.condBroadcast (struct.loadF Walog.S "condLogger" "l");;
      lock.condBroadcast (struct.loadF Walog.S "condInstall" "l");;
      #true).

(* logger writes blocks from the in-memory log to the on-disk log

   Operates by continuously polling for in-memory transactions, driven by
   condLogger for scheduling *)
Definition Walog__logger: val :=
  λ: "l",
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    struct.storeF Walog.S "nthread" "l" (struct.loadF Walog.S "nthread" "l" + #1);;
    Skip;;
    (for: (λ: <>, ~ (struct.loadF Walog.S "shutdown" "l")); (λ: <>, Skip) := λ: <>,
      let: "progress" := Walog__logAppend "l" in
      (if: ~ "progress"
      then lock.condWait (struct.loadF Walog.S "condLogger" "l")
      else #());;
      Continue);;
    util.DPrintf #1 (#(str"logger: shutdown
    "));;
    struct.storeF Walog.S "nthread" "l" (struct.loadF Walog.S "nthread" "l" - #1);;
    lock.condSignal (struct.loadF Walog.S "condShut" "l");;
    lock.release (struct.loadF Walog.S "memLock" "l").

(* wal.go *)

Definition Walog__recover: val :=
  λ: "l",
    let: "h" := Walog__readHdr "l" in
    let: "h2" := Walog__readHdr2 "l" in
    struct.storeF Walog.S "memStart" "l" (struct.loadF hdr2.S "start" "h2");;
    struct.storeF Walog.S "diskEnd" "l" (struct.loadF hdr.S "end" "h");;
    util.DPrintf #1 (#(str"recover %d %d
    ")) (struct.loadF Walog.S "memStart" "l") (struct.loadF Walog.S "diskEnd" "l");;
    let: "pos" := ref (struct.loadF hdr2.S "start" "h2") in
    (for: (λ: <>, ![LogPosition] "pos" < struct.loadF hdr.S "end" "h"); (λ: <>, "pos" <-[LogPosition] ![LogPosition] "pos" + #1) := λ: <>,
      let: "addr" := SliceGet uint64T (struct.loadF hdr.S "addrs" "h") (![LogPosition] "pos" `rem` Walog__LogSz "l") in
      util.DPrintf #1 (#(str"recover block %d
      ")) "addr";;
      let: "blk" := bcache.Bcache__Read (struct.loadF Walog.S "d" "l") (LOGSTART + ![LogPosition] "pos" `rem` Walog__LogSz "l") in
      let: "b" := MkBlockData "addr" "blk" in
      struct.storeF Walog.S "memLog" "l" (SliceAppend (struct.t BlockData.S) (struct.loadF Walog.S "memLog" "l") "b");;
      Continue);;
    struct.storeF Walog.S "nextDiskEnd" "l" (struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l")).

Definition MkLog: val :=
  λ: "disk",
    let: "ml" := lock.new #() in
    let: "l" := struct.new Walog.S [
      "d" ::= "disk";
      "memLock" ::= "ml";
      "condLogger" ::= lock.newCond "ml";
      "condInstall" ::= lock.newCond "ml";
      "memLog" ::= NewSlice (struct.t BlockData.S) #0;
      "memStart" ::= #0;
      "diskEnd" ::= #0;
      "nextDiskEnd" ::= #0;
      "shutdown" ::= #false;
      "nthread" ::= #0;
      "condShut" ::= lock.newCond "ml";
      "memLogMap" ::= NewMap LogPosition
    ] in
    util.DPrintf #1 (#(str"mkLog: size %d
    ")) LOGSZ;;
    Walog__recover "l";;
    Fork (Walog__logger "l");;
    Fork (Walog__installer "l");;
    "l".

(* Read blkno from memLog, if present *)
Definition Walog__readMemLog: val :=
  λ: "l" "blkno",
    let: "blk" := ref (zero_val (slice.T byteT)) in
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    let: ("pos", "ok") := MapGet (struct.loadF Walog.S "memLogMap" "l") "blkno" in
    (if: "ok"
    then
      util.DPrintf #5 (#(str"read memLogMap: read %d pos %d
      ")) "blkno" "pos";;
      let: "buf" := SliceGet (struct.t BlockData.S) (struct.loadF Walog.S "memLog" "l") ("pos" - struct.loadF Walog.S "memStart" "l") in
      "blk" <-[slice.T byteT] NewSlice byteT disk.BlockSize;;
      SliceCopy byteT (![slice.T byteT] "blk") (struct.get BlockData.S "blk" "buf");;
      #()
    else #());;
    lock.release (struct.loadF Walog.S "memLock" "l");;
    ![slice.T byteT] "blk".

Definition Walog__Read: val :=
  λ: "l" "blkno",
    let: "blk" := ref (zero_val (slice.T byteT)) in
    let: "blkMem" := Walog__readMemLog "l" "blkno" in
    (if: "blkMem" ≠ slice.nil
    then "blk" <-[slice.T byteT] "blkMem"
    else "blk" <-[slice.T byteT] bcache.Bcache__Read (struct.loadF Walog.S "d" "l") "blkno");;
    ![slice.T byteT] "blk".

(* memWrite writes out bufs to the in-memory log

   Absorbs writes in in-memory transactions (avoiding those that might be in
   the process of being logged or installed).

   Assumes caller holds memLock *)
Definition Walog__memWrite: val :=
  λ: "l" "bufs",
    let: "pos" := ref (slice.len (struct.loadF Walog.S "memLog" "l")) in
    ForSlice (struct.t BlockData.S) <> "buf" "bufs"
      (let: ("oldpos", "ok") := MapGet (struct.loadF Walog.S "memLogMap" "l") (struct.get BlockData.S "bn" "buf") in
      (if: "ok" && "oldpos" ≥ struct.loadF Walog.S "nextDiskEnd" "l"
      then
        util.DPrintf #5 (#(str"memWrite: absorb %d pos %d old %d
        ")) (struct.get BlockData.S "bn" "buf") (![LogPosition] "pos") "oldpos";;
        SliceSet (struct.t BlockData.S) (struct.loadF Walog.S "memLog" "l") ("oldpos" - struct.loadF Walog.S "memStart" "l") "buf"
      else
        (if: "ok"
        then
          util.DPrintf #5 (#(str"memLogMap: replace %d pos %d old %d
          ")) (struct.get BlockData.S "bn" "buf") (![LogPosition] "pos") "oldpos"
        else
          util.DPrintf #5 (#(str"memLogMap: add %d pos %d
          ")) (struct.get BlockData.S "bn" "buf") (![LogPosition] "pos"));;
        struct.storeF Walog.S "memLog" "l" (SliceAppend (struct.t BlockData.S) (struct.loadF Walog.S "memLog" "l") "buf");;
        MapInsert (struct.loadF Walog.S "memLogMap" "l") (struct.get BlockData.S "bn" "buf") (![LogPosition] "pos");;
        "pos" <-[LogPosition] ![LogPosition] "pos" + #1)).

(* Assumes caller holds memLock

   Appends to the in-memory log and returns the new transaction's pos in the
   log. *)
Definition Walog__doMemAppend: val :=
  λ: "l" "bufs",
    Walog__memWrite "l" "bufs";;
    let: "txn" := struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l") in
    "txn".

(* Append to in-memory log.

   On success returns the txn for this append.

   On failure guaranteed to be idempotent (failure can occur either due to bufs
   exceeding the size of the log or in principle due to overflowing 2^64 writes) *)
Definition Walog__MemAppend: val :=
  λ: "l" "bufs",
    (if: slice.len "bufs" > LOGSZ
    then (#0, #false)
    else
      let: "txn" := ref #0 in
      let: "ok" := ref #true in
      lock.acquire (struct.loadF Walog.S "memLock" "l");;
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: util.SumOverflows (struct.loadF Walog.S "memStart" "l") (slice.len "bufs")
        then
          "ok" <-[boolT] #false;;
          Break
        else
          let: "memEnd" := struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l") in
          let: "memSize" := "memEnd" - struct.loadF Walog.S "diskEnd" "l" in
          (if: "memSize" + slice.len "bufs" > LOGSZ
          then
            util.DPrintf #5 (#(str"memAppend: log is full; try again"));;
            struct.storeF Walog.S "nextDiskEnd" "l" (struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l"));;
            lock.condBroadcast (struct.loadF Walog.S "condLogger" "l");;
            lock.condWait (struct.loadF Walog.S "condLogger" "l");;
            Continue
          else
            "txn" <-[LogPosition] Walog__doMemAppend "l" "bufs";;
            Break)));;
      lock.release (struct.loadF Walog.S "memLock" "l");;
      (![LogPosition] "txn", ![boolT] "ok")).

(* Flush flushes a transaction (and all preceding transactions)

   The implementation waits until the logger has appended in-memory log up to
   txn to on-disk log. *)
Definition Walog__Flush: val :=
  λ: "l" "txn",
    util.DPrintf #1 (#(str"Flush: commit till txn %d
    ")) "txn";;
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    lock.condBroadcast (struct.loadF Walog.S "condLogger" "l");;
    (if: "txn" > struct.loadF Walog.S "nextDiskEnd" "l"
    then
      struct.storeF Walog.S "nextDiskEnd" "l" "txn";;
      #()
    else #());;
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: "txn" ≤ struct.loadF Walog.S "diskEnd" "l"
      then Break
      else lock.condWait (struct.loadF Walog.S "condLogger" "l"));;
      Continue);;
    lock.release (struct.loadF Walog.S "memLock" "l").

(* Shutdown logger and installer *)
Definition Walog__Shutdown: val :=
  λ: "l",
    util.DPrintf #1 (#(str"shutdown wal
    "));;
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    struct.storeF Walog.S "shutdown" "l" #true;;
    lock.condBroadcast (struct.loadF Walog.S "condLogger" "l");;
    lock.condBroadcast (struct.loadF Walog.S "condInstall" "l");;
    Skip;;
    (for: (λ: <>, struct.loadF Walog.S "nthread" "l" > #0); (λ: <>, Skip) := λ: <>,
      util.DPrintf #1 (#(str"wait for logger/installer"));;
      lock.condWait (struct.loadF Walog.S "condShut" "l");;
      Continue);;
    lock.release (struct.loadF Walog.S "memLock" "l");;
    util.DPrintf #1 (#(str"wal done
    ")).
