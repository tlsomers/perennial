(* autogenerated from github.com/mit-pdos/goose-nfsd/wal *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

From Goose Require github_com.mit_pdos.goose_nfsd.common.
From Goose Require github_com.mit_pdos.goose_nfsd.util.
From Goose Require github_com.tchajed.marshal.

(* 0circular.go *)

Definition LogPosition: ty := uint64T.

Module Update.
  Definition S := struct.decl [
    "Addr" :: uint64T;
    "Block" :: disk.blockT
  ].
End Update.

Definition MkBlockData: val :=
  rec: "MkBlockData" "bn" "blk" :=
    let: "b" := struct.mk Update.S [
      "Addr" ::= "bn";
      "Block" ::= "blk"
    ] in
    "b".

Module circular.
  Definition S := struct.decl [
    "d" :: disk.Disk;
    "diskStart" :: LogPosition;
    "diskEnd" :: LogPosition;
    "diskAddrs" :: slice.T uint64T
  ].
End circular.

(* initCircular takes ownership of the circular log, which is the first
   LOGDISKBLOCKS of the disk. *)
Definition initCircular: val :=
  rec: "initCircular" "d" :=
    let: "b0" := NewSlice byteT disk.BlockSize in
    disk.Write "LOGHDR" "b0";;
    disk.Write "LOGHDR2" "b0";;
    let: "addrs" := NewSlice uint64T "HDRADDRS" in
    (struct.new circular.S [
       "d" ::= "d";
       "diskStart" ::= #0;
       "diskEnd" ::= #0;
       "diskAddrs" ::= "addrs"
     ], slice.nil).

Definition recoverCircular: val :=
  rec: "recoverCircular" "d" :=
    let: "hdr1" := disk.Read "LOGHDR" in
    let: "dec1" := marshal.NewDec "hdr1" in
    let: "end" := marshal.Dec__GetInt "dec1" in
    let: "addrs" := marshal.Dec__GetInts "dec1" "HDRADDRS" in
    let: "hdr2" := disk.Read "LOGHDR2" in
    let: "dec2" := marshal.NewDec "hdr2" in
    let: "start" := marshal.Dec__GetInt "dec2" in
    let: "bufs" := ref (zero_val (slice.T (struct.t Update.S))) in
    let: "pos" := ref "start" in
    (for: (λ: <>, ![uint64T] "pos" < "end"); (λ: <>, "pos" <-[uint64T] ![uint64T] "pos" + #1) := λ: <>,
      let: "addr" := SliceGet uint64T "addrs" ((![uint64T] "pos") `rem` "LOGSZ") in
      let: "b" := disk.Read ("LOGSTART" + (![uint64T] "pos") `rem` "LOGSZ") in
      "bufs" <-[slice.T (struct.t Update.S)] SliceAppend (struct.t Update.S) (![slice.T (struct.t Update.S)] "bufs") (struct.mk Update.S [
        "Addr" ::= "addr";
        "Block" ::= "b"
      ]);;
      Continue);;
    (struct.new circular.S [
       "d" ::= "d";
       "diskStart" ::= "start";
       "diskEnd" ::= "end";
       "diskAddrs" ::= "addrs"
     ], ![slice.T (struct.t Update.S)] "bufs").

Definition circular__SpaceRemaining: val :=
  rec: "circular__SpaceRemaining" "c" :=
    "LOGSZ" - struct.loadF circular.S "diskEnd" "c" - struct.loadF circular.S "diskStart" "c".

Definition circular__hdr1: val :=
  rec: "circular__hdr1" "c" :=
    let: "enc" := marshal.NewEnc disk.BlockSize in
    marshal.Enc__PutInt "enc" (struct.loadF circular.S "diskEnd" "c");;
    marshal.Enc__PutInts "enc" (struct.loadF circular.S "diskAddrs" "c");;
    marshal.Enc__Finish "enc".

Definition circular__hdr2: val :=
  rec: "circular__hdr2" "c" :=
    let: "enc" := marshal.NewEnc disk.BlockSize in
    marshal.Enc__PutInt "enc" (struct.loadF circular.S "diskStart" "c");;
    marshal.Enc__Finish "enc".

Definition circular__appendFreeSpace: val :=
  rec: "circular__appendFreeSpace" "c" "bufs" :=
    (if: circular__SpaceRemaining "c" < slice.len "bufs"
    then
      Panic ("append would overflow circular log");;
      #()
    else #());;
    ForSlice (struct.t Update.S) "i" "buf" "bufs"
      (let: "pos" := struct.loadF circular.S "diskEnd" "c" + "i" in
      let: "blk" := struct.get Update.S "Block" "buf" in
      let: "blkno" := struct.get Update.S "Addr" "buf" in
      util.DPrintf #5 (#(str"logBlocks: %d to log block %d
      ")) "blkno" "pos";;
      disk.Write ("LOGSTART" + "pos" `rem` "LOGSZ") "blk";;
      SliceSet uint64T (struct.loadF circular.S "diskAddrs" "c") ("pos" `rem` "LOGSZ") "blkno");;
    struct.storeF circular.S "diskEnd" "c" (struct.loadF circular.S "diskEnd" "c" + slice.len "bufs").

Definition circular__Append: val :=
  rec: "circular__Append" "c" "bufs" :=
    circular__appendFreeSpace "c" "bufs";;
    let: "b" := circular__hdr1 "c" in
    disk.Write "LOGHDR" "b";;
    disk.Barrier #().

Definition circular__Empty: val :=
  rec: "circular__Empty" "c" :=
    struct.storeF circular.S "diskStart" "c" (struct.loadF circular.S "diskEnd" "c");;
    let: "b" := circular__hdr2 "c" in
    disk.Write "LOGHDR2" "b";;
    disk.Barrier #().

(* 0waldefs.go *)

(*  wal implements write-ahead logging

    The layout of log:
    [ installed writes | logged writes | in-memory/logged | unstable in-memory ]
     ^                   ^               ^                  ^
     0                   memStart        diskEnd            nextDiskEnd

    Blocks in the range [diskEnd, nextDiskEnd) are in the process of
    being logged.  Blocks in unstable are unstably committed (i.e.,
    written by NFS Write with the unstable flag and they can be lost
    on crash). Later transactions may absorb them (e.g., a later NFS
    write may update the same inode or indirect block).  The code
    implements a policy of postponing writing unstable blocks to disk
    as long as possible to maximize the chance of absorption (i.e.,
    commitWait or log is full).  It may better to start logging
    earlier. *)

(* space for the end position *)
Definition HDRMETA : expr := #8.

Definition HDRADDRS : expr := (disk.BlockSize - HDRMETA) `quot` #8.

Definition LOGSZ : expr := HDRADDRS.

(* 2 for log header *)
Definition LOGDISKBLOCKS : expr := HDRADDRS + #2.

Definition LOGHDR : expr := #0.

Definition LOGHDR2 : expr := #1.

Definition LOGSTART : expr := #2.

Module Walog.
  Definition S := struct.decl [
    "memLock" :: lockRefT;
    "d" :: disk.Disk;
    "circ" :: struct.ptrT circular.S;
    "condLogger" :: condvarRefT;
    "condInstall" :: condvarRefT;
    "memLog" :: slice.T (struct.t Update.S);
    "memStart" :: LogPosition;
    "nextDiskEnd" :: LogPosition;
    "shutdown" :: boolT;
    "nthread" :: uint64T;
    "condShut" :: condvarRefT;
    "memLogMap" :: mapT LogPosition
  ].
End Walog.

Definition Walog__LogSz: val :=
  rec: "Walog__LogSz" "l" :=
    common.HDRADDRS.

(* installer.go *)

Definition Walog__cutMemLog: val :=
  rec: "Walog__cutMemLog" "l" "installEnd" :=
    ForSlice (struct.t Update.S) "i" "blk" (SliceTake (struct.loadF Walog.S "memLog" "l") ("installEnd" - struct.loadF Walog.S "memStart" "l"))
      (let: "pos" := struct.loadF Walog.S "memStart" "l" + "i" in
      let: "blkno" := struct.get Update.S "Addr" "blk" in
      let: ("oldPos", "ok") := MapGet (struct.loadF Walog.S "memLogMap" "l") "blkno" in
      (if: "ok" && ("oldPos" = "pos")
      then
        util.DPrintf #5 (#(str"memLogMap: del %d %d
        ")) "blkno" "oldPos";;
        MapDelete (struct.loadF Walog.S "memLogMap" "l") "blkno"
      else #()));;
    struct.storeF Walog.S "memLog" "l" (SliceSkip (struct.t Update.S) (struct.loadF Walog.S "memLog" "l") ("installEnd" - struct.loadF Walog.S "memStart" "l"));;
    struct.storeF Walog.S "memStart" "l" "installEnd".

(* installBlocks installs the updates in bufs to the data region

   Does not hold the memLock, but expects exclusive ownership of the data
   region. *)
Definition installBlocks: val :=
  rec: "installBlocks" "d" "bufs" :=
    ForSlice (struct.t Update.S) "i" "buf" "bufs"
      (let: "blkno" := struct.get Update.S "Addr" "buf" in
      let: "blk" := struct.get Update.S "Block" "buf" in
      util.DPrintf #5 (#(str"installBlocks: write log block %d to %d
      ")) "i" "blkno";;
      disk.Write "blkno" "blk").

(* logInstall installs one on-disk transaction from the disk log to the data
   region.

   Returns (blkCount, installEnd)

   blkCount is the number of blocks installed (only used for liveness)

   installEnd is the new last position installed to the data region (only used
   for debugging)

   Installer holds memLock
   XXX absorb *)
Definition Walog__logInstall: val :=
  rec: "Walog__logInstall" "l" :=
    let: "installEnd" := struct.loadF circular.S "diskEnd" (struct.loadF Walog.S "circ" "l") in
    let: "bufs" := SliceTake (struct.loadF Walog.S "memLog" "l") ("installEnd" - struct.loadF Walog.S "memStart" "l") in
    (if: (slice.len "bufs" = #0)
    then (#0, "installEnd")
    else
      lock.release (struct.loadF Walog.S "memLock" "l");;
      util.DPrintf #5 (#(str"logInstall up to %d
      ")) "installEnd";;
      installBlocks (struct.loadF Walog.S "d" "l") "bufs";;
      circular__Empty (struct.loadF Walog.S "circ" "l");;
      lock.acquire (struct.loadF Walog.S "memLock" "l");;
      (if: "installEnd" < struct.loadF Walog.S "memStart" "l"
      then
        Panic "logInstall";;
        #()
      else #());;
      Walog__cutMemLog "l" "installEnd";;
      lock.condBroadcast (struct.loadF Walog.S "condInstall" "l");;
      (slice.len "bufs", "installEnd")).

(* installer installs blocks from the on-disk log to their home location. *)
Definition Walog__installer: val :=
  rec: "Walog__installer" "l" :=
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    struct.storeF Walog.S "nthread" "l" (struct.loadF Walog.S "nthread" "l" + #1);;
    Skip;;
    (for: (λ: <>, ~ (struct.loadF Walog.S "shutdown" "l")); (λ: <>, Skip) := λ: <>,
      let: ("blkcount", "txn") := Walog__logInstall "l" in
      (if: "blkcount" > #0
      then
        util.DPrintf #5 (#(str"Installed till txn %d
        ")) "txn"
      else lock.condWait (struct.loadF Walog.S "condInstall" "l"));;
      Continue);;
    util.DPrintf #1 (#(str"installer: shutdown
    "));;
    struct.storeF Walog.S "nthread" "l" (struct.loadF Walog.S "nthread" "l" - #1);;
    lock.condSignal (struct.loadF Walog.S "condShut" "l");;
    lock.release (struct.loadF Walog.S "memLock" "l").

(* logger.go *)

(* logAppend appends to the log, if it can find transactions to append.

   It grabs the new writes in memory and not on disk through l.nextDiskEnd; if
   there are any such writes, it commits them atomically.

   assumes caller holds memLock

   Returns true if it made progress (for liveness, not important for
   correctness). *)
Definition Walog__logAppend: val :=
  rec: "Walog__logAppend" "l" :=
    Skip;;
    (for: (λ: <>, slice.len (struct.loadF Walog.S "memLog" "l") > LOGSZ); (λ: <>, Skip) := λ: <>,
      lock.condWait (struct.loadF Walog.S "condInstall" "l");;
      Continue);;
    let: "memstart" := struct.loadF Walog.S "memStart" "l" in
    let: "memlog" := struct.loadF Walog.S "memLog" "l" in
    let: "newDiskEnd" := struct.loadF Walog.S "nextDiskEnd" "l" in
    let: "diskEnd" := struct.loadF circular.S "diskEnd" (struct.loadF Walog.S "circ" "l") in
    let: "newbufs" := SliceSubslice (struct.t Update.S) "memlog" ("diskEnd" - "memstart") ("newDiskEnd" - "memstart") in
    (if: (slice.len "newbufs" = #0)
    then #false
    else
      lock.release (struct.loadF Walog.S "memLock" "l");;
      circular__Append (struct.loadF Walog.S "circ" "l") "newbufs";;
      lock.acquire (struct.loadF Walog.S "memLock" "l");;
      lock.condBroadcast (struct.loadF Walog.S "condLogger" "l");;
      lock.condBroadcast (struct.loadF Walog.S "condInstall" "l");;
      #true).

(* logger writes blocks from the in-memory log to the on-disk log

   Operates by continuously polling for in-memory transactions, driven by
   condLogger for scheduling *)
Definition Walog__logger: val :=
  rec: "Walog__logger" "l" :=
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    struct.storeF Walog.S "nthread" "l" (struct.loadF Walog.S "nthread" "l" + #1);;
    Skip;;
    (for: (λ: <>, ~ (struct.loadF Walog.S "shutdown" "l")); (λ: <>, Skip) := λ: <>,
      let: "progress" := Walog__logAppend "l" in
      (if: ~ "progress"
      then lock.condWait (struct.loadF Walog.S "condLogger" "l")
      else #());;
      Continue);;
    util.DPrintf #1 (#(str"logger: shutdown
    "));;
    struct.storeF Walog.S "nthread" "l" (struct.loadF Walog.S "nthread" "l" - #1);;
    lock.condSignal (struct.loadF Walog.S "condShut" "l");;
    lock.release (struct.loadF Walog.S "memLock" "l").

(* wal.go *)

Definition Walog__recover: val :=
  rec: "Walog__recover" "l" :=
    struct.storeF Walog.S "memStart" "l" (struct.loadF circular.S "diskStart" (struct.loadF Walog.S "circ" "l"));;
    util.DPrintf #1 (#(str"recover %d %d
    ")) (struct.loadF Walog.S "memStart" "l") (struct.loadF circular.S "diskEnd" (struct.loadF Walog.S "circ" "l"));;
    ForSlice (struct.t Update.S) "i" "buf" (struct.loadF Walog.S "memLog" "l")
      (MapInsert (struct.loadF Walog.S "memLogMap" "l") (struct.get Update.S "Addr" "buf") (struct.loadF circular.S "diskStart" (struct.loadF Walog.S "circ" "l") + "i"));;
    struct.storeF Walog.S "nextDiskEnd" "l" (struct.loadF circular.S "diskEnd" (struct.loadF Walog.S "circ" "l") + slice.len (struct.loadF Walog.S "memLog" "l")).

Definition mkLog: val :=
  rec: "mkLog" "disk" :=
    let: ("circ", "memLog") := recoverCircular "disk" in
    let: "ml" := lock.new #() in
    let: "l" := struct.new Walog.S [
      "d" ::= "disk";
      "circ" ::= "circ";
      "memLock" ::= "ml";
      "condLogger" ::= lock.newCond "ml";
      "condInstall" ::= lock.newCond "ml";
      "memLog" ::= "memLog";
      "memStart" ::= #0;
      "nextDiskEnd" ::= #0;
      "shutdown" ::= #false;
      "nthread" ::= #0;
      "condShut" ::= lock.newCond "ml";
      "memLogMap" ::= NewMap LogPosition
    ] in
    util.DPrintf #1 (#(str"mkLog: size %d
    ")) LOGSZ;;
    Walog__recover "l";;
    "l".

Definition Walog__startBackgroundThreads: val :=
  rec: "Walog__startBackgroundThreads" "l" :=
    Fork (Walog__logger "l");;
    Fork (Walog__installer "l").

Definition MkLog: val :=
  rec: "MkLog" "disk" :=
    let: "l" := mkLog "disk" in
    Walog__startBackgroundThreads "l";;
    "l".

(* memWrite writes out bufs to the in-memory log

   Absorbs writes in in-memory transactions (avoiding those that might be in
   the process of being logged or installed).

   Assumes caller holds memLock *)
Definition Walog__memWrite: val :=
  rec: "Walog__memWrite" "l" "bufs" :=
    let: "pos" := ref (struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l")) in
    ForSlice (struct.t Update.S) <> "buf" "bufs"
      (let: ("oldpos", "ok") := MapGet (struct.loadF Walog.S "memLogMap" "l") (struct.get Update.S "Addr" "buf") in
      (if: "ok" && "oldpos" ≥ struct.loadF Walog.S "nextDiskEnd" "l"
      then
        util.DPrintf #5 (#(str"memWrite: absorb %d pos %d old %d
        ")) (struct.get Update.S "Addr" "buf") (![LogPosition] "pos") "oldpos";;
        SliceSet (struct.t Update.S) (struct.loadF Walog.S "memLog" "l") ("oldpos" - struct.loadF Walog.S "memStart" "l") "buf"
      else
        (if: "ok"
        then
          util.DPrintf #5 (#(str"memLogMap: replace %d pos %d old %d
          ")) (struct.get Update.S "Addr" "buf") (![LogPosition] "pos") "oldpos"
        else
          util.DPrintf #5 (#(str"memLogMap: add %d pos %d
          ")) (struct.get Update.S "Addr" "buf") (![LogPosition] "pos"));;
        struct.storeF Walog.S "memLog" "l" (SliceAppend (struct.t Update.S) (struct.loadF Walog.S "memLog" "l") "buf");;
        MapInsert (struct.loadF Walog.S "memLogMap" "l") (struct.get Update.S "Addr" "buf") (![LogPosition] "pos");;
        "pos" <-[LogPosition] ![LogPosition] "pos" + #1)).

(* Assumes caller holds memLock *)
Definition Walog__doMemAppend: val :=
  rec: "Walog__doMemAppend" "l" "bufs" :=
    Walog__memWrite "l" "bufs";;
    let: "txn" := struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l") in
    "txn".

(* Read blkno from memLog, if present *)
Definition Walog__readMemLog: val :=
  rec: "Walog__readMemLog" "l" "blkno" :=
    let: "blk" := ref (zero_val (slice.T byteT)) in
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    let: ("pos", "ok") := MapGet (struct.loadF Walog.S "memLogMap" "l") "blkno" in
    (if: "ok"
    then
      util.DPrintf #5 (#(str"read memLogMap: read %d pos %d
      ")) "blkno" "pos";;
      let: "buf" := SliceGet (struct.t Update.S) (struct.loadF Walog.S "memLog" "l") ("pos" - struct.loadF Walog.S "memStart" "l") in
      "blk" <-[slice.T byteT] NewSlice byteT disk.BlockSize;;
      SliceCopy byteT (![slice.T byteT] "blk") (struct.get Update.S "Block" "buf");;
      #()
    else #());;
    lock.release (struct.loadF Walog.S "memLock" "l");;
    ![slice.T byteT] "blk".

(* Read from only the in-memory cached state (the unstable and logged parts of
   the wal). *)
Definition Walog__ReadMem: val :=
  rec: "Walog__ReadMem" "l" "blkno" :=
    let: "blk" := Walog__readMemLog "l" "blkno" in
    ("blk", "blk" ≠ slice.nil).

(* Read from only the installed state (a subset of durable state). *)
Definition Walog__ReadInstalled: val :=
  rec: "Walog__ReadInstalled" "l" "blkno" :=
    disk.Read "blkno".

(* Read reads from the latest memory state, but does so in a
   difficult-to-linearize way (specifically, it is future-dependent when to
   linearize between the l.memLog.Unlock() and the eventual disk read, due to
   potential concurrent cache or disk writes). *)
Definition Walog__Read: val :=
  rec: "Walog__Read" "l" "blkno" :=
    let: ("blk", "ok") := Walog__ReadMem "l" "blkno" in
    (if: "ok"
    then "blk"
    else Walog__ReadInstalled "l" "blkno").

(* Append to in-memory log.

   On success returns the txn for this append.

   On failure guaranteed to be idempotent (failure can occur either due to bufs
   exceeding the size of the log or in principle due to overflowing 2^64 writes) *)
Definition Walog__MemAppend: val :=
  rec: "Walog__MemAppend" "l" "bufs" :=
    (if: slice.len "bufs" > LOGSZ
    then (#0, #false)
    else
      let: "txn" := ref #0 in
      let: "ok" := ref #true in
      lock.acquire (struct.loadF Walog.S "memLock" "l");;
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: util.SumOverflows (struct.loadF Walog.S "memStart" "l") (slice.len "bufs")
        then
          "ok" <-[boolT] #false;;
          Break
        else
          let: "memEnd" := struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l") in
          let: "memSize" := "memEnd" - struct.loadF circular.S "diskEnd" (struct.loadF Walog.S "circ" "l") in
          (if: "memSize" + slice.len "bufs" > LOGSZ
          then
            util.DPrintf #5 (#(str"memAppend: log is full; try again"));;
            struct.storeF Walog.S "nextDiskEnd" "l" (struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l"));;
            lock.condBroadcast (struct.loadF Walog.S "condLogger" "l");;
            lock.condWait (struct.loadF Walog.S "condLogger" "l");;
            Continue
          else
            "txn" <-[LogPosition] Walog__doMemAppend "l" "bufs";;
            Break)));;
      lock.release (struct.loadF Walog.S "memLock" "l");;
      (![LogPosition] "txn", ![boolT] "ok")).

(* Flush flushes a transaction (and all preceding transactions)

   The implementation waits until the logger has appended in-memory log up to
   txn to on-disk log. *)
Definition Walog__Flush: val :=
  rec: "Walog__Flush" "l" "txn" :=
    util.DPrintf #1 (#(str"Flush: commit till txn %d
    ")) "txn";;
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    lock.condBroadcast (struct.loadF Walog.S "condLogger" "l");;
    (if: "txn" > struct.loadF Walog.S "nextDiskEnd" "l"
    then
      struct.storeF Walog.S "nextDiskEnd" "l" (struct.loadF Walog.S "memStart" "l" + slice.len (struct.loadF Walog.S "memLog" "l"));;
      #()
    else #());;
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: "txn" ≤ struct.loadF circular.S "diskEnd" (struct.loadF Walog.S "circ" "l")
      then Break
      else lock.condWait (struct.loadF Walog.S "condLogger" "l"));;
      Continue);;
    lock.release (struct.loadF Walog.S "memLock" "l").

(* Shutdown logger and installer *)
Definition Walog__Shutdown: val :=
  rec: "Walog__Shutdown" "l" :=
    util.DPrintf #1 (#(str"shutdown wal
    "));;
    lock.acquire (struct.loadF Walog.S "memLock" "l");;
    struct.storeF Walog.S "shutdown" "l" #true;;
    lock.condBroadcast (struct.loadF Walog.S "condLogger" "l");;
    lock.condBroadcast (struct.loadF Walog.S "condInstall" "l");;
    Skip;;
    (for: (λ: <>, struct.loadF Walog.S "nthread" "l" > #0); (λ: <>, Skip) := λ: <>,
      util.DPrintf #1 (#(str"wait for logger/installer"));;
      lock.condWait (struct.loadF Walog.S "condShut" "l");;
      Continue);;
    lock.release (struct.loadF Walog.S "memLock" "l");;
    util.DPrintf #1 (#(str"wal done
    ")).
