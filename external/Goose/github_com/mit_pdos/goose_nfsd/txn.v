(* autogenerated from github.com/mit-pdos/goose-nfsd/txn *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

From Goose Require github_com.mit_pdos.goose_nfsd.addr.
From Goose Require github_com.mit_pdos.goose_nfsd.buf.
From Goose Require github_com.mit_pdos.goose_nfsd.common.
From Goose Require github_com.mit_pdos.goose_nfsd.super.
From Goose Require github_com.mit_pdos.goose_nfsd.util.
From Goose Require github_com.mit_pdos.goose_nfsd.wal.

Definition TransId: ty := uint64T.

Module Txn.
  Definition S := struct.decl [
    "mu" :: lockRefT;
    "log" :: struct.ptrT wal.Walog.S;
    "fs" :: struct.ptrT super.FsSuper.S;
    "nextId" :: TransId;
    "pos" :: wal.LogPosition
  ].
End Txn.

Definition MkTxn: val :=
  rec: "MkTxn" "fs" :=
    let: "txn" := struct.new Txn.S [
      "mu" ::= lock.new #();
      "log" ::= wal.MkLog (struct.loadF super.FsSuper.S "Disk" "fs");
      "fs" ::= "fs";
      "nextId" ::= #0;
      "pos" ::= #0
    ] in
    "txn".

(* Return a unique Id for a transaction *)
Definition Txn__GetTransId: val :=
  rec: "Txn__GetTransId" "txn" :=
    lock.acquire (struct.loadF Txn.S "mu" "txn");;
    let: "id" := ref_to uint64T (struct.loadF Txn.S "nextId" "txn") in
    (if: (![uint64T] "id" = #0)
    then
      struct.storeF Txn.S "nextId" "txn" (struct.loadF Txn.S "nextId" "txn" + #1);;
      "id" <-[uint64T] #1;;
      #()
    else #());;
    struct.storeF Txn.S "nextId" "txn" (struct.loadF Txn.S "nextId" "txn" + #1);;
    lock.release (struct.loadF Txn.S "mu" "txn");;
    ![uint64T] "id".

(* Read a disk object into buf *)
Definition Txn__Load: val :=
  rec: "Txn__Load" "txn" "addr" :=
    let: "blk" := wal.Walog__Read (struct.loadF Txn.S "log" "txn") (struct.get addr.Addr.S "Blkno" "addr") in
    let: "b" := buf.MkBufLoad "addr" "blk" in
    "b".

(* Installs the txn's bufs into their blocks and returns the blocks.
   A buf may only partially update a disk block and several bufs may
   apply to the same disk block. Assume caller holds commit lock. *)
Definition Txn__installBufs: val :=
  rec: "Txn__installBufs" "txn" "bufs" :=
    let: "blks" := ref_to (slice.T (struct.t wal.Update.S)) (NewSlice (struct.t wal.Update.S) #0) in
    let: "bufsByBlock" := ref_to (mapT (slice.T (refT (struct.t buf.Buf.S)))) (NewMap (slice.T (struct.ptrT buf.Buf.S))) in
    ForSlice (refT (struct.t buf.Buf.S)) <> "b" "bufs"
      (MapInsert (![mapT (slice.T (refT (struct.t buf.Buf.S)))] "bufsByBlock") (struct.get addr.Addr.S "Blkno" (struct.loadF buf.Buf.S "Addr" "b")) (SliceAppend (refT (struct.t buf.Buf.S)) (Fst (MapGet (![mapT (slice.T (refT (struct.t buf.Buf.S)))] "bufsByBlock") (struct.get addr.Addr.S "Blkno" (struct.loadF buf.Buf.S "Addr" "b")))) "b"));;
    MapIter (![mapT (slice.T (refT (struct.t buf.Buf.S)))] "bufsByBlock") (Î»: "blkno" "bufs",
      let: "blk" := ref (zero_val (slice.T byteT)) in
      ForSlice (refT (struct.t buf.Buf.S)) <> "b" "bufs"
        (if: super.FsSuper__DiskBlockSize (struct.loadF Txn.S "fs" "txn") (struct.loadF buf.Buf.S "Addr" "b")
        then "blk" <-[slice.T byteT] struct.loadF buf.Buf.S "Blk" "b"
        else
          (if: (![slice.T byteT] "blk" = slice.nil)
          then
            "blk" <-[slice.T byteT] wal.Walog__Read (struct.loadF Txn.S "log" "txn") "blkno";;
            #()
          else #());;
          buf.Buf__Install "b" (![slice.T byteT] "blk"));;
      let: "walblk" := wal.MkBlockData "blkno" (![slice.T byteT] "blk") in
      "blks" <-[slice.T (struct.t wal.Update.S)] SliceAppend (struct.t wal.Update.S) (![slice.T (struct.t wal.Update.S)] "blks") "walblk");;
    ![slice.T (struct.t wal.Update.S)] "blks".

(* Acquires the commit log, installs the txn's buffers into their
   blocks, and appends the blocks to the in-memory log. *)
Definition Txn__doCommit: val :=
  rec: "Txn__doCommit" "txn" "bufs" :=
    lock.acquire (struct.loadF Txn.S "mu" "txn");;
    let: "blks" := Txn__installBufs "txn" "bufs" in
    util.DPrintf #3 (#(str"doCommit: %v bufs
    ")) #();;
    let: ("n", "ok") := wal.Walog__MemAppend (struct.loadF Txn.S "log" "txn") "blks" in
    struct.storeF Txn.S "pos" "txn" "n";;
    lock.release (struct.loadF Txn.S "mu" "txn");;
    ("n", "ok").

(* Commit dirty bufs of the transaction into the log, and perhaps wait. *)
Definition Txn__CommitWait: val :=
  rec: "Txn__CommitWait" "txn" "bufs" "wait" "id" :=
    let: "commit" := ref_to boolT #true in
    (if: slice.len "bufs" > #0
    then
      let: ("n", "ok") := Txn__doCommit "txn" "bufs" in
      (if: ~ "ok"
      then
        util.DPrintf #10 (#(str"memappend failed; log is too small
        ")) #();;
        "commit" <-[boolT] #false
      else
        (if: "wait"
        then wal.Walog__Flush (struct.loadF Txn.S "log" "txn") "n"
        else #()))
    else
      util.DPrintf #5 (#(str"commit read-only trans
      ")) #());;
    ![boolT] "commit".

(* NOTE: this is coarse-grained and unattached to the transaction ID *)
Definition Txn__Flush: val :=
  rec: "Txn__Flush" "txn" :=
    wal.Walog__Flush (struct.loadF Txn.S "log" "txn") (struct.loadF Txn.S "pos" "txn");;
    #true.

Definition Txn__LogSz: val :=
  rec: "Txn__LogSz" "txn" :=
    wal.LOGSZ.

Definition Txn__Shutdown: val :=
  rec: "Txn__Shutdown" "txn" :=
    wal.Walog__Shutdown (struct.loadF Txn.S "log" "txn").
