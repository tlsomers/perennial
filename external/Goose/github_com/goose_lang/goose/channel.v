(* autogenerated from github.com/goose-lang/goose/channel *)
From Perennial.goose_lang Require Import base_prelude.

Section code.
Context `{ext_ty: ext_types}.

Definition ChannelState: ty := uint64T.

Definition start : expr := #0.

Definition receiver_ready : expr := #1.

Definition sender_ready : expr := #2.

Definition receiver_done : expr := #3.

Definition sender_done : expr := #4.

Definition closed : expr := #5.

Definition Channel (T: ty) : descriptor := struct.decl [
  "lock" :: ptrT;
  "state" :: ChannelState;
  "buffer" :: slice.T T;
  "first" :: uint64T;
  "count" :: uint64T;
  "v" :: T
].

(* buffer_size = 0 is an unbuffered channel *)
Definition NewChannel (T:ty): val :=
  rec: "NewChannel" "buffer_size" :=
    struct.mk (Channel T) [
      "buffer" ::= NewSlice T "buffer_size";
      "lock" ::= newMutex #();
      "first" ::= #0;
      "count" ::= #0;
      "state" ::= start
    ].

(* buffer_size = 0 is an unbuffered channel *)
Definition NewChannelRef (T:ty): val :=
  rec: "NewChannelRef" "buffer_size" :=
    struct.new (Channel T) [
      "buffer" ::= NewSlice T "buffer_size";
      "lock" ::= newMutex #();
      "first" ::= #0;
      "count" ::= #0;
      "state" ::= start
    ].

(* c.Send(val)

   is equivalent to:

   c <- val *)
Definition Channel__Send (T:ty): val :=
  rec: "Channel__Send" "c" "val" :=
    (if: "c" = #null
    then
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Continue)
    else #());;
    let: "buffer_size" := ref_to uint64T (slice.len (struct.loadF (Channel T) "buffer" "c")) in
    (if: (![uint64T] "buffer_size") ≠ #0
    then
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "state" "c") = closed
        then Panic "send on closed channel"
        else #());;
        (if: (struct.loadF (Channel T) "count" "c") ≥ (![uint64T] "buffer_size")
        then
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          Continue
        else
          let: "last" := ref_to uint64T (((struct.loadF (Channel T) "first" "c") + (struct.loadF (Channel T) "count" "c")) `rem` (![uint64T] "buffer_size")) in
          SliceSet T (struct.loadF (Channel T) "buffer" "c") (![uint64T] "last") "val";;
          struct.storeF (Channel T) "count" "c" ((struct.loadF (Channel T) "count" "c") + #1);;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          Break));;
      #()
    else
      let: "return_early" := ref_to boolT #false in
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "state" "c") = closed
        then Panic "send on closed channel"
        else #());;
        (if: (struct.loadF (Channel T) "state" "c") = receiver_ready
        then
          struct.storeF (Channel T) "state" "c" sender_done;;
          struct.storeF (Channel T) "v" "c" "val";;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          "return_early" <-[boolT] #true;;
          Break
        else
          (if: (struct.loadF (Channel T) "state" "c") = start
          then
            struct.storeF (Channel T) "v" "c" "val";;
            struct.storeF (Channel T) "state" "c" sender_ready;;
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Break
          else
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Continue)));;
      (if: ![boolT] "return_early"
      then
        Skip;;
        (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
          Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
          (if: (~ ((struct.loadF (Channel T) "state" "c") = sender_done))
          then
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Break
          else
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Continue));;
        #()
      else
        Skip;;
        (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
          Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
          (if: (struct.loadF (Channel T) "state" "c") = closed
          then Panic "send on closed channel"
          else #());;
          (if: (struct.loadF (Channel T) "state" "c") = receiver_done
          then
            struct.storeF (Channel T) "state" "c" start;;
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Break
          else
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Continue));;
        #())).

(* Equivalent to:
   value, ok := <-c
   Notably, this requires the user to consume the ok bool which is not actually required with Go
   channels. This should be able to be solved by adding an overload wrapper that discards the ok
   bool. *)
Definition Channel__Receive (T:ty): val :=
  rec: "Channel__Receive" "c" :=
    (if: "c" = #null
    then
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Continue)
    else #());;
    let: "ret_val" := ref (zero_val T) in
    let: "buffer_size" := ref_to uint64T (slice.len (struct.loadF (Channel T) "buffer" "c")) in
    let: "closed_local" := ref_to boolT #false in
    (if: (![uint64T] "buffer_size") ≠ #0
    then
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: ((struct.loadF (Channel T) "state" "c") = closed) && ((struct.loadF (Channel T) "count" "c") = #0)
        then
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          "closed_local" <-[boolT] #true;;
          Break
        else
          (if: (struct.loadF (Channel T) "count" "c") = #0
          then
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Continue
          else
            "ret_val" <-[T] (SliceGet T (struct.loadF (Channel T) "buffer" "c") (struct.loadF (Channel T) "first" "c"));;
            struct.storeF (Channel T) "first" "c" (((struct.loadF (Channel T) "first" "c") + #1) `rem` (![uint64T] "buffer_size"));;
            struct.storeF (Channel T) "count" "c" ((struct.loadF (Channel T) "count" "c") - #1);;
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Break)));;
      (![T] "ret_val", (~ (![boolT] "closed_local")))
    else
      let: "return_early" := ref_to boolT #false in
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "state" "c") = closed
        then
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          "closed_local" <-[boolT] #true;;
          Break
        else
          (if: (struct.loadF (Channel T) "state" "c") = sender_ready
          then
            struct.storeF (Channel T) "state" "c" receiver_done;;
            "ret_val" <-[T] (struct.loadF (Channel T) "v" "c");;
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            "return_early" <-[boolT] #true;;
            Break
          else
            (if: (struct.loadF (Channel T) "state" "c") = start
            then
              struct.storeF (Channel T) "state" "c" receiver_ready;;
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Break
            else
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Continue))));;
      (if: ![boolT] "closed_local"
      then (![T] "ret_val", (~ (![boolT] "closed_local")))
      else
        (if: ![boolT] "return_early"
        then
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
            (if: (~ ((struct.loadF (Channel T) "state" "c") = receiver_done))
            then
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Break
            else
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Continue));;
          (![T] "ret_val", (~ (![boolT] "closed_local")))
        else
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
            (if: (struct.loadF (Channel T) "state" "c") = closed
            then
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              "closed_local" <-[boolT] #true;;
              Break
            else
              (if: (struct.loadF (Channel T) "state" "c") = sender_done
              then
                struct.storeF (Channel T) "state" "c" start;;
                "ret_val" <-[T] (struct.loadF (Channel T) "v" "c");;
                Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
                Break
              else
                Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
                Continue)));;
          (![T] "ret_val", (~ (![boolT] "closed_local")))))).

(* c.Close()

   is equivalent to:

   close(c) *)
Definition Channel__Close (T:ty): val :=
  rec: "Channel__Close" "c" :=
    (if: "c" = #null
    then Panic "close of nil channel"
    else #());;
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
      (if: (struct.loadF (Channel T) "state" "c") = closed
      then Panic "close of closed channel"
      else #());;
      (if: ((struct.loadF (Channel T) "state" "c") = receiver_done) || ((struct.loadF (Channel T) "state" "c") = sender_done)
      then
        Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
        Continue
      else
        struct.storeF (Channel T) "state" "c" closed;;
        Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
        Break));;
    #().

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated. *)
Definition Channel__ReceiveDiscardOk (T:ty): val :=
  rec: "Channel__ReceiveDiscardOk" "c" :=
    let: "return_val" := ref (zero_val T) in
    let: ("0_ret", "1_ret") := Channel__Receive T "c" in
    "return_val" <-[T] "0_ret";;
    "1_ret";;
    ![T] "return_val".

(* This:

   	for {
   		selected, val, ok := ch.TryReceive()
   		if !ok {
   			break
   		}
   		if selected {
   			<body>
   		}
   	}

   is equivalent to:

   	for v := <-ch {
   			<body>
   	}

   This:

   	selected, val, ok := c.TryReceive()
   	if selected {
   		<first case body>
   	} else {
   		selected = c.TrySend(0)
   		if selected {
   			<second case body>
   		} else {
   			<default block body>
   		}
   	}

   is equivalent to:

   	select {
   		case <-c:
   			<first case body>
   		case c <- 0:
   			<second case body>
   		default:
   			<default body>
   		}

   This:

   	for {
   		selected, val, ok := c.TryReceive()
   		if selected {
   			<first case body>
   			break
   		} else {
   			selected = c.TrySend(0)
   			if selected {
   				<second case body>
   				break
   			}
   		}
   	}

   is equivalent to:

   	select {
   		case <-c:
   			<first case body>
   		case c <- 0:
   			<second case body>
   		}

   Note: Technically speaking, Go only compiles select statements to if/else blocks when there is 1
   case statement with a default block. When there are multiple statements, the Go code will choose
   a case statement with uniform probability among all "selectable" statements, meaning those that
   have a waiting sender/receiver on the other end and receives on closed channels. Since threading
   behavior means that it already can't be assumed with certainty which blocks are selected, the if/
   else block translation should be equivalent from a correctness perspective. There is at least 1
   notable unsound property with this approach:
   1. Once a channel is closed, a receive case statement on said channel will always be selectable.
   This means that after the channel is closed, this case statement will always be selected above
   other statements below. This is considered an antipattern in the Go community and it is
   recommended that if a select case permits a closed channel receive, the channel is set to nil so
   that the statement will no longer be selectable. We can prevent this with the specfication by
   forcing the receiver to renounce receive ownership after receiving on a closed channel.

   One approach for making 1. sound would be to do the following for select statements:
   1. Create a mutex guarded "winner_index" int
   2. Launch a goroutine for each channel in the select with an index for the select cases
   (For selects with multiple cases for a single channel, we still have just 1 goroutine)
   3. Lock the associated channel in each goroutine
   4. If there is a case for a channel that is "immediately selectable" i.e the channel is closed
   or in the receiver/sender_ready state for the sender/receiver respectively, lock the
   winner_index mutex and if not already set, set the winner_index to the goroutine's index
   5. If winner_index was set, complete the exchange and run the case's body
   6. Join the above goroutines and if no winner is selected, go through the if/else TryReceive/
   TrySend sequence that we currently use.

   This would make it so the race to setting winner_index simulates the randomness of
   Go select statements where any selectable case has uniform probablity of being selected

   Note: The above code technically makes it so the top block's expression variables
   are in scope in all of the other blocks. This would error in the Go code before it is translated
   so this shouldn't matter for practical purposes. *)
Definition Channel__TryReceive (T:ty): val :=
  rec: "Channel__TryReceive" "c" :=
    let: "ret_val" := ref (zero_val T) in
    (if: "c" = #null
    then (#false, ![T] "ret_val", #false)
    else
      let: "buffer_size" := ref_to uint64T (slice.len (struct.loadF (Channel T) "buffer" "c")) in
      let: "closed_local" := ref_to boolT #false in
      let: "selected" := ref_to boolT #false in
      (if: (![uint64T] "buffer_size") ≠ #0
      then
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "count" "c") = #0
        then
          (if: (struct.loadF (Channel T) "state" "c") = closed
          then
            "closed_local" <-[boolT] #true;;
            "selected" <-[boolT] #true
          else #());;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c")
        else
          "ret_val" <-[T] (SliceGet T (struct.loadF (Channel T) "buffer" "c") (struct.loadF (Channel T) "first" "c"));;
          struct.storeF (Channel T) "first" "c" (((struct.loadF (Channel T) "first" "c") + #1) `rem` (![uint64T] "buffer_size"));;
          struct.storeF (Channel T) "count" "c" ((struct.loadF (Channel T) "count" "c") - #1);;
          "selected" <-[boolT] #true;;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c"));;
        (![boolT] "selected", ![T] "ret_val", (~ (![boolT] "closed_local")))
      else
        let: "offer" := ref_to boolT #false in
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "state" "c") = closed
        then
          "closed_local" <-[boolT] #true;;
          "selected" <-[boolT] #true
        else
          (if: (struct.loadF (Channel T) "state" "c") = sender_ready
          then
            struct.storeF (Channel T) "state" "c" receiver_done;;
            "ret_val" <-[T] (struct.loadF (Channel T) "v" "c");;
            "selected" <-[boolT] #true
          else #());;
          (if: (struct.loadF (Channel T) "state" "c") = start
          then
            struct.storeF (Channel T) "state" "c" receiver_ready;;
            "offer" <-[boolT] #true
          else #()));;
        Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
        (if: ![boolT] "offer"
        then
          Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
          (if: (struct.loadF (Channel T) "state" "c") = sender_done
          then
            "ret_val" <-[T] (struct.loadF (Channel T) "v" "c");;
            struct.storeF (Channel T) "state" "c" start;;
            "selected" <-[boolT] #true
          else #());;
          (if: (struct.loadF (Channel T) "state" "c") = receiver_ready
          then struct.storeF (Channel T) "state" "c" start
          else #());;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c")
        else #());;
        (if: ![boolT] "closed_local"
        then (![boolT] "selected", ![T] "ret_val", (~ (![boolT] "closed_local")))
        else
          (if: (![boolT] "selected") && (~ (![boolT] "offer"))
          then
            Skip;;
            (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
              Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
              (if: (~ ((struct.loadF (Channel T) "state" "c") = receiver_done))
              then
                Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
                Break
              else
                Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
                Continue))
          else #());;
          (![boolT] "selected", ![T] "ret_val", (~ (![boolT] "closed_local")))))).

(* See comment in TryReceive for how this is used to translate selects. *)
Definition Channel__TrySend (T:ty): val :=
  rec: "Channel__TrySend" "c" "val" :=
    (if: "c" = #null
    then #false
    else
      let: "selected" := ref_to boolT #false in
      let: "buffer_size" := ref_to uint64T (slice.len (struct.loadF (Channel T) "buffer" "c")) in
      (if: (![uint64T] "buffer_size") ≠ #0
      then
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "state" "c") = closed
        then Panic "send on closed channel"
        else #());;
        (if: (~ ((struct.loadF (Channel T) "count" "c") ≥ (![uint64T] "buffer_size")))
        then
          let: "last" := ref_to uint64T (((struct.loadF (Channel T) "first" "c") + (struct.loadF (Channel T) "count" "c")) `rem` (![uint64T] "buffer_size")) in
          SliceSet T (struct.loadF (Channel T) "buffer" "c") (![uint64T] "last") "val";;
          struct.storeF (Channel T) "count" "c" ((struct.loadF (Channel T) "count" "c") + #1);;
          "selected" <-[boolT] #true
        else #());;
        Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
        ![boolT] "selected"
      else
        let: "offer" := ref_to boolT #false in
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "state" "c") = closed
        then Panic "send on closed channel"
        else #());;
        (if: (struct.loadF (Channel T) "state" "c") = receiver_ready
        then
          struct.storeF (Channel T) "state" "c" sender_done;;
          struct.storeF (Channel T) "v" "c" "val";;
          "selected" <-[boolT] #true
        else #());;
        (if: (struct.loadF (Channel T) "state" "c") = start
        then
          struct.storeF (Channel T) "state" "c" sender_ready;;
          struct.storeF (Channel T) "v" "c" "val";;
          "offer" <-[boolT] #true
        else #());;
        Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
        (if: ![boolT] "offer"
        then
          Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
          (if: (struct.loadF (Channel T) "state" "c") = receiver_done
          then
            struct.storeF (Channel T) "state" "c" start;;
            "selected" <-[boolT] #true
          else #());;
          (if: (struct.loadF (Channel T) "state" "c") = sender_ready
          then struct.storeF (Channel T) "state" "c" start
          else #());;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c")
        else #());;
        (if: (![boolT] "selected") && (~ (![boolT] "offer"))
        then
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
            (if: (~ ((struct.loadF (Channel T) "state" "c") = sender_done))
            then
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Break
            else
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Continue))
        else #());;
        ![boolT] "selected")).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics. *)
Definition Channel__Len (T:ty): val :=
  rec: "Channel__Len" "c" :=
    (if: "c" = #null
    then #0
    else
      let: "chan_len" := ref_to uint64T #0 in
      Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
      "chan_len" <-[uint64T] (struct.loadF (Channel T) "count" "c");;
      Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
      ![uint64T] "chan_len").

(* c.Cap()

   is equivalent to:
   cap(c) *)
Definition Channel__Cap (T:ty): val :=
  rec: "Channel__Cap" "c" :=
    (if: "c" = #null
    then #0
    else slice.len (struct.loadF (Channel T) "buffer" "c")).

End code.
