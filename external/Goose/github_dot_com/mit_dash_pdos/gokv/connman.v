(* autogenerated from github.com/mit-pdos/gokv/connman *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition HostName: ty := uint64T.

Definition ConnMan := struct.decl [
  "mu" :: ptrT;
  "rpcCls" :: mapT ptrT;
  "making" :: mapT ptrT
].

Definition MakeConnMan: val :=
  rec: "MakeConnMan" <> :=
    let: "c" := ref_zero ptrT in
    let: "$a0" := struct.alloc ConnMan (zero_val (struct.t ConnMan)) in
    do:  "c" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF ConnMan "mu" (![ptrT] "c") "$a0";;;
    let: "$a0" := NewMap uint64T ptrT #() in
    do:  struct.storeF ConnMan "rpcCls" (![ptrT] "c") "$a0";;;
    let: "$a0" := NewMap uint64T ptrT #() in
    do:  struct.storeF ConnMan "making" (![ptrT] "c") "$a0";;;
    return: (![ptrT] "c");;;
    do:  #().

Definition ConnMan__getClient: val :=
  rec: "ConnMan__getClient" "c" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "c" := ref_to ptrT "c" in
    let: "ret" := ref (zero_val ptrT) in
    do:  sync.Mutex__Lock (struct.loadF ConnMan "mu" (![ptrT] "c"));;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "ok" := ref_zero boolT in
      let: "cl" := ref_zero ptrT in
      let: ("$a0", "$a1") := Fst (MapGet (struct.loadF ConnMan "rpcCls" (![ptrT] "c")) (![uint64T] "host")) in
      do:  "ok" <-[boolT] "$a1";;;
      do:  "cl" <-[ptrT] "$a0";;;
      (if: ![boolT] "ok"
      then
        let: "$a0" := ![ptrT] "cl" in
        do:  "ret" <-[ptrT] "$a0";;;
        break: #();;;
        do:  #()
      else #());;;
      let: "cond" := ref_zero ptrT in
      let: ("$a0", "$a1") := Fst (MapGet (struct.loadF ConnMan "making" (![ptrT] "c")) (![uint64T] "host")) in
      do:  "ok" <-[boolT] "$a1";;;
      do:  "cond" <-[ptrT] "$a0";;;
      (if: ![boolT] "ok"
      then
        do:  sync.Cond__Wait (![ptrT] "cond");;;
        continue: #();;;
        do:  #()
      else #());;;
      let: "my_cond" := ref_zero ptrT in
      let: "$a0" := sync.NewCond (struct.loadF ConnMan "mu" (![ptrT] "c")) in
      do:  "my_cond" <-[ptrT] "$a0";;;
      let: "$a0" := ![ptrT] "my_cond" in
      do:  MapInsert (struct.loadF ConnMan "making" (![ptrT] "c")) (![uint64T] "host") "$a0";;;
      do:  sync.Mutex__Unlock (struct.loadF ConnMan "mu" (![ptrT] "c"));;;
      let: "$a0" := urpc.MakeClient (![uint64T] "host") in
      do:  "ret" <-[ptrT] "$a0";;;
      do:  sync.Mutex__Lock (struct.loadF ConnMan "mu" (![ptrT] "c"));;;
      let: "$a0" := ![ptrT] "ret" in
      do:  MapInsert (struct.loadF ConnMan "rpcCls" (![ptrT] "c")) (![uint64T] "host") "$a0";;;
      do:  sync.Cond__Broadcast (![ptrT] "my_cond");;;
      do:  MapDelete (struct.loadF ConnMan "making" (![ptrT] "c")) (![uint64T] "host");;;
      break: #();;;
      do:  #()).

(* This repeatedly retries the RPC after retryTimeout until it gets a response. *)
Definition ConnMan__CallAtLeastOnce: val :=
  rec: "ConnMan__CallAtLeastOnce" "c" "host" "rpcid" "args" "reply" "retryTimeout" :=
    let: "retryTimeout" := ref_to uint64T "retryTimeout" in
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to (slice.T byteT) "args" in
    let: "rpcid" := ref_to uint64T "rpcid" in
    let: "host" := ref_to uint64T "host" in
    let: "c" := ref_to ptrT "c" in
    let: "cl" := ref (zero_val ptrT) in
    let: "$a0" := ConnMan__getClient (![ptrT] "c") (![uint64T] "host") in
    do:  "cl" <-[ptrT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := ref_zero uint64T in
      let: "$a0" := urpc.Client__Call (![ptrT] "cl") (![uint64T] "rpcid") (![slice.T byteT] "args") (![ptrT] "reply") (![uint64T] "retryTimeout") in
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = urpc.ErrTimeout
      then
        continue: #();;;
        do:  #()
      else #());;;
      (if: (![uint64T] "err") = urpc.ErrDisconnect
      then
        do:  sync.Mutex__Lock (struct.loadF ConnMan "mu" (![ptrT] "c"));;;
        (if: (![ptrT] "cl") = (Fst (MapGet (struct.loadF ConnMan "rpcCls" (![ptrT] "c")) (![uint64T] "host")))
        then
          do:  MapDelete (struct.loadF ConnMan "rpcCls" (![ptrT] "c")) (![uint64T] "host");;;
          do:  #()
        else #());;;
        do:  sync.Mutex__Unlock (struct.loadF ConnMan "mu" (![ptrT] "c"));;;
        let: "$a0" := ConnMan__getClient (![ptrT] "c") (![uint64T] "host") in
        do:  "cl" <-[ptrT] "$a0";;;
        continue: #();;;
        do:  #()
      else #());;;
      break: #();;;
      do:  #()).
