(* autogenerated from github.com/mit-pdos/gokv/map_marshal *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition EncodeMapU64ToU64: val :=
  rec: "EncodeMapU64ToU64" "kvs" :=
    let: "kvs" := ref_to (mapT uint64T) "kvs" in
    let: "enc" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (MapLen (![mapT uint64T] "kvs")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    do:  MapIter (![mapT uint64T] "kvs") (λ: "k" "v",
      let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (![uint64T] "k") in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (![uint64T] "v") in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      do:  #());;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition DecodeMapU64ToU64: val :=
  rec: "DecodeMapU64ToU64" "enc_in" :=
    let: "enc_in" := ref_to (slice.T byteT) "enc_in" in
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "enc_in") in
    let: "kvs" := ref_zero (mapT uint64T) in
    let: "$a0" := NewMap uint64T uint64T #() in
    do:  "kvs" <-[mapT uint64T] "$a0";;;
    let: "enc2" := ref_zero (slice.T byteT) in
    let: "numEntries" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc2" <-[slice.T byteT] "$a1";;;
    do:  "numEntries" <-[uint64T] "$a0";;;
    let: "$a0" := ![slice.T byteT] "enc2" in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    (let: "i" := ref_zero uint64T in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "numEntries")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "key" := ref (zero_val uint64T) in
      let: "val" := ref (zero_val uint64T) in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
      do:  "enc" <-[slice.T byteT] "$a1";;;
      do:  "key" <-[uint64T] "$a0";;;
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
      do:  "enc" <-[slice.T byteT] "$a1";;;
      do:  "val" <-[uint64T] "$a0";;;
      let: "$a0" := ![uint64T] "val" in
      do:  MapInsert (![mapT uint64T] "kvs") (![uint64T] "key") "$a0";;;
      do:  #())).

Definition EncodeMapU64ToBytes: val :=
  rec: "EncodeMapU64ToBytes" "kvs" :=
    let: "kvs" := ref_to (mapT (slice.T byteT)) "kvs" in
    let: "enc" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (MapLen (![mapT (slice.T byteT)] "kvs")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    do:  MapIter (![mapT (slice.T byteT)] "kvs") (λ: "k" "v",
      let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (![uint64T] "k") in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (slice.len (![slice.T byteT] "v")) in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      let: "$a0" := marshal.WriteBytes (![slice.T byteT] "enc") (![slice.T byteT] "v") in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      do:  #());;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition DecodeMapU64ToBytes: val :=
  rec: "DecodeMapU64ToBytes" "enc_in" :=
    let: "enc_in" := ref_to (slice.T byteT) "enc_in" in
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "enc_in") in
    let: "kvs" := ref_zero (mapT (slice.T byteT)) in
    let: "$a0" := NewMap uint64T (slice.T byteT) #() in
    do:  "kvs" <-[mapT (slice.T byteT)] "$a0";;;
    let: "enc2" := ref_zero (slice.T byteT) in
    let: "numEntries" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc2" <-[slice.T byteT] "$a1";;;
    do:  "numEntries" <-[uint64T] "$a0";;;
    let: "$a0" := ![slice.T byteT] "enc2" in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    (let: "i" := ref_zero uint64T in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "numEntries")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "enc3" := ref_zero (slice.T byteT) in
      let: "key" := ref_zero uint64T in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
      do:  "enc3" <-[slice.T byteT] "$a1";;;
      do:  "key" <-[uint64T] "$a0";;;
      let: "enc4" := ref_zero (slice.T byteT) in
      let: "valLen" := ref_zero uint64T in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc3") in
      do:  "enc4" <-[slice.T byteT] "$a1";;;
      do:  "valLen" <-[uint64T] "$a0";;;
      let: "enc5" := ref_zero (slice.T byteT) in
      let: "val" := ref_zero (slice.T byteT) in
      let: ("$a0", "$a1") := marshal.ReadBytesCopy (![slice.T byteT] "enc4") (![uint64T] "valLen") in
      do:  "enc5" <-[slice.T byteT] "$a1";;;
      do:  "val" <-[slice.T byteT] "$a0";;;
      let: "$a0" := ![slice.T byteT] "enc5" in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      let: "$a0" := ![slice.T byteT] "val" in
      do:  MapInsert (![mapT (slice.T byteT)] "kvs") (![uint64T] "key") "$a0";;;
      do:  #())).

End code.
