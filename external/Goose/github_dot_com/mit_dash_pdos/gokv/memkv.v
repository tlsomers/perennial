(* autogenerated from github.com/mit-pdos/gokv/memkv *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.connman.
From Goose Require github_dot_com.mit_dash_pdos.gokv.erpc.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require log.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_common.go *)

Definition HostName: ty := uint64T.

Definition ValueType: ty := uint64T.

Definition ErrorType: ty := uint64T.

Definition ENone : expr := #0.

Definition EDontHaveShard : expr := #1.

Definition NSHARD : expr := #65536.

Definition KV_FRESHCID : expr := #0.

Definition KV_PUT : expr := #1.

Definition KV_GET : expr := #2.

Definition KV_CONDITIONAL_PUT : expr := #3.

Definition KV_INS_SHARD : expr := #4.

Definition KV_MOV_SHARD : expr := #5.

Definition shardOf: val :=
  rec: "shardOf" "key" :=
    let: "key" := ref_to uint64T "key" in
    return: ((![uint64T] "key") `rem` NSHARD);;;
    do:  #().

Definition PutRequest := struct.decl [
  "Key" :: uint64T;
  "Value" :: slice.T byteT
].

(* doesn't include the operation type *)
Definition EncodePutRequest: val :=
  rec: "EncodePutRequest" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "num_bytes" := ref_zero uint64T in
    let: "$a0" := std.SumAssumeNoOverflow (#8 + #8) (slice.len (struct.loadF PutRequest "Value" (![ptrT] "args"))) in
    do:  "num_bytes" <-[uint64T] "$a0";;;
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc (![uint64T] "num_bytes") in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF PutRequest "Key" (![ptrT] "args"));;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (slice.len (struct.loadF PutRequest "Value" (![ptrT] "args")));;;
    do:  marshal.Enc__PutBytes (![struct.t marshal.Enc] "e") (struct.loadF PutRequest "Value" (![ptrT] "args"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition DecodePutRequest: val :=
  rec: "DecodePutRequest" "reqData" :=
    let: "reqData" := ref_to (slice.T byteT) "reqData" in
    let: "req" := ref_zero ptrT in
    let: "$a0" := struct.alloc PutRequest (zero_val (struct.t PutRequest)) in
    do:  "req" <-[ptrT] "$a0";;;
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "reqData") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF PutRequest "Key" (![ptrT] "req") "$a0";;;
    let: "$a0" := marshal.Dec__GetBytes (![struct.t marshal.Dec] "d") (marshal.Dec__GetInt (![struct.t marshal.Dec] "d")) in
    do:  struct.storeF PutRequest "Value" (![ptrT] "req") "$a0";;;
    return: (![ptrT] "req");;;
    do:  #().

Definition PutReply := struct.decl [
  "Err" :: uint64T
].

Definition EncodePutReply: val :=
  rec: "EncodePutReply" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc #8 in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF PutReply "Err" (![ptrT] "reply"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition DecodePutReply: val :=
  rec: "DecodePutReply" "replyData" :=
    let: "replyData" := ref_to (slice.T byteT) "replyData" in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := struct.alloc PutReply (zero_val (struct.t PutReply)) in
    do:  "reply" <-[ptrT] "$a0";;;
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "replyData") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF PutReply "Err" (![ptrT] "reply") "$a0";;;
    return: (![ptrT] "reply");;;
    do:  #().

Definition GetRequest := struct.decl [
  "Key" :: uint64T
].

Definition GetReply := struct.decl [
  "Err" :: uint64T;
  "Value" :: slice.T byteT
].

Definition EncodeGetRequest: val :=
  rec: "EncodeGetRequest" "req" :=
    let: "req" := ref_to ptrT "req" in
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc #8 in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF GetRequest "Key" (![ptrT] "req"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition DecodeGetRequest: val :=
  rec: "DecodeGetRequest" "rawReq" :=
    let: "rawReq" := ref_to (slice.T byteT) "rawReq" in
    let: "req" := ref_zero ptrT in
    let: "$a0" := struct.alloc GetRequest (zero_val (struct.t GetRequest)) in
    do:  "req" <-[ptrT] "$a0";;;
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "rawReq") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF GetRequest "Key" (![ptrT] "req") "$a0";;;
    return: (![ptrT] "req");;;
    do:  #().

Definition EncodeGetReply: val :=
  rec: "EncodeGetReply" "rep" :=
    let: "rep" := ref_to ptrT "rep" in
    let: "num_bytes" := ref_zero uint64T in
    let: "$a0" := std.SumAssumeNoOverflow (#8 + #8) (slice.len (struct.loadF GetReply "Value" (![ptrT] "rep"))) in
    do:  "num_bytes" <-[uint64T] "$a0";;;
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc (![uint64T] "num_bytes") in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF GetReply "Err" (![ptrT] "rep"));;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (slice.len (struct.loadF GetReply "Value" (![ptrT] "rep")));;;
    do:  marshal.Enc__PutBytes (![struct.t marshal.Enc] "e") (struct.loadF GetReply "Value" (![ptrT] "rep"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition DecodeGetReply: val :=
  rec: "DecodeGetReply" "rawRep" :=
    let: "rawRep" := ref_to (slice.T byteT) "rawRep" in
    let: "rep" := ref_zero ptrT in
    let: "$a0" := struct.alloc GetReply (zero_val (struct.t GetReply)) in
    do:  "rep" <-[ptrT] "$a0";;;
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "rawRep") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF GetReply "Err" (![ptrT] "rep") "$a0";;;
    let: "$a0" := marshal.Dec__GetBytes (![struct.t marshal.Dec] "d") (marshal.Dec__GetInt (![struct.t marshal.Dec] "d")) in
    do:  struct.storeF GetReply "Value" (![ptrT] "rep") "$a0";;;
    return: (![ptrT] "rep");;;
    do:  #().

Definition ConditionalPutRequest := struct.decl [
  "Key" :: uint64T;
  "ExpectedValue" :: slice.T byteT;
  "NewValue" :: slice.T byteT
].

Definition ConditionalPutReply := struct.decl [
  "Err" :: uint64T;
  "Success" :: boolT
].

Definition EncodeConditionalPutRequest: val :=
  rec: "EncodeConditionalPutRequest" "req" :=
    let: "req" := ref_to ptrT "req" in
    let: "num_bytes" := ref_zero uint64T in
    let: "$a0" := std.SumAssumeNoOverflow ((#8 + #8) + #8) (std.SumAssumeNoOverflow (slice.len (struct.loadF ConditionalPutRequest "ExpectedValue" (![ptrT] "req"))) (slice.len (struct.loadF ConditionalPutRequest "NewValue" (![ptrT] "req")))) in
    do:  "num_bytes" <-[uint64T] "$a0";;;
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc (![uint64T] "num_bytes") in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF ConditionalPutRequest "Key" (![ptrT] "req"));;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (slice.len (struct.loadF ConditionalPutRequest "ExpectedValue" (![ptrT] "req")));;;
    do:  marshal.Enc__PutBytes (![struct.t marshal.Enc] "e") (struct.loadF ConditionalPutRequest "ExpectedValue" (![ptrT] "req"));;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (slice.len (struct.loadF ConditionalPutRequest "NewValue" (![ptrT] "req")));;;
    do:  marshal.Enc__PutBytes (![struct.t marshal.Enc] "e") (struct.loadF ConditionalPutRequest "NewValue" (![ptrT] "req"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition DecodeConditionalPutRequest: val :=
  rec: "DecodeConditionalPutRequest" "rawReq" :=
    let: "rawReq" := ref_to (slice.T byteT) "rawReq" in
    let: "req" := ref_zero ptrT in
    let: "$a0" := struct.alloc ConditionalPutRequest (zero_val (struct.t ConditionalPutRequest)) in
    do:  "req" <-[ptrT] "$a0";;;
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "rawReq") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF ConditionalPutRequest "Key" (![ptrT] "req") "$a0";;;
    let: "$a0" := marshal.Dec__GetBytes (![struct.t marshal.Dec] "d") (marshal.Dec__GetInt (![struct.t marshal.Dec] "d")) in
    do:  struct.storeF ConditionalPutRequest "ExpectedValue" (![ptrT] "req") "$a0";;;
    let: "$a0" := marshal.Dec__GetBytes (![struct.t marshal.Dec] "d") (marshal.Dec__GetInt (![struct.t marshal.Dec] "d")) in
    do:  struct.storeF ConditionalPutRequest "NewValue" (![ptrT] "req") "$a0";;;
    return: (![ptrT] "req");;;
    do:  #().

Definition EncodeConditionalPutReply: val :=
  rec: "EncodeConditionalPutReply" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc (#8 + #1) in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF ConditionalPutReply "Err" (![ptrT] "reply"));;;
    do:  marshal.Enc__PutBool (![struct.t marshal.Enc] "e") (struct.loadF ConditionalPutReply "Success" (![ptrT] "reply"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition DecodeConditionalPutReply: val :=
  rec: "DecodeConditionalPutReply" "replyData" :=
    let: "replyData" := ref_to (slice.T byteT) "replyData" in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := struct.alloc ConditionalPutReply (zero_val (struct.t ConditionalPutReply)) in
    do:  "reply" <-[ptrT] "$a0";;;
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "replyData") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF ConditionalPutReply "Err" (![ptrT] "reply") "$a0";;;
    let: "$a0" := marshal.Dec__GetBool (![struct.t marshal.Dec] "d") in
    do:  struct.storeF ConditionalPutReply "Success" (![ptrT] "reply") "$a0";;;
    return: (![ptrT] "reply");;;
    do:  #().

Definition InstallShardRequest := struct.decl [
  "Sid" :: uint64T;
  "Kvs" :: mapT (slice.T byteT)
].

(* NOTE: probably can just amortize this by keeping track of this with the map itself *)
Definition SizeOfMarshalledMap: val :=
  rec: "SizeOfMarshalledMap" "m" :=
    let: "m" := ref_to (mapT (slice.T byteT)) "m" in
    let: "s" := ref (zero_val uint64T) in
    let: "$a0" := #8 in
    do:  "s" <-[uint64T] "$a0";;;
    do:  MapIter (![mapT (slice.T byteT)] "m") (λ: <> "value",
      let: "v" := ref_zero uint64T in
      let: "$a0" := std.SumAssumeNoOverflow (slice.len (![slice.T byteT] "value")) (#8 + #8) in
      do:  "v" <-[uint64T] "$a0";;;
      let: "$a0" := std.SumAssumeNoOverflow (![uint64T] "s") (![uint64T] "v") in
      do:  "s" <-[uint64T] "$a0";;;
      do:  #());;;
    return: (![uint64T] "s");;;
    do:  #().

Definition EncSliceMap: val :=
  rec: "EncSliceMap" "e" "m" :=
    let: "m" := ref_to (mapT (slice.T byteT)) "m" in
    let: "e" := ref_to (struct.t marshal.Enc) "e" in
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (MapLen (![mapT (slice.T byteT)] "m"));;;
    do:  MapIter (![mapT (slice.T byteT)] "m") (λ: "key" "value",
      do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (![uint64T] "key");;;
      do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (slice.len (![slice.T byteT] "value"));;;
      do:  marshal.Enc__PutBytes (![struct.t marshal.Enc] "e") (![slice.T byteT] "value");;;
      do:  #());;;
    do:  #().

Definition DecSliceMap: val :=
  rec: "DecSliceMap" "d" :=
    let: "d" := ref_to (struct.t marshal.Dec) "d" in
    let: "sz" := ref_zero uint64T in
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  "sz" <-[uint64T] "$a0";;;
    let: "m" := ref_zero (mapT (slice.T byteT)) in
    let: "$a0" := NewMap uint64T (slice.T byteT) #() in
    do:  "m" <-[mapT (slice.T byteT)] "$a0";;;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "sz")); (λ: <>, Skip) := λ: <>,
      let: "k" := ref_zero uint64T in
      let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
      do:  "k" <-[uint64T] "$a0";;;
      let: "v" := ref_zero (slice.T byteT) in
      let: "$a0" := marshal.Dec__GetBytes (![struct.t marshal.Dec] "d") (marshal.Dec__GetInt (![struct.t marshal.Dec] "d")) in
      do:  "v" <-[slice.T byteT] "$a0";;;
      let: "$a0" := ![slice.T byteT] "v" in
      do:  MapInsert (![mapT (slice.T byteT)] "m") (![uint64T] "k") "$a0";;;
      let: "$a0" := (![uint64T] "i") + #1 in
      do:  "i" <-[uint64T] "$a0";;;
      do:  #()).

Definition encodeInstallShardRequest: val :=
  rec: "encodeInstallShardRequest" "req" :=
    let: "req" := ref_to ptrT "req" in
    let: "num_bytes" := ref_zero uint64T in
    let: "$a0" := std.SumAssumeNoOverflow #8 (SizeOfMarshalledMap (struct.loadF InstallShardRequest "Kvs" (![ptrT] "req"))) in
    do:  "num_bytes" <-[uint64T] "$a0";;;
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc (![uint64T] "num_bytes") in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF InstallShardRequest "Sid" (![ptrT] "req"));;;
    do:  EncSliceMap (![struct.t marshal.Enc] "e") (struct.loadF InstallShardRequest "Kvs" (![ptrT] "req"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition decodeInstallShardRequest: val :=
  rec: "decodeInstallShardRequest" "rawReq" :=
    let: "rawReq" := ref_to (slice.T byteT) "rawReq" in
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "rawReq") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    let: "req" := ref_zero ptrT in
    let: "$a0" := struct.alloc InstallShardRequest (zero_val (struct.t InstallShardRequest)) in
    do:  "req" <-[ptrT] "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF InstallShardRequest "Sid" (![ptrT] "req") "$a0";;;
    let: "$a0" := DecSliceMap (![struct.t marshal.Dec] "d") in
    do:  struct.storeF InstallShardRequest "Kvs" (![ptrT] "req") "$a0";;;
    return: (![ptrT] "req");;;
    do:  #().

Definition MoveShardRequest := struct.decl [
  "Sid" :: uint64T;
  "Dst" :: uint64T
].

Definition encodeMoveShardRequest: val :=
  rec: "encodeMoveShardRequest" "req" :=
    let: "req" := ref_to ptrT "req" in
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc (#8 + #8) in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF MoveShardRequest "Sid" (![ptrT] "req"));;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF MoveShardRequest "Dst" (![ptrT] "req"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition decodeMoveShardRequest: val :=
  rec: "decodeMoveShardRequest" "rawReq" :=
    let: "rawReq" := ref_to (slice.T byteT) "rawReq" in
    let: "req" := ref_zero ptrT in
    let: "$a0" := struct.alloc MoveShardRequest (zero_val (struct.t MoveShardRequest)) in
    do:  "req" <-[ptrT] "$a0";;;
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "rawReq") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF MoveShardRequest "Sid" (![ptrT] "req") "$a0";;;
    let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
    do:  struct.storeF MoveShardRequest "Dst" (![ptrT] "req") "$a0";;;
    return: (![ptrT] "req");;;
    do:  #().

(* FIXME: these should just be in goose std or something *)
Definition EncodeUint64: val :=
  rec: "EncodeUint64" "i" :=
    let: "i" := ref_to uint64T "i" in
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc #8 in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (![uint64T] "i");;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition DecodeUint64: val :=
  rec: "DecodeUint64" "raw" :=
    let: "raw" := ref_to (slice.T byteT) "raw" in
    return: (marshal.Dec__GetInt (marshal.NewDec (![slice.T byteT] "raw")));;;
    do:  #().

Definition encodeShardMap: val :=
  rec: "encodeShardMap" "shardMap" :=
    let: "shardMap" := ref_to ptrT "shardMap" in
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc (#8 * NSHARD) in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInts (![struct.t marshal.Enc] "e") (![slice.T uint64T] (![ptrT] "shardMap"));;;
    return: (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition decodeShardMap: val :=
  rec: "decodeShardMap" "raw" :=
    let: "raw" := ref_to (slice.T byteT) "raw" in
    let: "d" := ref_zero (struct.t marshal.Dec) in
    let: "$a0" := marshal.NewDec (![slice.T byteT] "raw") in
    do:  "d" <-[struct.t marshal.Dec] "$a0";;;
    return: (marshal.Dec__GetInts (![struct.t marshal.Dec] "d") NSHARD);;;
    do:  #().

(* 1_memkv_shard_clerk.go *)

Definition KVShardClerk := struct.decl [
  "erpc" :: ptrT;
  "host" :: uint64T;
  "c" :: ptrT
].

Definition MakeFreshKVShardClerk: val :=
  rec: "MakeFreshKVShardClerk" "host" "c" :=
    let: "c" := ref_to ptrT "c" in
    let: "host" := ref_to uint64T "host" in
    let: "ck" := ref_zero ptrT in
    let: "$a0" := struct.alloc KVShardClerk (zero_val (struct.t KVShardClerk)) in
    do:  "ck" <-[ptrT] "$a0";;;
    let: "$a0" := ![uint64T] "host" in
    do:  struct.storeF KVShardClerk "host" (![ptrT] "ck") "$a0";;;
    let: "$a0" := ![ptrT] "c" in
    do:  struct.storeF KVShardClerk "c" (![ptrT] "ck") "$a0";;;
    let: "rawRep" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "rawRep" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" (![ptrT] "ck")) (![uint64T] "host") KV_FRESHCID (NewSlice byteT #0) (![ptrT] "rawRep") #100;;;
    let: "cid" := ref_zero uint64T in
    let: "$a0" := DecodeUint64 (![slice.T byteT] (![ptrT] "rawRep")) in
    do:  "cid" <-[uint64T] "$a0";;;
    let: "$a0" := erpc.MakeClient (![uint64T] "cid") in
    do:  struct.storeF KVShardClerk "erpc" (![ptrT] "ck") "$a0";;;
    return: (![ptrT] "ck");;;
    do:  #().

Definition KVShardClerk__Put: val :=
  rec: "KVShardClerk__Put" "ck" "key" "value" :=
    let: "value" := ref_to (slice.T byteT) "value" in
    let: "key" := ref_to uint64T "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.alloc PutRequest (zero_val (struct.t PutRequest)) in
    do:  "args" <-[ptrT] "$a0";;;
    let: "$a0" := ![uint64T] "key" in
    do:  struct.storeF PutRequest "Key" (![ptrT] "args") "$a0";;;
    let: "$a0" := ![slice.T byteT] "value" in
    do:  struct.storeF PutRequest "Value" (![ptrT] "args") "$a0";;;
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := erpc.Client__NewRequest (struct.loadF KVShardClerk "erpc" (![ptrT] "ck")) (EncodePutRequest (![ptrT] "args")) in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "rawRep" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "rawRep" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" (![ptrT] "ck")) (struct.loadF KVShardClerk "host" (![ptrT] "ck")) KV_PUT (![slice.T byteT] "req") (![ptrT] "rawRep") #100;;;
    let: "rep" := ref_zero ptrT in
    let: "$a0" := DecodePutReply (![slice.T byteT] (![ptrT] "rawRep")) in
    do:  "rep" <-[ptrT] "$a0";;;
    return: (struct.loadF PutReply "Err" (![ptrT] "rep"));;;
    do:  #().

Definition KVShardClerk__Get: val :=
  rec: "KVShardClerk__Get" "ck" "key" "value" :=
    let: "value" := ref_to ptrT "value" in
    let: "key" := ref_to uint64T "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.alloc GetRequest (zero_val (struct.t GetRequest)) in
    do:  "args" <-[ptrT] "$a0";;;
    let: "$a0" := ![uint64T] "key" in
    do:  struct.storeF GetRequest "Key" (![ptrT] "args") "$a0";;;
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := erpc.Client__NewRequest (struct.loadF KVShardClerk "erpc" (![ptrT] "ck")) (EncodeGetRequest (![ptrT] "args")) in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "rawRep" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "rawRep" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" (![ptrT] "ck")) (struct.loadF KVShardClerk "host" (![ptrT] "ck")) KV_GET (![slice.T byteT] "req") (![ptrT] "rawRep") #100;;;
    let: "rep" := ref_zero ptrT in
    let: "$a0" := DecodeGetReply (![slice.T byteT] (![ptrT] "rawRep")) in
    do:  "rep" <-[ptrT] "$a0";;;
    let: "$a0" := struct.loadF GetReply "Value" (![ptrT] "rep") in
    do:  (![ptrT] "value") <-[slice.T byteT] "$a0";;;
    return: (struct.loadF GetReply "Err" (![ptrT] "rep"));;;
    do:  #().

Definition KVShardClerk__ConditionalPut: val :=
  rec: "KVShardClerk__ConditionalPut" "ck" "key" "expectedValue" "newValue" "success" :=
    let: "success" := ref_to ptrT "success" in
    let: "newValue" := ref_to (slice.T byteT) "newValue" in
    let: "expectedValue" := ref_to (slice.T byteT) "expectedValue" in
    let: "key" := ref_to uint64T "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.alloc ConditionalPutRequest (zero_val (struct.t ConditionalPutRequest)) in
    do:  "args" <-[ptrT] "$a0";;;
    let: "$a0" := ![uint64T] "key" in
    do:  struct.storeF ConditionalPutRequest "Key" (![ptrT] "args") "$a0";;;
    let: "$a0" := ![slice.T byteT] "expectedValue" in
    do:  struct.storeF ConditionalPutRequest "ExpectedValue" (![ptrT] "args") "$a0";;;
    let: "$a0" := ![slice.T byteT] "newValue" in
    do:  struct.storeF ConditionalPutRequest "NewValue" (![ptrT] "args") "$a0";;;
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := erpc.Client__NewRequest (struct.loadF KVShardClerk "erpc" (![ptrT] "ck")) (EncodeConditionalPutRequest (![ptrT] "args")) in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "rawRep" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "rawRep" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" (![ptrT] "ck")) (struct.loadF KVShardClerk "host" (![ptrT] "ck")) KV_CONDITIONAL_PUT (![slice.T byteT] "req") (![ptrT] "rawRep") #100;;;
    let: "rep" := ref_zero ptrT in
    let: "$a0" := DecodeConditionalPutReply (![slice.T byteT] (![ptrT] "rawRep")) in
    do:  "rep" <-[ptrT] "$a0";;;
    let: "$a0" := struct.loadF ConditionalPutReply "Success" (![ptrT] "rep") in
    do:  (![ptrT] "success") <-[boolT] "$a0";;;
    return: (struct.loadF ConditionalPutReply "Err" (![ptrT] "rep"));;;
    do:  #().

Definition KVShardClerk__InstallShard: val :=
  rec: "KVShardClerk__InstallShard" "ck" "sid" "kvs" :=
    let: "kvs" := ref_to (mapT (slice.T byteT)) "kvs" in
    let: "sid" := ref_to uint64T "sid" in
    let: "ck" := ref_to ptrT "ck" in
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.alloc InstallShardRequest (zero_val (struct.t InstallShardRequest)) in
    do:  "args" <-[ptrT] "$a0";;;
    let: "$a0" := ![uint64T] "sid" in
    do:  struct.storeF InstallShardRequest "Sid" (![ptrT] "args") "$a0";;;
    let: "$a0" := ![mapT (slice.T byteT)] "kvs" in
    do:  struct.storeF InstallShardRequest "Kvs" (![ptrT] "args") "$a0";;;
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := erpc.Client__NewRequest (struct.loadF KVShardClerk "erpc" (![ptrT] "ck")) (encodeInstallShardRequest (![ptrT] "args")) in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "rawRep" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "rawRep" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" (![ptrT] "ck")) (struct.loadF KVShardClerk "host" (![ptrT] "ck")) KV_INS_SHARD (![slice.T byteT] "req") (![ptrT] "rawRep") #100;;;
    do:  #().

Definition KVShardClerk__MoveShard: val :=
  rec: "KVShardClerk__MoveShard" "ck" "sid" "dst" :=
    let: "dst" := ref_to uint64T "dst" in
    let: "sid" := ref_to uint64T "sid" in
    let: "ck" := ref_to ptrT "ck" in
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.alloc MoveShardRequest (zero_val (struct.t MoveShardRequest)) in
    do:  "args" <-[ptrT] "$a0";;;
    let: "$a0" := ![uint64T] "sid" in
    do:  struct.storeF MoveShardRequest "Sid" (![ptrT] "args") "$a0";;;
    let: "$a0" := ![uint64T] "dst" in
    do:  struct.storeF MoveShardRequest "Dst" (![ptrT] "args") "$a0";;;
    let: "rawRep" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "rawRep" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" (![ptrT] "ck")) (struct.loadF KVShardClerk "host" (![ptrT] "ck")) KV_MOV_SHARD (encodeMoveShardRequest (![ptrT] "args")) (![ptrT] "rawRep") #100;;;
    do:  #().

Definition ShardClerkSet := struct.decl [
  "cls" :: mapT ptrT;
  "c" :: ptrT
].

Definition MakeShardClerkSet: val :=
  rec: "MakeShardClerkSet" "c" :=
    let: "c" := ref_to ptrT "c" in
    return: (struct.new ShardClerkSet [
       "cls" ::= NewMap uint64T ptrT #();
       "c" ::= ![ptrT] "c"
     ]);;;
    do:  #().

Definition ShardClerkSet__GetClerk: val :=
  rec: "ShardClerkSet__GetClerk" "s" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "s" := ref_to ptrT "s" in
    let: "ok" := ref_zero boolT in
    let: "ck" := ref_zero ptrT in
    let: ("$a0", "$a1") := Fst (MapGet (struct.loadF ShardClerkSet "cls" (![ptrT] "s")) (![uint64T] "host")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "ck" <-[ptrT] "$a0";;;
    (if: (~ (![boolT] "ok"))
    then
      let: "ck2" := ref_zero ptrT in
      let: "$a0" := MakeFreshKVShardClerk (![uint64T] "host") (struct.loadF ShardClerkSet "c" (![ptrT] "s")) in
      do:  "ck2" <-[ptrT] "$a0";;;
      let: "$a0" := ![ptrT] "ck2" in
      do:  MapInsert (struct.loadF ShardClerkSet "cls" (![ptrT] "s")) (![uint64T] "host") "$a0";;;
      return: (![ptrT] "ck2");;;
      do:  #()
    else
      return: (![ptrT] "ck");;;
      do:  #());;;
    do:  #().

(* 2_memkv_shard.go *)

Definition KvMap: ty := mapT (slice.T byteT).

Definition KVShardServer := struct.decl [
  "me" :: stringT;
  "mu" :: ptrT;
  "erpc" :: ptrT;
  "shardMap" :: slice.T boolT;
  "kvss" :: slice.T (mapT (slice.T byteT));
  "peers" :: mapT ptrT;
  "cm" :: ptrT
].

Definition PutArgs := struct.decl [
  "Key" :: uint64T;
  "Value" :: uint64T
].

Definition KVShardServer__put_inner: val :=
  rec: "KVShardServer__put_inner" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    let: "sid" := ref_zero uint64T in
    let: "$a0" := shardOf (struct.loadF PutRequest "Key" (![ptrT] "args")) in
    do:  "sid" <-[uint64T] "$a0";;;
    (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" (![ptrT] "s")) (![uint64T] "sid")) = #true
    then
      let: "$a0" := struct.loadF PutRequest "Value" (![ptrT] "args") in
      do:  MapInsert (SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" (![ptrT] "s")) (![uint64T] "sid")) (struct.loadF PutRequest "Key" (![ptrT] "args")) "$a0";;;
      let: "$a0" := ENone in
      do:  struct.storeF PutReply "Err" (![ptrT] "reply") "$a0";;;
      do:  #()
    else
      let: "$a0" := EDontHaveShard in
      do:  struct.storeF PutReply "Err" (![ptrT] "reply") "$a0";;;
      do:  #());;;
    do:  #().

Definition KVShardServer__PutRPC: val :=
  rec: "KVShardServer__PutRPC" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  KVShardServer__put_inner (![ptrT] "s") (![ptrT] "args") (![ptrT] "reply");;;
    do:  sync.Mutex__Unlock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  #().

Definition KVShardServer__get_inner: val :=
  rec: "KVShardServer__get_inner" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    let: "sid" := ref_zero uint64T in
    let: "$a0" := shardOf (struct.loadF GetRequest "Key" (![ptrT] "args")) in
    do:  "sid" <-[uint64T] "$a0";;;
    (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" (![ptrT] "s")) (![uint64T] "sid")) = #true
    then
      let: "$a0" := Fst (MapGet (SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" (![ptrT] "s")) (![uint64T] "sid")) (struct.loadF GetRequest "Key" (![ptrT] "args"))) in
      do:  struct.storeF GetReply "Value" (![ptrT] "reply") "$a0";;;
      let: "$a0" := ENone in
      do:  struct.storeF GetReply "Err" (![ptrT] "reply") "$a0";;;
      do:  #()
    else
      let: "$a0" := EDontHaveShard in
      do:  struct.storeF GetReply "Err" (![ptrT] "reply") "$a0";;;
      do:  #());;;
    do:  #().

Definition KVShardServer__GetRPC: val :=
  rec: "KVShardServer__GetRPC" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  KVShardServer__get_inner (![ptrT] "s") (![ptrT] "args") (![ptrT] "reply");;;
    do:  sync.Mutex__Unlock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  #().

Definition KVShardServer__conditional_put_inner: val :=
  rec: "KVShardServer__conditional_put_inner" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    let: "sid" := ref_zero uint64T in
    let: "$a0" := shardOf (struct.loadF ConditionalPutRequest "Key" (![ptrT] "args")) in
    do:  "sid" <-[uint64T] "$a0";;;
    (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" (![ptrT] "s")) (![uint64T] "sid")) = #true
    then
      let: "m" := ref_zero (mapT (slice.T byteT)) in
      let: "$a0" := SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" (![ptrT] "s")) (![uint64T] "sid") in
      do:  "m" <-[mapT (slice.T byteT)] "$a0";;;
      let: "equal" := ref_zero boolT in
      let: "$a0" := std.BytesEqual (struct.loadF ConditionalPutRequest "ExpectedValue" (![ptrT] "args")) (Fst (MapGet (![mapT (slice.T byteT)] "m") (struct.loadF ConditionalPutRequest "Key" (![ptrT] "args")))) in
      do:  "equal" <-[boolT] "$a0";;;
      (if: ![boolT] "equal"
      then
        let: "$a0" := struct.loadF ConditionalPutRequest "NewValue" (![ptrT] "args") in
        do:  MapInsert (![mapT (slice.T byteT)] "m") (struct.loadF ConditionalPutRequest "Key" (![ptrT] "args")) "$a0";;;
        do:  #()
      else #());;;
      let: "$a0" := ![boolT] "equal" in
      do:  struct.storeF ConditionalPutReply "Success" (![ptrT] "reply") "$a0";;;
      let: "$a0" := ENone in
      do:  struct.storeF ConditionalPutReply "Err" (![ptrT] "reply") "$a0";;;
      do:  #()
    else
      let: "$a0" := EDontHaveShard in
      do:  struct.storeF ConditionalPutReply "Err" (![ptrT] "reply") "$a0";;;
      do:  #());;;
    do:  #().

Definition KVShardServer__ConditionalPutRPC: val :=
  rec: "KVShardServer__ConditionalPutRPC" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  KVShardServer__conditional_put_inner (![ptrT] "s") (![ptrT] "args") (![ptrT] "reply");;;
    do:  sync.Mutex__Unlock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  #().

(* NOTE: easy to do a little optimization with shard migration:
   add a "RemoveShard" rpc, which removes the shard on the target server, and
   returns half of the ghost state for that shard. Meanwhile, InstallShard()
   will only grant half the ghost state, and physical state will keep track of
   the fact that the shard is only good for read-only operations up until that
   flag is updated (i.e. until RemoveShard() is run). *)
Definition KVShardServer__install_shard_inner: val :=
  rec: "KVShardServer__install_shard_inner" "s" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    let: "$a0" := #true in
    do:  SliceSet boolT (struct.loadF KVShardServer "shardMap" (![ptrT] "s")) (struct.loadF InstallShardRequest "Sid" (![ptrT] "args")) "$a0";;;
    let: "$a0" := struct.loadF InstallShardRequest "Kvs" (![ptrT] "args") in
    do:  SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" (![ptrT] "s")) (struct.loadF InstallShardRequest "Sid" (![ptrT] "args")) "$a0";;;
    do:  #().

Definition KVShardServer__InstallShardRPC: val :=
  rec: "KVShardServer__InstallShardRPC" "s" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  KVShardServer__install_shard_inner (![ptrT] "s") (![ptrT] "args");;;
    do:  sync.Mutex__Unlock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  #().

Definition KVShardServer__MoveShardRPC: val :=
  rec: "KVShardServer__MoveShardRPC" "s" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    let: "ok" := ref_zero boolT in
    let: <> := ref_zero ptrT in
    let: ("$a0", "$a1") := Fst (MapGet (struct.loadF KVShardServer "peers" (![ptrT] "s")) (struct.loadF MoveShardRequest "Dst" (![ptrT] "args"))) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "$a0";;;
    (if: (~ (![boolT] "ok"))
    then
      let: "ck" := ref_zero ptrT in
      let: "$a0" := MakeFreshKVShardClerk (struct.loadF MoveShardRequest "Dst" (![ptrT] "args")) (struct.loadF KVShardServer "cm" (![ptrT] "s")) in
      do:  "ck" <-[ptrT] "$a0";;;
      let: "$a0" := ![ptrT] "ck" in
      do:  MapInsert (struct.loadF KVShardServer "peers" (![ptrT] "s")) (struct.loadF MoveShardRequest "Dst" (![ptrT] "args")) "$a0";;;
      do:  #()
    else #());;;
    (if: (~ (SliceGet boolT (struct.loadF KVShardServer "shardMap" (![ptrT] "s")) (struct.loadF MoveShardRequest "Sid" (![ptrT] "args"))))
    then
      do:  sync.Mutex__Unlock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
      return: (#());;;
      do:  #()
    else #());;;
    let: "kvs" := ref_zero (mapT (slice.T byteT)) in
    let: "$a0" := SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" (![ptrT] "s")) (struct.loadF MoveShardRequest "Sid" (![ptrT] "args")) in
    do:  "kvs" <-[mapT (slice.T byteT)] "$a0";;;
    let: "$a0" := NewMap uint64T (slice.T byteT) #() in
    do:  SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" (![ptrT] "s")) (struct.loadF MoveShardRequest "Sid" (![ptrT] "args")) "$a0";;;
    let: "$a0" := #false in
    do:  SliceSet boolT (struct.loadF KVShardServer "shardMap" (![ptrT] "s")) (struct.loadF MoveShardRequest "Sid" (![ptrT] "args")) "$a0";;;
    do:  KVShardClerk__InstallShard (Fst (MapGet (struct.loadF KVShardServer "peers" (![ptrT] "s")) (struct.loadF MoveShardRequest "Dst" (![ptrT] "args")))) (struct.loadF MoveShardRequest "Sid" (![ptrT] "args")) (![mapT (slice.T byteT)] "kvs");;;
    do:  sync.Mutex__Unlock (struct.loadF KVShardServer "mu" (![ptrT] "s"));;;
    do:  #().

Definition MakeKVShardServer: val :=
  rec: "MakeKVShardServer" "is_init" :=
    let: "is_init" := ref_to boolT "is_init" in
    let: "srv" := ref_zero ptrT in
    let: "$a0" := struct.alloc KVShardServer (zero_val (struct.t KVShardServer)) in
    do:  "srv" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF KVShardServer "mu" (![ptrT] "srv") "$a0";;;
    let: "$a0" := erpc.MakeServer #() in
    do:  struct.storeF KVShardServer "erpc" (![ptrT] "srv") "$a0";;;
    let: "$a0" := NewSlice boolT NSHARD in
    do:  struct.storeF KVShardServer "shardMap" (![ptrT] "srv") "$a0";;;
    let: "$a0" := NewSlice (mapT (slice.T byteT)) NSHARD in
    do:  struct.storeF KVShardServer "kvss" (![ptrT] "srv") "$a0";;;
    let: "$a0" := NewMap uint64T ptrT #() in
    do:  struct.storeF KVShardServer "peers" (![ptrT] "srv") "$a0";;;
    let: "$a0" := connman.MakeConnMan #() in
    do:  struct.storeF KVShardServer "cm" (![ptrT] "srv") "$a0";;;
    (let: "i" := ref_zero uint64T in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < NSHARD); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "$a0" := ![boolT] "is_init" in
      do:  SliceSet boolT (struct.loadF KVShardServer "shardMap" (![ptrT] "srv")) (![uint64T] "i") "$a0";;;
      (if: ![boolT] "is_init"
      then
        let: "$a0" := NewMap uint64T (slice.T byteT) #() in
        do:  SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" (![ptrT] "srv")) (![uint64T] "i") "$a0";;;
        do:  #()
      else #());;;
      do:  #())).

Definition KVShardServer__GetCIDRPC: val :=
  rec: "KVShardServer__GetCIDRPC" "s" :=
    let: "s" := ref_to ptrT "s" in
    return: (erpc.Server__GetFreshCID (struct.loadF KVShardServer "erpc" (![ptrT] "s")));;;
    do:  #().

Definition KVShardServer__Start: val :=
  rec: "KVShardServer__Start" "mkv" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "mkv" := ref_to ptrT "mkv" in
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "erpc" := ref_zero ptrT in
    let: "$a0" := struct.loadF KVShardServer "erpc" (![ptrT] "mkv") in
    do:  "erpc" <-[ptrT] "$a0";;;
    let: "$a0" := (λ: "rawReq" "rawReply",
      let: "$a0" := EncodeUint64 (KVShardServer__GetCIDRPC (![ptrT] "mkv")) in
      do:  (![ptrT] "rawReply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") KV_FRESHCID "$a0";;;
    let: "$a0" := erpc.Server__HandleRequest (![ptrT] "erpc") (λ: "rawReq" "rawReply",
      let: "rep" := ref_zero ptrT in
      let: "$a0" := struct.alloc PutReply (zero_val (struct.t PutReply)) in
      do:  "rep" <-[ptrT] "$a0";;;
      do:  KVShardServer__PutRPC (![ptrT] "mkv") (DecodePutRequest (![slice.T byteT] "rawReq")) (![ptrT] "rep");;;
      let: "$a0" := EncodePutReply (![ptrT] "rep") in
      do:  (![ptrT] "rawReply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") KV_PUT "$a0";;;
    let: "$a0" := erpc.Server__HandleRequest (![ptrT] "erpc") (λ: "rawReq" "rawReply",
      let: "rep" := ref_zero ptrT in
      let: "$a0" := struct.alloc GetReply (zero_val (struct.t GetReply)) in
      do:  "rep" <-[ptrT] "$a0";;;
      do:  KVShardServer__GetRPC (![ptrT] "mkv") (DecodeGetRequest (![slice.T byteT] "rawReq")) (![ptrT] "rep");;;
      let: "$a0" := EncodeGetReply (![ptrT] "rep") in
      do:  (![ptrT] "rawReply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") KV_GET "$a0";;;
    let: "$a0" := erpc.Server__HandleRequest (![ptrT] "erpc") (λ: "rawReq" "rawReply",
      let: "rep" := ref_zero ptrT in
      let: "$a0" := struct.alloc ConditionalPutReply (zero_val (struct.t ConditionalPutReply)) in
      do:  "rep" <-[ptrT] "$a0";;;
      do:  KVShardServer__ConditionalPutRPC (![ptrT] "mkv") (DecodeConditionalPutRequest (![slice.T byteT] "rawReq")) (![ptrT] "rep");;;
      let: "$a0" := EncodeConditionalPutReply (![ptrT] "rep") in
      do:  (![ptrT] "rawReply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") KV_CONDITIONAL_PUT "$a0";;;
    let: "$a0" := erpc.Server__HandleRequest (![ptrT] "erpc") (λ: "rawReq" "rawReply",
      do:  KVShardServer__InstallShardRPC (![ptrT] "mkv") (decodeInstallShardRequest (![slice.T byteT] "rawReq"));;;
      let: "$a0" := NewSlice byteT #0 in
      do:  (![ptrT] "rawReply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") KV_INS_SHARD "$a0";;;
    let: "$a0" := (λ: "rawReq" "rawReply",
      do:  KVShardServer__MoveShardRPC (![ptrT] "mkv") (decodeMoveShardRequest (![slice.T byteT] "rawReq"));;;
      let: "$a0" := NewSlice byteT #0 in
      do:  (![ptrT] "rawReply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") KV_MOV_SHARD "$a0";;;
    let: "s" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    do:  "s" <-[ptrT] "$a0";;;
    do:  urpc.Server__Serve (![ptrT] "s") (![uint64T] "host");;;
    do:  #().

(* 3_memkv_coord.go *)

Definition COORD_ADD : expr := #1.

Definition COORD_GET : expr := #2.

Definition KVCoord := struct.decl [
  "mu" :: ptrT;
  "shardMap" :: slice.T uint64T;
  "hostShards" :: mapT uint64T;
  "shardClerks" :: ptrT
].

Definition KVCoord__AddServerRPC: val :=
  rec: "KVCoord__AddServerRPC" "c" "newhost" :=
    let: "newhost" := ref_to uint64T "newhost" in
    let: "c" := ref_to ptrT "c" in
    do:  sync.Mutex__Lock (struct.loadF KVCoord "mu" (![ptrT] "c"));;;
    do:  log.Printf #(str "Rebalancing
    ");;;
    let: "$a0" := #0 in
    do:  MapInsert (struct.loadF KVCoord "hostShards" (![ptrT] "c")) (![uint64T] "newhost") "$a0";;;
    let: "numHosts" := ref_zero uint64T in
    let: "$a0" := MapLen (struct.loadF KVCoord "hostShards" (![ptrT] "c")) in
    do:  "numHosts" <-[uint64T] "$a0";;;
    let: "numShardFloor" := ref_zero uint64T in
    let: "$a0" := NSHARD `quot` (![uint64T] "numHosts") in
    do:  "numShardFloor" <-[uint64T] "$a0";;;
    let: "numShardCeil" := ref_zero uint64T in
    let: "$a0" := (NSHARD `quot` (![uint64T] "numHosts")) + #1 in
    do:  "numShardCeil" <-[uint64T] "$a0";;;
    let: "nf_left" := ref (zero_val uint64T) in
    let: "$a0" := (![uint64T] "numHosts") - (NSHARD - (((![uint64T] "numHosts") * NSHARD) `quot` (![uint64T] "numHosts"))) in
    do:  "nf_left" <-[uint64T] "$a0";;;
    do:  ForSlice uint64T "sid" "host" (struct.loadF KVCoord "shardMap" (![ptrT] "c"))
      (let: "n" := ref_zero uint64T in
      let: "$a0" := Fst (MapGet (struct.loadF KVCoord "hostShards" (![ptrT] "c")) (![uint64T] "host")) in
      do:  "n" <-[uint64T] "$a0";;;
      (if: (![uint64T] "n") > (![uint64T] "numShardFloor")
      then
        (if: (![uint64T] "n") = (![uint64T] "numShardCeil")
        then
          (if: (![uint64T] "nf_left") > #0
          then
            let: "$a0" := (![uint64T] "nf_left") - #1 in
            do:  "nf_left" <-[uint64T] "$a0";;;
            do:  KVShardClerk__MoveShard (ShardClerkSet__GetClerk (struct.loadF KVCoord "shardClerks" (![ptrT] "c")) (![uint64T] "host")) (![intT] "sid") (![uint64T] "newhost");;;
            let: "$a0" := (![uint64T] "n") - #1 in
            do:  MapInsert (struct.loadF KVCoord "hostShards" (![ptrT] "c")) (![uint64T] "host") "$a0";;;
            do:  MapInsert (struct.loadF KVCoord "hostShards" (![ptrT] "c")) (![uint64T] "newhost") ((Fst (MapGet (struct.loadF KVCoord "hostShards" (![ptrT] "c")) (![uint64T] "newhost"))) + #1);;;
            let: "$a0" := ![uint64T] "newhost" in
            do:  SliceSet uint64T (struct.loadF KVCoord "shardMap" (![ptrT] "c")) (![intT] "sid") "$a0";;;
            do:  #()
          else #());;;
          do:  #()
        else
          do:  KVShardClerk__MoveShard (ShardClerkSet__GetClerk (struct.loadF KVCoord "shardClerks" (![ptrT] "c")) (![uint64T] "host")) (![intT] "sid") (![uint64T] "newhost");;;
          let: "$a0" := (![uint64T] "n") - #1 in
          do:  MapInsert (struct.loadF KVCoord "hostShards" (![ptrT] "c")) (![uint64T] "host") "$a0";;;
          do:  MapInsert (struct.loadF KVCoord "hostShards" (![ptrT] "c")) (![uint64T] "newhost") ((Fst (MapGet (struct.loadF KVCoord "hostShards" (![ptrT] "c")) (![uint64T] "newhost"))) + #1);;;
          let: "$a0" := ![uint64T] "newhost" in
          do:  SliceSet uint64T (struct.loadF KVCoord "shardMap" (![ptrT] "c")) (![intT] "sid") "$a0";;;
          do:  #());;;
        do:  #()
      else #());;;
      do:  #());;;
    do:  log.Println #(str "Done rebalancing");;;
    do:  log.Printf #(str "%!!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)v(MISSING)") (struct.loadF KVCoord "hostShards" (![ptrT] "c"));;;
    do:  sync.Mutex__Unlock (struct.loadF KVCoord "mu" (![ptrT] "c"));;;
    do:  #().

Definition KVCoord__GetShardMapRPC: val :=
  rec: "KVCoord__GetShardMapRPC" "c" <> "rep" :=
    let: "rep" := ref_to ptrT "rep" in
    let: <> := ref_to (slice.T byteT) "_" in
    let: "c" := ref_to ptrT "c" in
    do:  sync.Mutex__Lock (struct.loadF KVCoord "mu" (![ptrT] "c"));;;
    let: "$a0" := encodeShardMap (struct.fieldRef KVCoord "shardMap" (![ptrT] "c")) in
    do:  (![ptrT] "rep") <-[slice.T byteT] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF KVCoord "mu" (![ptrT] "c"));;;
    do:  #().

Definition MakeKVCoordServer: val :=
  rec: "MakeKVCoordServer" "initserver" :=
    let: "initserver" := ref_to uint64T "initserver" in
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc KVCoord (zero_val (struct.t KVCoord)) in
    do:  "s" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF KVCoord "mu" (![ptrT] "s") "$a0";;;
    let: "$a0" := NewSlice uint64T NSHARD in
    do:  struct.storeF KVCoord "shardMap" (![ptrT] "s") "$a0";;;
    (let: "i" := ref_zero uint64T in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < NSHARD); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "$a0" := ![uint64T] "initserver" in
      do:  SliceSet uint64T (struct.loadF KVCoord "shardMap" (![ptrT] "s")) (![uint64T] "i") "$a0";;;
      do:  #())).

Definition KVCoord__Start: val :=
  rec: "KVCoord__Start" "c" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "c" := ref_to ptrT "c" in
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := (λ: "rawReq" "rawRep",
      let: "s" := ref_zero uint64T in
      let: "$a0" := DecodeUint64 (![slice.T byteT] "rawReq") in
      do:  "s" <-[uint64T] "$a0";;;
      do:  KVCoord__AddServerRPC (![ptrT] "c") (![uint64T] "s");;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") COORD_ADD "$a0";;;
    let: "$a0" := KVCoord__GetShardMapRPC (![ptrT] "c") in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") COORD_GET "$a0";;;
    let: "s" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    do:  "s" <-[ptrT] "$a0";;;
    do:  urpc.Server__Serve (![ptrT] "s") (![uint64T] "host");;;
    do:  #().

(* 4_memkv_seq_clerk.go *)

Definition KVCoordClerk := struct.decl [
  "host" :: uint64T;
  "c" :: ptrT
].

Definition KVCoordClerk__AddShardServer: val :=
  rec: "KVCoordClerk__AddShardServer" "ck" "dst" :=
    let: "dst" := ref_to uint64T "dst" in
    let: "ck" := ref_to ptrT "ck" in
    let: "rawRep" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "rawRep" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF KVCoordClerk "c" (![ptrT] "ck")) (struct.loadF KVCoordClerk "host" (![ptrT] "ck")) COORD_ADD (EncodeUint64 (![uint64T] "dst")) (![ptrT] "rawRep") #50000;;;
    return: (#());;;
    do:  #().

Definition KVCoordClerk__GetShardMap: val :=
  rec: "KVCoordClerk__GetShardMap" "ck" :=
    let: "ck" := ref_to ptrT "ck" in
    let: "rawRep" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "rawRep" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF KVCoordClerk "c" (![ptrT] "ck")) (struct.loadF KVCoordClerk "host" (![ptrT] "ck")) COORD_GET (NewSlice byteT #0) (![ptrT] "rawRep") #50000;;;
    return: (decodeShardMap (![slice.T byteT] (![ptrT] "rawRep")));;;
    do:  #().

Definition SeqKVClerk := struct.decl [
  "shardClerks" :: ptrT;
  "coordCk" :: ptrT;
  "shardMap" :: slice.T uint64T
].

Definition SeqKVClerk__Get: val :=
  rec: "SeqKVClerk__Get" "ck" "key" :=
    let: "key" := ref_to uint64T "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "val" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "val" <-[ptrT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := ref_zero uint64T in
      let: "$a0" := shardOf (![uint64T] "key") in
      do:  "sid" <-[uint64T] "$a0";;;
      let: "shardServer" := ref_zero uint64T in
      let: "$a0" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" (![ptrT] "ck")) (![uint64T] "sid") in
      do:  "shardServer" <-[uint64T] "$a0";;;
      let: "shardCk" := ref_zero ptrT in
      let: "$a0" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" (![ptrT] "ck")) (![uint64T] "shardServer") in
      do:  "shardCk" <-[ptrT] "$a0";;;
      let: "err" := ref_zero uint64T in
      let: "$a0" := KVShardClerk__Get (![ptrT] "shardCk") (![uint64T] "key") (![ptrT] "val") in
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = ENone
      then
        break: #();;;
        do:  #()
      else #());;;
      let: "$a0" := KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" (![ptrT] "ck")) in
      do:  struct.storeF SeqKVClerk "shardMap" (![ptrT] "ck") "$a0";;;
      continue: #();;;
      do:  #()).

Definition SeqKVClerk__Put: val :=
  rec: "SeqKVClerk__Put" "ck" "key" "value" :=
    let: "value" := ref_to (slice.T byteT) "value" in
    let: "key" := ref_to uint64T "key" in
    let: "ck" := ref_to ptrT "ck" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := ref_zero uint64T in
      let: "$a0" := shardOf (![uint64T] "key") in
      do:  "sid" <-[uint64T] "$a0";;;
      let: "shardServer" := ref_zero uint64T in
      let: "$a0" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" (![ptrT] "ck")) (![uint64T] "sid") in
      do:  "shardServer" <-[uint64T] "$a0";;;
      let: "shardCk" := ref_zero ptrT in
      let: "$a0" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" (![ptrT] "ck")) (![uint64T] "shardServer") in
      do:  "shardCk" <-[ptrT] "$a0";;;
      let: "err" := ref_zero uint64T in
      let: "$a0" := KVShardClerk__Put (![ptrT] "shardCk") (![uint64T] "key") (![slice.T byteT] "value") in
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = ENone
      then
        break: #();;;
        do:  #()
      else #());;;
      let: "$a0" := KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" (![ptrT] "ck")) in
      do:  struct.storeF SeqKVClerk "shardMap" (![ptrT] "ck") "$a0";;;
      continue: #();;;
      do:  #()).

Definition SeqKVClerk__ConditionalPut: val :=
  rec: "SeqKVClerk__ConditionalPut" "ck" "key" "expectedValue" "newValue" :=
    let: "newValue" := ref_to (slice.T byteT) "newValue" in
    let: "expectedValue" := ref_to (slice.T byteT) "expectedValue" in
    let: "key" := ref_to uint64T "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "success" := ref_zero ptrT in
    let: "$a0" := ref (zero_val boolT) in
    do:  "success" <-[ptrT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := ref_zero uint64T in
      let: "$a0" := shardOf (![uint64T] "key") in
      do:  "sid" <-[uint64T] "$a0";;;
      let: "shardServer" := ref_zero uint64T in
      let: "$a0" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" (![ptrT] "ck")) (![uint64T] "sid") in
      do:  "shardServer" <-[uint64T] "$a0";;;
      let: "shardCk" := ref_zero ptrT in
      let: "$a0" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" (![ptrT] "ck")) (![uint64T] "shardServer") in
      do:  "shardCk" <-[ptrT] "$a0";;;
      let: "err" := ref_zero uint64T in
      let: "$a0" := KVShardClerk__ConditionalPut (![ptrT] "shardCk") (![uint64T] "key") (![slice.T byteT] "expectedValue") (![slice.T byteT] "newValue") (![ptrT] "success") in
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = ENone
      then
        break: #();;;
        do:  #()
      else #());;;
      let: "$a0" := KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" (![ptrT] "ck")) in
      do:  struct.storeF SeqKVClerk "shardMap" (![ptrT] "ck") "$a0";;;
      continue: #();;;
      do:  #()).

Definition SeqKVClerk__Add: val :=
  rec: "SeqKVClerk__Add" "ck" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "ck" := ref_to ptrT "ck" in
    do:  KVCoordClerk__AddShardServer (struct.loadF SeqKVClerk "coordCk" (![ptrT] "ck")) (![uint64T] "host");;;
    do:  #().

Definition MakeSeqKVClerk: val :=
  rec: "MakeSeqKVClerk" "coord" "cm" :=
    let: "cm" := ref_to ptrT "cm" in
    let: "coord" := ref_to uint64T "coord" in
    let: "cck" := ref_zero ptrT in
    let: "$a0" := struct.alloc KVCoordClerk (zero_val (struct.t KVCoordClerk)) in
    do:  "cck" <-[ptrT] "$a0";;;
    let: "ck" := ref_zero ptrT in
    let: "$a0" := struct.alloc SeqKVClerk (zero_val (struct.t SeqKVClerk)) in
    do:  "ck" <-[ptrT] "$a0";;;
    let: "$a0" := ![ptrT] "cck" in
    do:  struct.storeF SeqKVClerk "coordCk" (![ptrT] "ck") "$a0";;;
    let: "$a0" := ![uint64T] "coord" in
    do:  struct.storeF KVCoordClerk "host" (struct.loadF SeqKVClerk "coordCk" (![ptrT] "ck")) "$a0";;;
    let: "$a0" := ![ptrT] "cm" in
    do:  struct.storeF KVCoordClerk "c" (struct.loadF SeqKVClerk "coordCk" (![ptrT] "ck")) "$a0";;;
    let: "$a0" := MakeShardClerkSet (![ptrT] "cm") in
    do:  struct.storeF SeqKVClerk "shardClerks" (![ptrT] "ck") "$a0";;;
    let: "$a0" := KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" (![ptrT] "ck")) in
    do:  struct.storeF SeqKVClerk "shardMap" (![ptrT] "ck") "$a0";;;
    return: (![ptrT] "ck");;;
    do:  #().

(* 5_memkv_clerk.go *)

Definition KVClerk := struct.decl [
  "mu" :: ptrT;
  "freeClerks" :: slice.T ptrT;
  "cm" :: ptrT;
  "coord" :: uint64T
].

Definition KVClerk__getSeqClerk: val :=
  rec: "KVClerk__getSeqClerk" "p" :=
    let: "p" := ref_to ptrT "p" in
    do:  sync.Mutex__Lock (struct.loadF KVClerk "mu" (![ptrT] "p"));;;
    let: "n" := ref_zero intT in
    let: "$a0" := slice.len (struct.loadF KVClerk "freeClerks" (![ptrT] "p")) in
    do:  "n" <-[intT] "$a0";;;
    (if: (![intT] "n") = #0
    then
      do:  sync.Mutex__Unlock (struct.loadF KVClerk "mu" (![ptrT] "p"));;;
      return: (MakeSeqKVClerk (struct.loadF KVClerk "coord" (![ptrT] "p")) (connman.MakeConnMan #()));;;
      do:  #()
    else
      let: "ck" := ref_zero ptrT in
      let: "$a0" := SliceGet ptrT (struct.loadF KVClerk "freeClerks" (![ptrT] "p")) ((![intT] "n") - #1) in
      do:  "ck" <-[ptrT] "$a0";;;
      let: "$a0" := SliceTake (struct.loadF KVClerk "freeClerks" (![ptrT] "p")) ((![intT] "n") - #1) in
      do:  struct.storeF KVClerk "freeClerks" (![ptrT] "p") "$a0";;;
      do:  sync.Mutex__Unlock (struct.loadF KVClerk "mu" (![ptrT] "p"));;;
      return: (![ptrT] "ck");;;
      do:  #());;;
    do:  #().

Definition KVClerk__putSeqClerk: val :=
  rec: "KVClerk__putSeqClerk" "p" "ck" :=
    let: "ck" := ref_to ptrT "ck" in
    let: "p" := ref_to ptrT "p" in
    do:  Fork (do:  sync.Mutex__Lock (struct.loadF KVClerk "mu" (![ptrT] "p"));;;
          let: "$a0" := SliceAppend ptrT (struct.loadF KVClerk "freeClerks" (![ptrT] "p")) (![ptrT] "ck") in
          do:  struct.storeF KVClerk "freeClerks" (![ptrT] "p") "$a0";;;
          do:  sync.Mutex__Unlock (struct.loadF KVClerk "mu" (![ptrT] "p"));;;
          do:  #());;;
    do:  #().

(* the hope is that after a while, the number of clerks needed to maintain a
   request rate for an open system benchmark will stabilize. *)
Definition KVClerk__Put: val :=
  rec: "KVClerk__Put" "p" "key" "value" :=
    let: "value" := ref_to (slice.T byteT) "value" in
    let: "key" := ref_to uint64T "key" in
    let: "p" := ref_to ptrT "p" in
    let: "ck" := ref_zero ptrT in
    let: "$a0" := KVClerk__getSeqClerk (![ptrT] "p") in
    do:  "ck" <-[ptrT] "$a0";;;
    do:  SeqKVClerk__Put (![ptrT] "ck") (![uint64T] "key") (![slice.T byteT] "value");;;
    do:  KVClerk__putSeqClerk (![ptrT] "p") (![ptrT] "ck");;;
    do:  #().

Definition KVClerk__Get: val :=
  rec: "KVClerk__Get" "p" "key" :=
    let: "key" := ref_to uint64T "key" in
    let: "p" := ref_to ptrT "p" in
    let: "ck" := ref_zero ptrT in
    let: "$a0" := KVClerk__getSeqClerk (![ptrT] "p") in
    do:  "ck" <-[ptrT] "$a0";;;
    let: "value" := ref_zero (slice.T byteT) in
    let: "$a0" := SeqKVClerk__Get (![ptrT] "ck") (![uint64T] "key") in
    do:  "value" <-[slice.T byteT] "$a0";;;
    do:  KVClerk__putSeqClerk (![ptrT] "p") (![ptrT] "ck");;;
    return: (![slice.T byteT] "value");;;
    do:  #().

Definition KVClerk__ConditionalPut: val :=
  rec: "KVClerk__ConditionalPut" "p" "key" "expectedValue" "newValue" :=
    let: "newValue" := ref_to (slice.T byteT) "newValue" in
    let: "expectedValue" := ref_to (slice.T byteT) "expectedValue" in
    let: "key" := ref_to uint64T "key" in
    let: "p" := ref_to ptrT "p" in
    let: "ck" := ref_zero ptrT in
    let: "$a0" := KVClerk__getSeqClerk (![ptrT] "p") in
    do:  "ck" <-[ptrT] "$a0";;;
    let: "ret" := ref_zero boolT in
    let: "$a0" := SeqKVClerk__ConditionalPut (![ptrT] "ck") (![uint64T] "key") (![slice.T byteT] "expectedValue") (![slice.T byteT] "newValue") in
    do:  "ret" <-[boolT] "$a0";;;
    do:  KVClerk__putSeqClerk (![ptrT] "p") (![ptrT] "ck");;;
    return: (![boolT] "ret");;;
    do:  #().

(* FIXME: rename to AddShardServer *)
Definition KVClerk__Add: val :=
  rec: "KVClerk__Add" "p" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "p" := ref_to ptrT "p" in
    let: "ck" := ref_zero ptrT in
    let: "$a0" := KVClerk__getSeqClerk (![ptrT] "p") in
    do:  "ck" <-[ptrT] "$a0";;;
    do:  SeqKVClerk__Add (![ptrT] "ck") (![uint64T] "host");;;
    do:  KVClerk__putSeqClerk (![ptrT] "p") (![ptrT] "ck");;;
    do:  #().

(* returns a slice of "values" (which are byte slices) in the same order as the
   keys passed in as input
   FIXME: benchmark *)
Definition KVClerk__MGet: val :=
  rec: "KVClerk__MGet" "p" "keys" :=
    let: "keys" := ref_to (slice.T uint64T) "keys" in
    let: "p" := ref_to ptrT "p" in
    let: "vals" := ref_zero (slice.T (slice.T byteT)) in
    let: "$a0" := NewSlice (slice.T byteT) (slice.len (![slice.T uint64T] "keys")) in
    do:  "vals" <-[slice.T (slice.T byteT)] "$a0";;;
    do:  std.Multipar (slice.len (![slice.T uint64T] "keys")) (λ: "i",
      let: "$a0" := KVClerk__Get (![ptrT] "p") (SliceGet uint64T (![slice.T uint64T] "keys") (![uint64T] "i")) in
      do:  SliceSet (slice.T byteT) (![slice.T (slice.T byteT)] "vals") (![uint64T] "i") "$a0";;;
      do:  #()
      );;;
    return: (![slice.T (slice.T byteT)] "vals");;;
    do:  #().

Definition MakeKVClerk: val :=
  rec: "MakeKVClerk" "coord" "cm" :=
    let: "cm" := ref_to ptrT "cm" in
    let: "coord" := ref_to uint64T "coord" in
    let: "p" := ref_zero ptrT in
    let: "$a0" := struct.alloc KVClerk (zero_val (struct.t KVClerk)) in
    do:  "p" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF KVClerk "mu" (![ptrT] "p") "$a0";;;
    let: "$a0" := ![uint64T] "coord" in
    do:  struct.storeF KVClerk "coord" (![ptrT] "p") "$a0";;;
    let: "$a0" := ![ptrT] "cm" in
    do:  struct.storeF KVClerk "cm" (![ptrT] "p") "$a0";;;
    let: "$a0" := NewSlice ptrT #0 in
    do:  struct.storeF KVClerk "freeClerks" (![ptrT] "p") "$a0";;;
    return: (![ptrT] "p");;;
    do:  #().
