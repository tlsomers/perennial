(* autogenerated from github.com/mit-pdos/gokv/erpc *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require sync.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

(* Implements "exactly-once RPCs" with a reply table. *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "lastSeq" :: mapT uint64T;
  "lastReply" :: mapT (slice.T byteT);
  "nextCID" :: uint64T
].

Definition Server__HandleRequest: val :=
  rec: "Server__HandleRequest" "t" "handler" :=
    let: "handler" := ref_to ((slice.T byteT) -> ptrT -> unitT)%ht "handler" in
    let: "t" := ref_to ptrT "t" in
    return: ((λ: "raw_args" "reply",
       let: "cid" := ref_zero uint64T in
       let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "raw_args") in
       do:  "raw_args" <-[slice.T byteT] "$a1";;;
       do:  "cid" <-[uint64T] "$a0";;;
       let: "seq" := ref_zero uint64T in
       let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "raw_args") in
       do:  "raw_args" <-[slice.T byteT] "$a1";;;
       do:  "seq" <-[uint64T] "$a0";;;
       do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "t"));;;
       let: "last" := ref_zero uint64T in
       let: "$a0" := Fst (MapGet (struct.loadF Server "lastSeq" (![ptrT] "t")) (![uint64T] "cid")) in
       do:  "last" <-[uint64T] "$a0";;;
       (if: (![uint64T] "seq") ≤ (![uint64T] "last")
       then
         let: "$a0" := Fst (MapGet (struct.loadF Server "lastReply" (![ptrT] "t")) (![uint64T] "cid")) in
         do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
         do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "t"));;;
         return: (#());;;
         do:  #()
       else #());;;
       do:  (![(arrowT unitT unitT)] "handler") (![slice.T byteT] "raw_args") (![ptrT] "reply");;;
       let: "$a0" := ![uint64T] "seq" in
       do:  MapInsert (struct.loadF Server "lastSeq" (![ptrT] "t")) (![uint64T] "cid") "$a0";;;
       let: "$a0" := ![slice.T byteT] (![ptrT] "reply") in
       do:  MapInsert (struct.loadF Server "lastReply" (![ptrT] "t")) (![uint64T] "cid") "$a0";;;
       do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "t"));;;
       do:  #()
       ));;;
    do:  #().

Definition Server__GetFreshCID: val :=
  rec: "Server__GetFreshCID" "t" :=
    let: "t" := ref_to ptrT "t" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "t"));;;
    let: "r" := ref_zero uint64T in
    let: "$a0" := struct.loadF Server "nextCID" (![ptrT] "t") in
    do:  "r" <-[uint64T] "$a0";;;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF Server "nextCID" (![ptrT] "t")) #1 in
    do:  struct.storeF Server "nextCID" (![ptrT] "t") "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "t"));;;
    return: (![uint64T] "r");;;
    do:  #().

Definition MakeServer: val :=
  rec: "MakeServer" <> :=
    let: "t" := ref_zero ptrT in
    let: "$a0" := struct.alloc Server (zero_val (struct.t Server)) in
    do:  "t" <-[ptrT] "$a0";;;
    let: "$a0" := NewMap uint64T (slice.T byteT) #() in
    do:  struct.storeF Server "lastReply" (![ptrT] "t") "$a0";;;
    let: "$a0" := NewMap uint64T uint64T #() in
    do:  struct.storeF Server "lastSeq" (![ptrT] "t") "$a0";;;
    let: "$a0" := #0 in
    do:  struct.storeF Server "nextCID" (![ptrT] "t") "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF Server "mu" (![ptrT] "t") "$a0";;;
    return: (![ptrT] "t");;;
    do:  #().

Definition Client := struct.decl [
  "cid" :: uint64T;
  "nextSeq" :: uint64T
].

Definition Client__NewRequest: val :=
  rec: "Client__NewRequest" "c" "request" :=
    let: "request" := ref_to (slice.T byteT) "request" in
    let: "c" := ref_to ptrT "c" in
    let: "seq" := ref_zero uint64T in
    let: "$a0" := struct.loadF Client "nextSeq" (![ptrT] "c") in
    do:  "seq" <-[uint64T] "$a0";;;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF Client "nextSeq" (![ptrT] "c")) #1 in
    do:  struct.storeF Client "nextSeq" (![ptrT] "c") "$a0";;;
    let: "data1" := ref_zero (slice.T byteT) in
    let: "$a0" := NewSliceWithCap byteT #0 ((#8 + #8) + (slice.len (![slice.T byteT] "request"))) in
    do:  "data1" <-[slice.T byteT] "$a0";;;
    let: "data2" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "data1") (struct.loadF Client "cid" (![ptrT] "c")) in
    do:  "data2" <-[slice.T byteT] "$a0";;;
    let: "data3" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "data2") (![uint64T] "seq") in
    do:  "data3" <-[slice.T byteT] "$a0";;;
    let: "data4" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "data3") (![slice.T byteT] "request") in
    do:  "data4" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "data4");;;
    do:  #().

Definition MakeClient: val :=
  rec: "MakeClient" "cid" :=
    let: "cid" := ref_to uint64T "cid" in
    let: "c" := ref_zero ptrT in
    let: "$a0" := struct.alloc Client (zero_val (struct.t Client)) in
    do:  "c" <-[ptrT] "$a0";;;
    let: "$a0" := ![uint64T] "cid" in
    do:  struct.storeF Client "cid" (![ptrT] "c") "$a0";;;
    let: "$a0" := #1 in
    do:  struct.storeF Client "nextSeq" (![ptrT] "c") "$a0";;;
    return: (![ptrT] "c");;;
    do:  #().

End code.
