(* autogenerated from github.com/mit-pdos/gokv/tutorial/lockservice *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.tchajed.goose.machine.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require log.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_lock.gb.go *)

Definition EncodeBool: val :=
  rec: "EncodeBool" "a" :=
    let: "a" := ref_to boolT "a" in
    (if: ![boolT] "a"
    then
      return: (SliceAppend byteT (NewSlice byteT #0) #(U8 1));;;
      do:  #()
    else
      return: (SliceAppend byteT (NewSlice byteT #0) #(U8 0));;;
      do:  #());;;
    do:  #().

Definition DecodeBool: val :=
  rec: "DecodeBool" "x" :=
    let: "x" := ref_to (slice.T byteT) "x" in
    return: ((SliceGet byteT (![slice.T byteT] "x") #0) = #(U8 1));;;
    do:  #().

Definition EncodeUint64: val :=
  rec: "EncodeUint64" "a" :=
    let: "a" := ref_to uint64T "a" in
    return: (marshal.WriteInt (NewSlice byteT #0) (![uint64T] "a"));;;
    do:  #().

Definition DecodeUint64: val :=
  rec: "DecodeUint64" "x" :=
    let: "x" := ref_to (slice.T byteT) "x" in
    let: <> := ref_zero (slice.T byteT) in
    let: "a" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "x") in
    do:  "$a1";;;
    do:  "a" <-[uint64T] "$a0";;;
    return: (![uint64T] "a");;;
    do:  #().

(* 1_lock_rpc.gb.go *)

Definition RPC_GET_FRESH_NUM : expr := #0.

Definition RPC_TRY_ACQUIRE : expr := #1.

Definition RPC_RELEASE : expr := #2.

Definition Error: ty := uint64T.

Definition Client := struct.decl [
  "cl" :: ptrT
].

Definition Client__getFreshNum: val :=
  rec: "Client__getFreshNum" "cl" :=
    let: "cl" := ref_to ptrT "cl" in
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "args" := ref_zero (slice.T byteT) in
    let: "$a0" := NewSlice byteT #0 in
    do:  "args" <-[slice.T byteT] "$a0";;;
    let: "err" := ref_zero uint64T in
    let: "$a0" := urpc.Client__Call (struct.loadF Client "cl" (![ptrT] "cl")) RPC_GET_FRESH_NUM (![slice.T byteT] "args") "reply" #100 in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") = urpc.ErrNone
    then
      return: (DecodeUint64 (![slice.T byteT] "reply"), ![uint64T] "err");;;
      do:  #()
    else #());;;
    return: (#0, ![uint64T] "err");;;
    do:  #().

Definition Client__tryAcquire: val :=
  rec: "Client__tryAcquire" "cl" "id" :=
    let: "id" := ref_to uint64T "id" in
    let: "cl" := ref_to ptrT "cl" in
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "args" := ref_zero (slice.T byteT) in
    let: "$a0" := EncodeUint64 (![uint64T] "id") in
    do:  "args" <-[slice.T byteT] "$a0";;;
    let: "err" := ref_zero uint64T in
    let: "$a0" := urpc.Client__Call (struct.loadF Client "cl" (![ptrT] "cl")) RPC_TRY_ACQUIRE (![slice.T byteT] "args") "reply" #100 in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") = urpc.ErrNone
    then
      return: (DecodeUint64 (![slice.T byteT] "reply"), ![uint64T] "err");;;
      do:  #()
    else #());;;
    return: (#0, ![uint64T] "err");;;
    do:  #().

Definition Client__release: val :=
  rec: "Client__release" "cl" "id" :=
    let: "id" := ref_to uint64T "id" in
    let: "cl" := ref_to ptrT "cl" in
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "args" := ref_zero (slice.T byteT) in
    let: "$a0" := EncodeUint64 (![uint64T] "id") in
    do:  "args" <-[slice.T byteT] "$a0";;;
    return: (urpc.Client__Call (struct.loadF Client "cl" (![ptrT] "cl")) RPC_RELEASE (![slice.T byteT] "args") "reply" #100);;;
    do:  #().

Definition makeClient: val :=
  rec: "makeClient" "hostname" :=
    let: "hostname" := ref_to uint64T "hostname" in
    return: (struct.new Client [
       "cl" ::= urpc.MakeClient (![uint64T] "hostname")
     ]);;;
    do:  #().

(* 2_server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "nextId" :: uint64T;
  "locked" :: boolT;
  "holder" :: uint64T
].

Definition Server__getFreshNum: val :=
  rec: "Server__getFreshNum" "s" :=
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    let: "n" := ref_zero uint64T in
    let: "$a0" := struct.loadF Server "nextId" (![ptrT] "s") in
    do:  "n" <-[uint64T] "$a0";;;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF Server "nextId" (![ptrT] "s")) #1 in
    do:  struct.storeF Server "nextId" (![ptrT] "s") "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    return: (![uint64T] "n");;;
    do:  #().

Definition StatusGranted : expr := #0.

Definition StatusRetry : expr := #2.

Definition StatusStale : expr := #1.

Definition Server__tryAcquire: val :=
  rec: "Server__tryAcquire" "s" "id" :=
    let: "id" := ref_to uint64T "id" in
    let: "s" := ref_to ptrT "s" in
    let: "ret" := ref (zero_val uint64T) in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    (if: (struct.loadF Server "holder" (![ptrT] "s")) > (![uint64T] "id")
    then
      let: "$a0" := StatusStale in
      do:  "ret" <-[uint64T] "$a0";;;
      do:  #()
    else
      (if: struct.loadF Server "locked" (![ptrT] "s")
      then
        (if: (struct.loadF Server "holder" (![ptrT] "s")) = (![uint64T] "id")
        then
          let: "$a0" := StatusGranted in
          do:  "ret" <-[uint64T] "$a0";;;
          do:  #()
        else
          let: "$a0" := StatusRetry in
          do:  "ret" <-[uint64T] "$a0";;;
          do:  #());;;
        do:  #()
      else
        let: "$a0" := ![uint64T] "id" in
        do:  struct.storeF Server "holder" (![ptrT] "s") "$a0";;;
        let: "$a0" := #true in
        do:  struct.storeF Server "locked" (![ptrT] "s") "$a0";;;
        do:  log.Printf #(str "Lock held by %!!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)d(MISSING)") (![uint64T] "id");;;
        let: "$a0" := StatusGranted in
        do:  "ret" <-[uint64T] "$a0";;;
        do:  #());;;
      do:  #());;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    return: (![uint64T] "ret");;;
    do:  #().

Definition Server__release: val :=
  rec: "Server__release" "s" "id" :=
    let: "id" := ref_to uint64T "id" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    (if: (struct.loadF Server "holder" (![ptrT] "s")) = (![uint64T] "id")
    then
      let: "$a0" := #false in
      do:  struct.storeF Server "locked" (![ptrT] "s") "$a0";;;
      do:  #()
    else #());;;
    do:  log.Printf #(str "Lock released by %!!(MISSING)!(MISSING)!(MISSING)d(MISSING)") (![uint64T] "id");;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    do:  #().

Definition MakeServer: val :=
  rec: "MakeServer" <> :=
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc Server (zero_val (struct.t Server)) in
    do:  "s" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF Server "mu" (![ptrT] "s") "$a0";;;
    return: (![ptrT] "s");;;
    do:  #().

(* 3_lock_rpc_server.gb.go *)

Definition Server__Start: val :=
  rec: "Server__Start" "s" "me" :=
    let: "me" := ref_to uint64T "me" in
    let: "s" := ref_to ptrT "s" in
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := (λ: "enc_args" "enc_reply",
      let: "$a0" := EncodeUint64 (Server__getFreshNum (![ptrT] "s")) in
      do:  (![ptrT] "enc_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_GET_FRESH_NUM "$a0";;;
    let: "$a0" := (λ: "enc_args" "enc_reply",
      let: "$a0" := EncodeUint64 (Server__tryAcquire (![ptrT] "s") (DecodeUint64 (![slice.T byteT] "enc_args"))) in
      do:  (![ptrT] "enc_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_TRY_ACQUIRE "$a0";;;
    let: "$a0" := (λ: "enc_args" "enc_reply",
      do:  Server__release (![ptrT] "s") (DecodeUint64 (![slice.T byteT] "enc_args"));;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_RELEASE "$a0";;;
    do:  urpc.Server__Serve (urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers")) (![uint64T] "me");;;
    do:  #().

(* client.go *)

Definition Clerk := struct.decl [
  "rpcCl" :: ptrT
].

Definition Locked := struct.decl [
  "rpcCl" :: ptrT;
  "id" :: uint64T
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "host" :=
    let: "host" := ref_to uint64T "host" in
    return: (struct.new Clerk [
       "rpcCl" ::= makeClient (![uint64T] "host")
     ]);;;
    do:  #().

Definition Clerk__Acquire: val :=
  rec: "Clerk__Acquire" "ck" :=
    let: "ck" := ref_to ptrT "ck" in
    let: "id" := ref (zero_val uint64T) in
    let: "err" := ref (zero_val uint64T) in
    let: "l" := ref (zero_val ptrT) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("$a0", "$a1") := Client__getFreshNum (struct.loadF Clerk "rpcCl" (![ptrT] "ck")) in
      do:  "err" <-[uint64T] "$a1";;;
      do:  "id" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") ≠ #0
      then
        continue: #();;;
        do:  #()
      else #());;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        let: "err" := ref_zero uint64T in
        let: "lockStatus" := ref_zero uint64T in
        let: ("$a0", "$a1") := Client__tryAcquire (struct.loadF Clerk "rpcCl" (![ptrT] "ck")) (![uint64T] "id") in
        do:  "err" <-[uint64T] "$a1";;;
        do:  "lockStatus" <-[uint64T] "$a0";;;
        (if: ((![uint64T] "err") ≠ #0) || ((![uint64T] "lockStatus") = StatusRetry)
        then
          do:  machine.Sleep (#100 * #1000000);;;
          continue: #();;;
          do:  #()
        else
          (if: (![uint64T] "lockStatus") = StatusGranted
          then
            let: "$a0" := struct.new Locked [
              "rpcCl" ::= struct.loadF Clerk "rpcCl" (![ptrT] "ck");
              "id" ::= ![uint64T] "id"
            ] in
            do:  "l" <-[ptrT] "$a0";;;
            break: #();;;
            do:  #()
          else
            break: #();;;
            do:  #());;;
          #());;;
        do:  #())).

Definition Locked__Release: val :=
  rec: "Locked__Release" "l" :=
    let: "l" := ref_to ptrT "l" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (Client__release (struct.loadF Locked "rpcCl" (![ptrT] "l")) (struct.loadF Locked "id" (![ptrT] "l"))) = #0
      then
        break: #();;;
        do:  #()
      else #());;;
      do:  #()).
