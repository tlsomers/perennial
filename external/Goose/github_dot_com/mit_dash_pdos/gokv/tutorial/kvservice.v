(* autogenerated from github.com/mit-pdos/gokv/tutorial/kvservice *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* client.go *)

Definition Clerk := struct.decl [
  "rpcCl" :: ptrT
].

Definition Locked := struct.decl [
  "rpcCl" :: ptrT;
  "id" :: uint64T
].

(* Client from kvservice_rpc.gb.go *)

Definition Client := struct.decl [
  "cl" :: ptrT
].

Definition makeClient: val :=
  rec: "makeClient" "hostname" :=
    let: "hostname" := ref_to uint64T "hostname" in
    return: (struct.new Client [
       "cl" ::= urpc.MakeClient (![uint64T] "hostname")
     ]);;;
    do:  #().

Definition MakeClerk: val :=
  rec: "MakeClerk" "host" :=
    let: "host" := ref_to uint64T "host" in
    return: (struct.new Clerk [
       "rpcCl" ::= makeClient (![uint64T] "host")
     ]);;;
    do:  #().

Definition rpcIdGetFreshNum : expr := #0.

Definition rpcIdPut : expr := #1.

Definition rpcIdConditionalPut : expr := #2.

Definition rpcIdGet : expr := #3.

(* putArgs from kvservice.gb.go *)

Definition putArgs := struct.decl [
  "opId" :: uint64T;
  "key" :: stringT;
  "val" :: stringT
].

Definition encodePutArgs: val :=
  rec: "encodePutArgs" "a" :=
    let: "a" := ref_to ptrT "a" in
    let: "e" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF putArgs "opId" (![ptrT] "a")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "keyBytes" := ref_zero (slice.T byteT) in
    let: "$a0" := StringToBytes (struct.loadF putArgs "key" (![ptrT] "a")) in
    do:  "keyBytes" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (slice.len (![slice.T byteT] "keyBytes")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (![slice.T byteT] "keyBytes") in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (StringToBytes (struct.loadF putArgs "val" (![ptrT] "a"))) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "e");;;
    do:  #().

(* Client__putRpc from kvservice_rpc.gb.go *)

Definition Client__putRpc: val :=
  rec: "Client__putRpc" "cl" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "cl" := ref_to ptrT "cl" in
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := ref_zero uint64T in
    let: "$a0" := urpc.Client__Call (struct.loadF Client "cl" (![ptrT] "cl")) rpcIdPut (encodePutArgs (![ptrT] "args")) "reply" #100 in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") = urpc.ErrNone
    then
      return: (![uint64T] "err");;;
      do:  #()
    else #());;;
    return: (![uint64T] "err");;;
    do:  #().

(* DecodeUint64 from kvservice.gb.go *)

Definition DecodeUint64: val :=
  rec: "DecodeUint64" "x" :=
    let: "x" := ref_to (slice.T byteT) "x" in
    let: <> := ref_zero (slice.T byteT) in
    let: "a" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "x") in
    do:  "$a1";;;
    do:  "a" <-[uint64T] "$a0";;;
    return: (![uint64T] "a");;;
    do:  #().

(* Client__getFreshNumRpc from kvservice_rpc.gb.go *)

Definition Client__getFreshNumRpc: val :=
  rec: "Client__getFreshNumRpc" "cl" :=
    let: "cl" := ref_to ptrT "cl" in
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := ref_zero uint64T in
    let: "$a0" := urpc.Client__Call (struct.loadF Client "cl" (![ptrT] "cl")) rpcIdGetFreshNum (NewSlice byteT #0) "reply" #100 in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") = urpc.ErrNone
    then
      return: (DecodeUint64 (![slice.T byteT] "reply"), ![uint64T] "err");;;
      do:  #()
    else #());;;
    return: (#0, ![uint64T] "err");;;
    do:  #().

Definition Clerk__Put: val :=
  rec: "Clerk__Put" "ck" "key" "val" :=
    let: "val" := ref_to stringT "val" in
    let: "key" := ref_to stringT "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "err" := ref (zero_val uint64T) in
    let: "opId" := ref (zero_val uint64T) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("$a0", "$a1") := Client__getFreshNumRpc (struct.loadF Clerk "rpcCl" (![ptrT] "ck")) in
      do:  "err" <-[uint64T] "$a1";;;
      do:  "opId" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = #0
      then
        break: #();;;
        do:  #()
      else #());;;
      do:  #()).

(* conditionalPutArgs from kvservice.gb.go *)

Definition conditionalPutArgs := struct.decl [
  "opId" :: uint64T;
  "key" :: stringT;
  "expectedVal" :: stringT;
  "newVal" :: stringT
].

Definition encodeConditionalPutArgs: val :=
  rec: "encodeConditionalPutArgs" "a" :=
    let: "a" := ref_to ptrT "a" in
    let: "e" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF conditionalPutArgs "opId" (![ptrT] "a")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "keyBytes" := ref_zero (slice.T byteT) in
    let: "$a0" := StringToBytes (struct.loadF conditionalPutArgs "key" (![ptrT] "a")) in
    do:  "keyBytes" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (slice.len (![slice.T byteT] "keyBytes")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (![slice.T byteT] "keyBytes") in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "expectedValBytes" := ref_zero (slice.T byteT) in
    let: "$a0" := StringToBytes (struct.loadF conditionalPutArgs "expectedVal" (![ptrT] "a")) in
    do:  "expectedValBytes" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (slice.len (![slice.T byteT] "expectedValBytes")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (![slice.T byteT] "expectedValBytes") in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (StringToBytes (struct.loadF conditionalPutArgs "newVal" (![ptrT] "a"))) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "e");;;
    do:  #().

(* Client__conditionalPutRpc from kvservice_rpc.gb.go *)

Definition Client__conditionalPutRpc: val :=
  rec: "Client__conditionalPutRpc" "cl" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "cl" := ref_to ptrT "cl" in
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := ref_zero uint64T in
    let: "$a0" := urpc.Client__Call (struct.loadF Client "cl" (![ptrT] "cl")) rpcIdConditionalPut (encodeConditionalPutArgs (![ptrT] "args")) "reply" #100 in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") = urpc.ErrNone
    then
      return: (StringFromBytes (![slice.T byteT] "reply"), ![uint64T] "err");;;
      do:  #()
    else #());;;
    return: (#(str ""), ![uint64T] "err");;;
    do:  #().

(* returns true if ConditionalPut was successful, false if current value did not
   match expected value. *)
Definition Clerk__ConditionalPut: val :=
  rec: "Clerk__ConditionalPut" "ck" "key" "expectedVal" "newVal" :=
    let: "newVal" := ref_to stringT "newVal" in
    let: "expectedVal" := ref_to stringT "expectedVal" in
    let: "key" := ref_to stringT "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "err" := ref (zero_val uint64T) in
    let: "opId" := ref (zero_val uint64T) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("$a0", "$a1") := Client__getFreshNumRpc (struct.loadF Clerk "rpcCl" (![ptrT] "ck")) in
      do:  "err" <-[uint64T] "$a1";;;
      do:  "opId" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = #0
      then
        break: #();;;
        do:  #()
      else #());;;
      do:  #()).

(* getArgs from kvservice.gb.go *)

Definition getArgs := struct.decl [
  "opId" :: uint64T;
  "key" :: stringT
].

Definition encodeGetArgs: val :=
  rec: "encodeGetArgs" "a" :=
    let: "a" := ref_to ptrT "a" in
    let: "e" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF getArgs "opId" (![ptrT] "a")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (StringToBytes (struct.loadF getArgs "key" (![ptrT] "a"))) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "e");;;
    do:  #().

(* Client__getRpc from kvservice_rpc.gb.go *)

Definition Client__getRpc: val :=
  rec: "Client__getRpc" "cl" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "cl" := ref_to ptrT "cl" in
    let: "reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := ref_zero uint64T in
    let: "$a0" := urpc.Client__Call (struct.loadF Client "cl" (![ptrT] "cl")) rpcIdGet (encodeGetArgs (![ptrT] "args")) "reply" #100 in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") = urpc.ErrNone
    then
      return: (StringFromBytes (![slice.T byteT] "reply"), ![uint64T] "err");;;
      do:  #()
    else #());;;
    return: (#(str ""), ![uint64T] "err");;;
    do:  #().

(* returns true if ConditionalPut was successful, false if current value did not
   match expected value. *)
Definition Clerk__Get: val :=
  rec: "Clerk__Get" "ck" "key" :=
    let: "key" := ref_to stringT "key" in
    let: "ck" := ref_to ptrT "ck" in
    let: "err" := ref (zero_val uint64T) in
    let: "opId" := ref (zero_val uint64T) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("$a0", "$a1") := Client__getFreshNumRpc (struct.loadF Clerk "rpcCl" (![ptrT] "ck")) in
      do:  "err" <-[uint64T] "$a1";;;
      do:  "opId" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = #0
      then
        break: #();;;
        do:  #()
      else #());;;
      do:  #()).

(* kvservice.gb.go *)

(* TODO: these are generic *)
Definition EncodeBool: val :=
  rec: "EncodeBool" "a" :=
    let: "a" := ref_to boolT "a" in
    (if: ![boolT] "a"
    then
      return: (SliceAppend byteT (NewSlice byteT #0) #(U8 1));;;
      do:  #()
    else
      return: (SliceAppend byteT (NewSlice byteT #0) #(U8 0));;;
      do:  #());;;
    do:  #().

Definition DecodeBool: val :=
  rec: "DecodeBool" "x" :=
    let: "x" := ref_to (slice.T byteT) "x" in
    return: ((SliceGet byteT (![slice.T byteT] "x") #0) = #(U8 1));;;
    do:  #().

Definition EncodeUint64: val :=
  rec: "EncodeUint64" "a" :=
    let: "a" := ref_to uint64T "a" in
    return: (marshal.WriteInt (NewSlice byteT #0) (![uint64T] "a"));;;
    do:  #().

Definition decodePutArgs: val :=
  rec: "decodePutArgs" "x" :=
    let: "x" := ref_to (slice.T byteT) "x" in
    let: "e" := ref_to (slice.T byteT) (![slice.T byteT] "x") in
    let: "a" := ref_zero ptrT in
    let: "$a0" := struct.alloc putArgs (zero_val (struct.t putArgs)) in
    do:  "a" <-[ptrT] "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "e" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF putArgs "opId" (![ptrT] "a") "$a0";;;
    let: "e2" := ref_zero (slice.T byteT) in
    let: "keyLen" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "e2" <-[slice.T byteT] "$a1";;;
    do:  "keyLen" <-[uint64T] "$a0";;;
    let: "valBytes" := ref_zero (slice.T byteT) in
    let: "keyBytes" := ref_zero (slice.T byteT) in
    let: ("$a0", "$a1") := marshal.ReadBytes (![slice.T byteT] "e2") (![uint64T] "keyLen") in
    do:  "valBytes" <-[slice.T byteT] "$a1";;;
    do:  "keyBytes" <-[slice.T byteT] "$a0";;;
    let: "$a0" := StringFromBytes (![slice.T byteT] "keyBytes") in
    do:  struct.storeF putArgs "key" (![ptrT] "a") "$a0";;;
    let: "$a0" := StringFromBytes (![slice.T byteT] "valBytes") in
    do:  struct.storeF putArgs "val" (![ptrT] "a") "$a0";;;
    return: (![ptrT] "a");;;
    do:  #().

Definition decodeConditionalPutArgs: val :=
  rec: "decodeConditionalPutArgs" "x" :=
    let: "x" := ref_to (slice.T byteT) "x" in
    let: "e" := ref_to (slice.T byteT) (![slice.T byteT] "x") in
    let: "a" := ref_zero ptrT in
    let: "$a0" := struct.alloc conditionalPutArgs (zero_val (struct.t conditionalPutArgs)) in
    do:  "a" <-[ptrT] "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "e" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF conditionalPutArgs "opId" (![ptrT] "a") "$a0";;;
    let: "e2" := ref_zero (slice.T byteT) in
    let: "keyLen" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "e2" <-[slice.T byteT] "$a1";;;
    do:  "keyLen" <-[uint64T] "$a0";;;
    let: "e3" := ref_zero (slice.T byteT) in
    let: "keyBytes" := ref_zero (slice.T byteT) in
    let: ("$a0", "$a1") := marshal.ReadBytes (![slice.T byteT] "e2") (![uint64T] "keyLen") in
    do:  "e3" <-[slice.T byteT] "$a1";;;
    do:  "keyBytes" <-[slice.T byteT] "$a0";;;
    let: "$a0" := StringFromBytes (![slice.T byteT] "keyBytes") in
    do:  struct.storeF conditionalPutArgs "key" (![ptrT] "a") "$a0";;;
    let: "e4" := ref_zero (slice.T byteT) in
    let: "expectedValLen" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e3") in
    do:  "e4" <-[slice.T byteT] "$a1";;;
    do:  "expectedValLen" <-[uint64T] "$a0";;;
    let: "newValBytes" := ref_zero (slice.T byteT) in
    let: "expectedValBytes" := ref_zero (slice.T byteT) in
    let: ("$a0", "$a1") := marshal.ReadBytes (![slice.T byteT] "e4") (![uint64T] "expectedValLen") in
    do:  "newValBytes" <-[slice.T byteT] "$a1";;;
    do:  "expectedValBytes" <-[slice.T byteT] "$a0";;;
    let: "$a0" := StringFromBytes (![slice.T byteT] "expectedValBytes") in
    do:  struct.storeF conditionalPutArgs "expectedVal" (![ptrT] "a") "$a0";;;
    let: "$a0" := StringFromBytes (![slice.T byteT] "newValBytes") in
    do:  struct.storeF conditionalPutArgs "newVal" (![ptrT] "a") "$a0";;;
    return: (![ptrT] "a");;;
    do:  #().

Definition decodeGetArgs: val :=
  rec: "decodeGetArgs" "x" :=
    let: "x" := ref_to (slice.T byteT) "x" in
    let: "e" := ref_to (slice.T byteT) (![slice.T byteT] "x") in
    let: "keyBytes" := ref (zero_val (slice.T byteT)) in
    let: "a" := ref_zero ptrT in
    let: "$a0" := struct.alloc getArgs (zero_val (struct.t getArgs)) in
    do:  "a" <-[ptrT] "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "keyBytes" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF getArgs "opId" (![ptrT] "a") "$a0";;;
    let: "$a0" := StringFromBytes (![slice.T byteT] "keyBytes") in
    do:  struct.storeF getArgs "key" (![ptrT] "a") "$a0";;;
    return: (![ptrT] "a");;;
    do:  #().

(* kvservice_rpc.gb.go *)

Definition Error: ty := uint64T.

(* kvservice_rpc_server.gb.go *)

(* Server from server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "nextFreshId" :: uint64T;
  "lastReplies" :: mapT stringT;
  "kvs" :: mapT stringT
].

Definition Server__get: val :=
  rec: "Server__get" "s" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    let: "ok" := ref_zero boolT in
    let: "ret" := ref_zero stringT in
    let: ("$a0", "$a1") := Fst (MapGet (struct.loadF Server "lastReplies" (![ptrT] "s")) (struct.loadF getArgs "opId" (![ptrT] "args"))) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "ret" <-[stringT] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
      return: (![stringT] "ret");;;
      do:  #()
    else #());;;
    let: "ret2" := ref_zero stringT in
    let: "$a0" := Fst (MapGet (struct.loadF Server "kvs" (![ptrT] "s")) (struct.loadF getArgs "key" (![ptrT] "args"))) in
    do:  "ret2" <-[stringT] "$a0";;;
    let: "$a0" := ![stringT] "ret2" in
    do:  MapInsert (struct.loadF Server "lastReplies" (![ptrT] "s")) (struct.loadF getArgs "opId" (![ptrT] "args")) "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    return: (![stringT] "ret2");;;
    do:  #().

Definition Server__conditionalPut: val :=
  rec: "Server__conditionalPut" "s" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    let: "ok" := ref_zero boolT in
    let: "ret" := ref_zero stringT in
    let: ("$a0", "$a1") := Fst (MapGet (struct.loadF Server "lastReplies" (![ptrT] "s")) (struct.loadF conditionalPutArgs "opId" (![ptrT] "args"))) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "ret" <-[stringT] "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
      return: (![stringT] "ret");;;
      do:  #()
    else #());;;
    let: "ret2" := ref_to stringT #(str "") in
    (if: (Fst (MapGet (struct.loadF Server "kvs" (![ptrT] "s")) (struct.loadF conditionalPutArgs "key" (![ptrT] "args")))) = (struct.loadF conditionalPutArgs "expectedVal" (![ptrT] "args"))
    then
      let: "$a0" := struct.loadF conditionalPutArgs "newVal" (![ptrT] "args") in
      do:  MapInsert (struct.loadF Server "kvs" (![ptrT] "s")) (struct.loadF conditionalPutArgs "key" (![ptrT] "args")) "$a0";;;
      let: "$a0" := #(str "ok") in
      do:  "ret2" <-[stringT] "$a0";;;
      do:  #()
    else #());;;
    let: "$a0" := ![stringT] "ret2" in
    do:  MapInsert (struct.loadF Server "lastReplies" (![ptrT] "s")) (struct.loadF conditionalPutArgs "opId" (![ptrT] "args")) "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    return: (![stringT] "ret2");;;
    do:  #().

Definition Server__put: val :=
  rec: "Server__put" "s" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    let: "ok" := ref_zero boolT in
    let: <> := ref_zero stringT in
    let: ("$a0", "$a1") := Fst (MapGet (struct.loadF Server "lastReplies" (![ptrT] "s")) (struct.loadF putArgs "opId" (![ptrT] "args"))) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "$a0";;;
    (if: ![boolT] "ok"
    then
      do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
      return: (#());;;
      do:  #()
    else #());;;
    let: "$a0" := struct.loadF putArgs "val" (![ptrT] "args") in
    do:  MapInsert (struct.loadF Server "kvs" (![ptrT] "s")) (struct.loadF putArgs "key" (![ptrT] "args")) "$a0";;;
    let: "$a0" := #(str "") in
    do:  MapInsert (struct.loadF Server "lastReplies" (![ptrT] "s")) (struct.loadF putArgs "opId" (![ptrT] "args")) "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    do:  #().

Definition Server__getFreshNum: val :=
  rec: "Server__getFreshNum" "s" :=
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    let: "n" := ref_zero uint64T in
    let: "$a0" := struct.loadF Server "nextFreshId" (![ptrT] "s") in
    do:  "n" <-[uint64T] "$a0";;;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF Server "nextFreshId" (![ptrT] "s")) #1 in
    do:  struct.storeF Server "nextFreshId" (![ptrT] "s") "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    return: (![uint64T] "n");;;
    do:  #().

Definition Server__Start: val :=
  rec: "Server__Start" "s" "me" :=
    let: "me" := ref_to uint64T "me" in
    let: "s" := ref_to ptrT "s" in
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := (λ: "enc_args" "enc_reply",
      let: "$a0" := EncodeUint64 (Server__getFreshNum (![ptrT] "s")) in
      do:  (![ptrT] "enc_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") rpcIdGetFreshNum "$a0";;;
    let: "$a0" := (λ: "enc_args" "enc_reply",
      do:  Server__put (![ptrT] "s") (decodePutArgs (![slice.T byteT] "enc_args"));;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") rpcIdPut "$a0";;;
    let: "$a0" := (λ: "enc_args" "enc_reply",
      let: "$a0" := StringToBytes (Server__conditionalPut (![ptrT] "s") (decodeConditionalPutArgs (![slice.T byteT] "enc_args"))) in
      do:  (![ptrT] "enc_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") rpcIdConditionalPut "$a0";;;
    let: "$a0" := (λ: "enc_args" "enc_reply",
      let: "$a0" := StringToBytes (Server__get (![ptrT] "s") (decodeGetArgs (![slice.T byteT] "enc_args"))) in
      do:  (![ptrT] "enc_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") rpcIdGet "$a0";;;
    do:  urpc.Server__Serve (urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers")) (![uint64T] "me");;;
    do:  #().

(* server.go *)

Definition MakeServer: val :=
  rec: "MakeServer" <> :=
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc Server (zero_val (struct.t Server)) in
    do:  "s" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF Server "mu" (![ptrT] "s") "$a0";;;
    let: "$a0" := NewMap stringT stringT #() in
    do:  struct.storeF Server "kvs" (![ptrT] "s") "$a0";;;
    let: "$a0" := NewMap uint64T stringT #() in
    do:  struct.storeF Server "lastReplies" (![ptrT] "s") "$a0";;;
    return: (![ptrT] "s");;;
    do:  #().
