(* autogenerated from github.com/mit-pdos/gokv/tutorial/objectstore/chunk *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.connman.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.trusted__hash.
From Goose Require github_dot_com.mit_dash_pdos.gokv.tutorial.objectstore.dir.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0data.go *)

Definition WriteChunkArgs := struct.decl [
  "WriteId" :: uint64T;
  "Chunk" :: slice.T byteT;
  "Index" :: uint64T
].

Definition MarshalWriteChunkArgs: val :=
  rec: "MarshalWriteChunkArgs" "args" :=
    let: "args" := ref_to (struct.t WriteChunkArgs) "args" in
    do:  Panic "TODO: marshalling";;;
    do:  #().

Definition ParseWriteChunkArgs: val :=
  rec: "ParseWriteChunkArgs" "data" :=
    let: "data" := ref_to (slice.T byteT) "data" in
    do:  Panic "TODO: marshalling";;;
    do:  #().

(* client.go *)

Definition WriteID: ty := uint64T.

Definition WriteChunkId : expr := #1.

Definition GetChunkId : expr := #2.

Definition ClerkPool := struct.decl [
  "cm" :: ptrT
].

Definition ClerkPool__WriteChunk: val :=
  rec: "ClerkPool__WriteChunk" "ck" "addr" "args" :=
    let: "args" := ref_to (struct.t WriteChunkArgs) "args" in
    let: "addr" := ref_to uint64T "addr" in
    let: "ck" := ref_to ptrT "ck" in
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := MarshalWriteChunkArgs (![struct.t WriteChunkArgs] "args") in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF ClerkPool "cm" (![ptrT] "ck")) (![uint64T] "addr") WriteChunkId (![slice.T byteT] "req") (![ptrT] "reply") #100;;;
    do:  #().

Definition ClerkPool__GetChunk: val :=
  rec: "ClerkPool__GetChunk" "ck" "addr" "content_hash" :=
    let: "content_hash" := ref_to stringT "content_hash" in
    let: "addr" := ref_to uint64T "addr" in
    let: "ck" := ref_to ptrT "ck" in
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := StringToBytes (![stringT] "content_hash") in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF ClerkPool "cm" (![ptrT] "ck")) (![uint64T] "addr") GetChunkId (![slice.T byteT] "req") (![ptrT] "reply") #100;;;
    return: (![slice.T byteT] (![ptrT] "reply"));;;
    do:  #().

(* server.go *)

Definition Server := struct.decl [
  "m" :: ptrT;
  "chunks" :: mapT (slice.T byteT);
  "dir" :: ptrT;
  "me" :: uint64T
].

Definition Server__WriteChunk: val :=
  rec: "Server__WriteChunk" "s" "args" :=
    let: "args" := ref_to (struct.t WriteChunkArgs) "args" in
    let: "s" := ref_to ptrT "s" in
    let: "content_hash" := ref_zero stringT in
    let: "$a0" := trusted__hash.Hash (struct.get WriteChunkArgs "Chunk" (![struct.t WriteChunkArgs] "args")) in
    do:  "content_hash" <-[stringT] "$a0";;;
    do:  sync.Mutex__Lock (struct.loadF Server "m" (![ptrT] "s"));;;
    let: "$a0" := struct.get WriteChunkArgs "Chunk" (![struct.t WriteChunkArgs] "args") in
    do:  MapInsert (struct.loadF Server "chunks" (![ptrT] "s")) (![stringT] "content_hash") "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "m" (![ptrT] "s"));;;
    do:  dir.Clerk__RecordChunk (struct.loadF Server "dir" (![ptrT] "s")) (struct.mk dir.RecordChunkArgs [
      "WriteId" ::= struct.get WriteChunkArgs "WriteId" (![struct.t WriteChunkArgs] "args");
      "Server" ::= struct.loadF Server "me" (![ptrT] "s");
      "ContentHash" ::= ![stringT] "content_hash";
      "Index" ::= struct.get WriteChunkArgs "Index" (![struct.t WriteChunkArgs] "args")
    ]);;;
    do:  #().

Definition Server__GetChunk: val :=
  rec: "Server__GetChunk" "s" "content_hash" :=
    let: "content_hash" := ref_to stringT "content_hash" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "m" (![ptrT] "s"));;;
    let: "data" := ref_zero (slice.T byteT) in
    let: "$a0" := Fst (MapGet (struct.loadF Server "chunks" (![ptrT] "s")) (![stringT] "content_hash")) in
    do:  "data" <-[slice.T byteT] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "m" (![ptrT] "s"));;;
    return: (![slice.T byteT] "data");;;
    do:  #().

Definition StartServer: val :=
  rec: "StartServer" "me" "dir_addr" :=
    let: "dir_addr" := ref_to uint64T "dir_addr" in
    let: "me" := ref_to uint64T "me" in
    let: "dir" := ref_zero ptrT in
    let: "$a0" := dir.MakeClerk (![uint64T] "dir_addr") in
    do:  "dir" <-[ptrT] "$a0";;;
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.new Server [
      "m" ::= struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex));
      "chunks" ::= NewMap stringT (slice.T byteT) #();
      "dir" ::= ![ptrT] "dir";
      "me" ::= ![uint64T] "me"
    ] in
    do:  "s" <-[ptrT] "$a0";;;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := (λ: "req" "reply",
      let: "args" := ref_zero (struct.t WriteChunkArgs) in
      let: "$a0" := ParseWriteChunkArgs (![slice.T byteT] "req") in
      do:  "args" <-[struct.t WriteChunkArgs] "$a0";;;
      do:  Server__WriteChunk (![ptrT] "s") (![struct.t WriteChunkArgs] "args");;;
      let: "$a0" := NewSlice byteT #0 in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") WriteChunkId "$a0";;;
    let: "$a0" := (λ: "req" "reply",
      let: "args" := ref_zero stringT in
      let: "$a0" := StringFromBytes (![slice.T byteT] "req") in
      do:  "args" <-[stringT] "$a0";;;
      let: "ret" := ref_zero (slice.T byteT) in
      let: "$a0" := Server__GetChunk (![ptrT] "s") (![stringT] "args") in
      do:  "ret" <-[slice.T byteT] "$a0";;;
      let: "$a0" := ![slice.T byteT] "ret" in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") GetChunkId "$a0";;;
    let: "server" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    do:  "server" <-[ptrT] "$a0";;;
    do:  urpc.Server__Serve (![ptrT] "server") (![uint64T] "me");;;
    do:  #().
