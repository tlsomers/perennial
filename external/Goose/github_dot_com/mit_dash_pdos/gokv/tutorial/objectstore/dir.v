(* autogenerated from github.com/mit-pdos/gokv/tutorial/objectstore/dir *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.reconnectclient.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0data.go *)

Definition PreparedWrite := struct.decl [
  "Id" :: uint64T;
  "ChunkAddrs" :: slice.T uint64T
].

Definition ParsePreparedWrite: val :=
  rec: "ParsePreparedWrite" "data" :=
    let: "data" := ref_to (slice.T byteT) "data" in
    do:  Panic "TODO: marshaling";;;
    do:  #().

Definition MarshalPreparedWrite: val :=
  rec: "MarshalPreparedWrite" "id" :=
    let: "id" := ref_to (struct.t PreparedWrite) "id" in
    do:  Panic "TODO: marshaling";;;
    do:  #().

Definition RecordChunkArgs := struct.decl [
  "WriteId" :: uint64T;
  "Server" :: uint64T;
  "ContentHash" :: stringT;
  "Index" :: uint64T
].

Definition MarshalRecordChunkArgs: val :=
  rec: "MarshalRecordChunkArgs" "args" :=
    let: "args" := ref_to (struct.t RecordChunkArgs) "args" in
    do:  Panic "TODO: marshaling";;;
    do:  #().

Definition ParseRecordChunkArgs: val :=
  rec: "ParseRecordChunkArgs" "data" :=
    let: "data" := ref_to (slice.T byteT) "data" in
    do:  Panic "TODO: marshaling";;;
    do:  #().

Definition FinishWriteArgs := struct.decl [
  "WriteId" :: uint64T;
  "Keyname" :: stringT
].

Definition MarshalFinishWriteArgs: val :=
  rec: "MarshalFinishWriteArgs" "args" :=
    let: "args" := ref_to (struct.t FinishWriteArgs) "args" in
    do:  Panic "TODO: marshaling";;;
    do:  #().

Definition ParseFinishWriteArgs: val :=
  rec: "ParseFinishWriteArgs" "data" :=
    let: "data" := ref_to (slice.T byteT) "data" in
    do:  Panic "TODO: marshaling";;;
    do:  #().

Definition ChunkHandle := struct.decl [
  "Addr" :: uint64T;
  "ContentHash" :: stringT
].

Definition PreparedRead := struct.decl [
  "Handles" :: slice.T (struct.t ChunkHandle)
].

Definition MarshalPreparedRead: val :=
  rec: "MarshalPreparedRead" "v" :=
    let: "v" := ref_to (struct.t PreparedRead) "v" in
    do:  Panic "TODO: marshaling";;;
    do:  #().

Definition ParsePreparedRead: val :=
  rec: "ParsePreparedRead" "data" :=
    let: "data" := ref_to (slice.T byteT) "data" in
    do:  Panic "TODO: marshaling";;;
    do:  #().

(* client.go *)

Definition WriteID: ty := uint64T.

Definition PrepareWriteId : expr := #1.

Definition RecordChunkId : expr := #2.

Definition FinishWriteId : expr := #3.

Definition PrepareReadId : expr := #4.

Definition Clerk := struct.decl [
  "client" :: ptrT
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "addr" :=
    let: "addr" := ref_to uint64T "addr" in
    let: "client" := ref_zero ptrT in
    let: "$a0" := reconnectclient.MakeReconnectingClient (![uint64T] "addr") in
    do:  "client" <-[ptrT] "$a0";;;
    return: (struct.new Clerk [
       "client" ::= ![ptrT] "client"
     ]);;;
    do:  #().

Definition Clerk__PrepareWrite: val :=
  rec: "Clerk__PrepareWrite" "ck" :=
    let: "ck" := ref_to ptrT "ck" in
    let: "empty" := ref_zero (slice.T byteT) in
    let: "$a0" := NewSlice byteT #0 in
    do:  "empty" <-[slice.T byteT] "$a0";;;
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    do:  reconnectclient.ReconnectingClient__Call (struct.loadF Clerk "client" (![ptrT] "ck")) PrepareWriteId (![slice.T byteT] "empty") (![ptrT] "reply") #100;;;
    return: (ParsePreparedWrite (![slice.T byteT] (![ptrT] "reply")));;;
    do:  #().

(* From chunk *)
Definition Clerk__RecordChunk: val :=
  rec: "Clerk__RecordChunk" "ck" "args" :=
    let: "args" := ref_to (struct.t RecordChunkArgs) "args" in
    let: "ck" := ref_to ptrT "ck" in
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := MarshalRecordChunkArgs (![struct.t RecordChunkArgs] "args") in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    do:  reconnectclient.ReconnectingClient__Call (struct.loadF Clerk "client" (![ptrT] "ck")) RecordChunkId (![slice.T byteT] "req") (![ptrT] "reply") #100;;;
    do:  #().

(* From chunk *)
Definition Clerk__FinishWrite: val :=
  rec: "Clerk__FinishWrite" "ck" "args" :=
    let: "args" := ref_to (struct.t FinishWriteArgs) "args" in
    let: "ck" := ref_to ptrT "ck" in
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := MarshalFinishWriteArgs (![struct.t FinishWriteArgs] "args") in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    do:  reconnectclient.ReconnectingClient__Call (struct.loadF Clerk "client" (![ptrT] "ck")) FinishWriteId (![slice.T byteT] "req") (![ptrT] "reply") #100;;;
    do:  #().

Definition Clerk__PrepareRead: val :=
  rec: "Clerk__PrepareRead" "ck" "keyname" :=
    let: "keyname" := ref_to stringT "keyname" in
    let: "ck" := ref_to ptrT "ck" in
    let: "req" := ref_zero (slice.T byteT) in
    let: "$a0" := StringToBytes (![stringT] "keyname") in
    do:  "req" <-[slice.T byteT] "$a0";;;
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    do:  reconnectclient.ReconnectingClient__Call (struct.loadF Clerk "client" (![ptrT] "ck")) PrepareReadId (![slice.T byteT] "req") (![ptrT] "reply") #100;;;
    return: (ParsePreparedRead (![slice.T byteT] (![ptrT] "reply")));;;
    do:  #().

(* server.go *)

Definition PartialValue := struct.decl [
  "servers" :: mapT (struct.t ChunkHandle)
].

Definition Value := struct.decl [
  "servers" :: slice.T (struct.t ChunkHandle)
].

Definition Server := struct.decl [
  "m" :: ptrT;
  "ongoing" :: mapT (struct.t PartialValue);
  "data" :: mapT (struct.t Value);
  "nextWriteId" :: uint64T
].

(* From client *)
Definition Server__PrepareWrite: val :=
  rec: "Server__PrepareWrite" "s" :=
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "m" (![ptrT] "s"));;;
    let: "id" := ref_zero uint64T in
    let: "$a0" := struct.loadF Server "nextWriteId" (![ptrT] "s") in
    do:  "id" <-[uint64T] "$a0";;;
    do:  struct.storeF Server "nextWriteId" (![ptrT] "s") ((struct.loadF Server "nextWriteId" (![ptrT] "s")) + #1);;;
    let: "$a0" := struct.mk PartialValue [
      "servers" ::= NewMap uint64T (struct.t ChunkHandle) #()
    ] in
    do:  MapInsert (struct.loadF Server "ongoing" (![ptrT] "s")) (![uint64T] "id") "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "m" (![ptrT] "s"));;;
    return: (struct.mk PreparedWrite [
       "Id" ::= ![uint64T] "id";
       "ChunkAddrs" ::= NewSlice uint64T #0
     ]);;;
    do:  #().

(* From chunk *)
Definition Server__RecordChunk: val :=
  rec: "Server__RecordChunk" "s" "args" :=
    let: "args" := ref_to (struct.t RecordChunkArgs) "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "m" (![ptrT] "s"));;;
    let: "$a0" := struct.mk ChunkHandle [
      "Addr" ::= struct.get RecordChunkArgs "Server" (![struct.t RecordChunkArgs] "args");
      "ContentHash" ::= struct.get RecordChunkArgs "ContentHash" (![struct.t RecordChunkArgs] "args")
    ] in
    do:  MapInsert (struct.get PartialValue "servers" (Fst (MapGet (struct.loadF Server "ongoing" (![ptrT] "s")) (struct.get RecordChunkArgs "WriteId" (![struct.t RecordChunkArgs] "args"))))) (struct.get RecordChunkArgs "Index" (![struct.t RecordChunkArgs] "args")) "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "m" (![ptrT] "s"));;;
    do:  #().

(* From chunk *)
Definition Server__FinishWrite: val :=
  rec: "Server__FinishWrite" "s" "args" :=
    let: "args" := ref_to (struct.t FinishWriteArgs) "args" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "m" (![ptrT] "s"));;;
    let: "v" := ref_zero (mapT (struct.t ChunkHandle)) in
    let: "$a0" := struct.get PartialValue "servers" (Fst (MapGet (struct.loadF Server "ongoing" (![ptrT] "s")) (struct.get FinishWriteArgs "WriteId" (![struct.t FinishWriteArgs] "args")))) in
    do:  "v" <-[mapT (struct.t ChunkHandle)] "$a0";;;
    let: "numChunks" := ref_zero uint64T in
    let: "$a0" := MapLen (![mapT (struct.t ChunkHandle)] "v") in
    do:  "numChunks" <-[uint64T] "$a0";;;
    let: "servers" := ref_to (slice.T (struct.t ChunkHandle)) (NewSlice (struct.t ChunkHandle) #0) in
    (let: "i" := ref_zero uint64T in
    let: "$a0" := #0 in
    do:  "i" <-[uint64T] "$a0";;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "numChunks")); (λ: <>, do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
    #()) := λ: <>,
      let: "$a0" := SliceAppend (struct.t ChunkHandle) (![slice.T (struct.t ChunkHandle)] "servers") (Fst (MapGet (![mapT (struct.t ChunkHandle)] "v") (![uint64T] "i"))) in
      do:  "servers" <-[slice.T (struct.t ChunkHandle)] "$a0";;;
      do:  #())).

Definition Server__PrepareRead: val :=
  rec: "Server__PrepareRead" "s" "keyname" :=
    let: "keyname" := ref_to stringT "keyname" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "m" (![ptrT] "s"));;;
    let: "servers" := ref_zero (slice.T (struct.t ChunkHandle)) in
    let: "$a0" := struct.get Value "servers" (Fst (MapGet (struct.loadF Server "data" (![ptrT] "s")) (![stringT] "keyname"))) in
    do:  "servers" <-[slice.T (struct.t ChunkHandle)] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "m" (![ptrT] "s"));;;
    return: (struct.mk PreparedRead [
       "Handles" ::= ![slice.T (struct.t ChunkHandle)] "servers"
     ]);;;
    do:  #().

Definition StartServer: val :=
  rec: "StartServer" "me" :=
    let: "me" := ref_to uint64T "me" in
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.new Server [
      "m" ::= struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex));
      "ongoing" ::= NewMap uint64T (struct.t PartialValue) #();
      "data" ::= NewMap stringT (struct.t Value) #();
      "nextWriteId" ::= #1
    ] in
    do:  "s" <-[ptrT] "$a0";;;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := (λ: "_req" "reply",
      let: "ret" := ref_zero (struct.t PreparedWrite) in
      let: "$a0" := Server__PrepareWrite (![ptrT] "s") in
      do:  "ret" <-[struct.t PreparedWrite] "$a0";;;
      let: "$a0" := MarshalPreparedWrite (![struct.t PreparedWrite] "ret") in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") PrepareWriteId "$a0";;;
    let: "$a0" := (λ: "req" "reply",
      let: "args" := ref_zero (struct.t RecordChunkArgs) in
      let: "$a0" := ParseRecordChunkArgs (![slice.T byteT] "req") in
      do:  "args" <-[struct.t RecordChunkArgs] "$a0";;;
      do:  Server__RecordChunk (![ptrT] "s") (![struct.t RecordChunkArgs] "args");;;
      let: "$a0" := NewSlice byteT #0 in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RecordChunkId "$a0";;;
    let: "$a0" := (λ: "req" "reply",
      let: "args" := ref_zero (struct.t FinishWriteArgs) in
      let: "$a0" := ParseFinishWriteArgs (![slice.T byteT] "req") in
      do:  "args" <-[struct.t FinishWriteArgs] "$a0";;;
      do:  Server__FinishWrite (![ptrT] "s") (![struct.t FinishWriteArgs] "args");;;
      let: "$a0" := NewSlice byteT #0 in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") FinishWriteId "$a0";;;
    let: "$a0" := (λ: "req" "reply",
      let: "args" := ref_zero stringT in
      let: "$a0" := StringFromBytes (![slice.T byteT] "req") in
      do:  "args" <-[stringT] "$a0";;;
      let: "ret" := ref_zero (struct.t PreparedRead) in
      let: "$a0" := Server__PrepareRead (![ptrT] "s") (![stringT] "args") in
      do:  "ret" <-[struct.t PreparedRead] "$a0";;;
      let: "$a0" := MarshalPreparedRead (![struct.t PreparedRead] "ret") in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") PrepareReadId "$a0";;;
    let: "server" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    do:  "server" <-[ptrT] "$a0";;;
    do:  urpc.Server__Serve (![ptrT] "server") (![uint64T] "me");;;
    do:  #().
