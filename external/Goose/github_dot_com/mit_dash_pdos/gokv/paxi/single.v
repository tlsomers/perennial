(* autogenerated from github.com/mit-pdos/gokv/paxi/single *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* clerk.go *)

Definition Clerk := struct.decl [
  "cl" :: ptrT
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "host" :=
    let: "host" := ref_to uint64T "host" in
    return: (struct.new Clerk [
       "cl" ::= urpc.MakeClient (![uint64T] "host")
     ]);;;
    do:  #().

Definition Clerk__Prepare: val :=
  rec: "Clerk__Prepare" "ck" "pn" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "pn" := ref_to uint64T "pn" in
    let: "ck" := ref_to ptrT "ck" in
    do:  #().

Definition Clerk__Propose: val :=
  rec: "Clerk__Propose" "ck" "Pn" "Val" :=
    let: "Val" := ref_to uint64T "Val" in
    let: "Pn" := ref_to uint64T "Pn" in
    let: "ck" := ref_to ptrT "ck" in
    return: (#false);;;
    do:  #().

(* common.go *)

Definition ValType: ty := uint64T.

Definition PREPARE : expr := #1.

Definition PROPOSE : expr := #2.

(* singleslot.go *)

Definition Replica := struct.decl [
  "mu" :: ptrT;
  "promisedPN" :: uint64T;
  "acceptedPN" :: uint64T;
  "acceptedVal" :: uint64T;
  "committedVal" :: uint64T;
  "peers" :: slice.T ptrT
].

Definition PrepareReply := struct.decl [
  "Success" :: boolT;
  "Val" :: uint64T;
  "Pn" :: uint64T
].

Definition Replica__PrepareRPC: val :=
  rec: "Replica__PrepareRPC" "r" "pn" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "pn" := ref_to uint64T "pn" in
    let: "r" := ref_to ptrT "r" in
    do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    (if: (![uint64T] "pn") > (struct.loadF Replica "promisedPN" (![ptrT] "r"))
    then
      let: "$a0" := ![uint64T] "pn" in
      do:  struct.storeF Replica "promisedPN" (![ptrT] "r") "$a0";;;
      let: "$a0" := struct.loadF Replica "acceptedPN" (![ptrT] "r") in
      do:  struct.storeF PrepareReply "Pn" (![ptrT] "reply") "$a0";;;
      let: "$a0" := struct.loadF Replica "acceptedVal" (![ptrT] "r") in
      do:  struct.storeF PrepareReply "Val" (![ptrT] "reply") "$a0";;;
      let: "$a0" := #true in
      do:  struct.storeF PrepareReply "Success" (![ptrT] "reply") "$a0";;;
      do:  #()
    else
      let: "$a0" := #false in
      do:  struct.storeF PrepareReply "Success" (![ptrT] "reply") "$a0";;;
      let: "$a0" := struct.loadF Replica "promisedPN" (![ptrT] "r") in
      do:  struct.storeF PrepareReply "Pn" (![ptrT] "reply") "$a0";;;
      do:  #());;;
    do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    do:  #().

Definition ProposeArgs := struct.decl [
  "Pn" :: uint64T;
  "Val" :: uint64T
].

Definition Replica__ProposeRPC: val :=
  rec: "Replica__ProposeRPC" "r" "pn" "val" :=
    let: "val" := ref_to uint64T "val" in
    let: "pn" := ref_to uint64T "pn" in
    let: "r" := ref_to ptrT "r" in
    do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    (if: ((![uint64T] "pn") ≥ (struct.loadF Replica "promisedPN" (![ptrT] "r"))) && ((![uint64T] "pn") ≥ (struct.loadF Replica "acceptedPN" (![ptrT] "r")))
    then
      let: "$a0" := ![uint64T] "val" in
      do:  struct.storeF Replica "acceptedVal" (![ptrT] "r") "$a0";;;
      let: "$a0" := ![uint64T] "pn" in
      do:  struct.storeF Replica "acceptedPN" (![ptrT] "r") "$a0";;;
      do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      return: (#true);;;
      do:  #()
    else
      do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      return: (#false);;;
      do:  #());;;
    do:  #().

(* returns true iff there was an error *)
Definition Replica__TryDecide: val :=
  rec: "Replica__TryDecide" "r" "v" "outv" :=
    let: "outv" := ref_to ptrT "outv" in
    let: "v" := ref_to uint64T "v" in
    let: "r" := ref_to ptrT "r" in
    do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    let: "pn" := ref_zero uint64T in
    let: "$a0" := (struct.loadF Replica "promisedPN" (![ptrT] "r")) + #1 in
    do:  "pn" <-[uint64T] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    let: "numPrepared" := ref (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "numPrepared" <-[uint64T] "$a0";;;
    let: "highestPn" := ref (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "highestPn" <-[uint64T] "$a0";;;
    let: "highestVal" := ref (zero_val uint64T) in
    let: "$a0" := ![uint64T] "v" in
    do:  "highestVal" <-[uint64T] "$a0";;;
    let: "mu" := ref_zero ptrT in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  "mu" <-[ptrT] "$a0";;;
    do:  ForSlice ptrT <> "peer" (struct.loadF Replica "peers" (![ptrT] "r"))
      (let: "local_peer" := ref_zero ptrT in
      let: "$a0" := ![ptrT] "peer" in
      do:  "local_peer" <-[ptrT] "$a0";;;
      do:  Fork (let: "reply_ptr" := ref_zero ptrT in
            let: "$a0" := struct.alloc PrepareReply (zero_val (struct.t PrepareReply)) in
            do:  "reply_ptr" <-[ptrT] "$a0";;;
            do:  Clerk__Prepare (![ptrT] "local_peer") (![uint64T] "pn") (![ptrT] "reply_ptr");;;
            (if: struct.loadF PrepareReply "Success" (![ptrT] "reply_ptr")
            then
              do:  sync.Mutex__Lock (![ptrT] "mu");;;
              let: "$a0" := (![uint64T] "numPrepared") + #1 in
              do:  "numPrepared" <-[uint64T] "$a0";;;
              (if: (struct.loadF PrepareReply "Pn" (![ptrT] "reply_ptr")) > (![uint64T] "highestPn")
              then
                let: "$a0" := struct.loadF PrepareReply "Val" (![ptrT] "reply_ptr") in
                do:  "highestVal" <-[uint64T] "$a0";;;
                let: "$a0" := struct.loadF PrepareReply "Pn" (![ptrT] "reply_ptr") in
                do:  "highestPn" <-[uint64T] "$a0";;;
                do:  #()
              else #());;;
              do:  sync.Mutex__Unlock (![ptrT] "mu");;;
              do:  #()
            else #());;;
            do:  #());;;
      do:  #());;;
    do:  sync.Mutex__Lock (![ptrT] "mu");;;
    let: "n" := ref_zero uint64T in
    let: "$a0" := ![uint64T] "numPrepared" in
    do:  "n" <-[uint64T] "$a0";;;
    let: "proposeVal" := ref_zero uint64T in
    let: "$a0" := ![uint64T] "highestVal" in
    do:  "proposeVal" <-[uint64T] "$a0";;;
    do:  sync.Mutex__Unlock (![ptrT] "mu");;;
    (if: (#2 * (![uint64T] "n")) > (slice.len (struct.loadF Replica "peers" (![ptrT] "r")))
    then
      let: "mu2" := ref_zero ptrT in
      let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
      do:  "mu2" <-[ptrT] "$a0";;;
      let: "numAccepted" := ref (zero_val uint64T) in
      let: "$a0" := #0 in
      do:  "numAccepted" <-[uint64T] "$a0";;;
      do:  ForSlice ptrT <> "peer" (struct.loadF Replica "peers" (![ptrT] "r"))
        (let: "local_peer" := ref_zero ptrT in
        let: "$a0" := ![ptrT] "peer" in
        do:  "local_peer" <-[ptrT] "$a0";;;
        do:  Fork (let: "r" := ref_zero boolT in
              let: "$a0" := Clerk__Propose (![ptrT] "local_peer") (![uint64T] "pn") (![uint64T] "proposeVal") in
              do:  "r" <-[boolT] "$a0";;;
              (if: ![boolT] "r"
              then
                do:  sync.Mutex__Lock (![ptrT] "mu2");;;
                let: "$a0" := (![uint64T] "numAccepted") + #1 in
                do:  "numAccepted" <-[uint64T] "$a0";;;
                do:  sync.Mutex__Unlock (![ptrT] "mu2");;;
                do:  #()
              else #());;;
              do:  #());;;
        do:  #());;;
      do:  sync.Mutex__Lock (![ptrT] "mu2");;;
      let: "n" := ref_zero uint64T in
      let: "$a0" := ![uint64T] "numAccepted" in
      do:  "n" <-[uint64T] "$a0";;;
      do:  sync.Mutex__Unlock (![ptrT] "mu2");;;
      (if: (#2 * (![uint64T] "n")) > (slice.len (struct.loadF Replica "peers" (![ptrT] "r")))
      then
        let: "$a0" := ![uint64T] "proposeVal" in
        do:  (![ptrT] "outv") <-[uint64T] "$a0";;;
        return: (#false);;;
        do:  #()
      else
        return: (#true);;;
        do:  #());;;
      do:  #()
    else
      return: (#true);;;
      do:  #());;;
    do:  #().
