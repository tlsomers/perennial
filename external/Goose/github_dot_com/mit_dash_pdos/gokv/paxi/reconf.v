(* autogenerated from github.com/mit-pdos/gokv/paxi/reconf *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.connman.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.tchajed.goose.machine.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require log.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_quorums.go *)

Definition Config := struct.decl [
  "Members" :: slice.T uint64T;
  "NextMembers" :: slice.T uint64T
].

(* Returns some integer i with the property that
   there exists W such that W contains a majority of members and of nextMembers,
   and every node n in W has indices[n] >= i.
   Even more precisely, it returns the largest such i. *)
Definition GetHighestIndexOfQuorum: val :=
  rec: "GetHighestIndexOfQuorum" "config" "indices" :=
    let: "indices" := ref_to (mapT uint64T) "indices" in
    let: "config" := ref_to ptrT "config" in
    let: "orderedIndices" := ref_to (slice.T uint64T) (NewSlice uint64T (((slice.len (struct.loadF Config "Members" (![ptrT] "config"))) + #1) `quot` #2)) in
    do:  ForSlice uint64T <> "m" (struct.loadF Config "Members" (![ptrT] "config"))
      (let: "indexToInsert" := ref_zero uint64T in
      let: "$a0" := Fst (MapGet (![mapT uint64T] "indices") (![uint64T] "m")) in
      do:  "indexToInsert" <-[uint64T] "$a0";;;
      do:  ForSlice uint64T "i" <> (![slice.T uint64T] "orderedIndices")
        ((if: (SliceGet uint64T (![slice.T uint64T] "orderedIndices") (![intT] "i")) > (![uint64T] "indexToInsert")
        then
          (let: "j" := ref_zero uint64T in
          let: "$a0" := ![intT] "i" in
          do:  "j" <-[uint64T] "$a0";;;
          (for: (λ: <>, (![uint64T] "j") < ((slice.len (![slice.T uint64T] "orderedIndices")) - #1)); (λ: <>, do:  "j" <-[uint64T] ((![uint64T] "j") + #1);;;
          #()) := λ: <>,
            let: "$a0" := SliceGet uint64T (![slice.T uint64T] "orderedIndices") (![intT] "i") in
            do:  SliceSet uint64T (![slice.T uint64T] "orderedIndices") ((![intT] "i") + #1) "$a0";;;
            do:  #()))
        else #());;;
        do:  #());;;
      do:  #());;;
    let: "ret" := ref_zero uint64T in
    let: "$a0" := SliceGet uint64T (![slice.T uint64T] "orderedIndices") ((slice.len (struct.loadF Config "Members" (![ptrT] "config"))) - #1) in
    do:  "ret" <-[uint64T] "$a0";;;
    (if: (slice.len (struct.loadF Config "NextMembers" (![ptrT] "config"))) = #0
    then
      return: (![uint64T] "ret");;;
      do:  #()
    else #());;;
    return: (#0);;;
    do:  #().

(* Returns true iff w is a (write) quorum for the config `config`. *)
Definition IsQuorum: val :=
  rec: "IsQuorum" "config" "w" :=
    let: "w" := ref_to (mapT boolT) "w" in
    let: "config" := ref_to ptrT "config" in
    let: "num" := ref (zero_val uint64T) in
    do:  ForSlice uint64T <> "member" (struct.loadF Config "Members" (![ptrT] "config"))
      ((if: Fst (MapGet (![mapT boolT] "w") (![uint64T] "member"))
      then
        do:  "num" <-[uint64T] ((![uint64T] "num") + #1);;;
        do:  #()
      else #());;;
      do:  #());;;
    (if: (#2 * (![uint64T] "num")) ≤ (slice.len (struct.loadF Config "Members" (![ptrT] "config")))
    then
      return: (#false);;;
      do:  #()
    else #());;;
    (if: (slice.len (struct.loadF Config "NextMembers" (![ptrT] "config"))) = #0
    then
      return: (#true);;;
      do:  #()
    else #());;;
    let: "$a0" := #0 in
    do:  "num" <-[uint64T] "$a0";;;
    do:  ForSlice uint64T <> "member" (struct.loadF Config "NextMembers" (![ptrT] "config"))
      ((if: Fst (MapGet (![mapT boolT] "w") (![uint64T] "member"))
      then
        do:  "num" <-[uint64T] ((![uint64T] "num") + #1);;;
        do:  #()
      else #());;;
      do:  #());;;
    (if: (#2 * (![uint64T] "num")) ≤ (slice.len (struct.loadF Config "NextMembers" (![ptrT] "config")))
    then
      return: (#false);;;
      do:  #()
    else #());;;
    return: (#true);;;
    do:  #().

Definition Config__ForEachMember: val :=
  rec: "Config__ForEachMember" "c" "f" :=
    let: "f" := ref_to (uint64T -> unitT)%ht "f" in
    let: "c" := ref_to ptrT "c" in
    do:  ForSlice uint64T <> "member" (struct.loadF Config "Members" (![ptrT] "c"))
      (do:  (![(arrowT unitT unitT)] "f") (![uint64T] "member");;;
      do:  #());;;
    do:  ForSlice uint64T <> "member" (struct.loadF Config "NextMembers" (![ptrT] "c"))
      (do:  (![(arrowT unitT unitT)] "f") (![uint64T] "member");;;
      do:  #());;;
    do:  #().

Definition Config__Contains: val :=
  rec: "Config__Contains" "c" "m" :=
    let: "m" := ref_to uint64T "m" in
    let: "c" := ref_to ptrT "c" in
    let: "ret" := ref_to boolT #false in
    do:  ForSlice uint64T <> "member" (struct.loadF Config "Members" (![ptrT] "c"))
      ((if: (![uint64T] "member") = (![uint64T] "m")
      then
        let: "$a0" := #true in
        do:  "ret" <-[boolT] "$a0";;;
        do:  #()
      else #());;;
      do:  #());;;
    do:  ForSlice uint64T <> "member" (struct.loadF Config "NextMembers" (![ptrT] "c"))
      ((if: (![uint64T] "member") = (![uint64T] "m")
      then
        let: "$a0" := #true in
        do:  "ret" <-[boolT] "$a0";;;
        do:  #()
      else #());;;
      do:  #());;;
    return: (![boolT] "ret");;;
    do:  #().

(* 1_marshal.go *)

Definition EncConfig: val :=
  rec: "EncConfig" "pre" "conf" :=
    let: "conf" := ref_to ptrT "conf" in
    let: "pre" := ref_to (slice.T byteT) "pre" in
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "pre") in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (slice.len (struct.loadF Config "Members" (![ptrT] "conf"))) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (slice.len (struct.loadF Config "NextMembers" (![ptrT] "conf"))) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    do:  ForSlice uint64T <> "member" (struct.loadF Config "Members" (![ptrT] "conf"))
      (let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (![uint64T] "member") in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      do:  #());;;
    do:  ForSlice uint64T <> "member" (struct.loadF Config "NextMembers" (![ptrT] "conf"))
      (let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (![uint64T] "member") in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      do:  #());;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition DecConfig: val :=
  rec: "DecConfig" "encoded" :=
    let: "encoded" := ref_to (slice.T byteT) "encoded" in
    let: "dec" := ref_to (slice.T byteT) (![slice.T byteT] "encoded") in
    let: "conf" := ref_zero ptrT in
    let: "$a0" := struct.alloc Config (zero_val (struct.t Config)) in
    do:  "conf" <-[ptrT] "$a0";;;
    let: "numMembers" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  "numMembers" <-[uint64T] "$a0";;;
    let: "numNextMembers" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  "numNextMembers" <-[uint64T] "$a0";;;
    let: "$a0" := NewSlice uint64T (![uint64T] "numMembers") in
    do:  struct.storeF Config "Members" (![ptrT] "conf") "$a0";;;
    let: "$a0" := NewSlice uint64T (![uint64T] "numNextMembers") in
    do:  struct.storeF Config "NextMembers" (![ptrT] "conf") "$a0";;;
    do:  ForSlice uint64T "i" <> (struct.loadF Config "Members" (![ptrT] "conf"))
      (let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
      do:  "dec" <-[slice.T byteT] "$a1";;;
      do:  SliceSet uint64T (struct.loadF Config "Members" (![ptrT] "conf")) (![intT] "i") "$a0";;;
      do:  #());;;
    do:  ForSlice uint64T "i" <> (struct.loadF Config "NextMembers" (![ptrT] "conf"))
      (let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
      do:  "dec" <-[slice.T byteT] "$a1";;;
      do:  SliceSet uint64T (struct.loadF Config "Members" (![ptrT] "conf")) (![intT] "i") "$a0";;;
      do:  #());;;
    return: (![ptrT] "conf", ![slice.T byteT] "dec");;;
    do:  #().

Definition MonotonicValue := struct.decl [
  "version" :: uint64T;
  "val" :: slice.T byteT;
  "conf" :: ptrT
].

Definition EncMonotonicValue: val :=
  rec: "EncMonotonicValue" "pre" "mval" :=
    let: "mval" := ref_to ptrT "mval" in
    let: "pre" := ref_to (slice.T byteT) "pre" in
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "pre") in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF MonotonicValue "version" (![ptrT] "mval")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (slice.len (struct.loadF MonotonicValue "val" (![ptrT] "mval"))) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF MonotonicValue "val" (![ptrT] "mval")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := EncConfig (![slice.T byteT] "enc") (struct.loadF MonotonicValue "conf" (![ptrT] "mval")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition DecMonotonicValue: val :=
  rec: "DecMonotonicValue" "encoded" :=
    let: "encoded" := ref_to (slice.T byteT) "encoded" in
    let: "mval" := ref_zero ptrT in
    let: "$a0" := struct.alloc MonotonicValue (zero_val (struct.t MonotonicValue)) in
    do:  "mval" <-[ptrT] "$a0";;;
    let: "dec" := ref_to (slice.T byteT) (![slice.T byteT] "encoded") in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF MonotonicValue "version" (![ptrT] "mval") "$a0";;;
    let: "valLen" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  "valLen" <-[uint64T] "$a0";;;
    let: "$a0" := SliceTake (![slice.T byteT] "dec") (![uint64T] "valLen") in
    do:  struct.storeF MonotonicValue "val" (![ptrT] "mval") "$a0";;;
    let: "$a0" := SliceSkip byteT (![slice.T byteT] "dec") (![uint64T] "valLen") in
    do:  "dec" <-[slice.T byteT] "$a0";;;
    let: ("$a0", "$a1") := DecConfig (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF MonotonicValue "conf" (![ptrT] "mval") "$a0";;;
    return: (![ptrT] "mval", ![slice.T byteT] "dec");;;
    do:  #().

Definition PrepareReply := struct.decl [
  "Err" :: uint64T;
  "Term" :: uint64T;
  "Val" :: ptrT
].

Definition EncPrepareReply: val :=
  rec: "EncPrepareReply" "pre" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "pre" := ref_to (slice.T byteT) "pre" in
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "pre") in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF PrepareReply "Err" (![ptrT] "reply")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF PrepareReply "Term" (![ptrT] "reply")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := EncMonotonicValue (![slice.T byteT] "enc") (struct.loadF PrepareReply "Val" (![ptrT] "reply")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition DecPrepareReply: val :=
  rec: "DecPrepareReply" "encoded" :=
    let: "encoded" := ref_to (slice.T byteT) "encoded" in
    let: "dec" := ref_to (slice.T byteT) (![slice.T byteT] "encoded") in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := struct.alloc PrepareReply (zero_val (struct.t PrepareReply)) in
    do:  "reply" <-[ptrT] "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF PrepareReply "Err" (![ptrT] "reply") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF PrepareReply "Term" (![ptrT] "reply") "$a0";;;
    let: ("$a0", "$a1") := DecMonotonicValue (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF PrepareReply "Val" (![ptrT] "reply") "$a0";;;
    return: (![ptrT] "reply");;;
    do:  #().

Definition ProposeArgs := struct.decl [
  "Term" :: uint64T;
  "Val" :: ptrT
].

Definition EncProposeArgs: val :=
  rec: "EncProposeArgs" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "enc" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF ProposeArgs "Term" (![ptrT] "args")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := EncMonotonicValue (![slice.T byteT] "enc") (struct.loadF ProposeArgs "Val" (![ptrT] "args")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition DecProposeArgs: val :=
  rec: "DecProposeArgs" "encoded" :=
    let: "encoded" := ref_to (slice.T byteT) "encoded" in
    let: "dec" := ref_to (slice.T byteT) (![slice.T byteT] "encoded") in
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.alloc ProposeArgs (zero_val (struct.t ProposeArgs)) in
    do:  "args" <-[ptrT] "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF ProposeArgs "Term" (![ptrT] "args") "$a0";;;
    let: ("$a0", "$a1") := DecMonotonicValue (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF ProposeArgs "Val" (![ptrT] "args") "$a0";;;
    return: (![ptrT] "args", ![slice.T byteT] "dec");;;
    do:  #().

Definition TryCommitReply := struct.decl [
  "err" :: uint64T;
  "version" :: uint64T
].

Definition EncMembers: val :=
  rec: "EncMembers" "members" :=
    let: "members" := ref_to (slice.T uint64T) "members" in
    let: "enc" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (slice.len (![slice.T uint64T] "members")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    do:  ForSlice uint64T <> "member" (![slice.T uint64T] "members")
      (let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (![uint64T] "member") in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      do:  #());;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition DecMembers: val :=
  rec: "DecMembers" "encoded" :=
    let: "encoded" := ref_to (slice.T byteT) "encoded" in
    let: "dec" := ref_to (slice.T byteT) (![slice.T byteT] "encoded") in
    let: "numMembers" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
    do:  "dec" <-[slice.T byteT] "$a1";;;
    do:  "numMembers" <-[uint64T] "$a0";;;
    let: "members" := ref_zero (slice.T uint64T) in
    let: "$a0" := NewSlice uint64T (![uint64T] "numMembers") in
    do:  "members" <-[slice.T uint64T] "$a0";;;
    do:  ForSlice uint64T "i" <> (![slice.T uint64T] "members")
      (let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "dec") in
      do:  "dec" <-[slice.T byteT] "$a1";;;
      do:  SliceSet uint64T (![slice.T uint64T] "members") (![intT] "i") "$a0";;;
      do:  #());;;
    return: (![slice.T uint64T] "members", ![slice.T byteT] "dec");;;
    do:  #().

(* client.go *)

Definition ClerkPool := struct.decl [
  "cl" :: ptrT
].

Definition RPC_PREPARE : expr := #0.

Definition RPC_PROPOSE : expr := #1.

Definition RPC_TRY_COMMIT_VAL : expr := #2.

Definition RPC_TRY_CONFIG_CHANGE : expr := #3.

Definition MakeClerkPool: val :=
  rec: "MakeClerkPool" <> :=
    return: (struct.new ClerkPool [
       "cl" ::= connman.MakeConnMan #()
     ]);;;
    do:  #().

Definition ClerkPool__PrepareRPC: val :=
  rec: "ClerkPool__PrepareRPC" "ck" "srv" "newTerm" "reply_ptr" :=
    let: "reply_ptr" := ref_to ptrT "reply_ptr" in
    let: "newTerm" := ref_to uint64T "newTerm" in
    let: "srv" := ref_to uint64T "srv" in
    let: "ck" := ref_to ptrT "ck" in
    let: "raw_reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "raw_reply" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF ClerkPool "cl" (![ptrT] "ck")) (![uint64T] "srv") RPC_PREPARE (marshal.WriteInt (NewSlice byteT #0) (![uint64T] "newTerm")) (![ptrT] "raw_reply") #10;;;
    let: "$a0" := struct.load PrepareReply (DecPrepareReply (![slice.T byteT] (![ptrT] "raw_reply"))) in
    do:  struct.store PrepareReply (![ptrT] "reply_ptr") "$a0";;;
    do:  #().

Definition ClerkPool__ProposeRPC: val :=
  rec: "ClerkPool__ProposeRPC" "ck" "srv" "term" "val" :=
    let: "val" := ref_to ptrT "val" in
    let: "term" := ref_to uint64T "term" in
    let: "srv" := ref_to uint64T "srv" in
    let: "ck" := ref_to ptrT "ck" in
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.new ProposeArgs [
      "Term" ::= ![uint64T] "term";
      "Val" ::= ![ptrT] "val"
    ] in
    do:  "args" <-[ptrT] "$a0";;;
    let: "raw_reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "raw_reply" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF ClerkPool "cl" (![ptrT] "ck")) (![uint64T] "srv") RPC_PROPOSE (EncProposeArgs (![ptrT] "args")) (![ptrT] "raw_reply") #10;;;
    let: <> := ref_zero (slice.T byteT) in
    let: "err" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] (![ptrT] "raw_reply")) in
    do:  "$a1";;;
    do:  "err" <-[uint64T] "$a0";;;
    return: ((![uint64T] "err") = #0);;;
    do:  #().

Definition ClerkPool__TryCommitVal: val :=
  rec: "ClerkPool__TryCommitVal" "ck" "srv" "v" :=
    let: "v" := ref_to (slice.T byteT) "v" in
    let: "srv" := ref_to uint64T "srv" in
    let: "ck" := ref_to ptrT "ck" in
    let: "raw_reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "raw_reply" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF ClerkPool "cl" (![ptrT] "ck")) (![uint64T] "srv") RPC_TRY_COMMIT_VAL (![slice.T byteT] "v") (![ptrT] "raw_reply") #1000;;;
    let: <> := ref_zero (slice.T byteT) in
    let: "err" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] (![ptrT] "raw_reply")) in
    do:  "$a1";;;
    do:  "err" <-[uint64T] "$a0";;;
    return: ((![uint64T] "err") = #0);;;
    do:  #().

Definition ClerkPool__TryConfigChange: val :=
  rec: "ClerkPool__TryConfigChange" "ck" "srv" "newMembers" :=
    let: "newMembers" := ref_to (slice.T uint64T) "newMembers" in
    let: "srv" := ref_to uint64T "srv" in
    let: "ck" := ref_to ptrT "ck" in
    let: "raw_args" := ref_zero (slice.T byteT) in
    let: "$a0" := EncMembers (![slice.T uint64T] "newMembers") in
    do:  "raw_args" <-[slice.T byteT] "$a0";;;
    let: "raw_reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "raw_reply" <-[ptrT] "$a0";;;
    do:  connman.ConnMan__CallAtLeastOnce (struct.loadF ClerkPool "cl" (![ptrT] "ck")) (![uint64T] "srv") RPC_TRY_CONFIG_CHANGE (![slice.T byteT] "raw_args") (![ptrT] "raw_reply") #50;;;
    let: <> := ref_zero (slice.T byteT) in
    let: "err" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] (![ptrT] "raw_reply")) in
    do:  "$a1";;;
    do:  "err" <-[uint64T] "$a0";;;
    return: ((![uint64T] "err") = #0);;;
    do:  #().

(* server.go *)

Definition MonotonicValue__GreaterThan: val :=
  rec: "MonotonicValue__GreaterThan" "lhs" "rhs" :=
    let: "rhs" := ref_to ptrT "rhs" in
    let: "lhs" := ref_to ptrT "lhs" in
    return: ((struct.loadF MonotonicValue "version" (![ptrT] "lhs")) > (struct.loadF MonotonicValue "version" (![ptrT] "rhs")));;;
    do:  #().

Definition Replica := struct.decl [
  "mu" :: ptrT;
  "promisedTerm" :: uint64T;
  "acceptedTerm" :: uint64T;
  "acceptedMVal" :: ptrT;
  "clerkPool" :: ptrT;
  "isLeader" :: boolT
].

Definition ENone : expr := #0.

Definition ETermStale : expr := #1.

Definition ENotLeader : expr := #2.

Definition EQuorumFailed : expr := #3.

Definition Replica__PrepareRPC: val :=
  rec: "Replica__PrepareRPC" "r" "term" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "term" := ref_to uint64T "term" in
    let: "r" := ref_to ptrT "r" in
    do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    (if: (![uint64T] "term") > (struct.loadF Replica "promisedTerm" (![ptrT] "r"))
    then
      let: "$a0" := ![uint64T] "term" in
      do:  struct.storeF Replica "promisedTerm" (![ptrT] "r") "$a0";;;
      let: "$a0" := struct.loadF Replica "acceptedTerm" (![ptrT] "r") in
      do:  struct.storeF PrepareReply "Term" (![ptrT] "reply") "$a0";;;
      let: "$a0" := struct.loadF Replica "acceptedMVal" (![ptrT] "r") in
      do:  struct.storeF PrepareReply "Val" (![ptrT] "reply") "$a0";;;
      let: "$a0" := ENone in
      do:  struct.storeF PrepareReply "Err" (![ptrT] "reply") "$a0";;;
      do:  #()
    else
      let: "$a0" := ETermStale in
      do:  struct.storeF PrepareReply "Err" (![ptrT] "reply") "$a0";;;
      let: "$a0" := struct.alloc MonotonicValue (zero_val (struct.t MonotonicValue)) in
      do:  struct.storeF PrepareReply "Val" (![ptrT] "reply") "$a0";;;
      let: "$a0" := struct.alloc Config (zero_val (struct.t Config)) in
      do:  struct.storeF MonotonicValue "conf" (struct.loadF PrepareReply "Val" (![ptrT] "reply")) "$a0";;;
      let: "$a0" := struct.loadF Replica "promisedTerm" (![ptrT] "r") in
      do:  struct.storeF PrepareReply "Term" (![ptrT] "reply") "$a0";;;
      do:  #());;;
    do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    do:  #().

Definition Replica__ProposeRPC: val :=
  rec: "Replica__ProposeRPC" "r" "term" "v" :=
    let: "v" := ref_to ptrT "v" in
    let: "term" := ref_to uint64T "term" in
    let: "r" := ref_to ptrT "r" in
    do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    (if: (![uint64T] "term") ≥ (struct.loadF Replica "promisedTerm" (![ptrT] "r"))
    then
      let: "$a0" := ![uint64T] "term" in
      do:  struct.storeF Replica "promisedTerm" (![ptrT] "r") "$a0";;;
      let: "$a0" := ![uint64T] "term" in
      do:  struct.storeF Replica "acceptedTerm" (![ptrT] "r") "$a0";;;
      (if: MonotonicValue__GreaterThan (![ptrT] "v") (struct.loadF Replica "acceptedMVal" (![ptrT] "r"))
      then
        let: "$a0" := ![ptrT] "v" in
        do:  struct.storeF Replica "acceptedMVal" (![ptrT] "r") "$a0";;;
        do:  #()
      else #());;;
      do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      return: (ENone);;;
      do:  #()
    else
      do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      return: (ETermStale);;;
      do:  #());;;
    do:  #().

Definition Replica__TryBecomeLeader: val :=
  rec: "Replica__TryBecomeLeader" "r" :=
    let: "r" := ref_to ptrT "r" in
    do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    let: "newTerm" := ref_zero uint64T in
    let: "$a0" := (struct.loadF Replica "promisedTerm" (![ptrT] "r")) + #1 in
    do:  "newTerm" <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "newTerm" in
    do:  struct.storeF Replica "promisedTerm" (![ptrT] "r") "$a0";;;
    let: "highestTerm" := ref (zero_val uint64T) in
    let: "$a0" := #0 in
    do:  "highestTerm" <-[uint64T] "$a0";;;
    let: "highestVal" := ref (zero_val ptrT) in
    let: "$a0" := struct.loadF Replica "acceptedMVal" (![ptrT] "r") in
    do:  "highestVal" <-[ptrT] "$a0";;;
    let: "conf" := ref_zero ptrT in
    let: "$a0" := struct.loadF MonotonicValue "conf" (struct.loadF Replica "acceptedMVal" (![ptrT] "r")) in
    do:  "conf" <-[ptrT] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    let: "mu" := ref_zero ptrT in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  "mu" <-[ptrT] "$a0";;;
    let: "prepared" := ref_zero (mapT boolT) in
    let: "$a0" := NewMap uint64T boolT #() in
    do:  "prepared" <-[mapT boolT] "$a0";;;
    do:  Config__ForEachMember (![ptrT] "conf") (λ: "addr",
      do:  Fork (let: "reply_ptr" := ref_zero ptrT in
            let: "$a0" := struct.alloc PrepareReply (zero_val (struct.t PrepareReply)) in
            do:  "reply_ptr" <-[ptrT] "$a0";;;
            do:  ClerkPool__PrepareRPC (struct.loadF Replica "clerkPool" (![ptrT] "r")) (![uint64T] "addr") (![uint64T] "newTerm") (![ptrT] "reply_ptr");;;
            (if: (struct.loadF PrepareReply "Err" (![ptrT] "reply_ptr")) = ENone
            then
              do:  sync.Mutex__Lock (![ptrT] "mu");;;
              let: "$a0" := #true in
              do:  MapInsert (![mapT boolT] "prepared") (![uint64T] "addr") "$a0";;;
              (if: (struct.loadF PrepareReply "Term" (![ptrT] "reply_ptr")) > (![uint64T] "highestTerm")
              then
                let: "$a0" := struct.loadF PrepareReply "Val" (![ptrT] "reply_ptr") in
                do:  "highestVal" <-[ptrT] "$a0";;;
                do:  #()
              else
                (if: (struct.loadF PrepareReply "Term" (![ptrT] "reply_ptr")) = (![uint64T] "highestTerm")
                then
                  (if: MonotonicValue__GreaterThan (![ptrT] "highestVal") (struct.loadF PrepareReply "Val" (![ptrT] "reply_ptr"))
                  then
                    let: "$a0" := struct.loadF PrepareReply "Val" (![ptrT] "reply_ptr") in
                    do:  "highestVal" <-[ptrT] "$a0";;;
                    do:  #()
                  else #());;;
                  do:  #()
                else #());;;
                #());;;
              do:  sync.Mutex__Unlock (![ptrT] "mu");;;
              do:  #()
            else do:  #());;;
            do:  #());;;
      do:  #()
      );;;
    do:  machine.Sleep (#50 * #1000000);;;
    do:  sync.Mutex__Lock (![ptrT] "mu");;;
    (if: IsQuorum (struct.loadF MonotonicValue "conf" (![ptrT] "highestVal")) (![mapT boolT] "prepared")
    then
      do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      (if: (struct.loadF Replica "promisedTerm" (![ptrT] "r")) = (![uint64T] "newTerm")
      then
        let: "$a0" := ![ptrT] "highestVal" in
        do:  struct.storeF Replica "acceptedMVal" (![ptrT] "r") "$a0";;;
        let: "$a0" := #true in
        do:  struct.storeF Replica "isLeader" (![ptrT] "r") "$a0";;;
        do:  #()
      else #());;;
      do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      do:  sync.Mutex__Unlock (![ptrT] "mu");;;
      return: (#true);;;
      do:  #()
    else #());;;
    do:  sync.Mutex__Unlock (![ptrT] "mu");;;
    return: (#false);;;
    do:  #().

(* Returns true iff there was an error;
   The error is either that r is not currently a primary, or that r was unable
   to commit the value within one round of commits.

   mvalModifier is not allowed to modify the version number in the given mval. *)
Definition Replica__tryCommit: val :=
  rec: "Replica__tryCommit" "r" "mvalModifier" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "mvalModifier" := ref_to (ptrT -> unitT)%!h(MISSING)t "mvalModifier" in
    let: "r" := ref_to ptrT "r" in
    do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    (if: (~ (struct.loadF Replica "isLeader" (![ptrT] "r")))
    then
      do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      let: "$a0" := ENotLeader in
      do:  struct.storeF TryCommitReply "err" (![ptrT] "reply") "$a0";;;
      return: (#());;;
      do:  #()
    else #());;;
    do:  (![(arrowT unitT unitT)] "mvalModifier") (struct.loadF Replica "acceptedMVal" (![ptrT] "r"));;;
    do:  log.Printf #(str "Trying to commit value; node state: %!!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)v(MISSING)
    ") (![ptrT] "r");;;
    do:  struct.storeF MonotonicValue "version" (struct.loadF Replica "acceptedMVal" (![ptrT] "r")) ((struct.loadF MonotonicValue "version" (struct.loadF Replica "acceptedMVal" (![ptrT] "r"))) + #1);;;
    let: "term" := ref_zero uint64T in
    let: "$a0" := struct.loadF Replica "promisedTerm" (![ptrT] "r") in
    do:  "term" <-[uint64T] "$a0";;;
    let: "mval" := ref_zero ptrT in
    let: "$a0" := struct.loadF Replica "acceptedMVal" (![ptrT] "r") in
    do:  "mval" <-[ptrT] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    let: "mu" := ref_zero ptrT in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  "mu" <-[ptrT] "$a0";;;
    let: "accepted" := ref_zero (mapT boolT) in
    let: "$a0" := NewMap uint64T boolT #() in
    do:  "accepted" <-[mapT boolT] "$a0";;;
    do:  Config__ForEachMember (struct.loadF MonotonicValue "conf" (![ptrT] "mval")) (λ: "addr",
      do:  Fork ((if: ClerkPool__ProposeRPC (struct.loadF Replica "clerkPool" (![ptrT] "r")) (![uint64T] "addr") (![uint64T] "term") (![ptrT] "mval")
            then
              do:  sync.Mutex__Lock (![ptrT] "mu");;;
              let: "$a0" := #true in
              do:  MapInsert (![mapT boolT] "accepted") (![uint64T] "addr") "$a0";;;
              do:  sync.Mutex__Unlock (![ptrT] "mu");;;
              do:  #()
            else #());;;
            do:  #());;;
      do:  #()
      );;;
    do:  machine.Sleep (#100 * #1000000);;;
    do:  sync.Mutex__Lock (![ptrT] "mu");;;
    (if: IsQuorum (struct.loadF MonotonicValue "conf" (![ptrT] "mval")) (![mapT boolT] "accepted")
    then
      let: "$a0" := ENone in
      do:  struct.storeF TryCommitReply "err" (![ptrT] "reply") "$a0";;;
      let: "$a0" := struct.loadF MonotonicValue "version" (![ptrT] "mval") in
      do:  struct.storeF TryCommitReply "version" (![ptrT] "reply") "$a0";;;
      do:  #()
    else
      let: "$a0" := EQuorumFailed in
      do:  struct.storeF TryCommitReply "err" (![ptrT] "reply") "$a0";;;
      do:  #());;;
    do:  log.Printf #(str "Result of trying to commit: %!!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)v(MISSING)
    ") (![ptrT] "reply");;;
    do:  #().

Definition Replica__TryCommitVal: val :=
  rec: "Replica__TryCommitVal" "r" "v" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "v" := ref_to (slice.T byteT) "v" in
    let: "r" := ref_to ptrT "r" in
    do:  sync.Mutex__Lock (struct.loadF Replica "mu" (![ptrT] "r"));;;
    (if: (~ (struct.loadF Replica "isLeader" (![ptrT] "r")))
    then
      do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      do:  Replica__TryBecomeLeader (![ptrT] "r");;;
      do:  #()
    else
      do:  sync.Mutex__Unlock (struct.loadF Replica "mu" (![ptrT] "r"));;;
      do:  #());;;
    do:  Replica__tryCommit (![ptrT] "r") (λ: "mval",
      let: "$a0" := ![slice.T byteT] "v" in
      do:  struct.storeF MonotonicValue "val" (![ptrT] "mval") "$a0";;;
      do:  #()
      ) (![ptrT] "reply");;;
    do:  #().

(* requires that newConfig has overlapping quorums with r.config *)
Definition Replica__TryEnterNewConfig: val :=
  rec: "Replica__TryEnterNewConfig" "r" "newMembers" :=
    let: "newMembers" := ref_to (slice.T uint64T) "newMembers" in
    let: "r" := ref_to ptrT "r" in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := struct.alloc TryCommitReply (zero_val (struct.t TryCommitReply)) in
    do:  "reply" <-[ptrT] "$a0";;;
    do:  Replica__tryCommit (![ptrT] "r") (λ: "mval",
      (if: (slice.len (struct.loadF Config "NextMembers" (struct.loadF MonotonicValue "conf" (![ptrT] "mval")))) = #0
      then
        let: "$a0" := ![slice.T uint64T] "newMembers" in
        do:  struct.storeF Config "NextMembers" (struct.loadF MonotonicValue "conf" (![ptrT] "mval")) "$a0";;;
        do:  #()
      else #());;;
      do:  #()
      ) (![ptrT] "reply");;;
    do:  Replica__tryCommit (![ptrT] "r") (λ: "mval",
      (if: (slice.len (struct.loadF Config "NextMembers" (struct.loadF MonotonicValue "conf" (![ptrT] "mval")))) ≠ #0
      then
        let: "$a0" := struct.loadF Config "NextMembers" (struct.loadF MonotonicValue "conf" (![ptrT] "mval")) in
        do:  struct.storeF Config "Members" (struct.loadF MonotonicValue "conf" (![ptrT] "mval")) "$a0";;;
        let: "$a0" := NewSlice uint64T #0 in
        do:  struct.storeF Config "NextMembers" (struct.loadF MonotonicValue "conf" (![ptrT] "mval")) "$a0";;;
        do:  #()
      else #());;;
      do:  #()
      ) (![ptrT] "reply");;;
    do:  #().

Definition StartReplicaServer: val :=
  rec: "StartReplicaServer" "me" "initConfig" :=
    let: "initConfig" := ref_to ptrT "initConfig" in
    let: "me" := ref_to uint64T "me" in
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc Replica (zero_val (struct.t Replica)) in
    do:  "s" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF Replica "mu" (![ptrT] "s") "$a0";;;
    let: "$a0" := #0 in
    do:  struct.storeF Replica "promisedTerm" (![ptrT] "s") "$a0";;;
    let: "$a0" := #0 in
    do:  struct.storeF Replica "acceptedTerm" (![ptrT] "s") "$a0";;;
    let: "$a0" := struct.alloc MonotonicValue (zero_val (struct.t MonotonicValue)) in
    do:  struct.storeF Replica "acceptedMVal" (![ptrT] "s") "$a0";;;
    let: "$a0" := ![ptrT] "initConfig" in
    do:  struct.storeF MonotonicValue "conf" (struct.loadF Replica "acceptedMVal" (![ptrT] "s")) "$a0";;;
    let: "$a0" := MakeClerkPool #() in
    do:  struct.storeF Replica "clerkPool" (![ptrT] "s") "$a0";;;
    let: "$a0" := #false in
    do:  struct.storeF Replica "isLeader" (![ptrT] "s") "$a0";;;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := (λ: "args" "raw_reply",
      let: <> := ref_zero (slice.T byteT) in
      let: "term" := ref_zero uint64T in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "args") in
      do:  "$a1";;;
      do:  "term" <-[uint64T] "$a0";;;
      let: "reply" := ref_zero ptrT in
      let: "$a0" := struct.alloc PrepareReply (zero_val (struct.t PrepareReply)) in
      do:  "reply" <-[ptrT] "$a0";;;
      do:  Replica__PrepareRPC (![ptrT] "s") (![uint64T] "term") (![ptrT] "reply");;;
      let: "$a0" := EncPrepareReply (NewSlice byteT #0) (![ptrT] "reply") in
      do:  (![ptrT] "raw_reply") <-[slice.T byteT] "$a0";;;
      do:  DecPrepareReply (![slice.T byteT] (![ptrT] "raw_reply"));;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_PREPARE "$a0";;;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      let: <> := ref_zero (slice.T byteT) in
      let: "args" := ref_zero ptrT in
      let: ("$a0", "$a1") := DecProposeArgs (![slice.T byteT] "raw_args") in
      do:  "$a1";;;
      do:  "args" <-[ptrT] "$a0";;;
      let: "reply" := ref_zero uint64T in
      let: "$a0" := Replica__ProposeRPC (![ptrT] "s") (struct.loadF ProposeArgs "Term" (![ptrT] "args")) (struct.loadF ProposeArgs "Val" (![ptrT] "args")) in
      do:  "reply" <-[uint64T] "$a0";;;
      let: "$a0" := marshal.WriteInt (NewSliceWithCap byteT #0 #8) (![uint64T] "reply") in
      do:  (![ptrT] "raw_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_PROPOSE "$a0";;;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      do:  log.Println #(str "RPC_TRY_COMMIT_VAL");;;
      let: "val" := ref_zero (slice.T byteT) in
      let: "$a0" := ![slice.T byteT] "raw_args" in
      do:  "val" <-[slice.T byteT] "$a0";;;
      let: "reply" := ref_zero ptrT in
      let: "$a0" := struct.alloc TryCommitReply (zero_val (struct.t TryCommitReply)) in
      do:  "reply" <-[ptrT] "$a0";;;
      do:  Replica__TryCommitVal (![ptrT] "s") (![slice.T byteT] "val") (![ptrT] "reply");;;
      let: "$a0" := marshal.WriteInt (NewSliceWithCap byteT #0 #8) (struct.loadF TryCommitReply "err" (![ptrT] "reply")) in
      do:  (![ptrT] "raw_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_TRY_COMMIT_VAL "$a0";;;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      let: <> := ref_zero (slice.T byteT) in
      let: "args" := ref_zero (slice.T uint64T) in
      let: ("$a0", "$a1") := DecMembers (![slice.T byteT] "raw_args") in
      do:  "$a1";;;
      do:  "args" <-[slice.T uint64T] "$a0";;;
      do:  Replica__TryEnterNewConfig (![ptrT] "s") (![slice.T uint64T] "args");;;
      let: "$a0" := NewSlice byteT #0 in
      do:  (![ptrT] "raw_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_TRY_CONFIG_CHANGE "$a0";;;
    let: "r" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    do:  "r" <-[ptrT] "$a0";;;
    do:  urpc.Server__Serve (![ptrT] "r") (![uint64T] "me");;;
    do:  #().
