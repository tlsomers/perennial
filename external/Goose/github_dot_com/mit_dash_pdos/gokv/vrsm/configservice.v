(* autogenerated from github.com/mit-pdos/gokv/vrsm/configservice *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.reconnectclient.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.e.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.paxos.
From Goose Require github_dot_com.tchajed.goose.machine.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require log.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_marshal.go *)

Definition EncodeConfig: val :=
  rec: "EncodeConfig" "config" :=
    let: "config" := ref_to (slice.T uint64T) "config" in
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + (#8 * (slice.len (![slice.T uint64T] "config"))))) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (slice.len (![slice.T uint64T] "config")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    do:  ForSlice uint64T <> "h" (![slice.T uint64T] "config")
      (let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (![uint64T] "h") in
      do:  "enc" <-[slice.T byteT] "$a0";;;
      do:  #());;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition DecodeConfig: val :=
  rec: "DecodeConfig" "enc_config" :=
    let: "enc_config" := ref_to (slice.T byteT) "enc_config" in
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "enc_config") in
    let: "configLen" := ref (zero_val uint64T) in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc" <-[slice.T byteT] "$a1";;;
    do:  "configLen" <-[uint64T] "$a0";;;
    let: "config" := ref_zero (slice.T uint64T) in
    let: "$a0" := NewSlice uint64T (![uint64T] "configLen") in
    do:  "config" <-[slice.T uint64T] "$a0";;;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (slice.len (![slice.T uint64T] "config"))); (λ: <>, Skip) := λ: <>,
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
      do:  "enc" <-[slice.T byteT] "$a1";;;
      do:  SliceSet uint64T (![slice.T uint64T] "config") (![uint64T] "i") "$a0";;;
      do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
      do:  #()).

(* client.go *)

Definition Clerk := struct.decl [
  "mu" :: ptrT;
  "cls" :: slice.T ptrT;
  "leader" :: uint64T
].

Definition RPC_RESERVEEPOCH : expr := #0.

Definition RPC_GETCONFIG : expr := #1.

Definition RPC_TRYWRITECONFIG : expr := #2.

Definition RPC_GETLEASE : expr := #3.

Definition MakeClerk: val :=
  rec: "MakeClerk" "hosts" :=
    let: "hosts" := ref_to (slice.T uint64T) "hosts" in
    let: "cls" := ref_to (slice.T ptrT) (NewSlice ptrT #0) in
    do:  ForSlice uint64T <> "host" (![slice.T uint64T] "hosts")
      (let: "$a0" := SliceAppend ptrT (![slice.T ptrT] "cls") (reconnectclient.MakeReconnectingClient (![uint64T] "host")) in
      do:  "cls" <-[slice.T ptrT] "$a0";;;
      do:  #());;;
    return: (struct.new Clerk [
       "cls" ::= ![slice.T ptrT] "cls";
       "mu" ::= struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex))
     ]);;;
    do:  #().

Definition Clerk__ReserveEpochAndGetConfig: val :=
  rec: "Clerk__ReserveEpochAndGetConfig" "ck" :=
    let: "ck" := ref_to ptrT "ck" in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  sync.Mutex__Lock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
      let: "l" := ref_zero uint64T in
      let: "$a0" := struct.loadF Clerk "leader" (![ptrT] "ck") in
      do:  "l" <-[uint64T] "$a0";;;
      do:  sync.Mutex__Unlock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
      let: "err" := ref_zero uint64T in
      let: "$a0" := reconnectclient.ReconnectingClient__Call (SliceGet ptrT (struct.loadF Clerk "cls" (![ptrT] "ck")) (![uint64T] "l")) RPC_RESERVEEPOCH (NewSlice byteT #0) (![ptrT] "reply") #100 in
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") ≠ #0
      then
        continue: #();;;
        do:  #()
      else #());;;
      let: "err2" := ref (zero_val uint64T) in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] (![ptrT] "reply")) in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a1";;;
      do:  "err2" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err2") = e.NotLeader
      then
        do:  sync.Mutex__Lock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
        (if: (![uint64T] "l") = (struct.loadF Clerk "leader" (![ptrT] "ck"))
        then
          let: "$a0" := ((struct.loadF Clerk "leader" (![ptrT] "ck")) + #1) `rem` (slice.len (struct.loadF Clerk "cls" (![ptrT] "ck"))) in
          do:  struct.storeF Clerk "leader" (![ptrT] "ck") "$a0";;;
          do:  #()
        else #());;;
        do:  sync.Mutex__Unlock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
        continue: #();;;
        do:  #()
      else #());;;
      (if: (![uint64T] "err2") = e.None
      then
        break: #();;;
        do:  #()
      else #());;;
      do:  #()).

Definition Clerk__GetConfig: val :=
  rec: "Clerk__GetConfig" "ck" :=
    let: "ck" := ref_to ptrT "ck" in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "i" := ref_zero uint64T in
      let: "$a0" := (machine.RandomUint64 #()) `rem` (slice.len (struct.loadF Clerk "cls" (![ptrT] "ck"))) in
      do:  "i" <-[uint64T] "$a0";;;
      let: "err" := ref_zero uint64T in
      let: "$a0" := reconnectclient.ReconnectingClient__Call (SliceGet ptrT (struct.loadF Clerk "cls" (![ptrT] "ck")) (![uint64T] "i")) RPC_GETCONFIG (NewSlice byteT #0) (![ptrT] "reply") #100 in
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = #0
      then
        break: #();;;
        do:  #()
      else #());;;
      continue: #();;;
      do:  #()).

Definition Clerk__TryWriteConfig: val :=
  rec: "Clerk__TryWriteConfig" "ck" "epoch" "config" :=
    let: "config" := ref_to (slice.T uint64T) "config" in
    let: "epoch" := ref_to uint64T "epoch" in
    let: "ck" := ref_to ptrT "ck" in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    let: "args" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + (#8 * (slice.len (![slice.T uint64T] "config"))))) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "args") (![uint64T] "epoch") in
    do:  "args" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "args") (EncodeConfig (![slice.T uint64T] "config")) in
    do:  "args" <-[slice.T byteT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  sync.Mutex__Lock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
      let: "l" := ref_zero uint64T in
      let: "$a0" := struct.loadF Clerk "leader" (![ptrT] "ck") in
      do:  "l" <-[uint64T] "$a0";;;
      do:  sync.Mutex__Unlock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
      let: "err" := ref_zero uint64T in
      let: "$a0" := reconnectclient.ReconnectingClient__Call (SliceGet ptrT (struct.loadF Clerk "cls" (![ptrT] "ck")) (![uint64T] "l")) RPC_TRYWRITECONFIG (![slice.T byteT] "args") (![ptrT] "reply") #2000 in
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") ≠ #0
      then
        continue: #();;;
        do:  #()
      else #());;;
      let: <> := ref_zero (slice.T byteT) in
      let: "err2" := ref_zero uint64T in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] (![ptrT] "reply")) in
      do:  "$a1";;;
      do:  "err2" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err2") = e.NotLeader
      then
        do:  sync.Mutex__Lock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
        (if: (![uint64T] "l") = (struct.loadF Clerk "leader" (![ptrT] "ck"))
        then
          let: "$a0" := ((struct.loadF Clerk "leader" (![ptrT] "ck")) + #1) `rem` (slice.len (struct.loadF Clerk "cls" (![ptrT] "ck"))) in
          do:  struct.storeF Clerk "leader" (![ptrT] "ck") "$a0";;;
          do:  #()
        else #());;;
        do:  sync.Mutex__Unlock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
        continue: #();;;
        do:  #()
      else
        break: #();;;
        do:  #());;;
      do:  #()).

(* returns e.None if the lease was granted for the given epoch, and a conservative
   guess on when the lease expires. *)
Definition Clerk__GetLease: val :=
  rec: "Clerk__GetLease" "ck" "epoch" :=
    let: "epoch" := ref_to uint64T "epoch" in
    let: "ck" := ref_to ptrT "ck" in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    let: "args" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "args") (![uint64T] "epoch") in
    do:  "args" <-[slice.T byteT] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  sync.Mutex__Lock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
      let: "l" := ref_zero uint64T in
      let: "$a0" := struct.loadF Clerk "leader" (![ptrT] "ck") in
      do:  "l" <-[uint64T] "$a0";;;
      do:  sync.Mutex__Unlock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
      let: "err" := ref_zero uint64T in
      let: "$a0" := reconnectclient.ReconnectingClient__Call (SliceGet ptrT (struct.loadF Clerk "cls" (![ptrT] "ck")) (![uint64T] "l")) RPC_GETLEASE (![slice.T byteT] "args") (![ptrT] "reply") #100 in
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") ≠ #0
      then
        continue: #();;;
        do:  #()
      else #());;;
      let: <> := ref_zero (slice.T byteT) in
      let: "err2" := ref_zero uint64T in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] (![ptrT] "reply")) in
      do:  "$a1";;;
      do:  "err2" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err2") = e.NotLeader
      then
        do:  sync.Mutex__Lock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
        (if: (![uint64T] "l") = (struct.loadF Clerk "leader" (![ptrT] "ck"))
        then
          let: "$a0" := ((struct.loadF Clerk "leader" (![ptrT] "ck")) + #1) `rem` (slice.len (struct.loadF Clerk "cls" (![ptrT] "ck"))) in
          do:  struct.storeF Clerk "leader" (![ptrT] "ck") "$a0";;;
          do:  #()
        else #());;;
        do:  sync.Mutex__Unlock (struct.loadF Clerk "mu" (![ptrT] "ck"));;;
        continue: #();;;
        do:  #()
      else
        break: #();;;
        do:  #());;;
      do:  #()).

(* server.go *)

(* 1 second *)
Definition LeaseInterval : expr := #1000000000.

Definition state := struct.decl [
  "epoch" :: uint64T;
  "reservedEpoch" :: uint64T;
  "leaseExpiration" :: uint64T;
  "wantLeaseToExpire" :: boolT;
  "config" :: slice.T uint64T
].

Definition encodeState: val :=
  rec: "encodeState" "st" :=
    let: "st" := ref_to ptrT "st" in
    let: "e" := ref (zero_val (slice.T byteT)) in
    let: "$a0" := marshal.WriteInt slice.nil (struct.loadF state "epoch" (![ptrT] "st")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF state "reservedEpoch" (![ptrT] "st")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF state "leaseExpiration" (![ptrT] "st")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    (if: struct.loadF state "wantLeaseToExpire" (![ptrT] "st")
    then
      let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") #1 in
      do:  "e" <-[slice.T byteT] "$a0";;;
      do:  #()
    else
      let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") #0 in
      do:  "e" <-[slice.T byteT] "$a0";;;
      do:  #());;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (EncodeConfig (struct.loadF state "config" (![ptrT] "st"))) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "e");;;
    do:  #().

Definition decodeState: val :=
  rec: "decodeState" "e" :=
    let: "e" := ref_to (slice.T byteT) "e" in
    let: "st" := ref_zero ptrT in
    let: "$a0" := struct.alloc state (zero_val (struct.t state)) in
    do:  "st" <-[ptrT] "$a0";;;
    let: "e2" := ref_to (slice.T byteT) (![slice.T byteT] "e") in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e2") in
    do:  "e2" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF state "epoch" (![ptrT] "st") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e2") in
    do:  "e2" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF state "reservedEpoch" (![ptrT] "st") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e2") in
    do:  "e2" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF state "leaseExpiration" (![ptrT] "st") "$a0";;;
    let: "wantExp" := ref (zero_val uint64T) in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e2") in
    do:  "e2" <-[slice.T byteT] "$a1";;;
    do:  "wantExp" <-[uint64T] "$a0";;;
    let: "$a0" := (![uint64T] "wantExp") = #1 in
    do:  struct.storeF state "wantLeaseToExpire" (![ptrT] "st") "$a0";;;
    let: "$a0" := DecodeConfig (![slice.T byteT] "e2") in
    do:  struct.storeF state "config" (![ptrT] "st") "$a0";;;
    return: (![ptrT] "st");;;
    do:  #().

Definition Server := struct.decl [
  "s" :: ptrT
].

Definition Server__tryAcquire: val :=
  rec: "Server__tryAcquire" "s" :=
    let: "s" := ref_to ptrT "s" in
    let: "relF" := ref_zero (arrowT unitT unitT) in
    let: "e" := ref_zero ptrT in
    let: "err" := ref_zero paxos.Error in
    let: (("$a0", "$a1"), "$a2") := paxos.Server__TryAcquire (struct.loadF Server "s" (![ptrT] "s")) in
    do:  "relF" <-[(arrowT unitT unitT)] "$a2";;;
    do:  "e" <-[ptrT] "$a1";;;
    do:  "err" <-[paxos.Error] "$a0";;;
    (if: (![paxos.Error] "err") ≠ #0
    then
      let: "p" := ref (zero_val ptrT) in
      return: (#false, ![ptrT] "p", slice.nil);;;
      do:  #()
    else #());;;
    let: "st" := ref_zero ptrT in
    let: "$a0" := decodeState (![slice.T byteT] (![ptrT] "e")) in
    do:  "st" <-[ptrT] "$a0";;;
    let: "releaseFn" := ref_zero (arrowT unitT unitT) in
    let: "$a0" := (λ: <>,
      let: "$a0" := encodeState (![ptrT] "st") in
      do:  (![ptrT] "e") <-[slice.T byteT] "$a0";;;
      return: (((![(arrowT unitT unitT)] "relF") #()) = #0);;;
      do:  #()
      ) in
    do:  "releaseFn" <-[(arrowT unitT unitT)] "$a0";;;
    return: (#true, ![ptrT] "st", ![(arrowT unitT unitT)] "releaseFn");;;
    do:  #().

Definition Server__ReserveEpochAndGetConfig: val :=
  rec: "Server__ReserveEpochAndGetConfig" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to (slice.T byteT) "args" in
    let: "s" := ref_to ptrT "s" in
    let: "$a0" := marshal.WriteInt slice.nil e.NotLeader in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    let: "tryReleaseFn" := ref_zero (arrowT unitT unitT) in
    let: "st" := ref_zero ptrT in
    let: "ok" := ref_zero boolT in
    let: (("$a0", "$a1"), "$a2") := Server__tryAcquire (![ptrT] "s") in
    do:  "tryReleaseFn" <-[(arrowT unitT unitT)] "$a2";;;
    do:  "st" <-[ptrT] "$a1";;;
    do:  "ok" <-[boolT] "$a0";;;
    (if: (~ (![boolT] "ok"))
    then
      return: (#());;;
      do:  #()
    else #());;;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF state "reservedEpoch" (![ptrT] "st")) #1 in
    do:  struct.storeF state "reservedEpoch" (![ptrT] "st") "$a0";;;
    let: "config" := ref_zero (slice.T uint64T) in
    let: "$a0" := struct.loadF state "config" (![ptrT] "st") in
    do:  "config" <-[slice.T uint64T] "$a0";;;
    let: "reservedEpoch" := ref_zero uint64T in
    let: "$a0" := struct.loadF state "reservedEpoch" (![ptrT] "st") in
    do:  "reservedEpoch" <-[uint64T] "$a0";;;
    (if: (~ ((![(arrowT unitT unitT)] "tryReleaseFn") #()))
    then
      return: (#());;;
      do:  #()
    else #());;;
    let: "$a0" := NewSliceWithCap byteT #0 ((#8 + #8) + (#8 * (slice.len (![slice.T uint64T] "config")))) in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] (![ptrT] "reply")) e.None in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] (![ptrT] "reply")) (![uint64T] "reservedEpoch") in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] (![ptrT] "reply")) (EncodeConfig (![slice.T uint64T] "config")) in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    do:  #().

Definition Server__GetConfig: val :=
  rec: "Server__GetConfig" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to (slice.T byteT) "args" in
    let: "s" := ref_to ptrT "s" in
    let: "st" := ref_zero ptrT in
    let: "$a0" := decodeState (paxos.Server__WeakRead (struct.loadF Server "s" (![ptrT] "s"))) in
    do:  "st" <-[ptrT] "$a0";;;
    let: "$a0" := EncodeConfig (struct.loadF state "config" (![ptrT] "st")) in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    do:  #().

Definition Server__TryWriteConfig: val :=
  rec: "Server__TryWriteConfig" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to (slice.T byteT) "args" in
    let: "s" := ref_to ptrT "s" in
    let: "$a0" := marshal.WriteInt slice.nil e.NotLeader in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    let: "enc" := ref_zero (slice.T byteT) in
    let: "epoch" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "args") in
    do:  "enc" <-[slice.T byteT] "$a1";;;
    do:  "epoch" <-[uint64T] "$a0";;;
    let: "config" := ref_zero (slice.T uint64T) in
    let: "$a0" := DecodeConfig (![slice.T byteT] "enc") in
    do:  "config" <-[slice.T uint64T] "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "tryReleaseFn" := ref_zero (arrowT unitT unitT) in
      let: "st" := ref_zero ptrT in
      let: "ok" := ref_zero boolT in
      let: (("$a0", "$a1"), "$a2") := Server__tryAcquire (![ptrT] "s") in
      do:  "tryReleaseFn" <-[(arrowT unitT unitT)] "$a2";;;
      do:  "st" <-[ptrT] "$a1";;;
      do:  "ok" <-[boolT] "$a0";;;
      (if: (~ (![boolT] "ok"))
      then
        break: #();;;
        do:  #()
      else #());;;
      (if: (![uint64T] "epoch") < (struct.loadF state "reservedEpoch" (![ptrT] "st"))
      then
        (if: (~ ((![(arrowT unitT unitT)] "tryReleaseFn") #()))
        then
          break: #();;;
          do:  #()
        else #());;;
        let: "$a0" := marshal.WriteInt slice.nil e.Stale in
        do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
        do:  log.Printf #(str "Stale: %!!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)d(MISSING) < %!!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)d(MISSING)") (![uint64T] "epoch") (struct.loadF state "reservedEpoch" (![ptrT] "st"));;;
        break: #();;;
        do:  #()
      else
        (if: (![uint64T] "epoch") > (struct.loadF state "epoch" (![ptrT] "st"))
        then
          let: <> := ref_zero uint64T in
          let: "l" := ref_zero uint64T in
          let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
          do:  "$a1";;;
          do:  "l" <-[uint64T] "$a0";;;
          (if: (![uint64T] "l") ≥ (struct.loadF state "leaseExpiration" (![ptrT] "st"))
          then
            let: "$a0" := #false in
            do:  struct.storeF state "wantLeaseToExpire" (![ptrT] "st") "$a0";;;
            let: "$a0" := ![uint64T] "epoch" in
            do:  struct.storeF state "epoch" (![ptrT] "st") "$a0";;;
            let: "$a0" := ![slice.T uint64T] "config" in
            do:  struct.storeF state "config" (![ptrT] "st") "$a0";;;
            (if: (~ ((![(arrowT unitT unitT)] "tryReleaseFn") #()))
            then
              break: #();;;
              do:  #()
            else #());;;
            do:  log.Println #(str "New config is:") (struct.loadF state "config" (![ptrT] "st"));;;
            let: "$a0" := marshal.WriteInt slice.nil e.None in
            do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
            break: #();;;
            do:  #()
          else
            let: "$a0" := #true in
            do:  struct.storeF state "wantLeaseToExpire" (![ptrT] "st") "$a0";;;
            let: "timeToSleep" := ref_zero uint64T in
            let: "$a0" := (struct.loadF state "leaseExpiration" (![ptrT] "st")) - (![uint64T] "l") in
            do:  "timeToSleep" <-[uint64T] "$a0";;;
            (if: (~ ((![(arrowT unitT unitT)] "tryReleaseFn") #()))
            then
              break: #();;;
              do:  #()
            else #());;;
            do:  machine.Sleep (![uint64T] "timeToSleep");;;
            continue: #();;;
            do:  #());;;
          do:  #()
        else
          let: "$a0" := ![slice.T uint64T] "config" in
          do:  struct.storeF state "config" (![ptrT] "st") "$a0";;;
          (if: (~ ((![(arrowT unitT unitT)] "tryReleaseFn") #()))
          then
            break: #();;;
            do:  #()
          else #());;;
          let: "$a0" := marshal.WriteInt slice.nil e.None in
          do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
          break: #();;;
          do:  #());;;
        #());;;
      do:  #()).

Definition Server__GetLease: val :=
  rec: "Server__GetLease" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to (slice.T byteT) "args" in
    let: "s" := ref_to ptrT "s" in
    let: "$a0" := marshal.WriteInt slice.nil e.NotLeader in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] (![ptrT] "reply")) #0 in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    let: <> := ref_zero (slice.T byteT) in
    let: "epoch" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "args") in
    do:  "$a1";;;
    do:  "epoch" <-[uint64T] "$a0";;;
    let: "tryReleaseFn" := ref_zero (arrowT unitT unitT) in
    let: "st" := ref_zero ptrT in
    let: "ok" := ref_zero boolT in
    let: (("$a0", "$a1"), "$a2") := Server__tryAcquire (![ptrT] "s") in
    do:  "tryReleaseFn" <-[(arrowT unitT unitT)] "$a2";;;
    do:  "st" <-[ptrT] "$a1";;;
    do:  "ok" <-[boolT] "$a0";;;
    (if: (~ (![boolT] "ok"))
    then
      return: (#());;;
      do:  #()
    else #());;;
    (if: ((struct.loadF state "epoch" (![ptrT] "st")) ≠ (![uint64T] "epoch")) || (struct.loadF state "wantLeaseToExpire" (![ptrT] "st"))
    then
      do:  log.Println #(str "Rejected lease request") (![uint64T] "epoch") (struct.loadF state "epoch" (![ptrT] "st")) (struct.loadF state "wantLeaseToExpire" (![ptrT] "st"));;;
      (if: (~ ((![(arrowT unitT unitT)] "tryReleaseFn") #()))
      then
        return: (#());;;
        do:  #()
      else #());;;
      let: "$a0" := marshal.WriteInt slice.nil e.Stale in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      let: "$a0" := marshal.WriteInt (![slice.T byteT] (![ptrT] "reply")) #0 in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      return: (#());;;
      do:  #()
    else #());;;
    let: <> := ref_zero uint64T in
    let: "l" := ref_zero uint64T in
    let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
    do:  "$a1";;;
    do:  "l" <-[uint64T] "$a0";;;
    let: "newLeaseExpiration" := ref_zero uint64T in
    let: "$a0" := (![uint64T] "l") + LeaseInterval in
    do:  "newLeaseExpiration" <-[uint64T] "$a0";;;
    (if: (![uint64T] "newLeaseExpiration") > (struct.loadF state "leaseExpiration" (![ptrT] "st"))
    then
      let: "$a0" := ![uint64T] "newLeaseExpiration" in
      do:  struct.storeF state "leaseExpiration" (![ptrT] "st") "$a0";;;
      do:  #()
    else #());;;
    (if: (~ ((![(arrowT unitT unitT)] "tryReleaseFn") #()))
    then
      return: (#());;;
      do:  #()
    else #());;;
    let: "$a0" := marshal.WriteInt slice.nil e.None in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] (![ptrT] "reply")) (![uint64T] "newLeaseExpiration") in
    do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
    do:  #().

Definition makeServer: val :=
  rec: "makeServer" "fname" "paxosMe" "hosts" "initconfig" :=
    let: "initconfig" := ref_to (slice.T uint64T) "initconfig" in
    let: "hosts" := ref_to (slice.T uint64T) "hosts" in
    let: "paxosMe" := ref_to uint64T "paxosMe" in
    let: "fname" := ref_to stringT "fname" in
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc Server (zero_val (struct.t Server)) in
    do:  "s" <-[ptrT] "$a0";;;
    let: "initEnc" := ref_zero (slice.T byteT) in
    let: "$a0" := encodeState (struct.new state [
      "config" ::= ![slice.T uint64T] "initconfig"
    ]) in
    do:  "initEnc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := paxos.StartServer (![stringT] "fname") (![slice.T byteT] "initEnc") (![uint64T] "paxosMe") (![slice.T uint64T] "hosts") in
    do:  struct.storeF Server "s" (![ptrT] "s") "$a0";;;
    return: (![ptrT] "s");;;
    do:  #().

Definition StartServer: val :=
  rec: "StartServer" "fname" "me" "paxosMe" "hosts" "initconfig" :=
    let: "initconfig" := ref_to (slice.T uint64T) "initconfig" in
    let: "hosts" := ref_to (slice.T uint64T) "hosts" in
    let: "paxosMe" := ref_to uint64T "paxosMe" in
    let: "me" := ref_to uint64T "me" in
    let: "fname" := ref_to stringT "fname" in
    let: "s" := ref_zero ptrT in
    let: "$a0" := makeServer (![stringT] "fname") (![uint64T] "paxosMe") (![slice.T uint64T] "hosts") (![slice.T uint64T] "initconfig") in
    do:  "s" <-[ptrT] "$a0";;;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := Server__ReserveEpochAndGetConfig (![ptrT] "s") in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_RESERVEEPOCH "$a0";;;
    let: "$a0" := Server__GetConfig (![ptrT] "s") in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_GETCONFIG "$a0";;;
    let: "$a0" := Server__TryWriteConfig (![ptrT] "s") in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_TRYWRITECONFIG "$a0";;;
    let: "$a0" := Server__GetLease (![ptrT] "s") in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_GETLEASE "$a0";;;
    let: "rs" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    do:  "rs" <-[ptrT] "$a0";;;
    do:  urpc.Server__Serve (![ptrT] "rs") (![uint64T] "me");;;
    return: (![ptrT] "s");;;
    do:  #().
