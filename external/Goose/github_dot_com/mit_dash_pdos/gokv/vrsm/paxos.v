(* autogenerated from github.com/mit-pdos/gokv/vrsm/paxos *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.asyncfile.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.reconnectclient.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require log.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_marshal.go *)

Definition Error: ty := uint64T.

Definition ENone : expr := #0.

Definition EEpochStale : expr := #1.

Definition EOutOfOrder : expr := #2.

Definition ETimeout : expr := #3.

Definition ENotLeader : expr := #4.

Definition applyAsFollowerArgs := struct.decl [
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT
].

Definition encodeApplyAsFollowerArgs: val :=
  rec: "encodeApplyAsFollowerArgs" "o" :=
    let: "o" := ref_to ptrT "o" in
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 ((#8 + #8) + (slice.len (struct.loadF applyAsFollowerArgs "state" (![ptrT] "o"))))) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "nextIndex" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "state" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition decodeApplyAsFollowerArgs: val :=
  rec: "decodeApplyAsFollowerArgs" "s" :=
    let: "s" := ref_to (slice.T byteT) "s" in
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "s") in
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc applyAsFollowerArgs (zero_val (struct.t applyAsFollowerArgs)) in
    do:  "o" <-[ptrT] "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF applyAsFollowerArgs "epoch" (![ptrT] "o") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF applyAsFollowerArgs "nextIndex" (![ptrT] "o") "$a0";;;
    let: "$a0" := ![slice.T byteT] "enc" in
    do:  struct.storeF applyAsFollowerArgs "state" (![ptrT] "o") "$a0";;;
    return: (![ptrT] "o");;;
    do:  #().

Definition applyAsFollowerReply := struct.decl [
  "err" :: Error
].

Definition decodeApplyAsFollowerReply: val :=
  rec: "decodeApplyAsFollowerReply" "s" :=
    let: "s" := ref_to (slice.T byteT) "s" in
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc applyAsFollowerReply (zero_val (struct.t applyAsFollowerReply)) in
    do:  "o" <-[ptrT] "$a0";;;
    let: <> := ref_zero (slice.T byteT) in
    let: "err" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "s") in
    do:  "$a1";;;
    do:  "err" <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "err" in
    do:  struct.storeF applyAsFollowerReply "err" (![ptrT] "o") "$a0";;;
    return: (![ptrT] "o");;;
    do:  #().

Definition encodeApplyAsFollowerReply: val :=
  rec: "encodeApplyAsFollowerReply" "o" :=
    let: "o" := ref_to ptrT "o" in
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerReply "err" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition enterNewEpochArgs := struct.decl [
  "epoch" :: uint64T
].

Definition encodeEnterNewEpochArgs: val :=
  rec: "encodeEnterNewEpochArgs" "o" :=
    let: "o" := ref_to ptrT "o" in
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochArgs "epoch" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition decodeEnterNewEpochArgs: val :=
  rec: "decodeEnterNewEpochArgs" "s" :=
    let: "s" := ref_to (slice.T byteT) "s" in
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc enterNewEpochArgs (zero_val (struct.t enterNewEpochArgs)) in
    do:  "o" <-[ptrT] "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "s") in
    do:  "$a1";;;
    do:  struct.storeF enterNewEpochArgs "epoch" (![ptrT] "o") "$a0";;;
    return: (![ptrT] "o");;;
    do:  #().

Definition enterNewEpochReply := struct.decl [
  "err" :: Error;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT
].

Definition decodeEnterNewEpochReply: val :=
  rec: "decodeEnterNewEpochReply" "s" :=
    let: "s" := ref_to (slice.T byteT) "s" in
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc enterNewEpochReply (zero_val (struct.t enterNewEpochReply)) in
    do:  "o" <-[ptrT] "$a0";;;
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "s") in
    let: "err" := ref (zero_val uint64T) in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc" <-[slice.T byteT] "$a1";;;
    do:  "err" <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "err" in
    do:  struct.storeF enterNewEpochReply "err" (![ptrT] "o") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF enterNewEpochReply "acceptedEpoch" (![ptrT] "o") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF enterNewEpochReply "nextIndex" (![ptrT] "o") "$a0";;;
    let: "$a0" := ![slice.T byteT] "enc" in
    do:  struct.storeF enterNewEpochReply "state" (![ptrT] "o") "$a0";;;
    return: (![ptrT] "o");;;
    do:  #().

Definition encodeEnterNewEpochReply: val :=
  rec: "encodeEnterNewEpochReply" "o" :=
    let: "o" := ref_to ptrT "o" in
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (((#8 + #8) + #8) + (slice.len (struct.loadF enterNewEpochReply "state" (![ptrT] "o"))))) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "err" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "acceptedEpoch" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "nextIndex" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "state" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition applyReply := struct.decl [
  "err" :: Error;
  "ret" :: slice.T byteT
].

Definition encodeApplyReply: val :=
  rec: "encodeApplyReply" "o" :=
    let: "o" := ref_to ptrT "o" in
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + (slice.len (struct.loadF applyReply "ret" (![ptrT] "o"))))) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyReply "err" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF applyReply "ret" (![ptrT] "o")) in
    do:  "enc" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "enc");;;
    do:  #().

Definition decodeApplyReply: val :=
  rec: "decodeApplyReply" "s" :=
    let: "s" := ref_to (slice.T byteT) "s" in
    let: "enc" := ref_to (slice.T byteT) (![slice.T byteT] "s") in
    let: "o" := ref_zero ptrT in
    let: "$a0" := struct.alloc applyReply (zero_val (struct.t applyReply)) in
    do:  "o" <-[ptrT] "$a0";;;
    let: "err" := ref (zero_val uint64T) in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "enc") in
    do:  "enc" <-[slice.T byteT] "$a1";;;
    do:  "err" <-[uint64T] "$a0";;;
    let: "$a0" := ![uint64T] "err" in
    do:  struct.storeF applyReply "err" (![ptrT] "o") "$a0";;;
    let: "$a0" := ![slice.T byteT] "enc" in
    do:  struct.storeF applyReply "ret" (![ptrT] "o") "$a0";;;
    return: (![ptrT] "o");;;
    do:  #().

Definition boolToU64: val :=
  rec: "boolToU64" "b" :=
    let: "b" := ref_to boolT "b" in
    (if: ![boolT] "b"
    then
      return: (#1);;;
      do:  #()
    else
      return: (#0);;;
      do:  #());;;
    do:  #().

(* paxosState from server.go *)

Definition paxosState := struct.decl [
  "epoch" :: uint64T;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT;
  "isLeader" :: boolT
].

Definition encodePaxosState: val :=
  rec: "encodePaxosState" "ps" :=
    let: "ps" := ref_to ptrT "ps" in
    let: "e" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "epoch" (![ptrT] "ps")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "acceptedEpoch" (![ptrT] "ps")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "nextIndex" (![ptrT] "ps")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (boolToU64 (struct.loadF paxosState "isLeader" (![ptrT] "ps"))) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (struct.loadF paxosState "state" (![ptrT] "ps")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    return: (![slice.T byteT] "e");;;
    do:  #().

Definition decodePaxosState: val :=
  rec: "decodePaxosState" "enc" :=
    let: "enc" := ref_to (slice.T byteT) "enc" in
    let: "e" := ref_to (slice.T byteT) (![slice.T byteT] "enc") in
    let: "leaderInt" := ref (zero_val uint64T) in
    let: "ps" := ref_zero ptrT in
    let: "$a0" := struct.alloc paxosState (zero_val (struct.t paxosState)) in
    do:  "ps" <-[ptrT] "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "e" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF paxosState "epoch" (![ptrT] "ps") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "e" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF paxosState "acceptedEpoch" (![ptrT] "ps") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "e" <-[slice.T byteT] "$a1";;;
    do:  struct.storeF paxosState "nextIndex" (![ptrT] "ps") "$a0";;;
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  struct.storeF paxosState "state" (![ptrT] "ps") "$a1";;;
    do:  "leaderInt" <-[uint64T] "$a0";;;
    let: "$a0" := (![uint64T] "leaderInt") = #1 in
    do:  struct.storeF paxosState "isLeader" (![ptrT] "ps") "$a0";;;
    return: (![ptrT] "ps");;;
    do:  #().

(* 2_internalclerk.go *)

Definition RPC_APPLY_AS_FOLLOWER : expr := #0.

Definition RPC_ENTER_NEW_EPOCH : expr := #1.

Definition RPC_BECOME_LEADER : expr := #2.

Definition singleClerk := struct.decl [
  "cl" :: ptrT
].

Definition MakeSingleClerk: val :=
  rec: "MakeSingleClerk" "addr" :=
    let: "addr" := ref_to uint64T "addr" in
    let: "ck" := ref_zero ptrT in
    let: "$a0" := struct.new singleClerk [
      "cl" ::= reconnectclient.MakeReconnectingClient (![uint64T] "addr")
    ] in
    do:  "ck" <-[ptrT] "$a0";;;
    return: (![ptrT] "ck");;;
    do:  #().

Definition singleClerk__enterNewEpoch: val :=
  rec: "singleClerk__enterNewEpoch" "s" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    let: "raw_args" := ref_zero (slice.T byteT) in
    let: "$a0" := encodeEnterNewEpochArgs (![ptrT] "args") in
    do:  "raw_args" <-[slice.T byteT] "$a0";;;
    let: "raw_reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "raw_reply" <-[ptrT] "$a0";;;
    let: "err" := ref_zero uint64T in
    let: "$a0" := reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" (![ptrT] "s")) RPC_ENTER_NEW_EPOCH (![slice.T byteT] "raw_args") (![ptrT] "raw_reply") #500 in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") = #0
    then
      return: (decodeEnterNewEpochReply (![slice.T byteT] (![ptrT] "raw_reply")));;;
      do:  #()
    else
      return: (struct.new enterNewEpochReply [
         "err" ::= ETimeout
       ]);;;
      do:  #());;;
    do:  #().

Definition singleClerk__applyAsFollower: val :=
  rec: "singleClerk__applyAsFollower" "s" "args" :=
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    let: "raw_args" := ref_zero (slice.T byteT) in
    let: "$a0" := encodeApplyAsFollowerArgs (![ptrT] "args") in
    do:  "raw_args" <-[slice.T byteT] "$a0";;;
    let: "raw_reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "raw_reply" <-[ptrT] "$a0";;;
    let: "err" := ref_zero uint64T in
    let: "$a0" := reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" (![ptrT] "s")) RPC_APPLY_AS_FOLLOWER (![slice.T byteT] "raw_args") (![ptrT] "raw_reply") #500 in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") = #0
    then
      return: (decodeApplyAsFollowerReply (![slice.T byteT] (![ptrT] "raw_reply")));;;
      do:  #()
    else
      return: (struct.new applyAsFollowerReply [
         "err" ::= ETimeout
       ]);;;
      do:  #());;;
    do:  #().

Definition singleClerk__TryBecomeLeader: val :=
  rec: "singleClerk__TryBecomeLeader" "s" :=
    let: "s" := ref_to ptrT "s" in
    let: "reply" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply" <-[ptrT] "$a0";;;
    do:  reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" (![ptrT] "s")) RPC_BECOME_LEADER (NewSlice byteT #0) (![ptrT] "reply") #500;;;
    do:  #().

(* server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "ps" :: ptrT;
  "storage" :: ptrT;
  "clerks" :: slice.T ptrT
].

Definition Server__withLock: val :=
  rec: "Server__withLock" "s" "f" :=
    let: "f" := ref_to (ptrT -> unitT)%ht "f" in
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    do:  (![(arrowT unitT unitT)] "f") (struct.loadF Server "ps" (![ptrT] "s"));;;
    let: "waitFn" := ref_zero (arrowT unitT unitT) in
    let: "$a0" := asyncfile.AsyncFile__Write (struct.loadF Server "storage" (![ptrT] "s")) (encodePaxosState (struct.loadF Server "ps" (![ptrT] "s"))) in
    do:  "waitFn" <-[(arrowT unitT unitT)] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    do:  (![(arrowT unitT unitT)] "waitFn") #();;;
    do:  #().

Definition Server__applyAsFollower: val :=
  rec: "Server__applyAsFollower" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  Server__withLock (![ptrT] "s") (λ: "ps",
      (if: (struct.loadF paxosState "epoch" (![ptrT] "ps")) ≤ (struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "args"))
      then
        (if: (struct.loadF paxosState "acceptedEpoch" (![ptrT] "ps")) = (struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "args"))
        then
          (if: (struct.loadF paxosState "nextIndex" (![ptrT] "ps")) < (struct.loadF applyAsFollowerArgs "nextIndex" (![ptrT] "args"))
          then
            let: "$a0" := struct.loadF applyAsFollowerArgs "nextIndex" (![ptrT] "args") in
            do:  struct.storeF paxosState "nextIndex" (![ptrT] "ps") "$a0";;;
            let: "$a0" := struct.loadF applyAsFollowerArgs "state" (![ptrT] "args") in
            do:  struct.storeF paxosState "state" (![ptrT] "ps") "$a0";;;
            let: "$a0" := ENone in
            do:  struct.storeF applyAsFollowerReply "err" (![ptrT] "reply") "$a0";;;
            do:  #()
          else
            let: "$a0" := ENone in
            do:  struct.storeF applyAsFollowerReply "err" (![ptrT] "reply") "$a0";;;
            do:  #());;;
          do:  #()
        else
          let: "$a0" := struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "args") in
          do:  struct.storeF paxosState "acceptedEpoch" (![ptrT] "ps") "$a0";;;
          let: "$a0" := struct.loadF applyAsFollowerArgs "epoch" (![ptrT] "args") in
          do:  struct.storeF paxosState "epoch" (![ptrT] "ps") "$a0";;;
          let: "$a0" := struct.loadF applyAsFollowerArgs "state" (![ptrT] "args") in
          do:  struct.storeF paxosState "state" (![ptrT] "ps") "$a0";;;
          let: "$a0" := struct.loadF applyAsFollowerArgs "nextIndex" (![ptrT] "args") in
          do:  struct.storeF paxosState "nextIndex" (![ptrT] "ps") "$a0";;;
          let: "$a0" := #false in
          do:  struct.storeF paxosState "isLeader" (![ptrT] "ps") "$a0";;;
          let: "$a0" := ENone in
          do:  struct.storeF applyAsFollowerReply "err" (![ptrT] "reply") "$a0";;;
          do:  #());;;
        do:  #()
      else
        let: "$a0" := EEpochStale in
        do:  struct.storeF applyAsFollowerReply "err" (![ptrT] "reply") "$a0";;;
        do:  #());;;
      do:  #()
      );;;
    do:  #().

(* NOTE:
   This will vote yes only the first time it's called in an epoch.
   If you have too aggressive of a timeout and end up retrying this, the retry
   might fail because it may be the second execution of enterNewEpoch(epoch) on
   the server.
   Solution: either conservative (maybe double) timeouts, or don't use this for
   leader election, only for coming up with a valid proposal. *)
Definition Server__enterNewEpoch: val :=
  rec: "Server__enterNewEpoch" "s" "args" "reply" :=
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to ptrT "args" in
    let: "s" := ref_to ptrT "s" in
    do:  Server__withLock (![ptrT] "s") (λ: "ps",
      (if: (struct.loadF paxosState "epoch" (![ptrT] "ps")) ≥ (struct.loadF enterNewEpochArgs "epoch" (![ptrT] "args"))
      then
        let: "$a0" := EEpochStale in
        do:  struct.storeF enterNewEpochReply "err" (![ptrT] "reply") "$a0";;;
        return: (#());;;
        do:  #()
      else #());;;
      let: "$a0" := #false in
      do:  struct.storeF paxosState "isLeader" (![ptrT] "ps") "$a0";;;
      let: "$a0" := struct.loadF enterNewEpochArgs "epoch" (![ptrT] "args") in
      do:  struct.storeF paxosState "epoch" (![ptrT] "ps") "$a0";;;
      let: "$a0" := struct.loadF paxosState "acceptedEpoch" (![ptrT] "ps") in
      do:  struct.storeF enterNewEpochReply "acceptedEpoch" (![ptrT] "reply") "$a0";;;
      let: "$a0" := struct.loadF paxosState "nextIndex" (![ptrT] "ps") in
      do:  struct.storeF enterNewEpochReply "nextIndex" (![ptrT] "reply") "$a0";;;
      let: "$a0" := struct.loadF paxosState "state" (![ptrT] "ps") in
      do:  struct.storeF enterNewEpochReply "state" (![ptrT] "reply") "$a0";;;
      do:  #()
      );;;
    do:  #().

Definition Server__TryBecomeLeader: val :=
  rec: "Server__TryBecomeLeader" "s" :=
    let: "s" := ref_to ptrT "s" in
    do:  log.Println #(str "started trybecomeleader");;;
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    (if: struct.loadF paxosState "isLeader" (struct.loadF Server "ps" (![ptrT] "s"))
    then
      do:  log.Println #(str "already leader");;;
      do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
      return: (#());;;
      do:  #()
    else #());;;
    let: "clerks" := ref_zero (slice.T ptrT) in
    let: "$a0" := struct.loadF Server "clerks" (![ptrT] "s") in
    do:  "clerks" <-[slice.T ptrT] "$a0";;;
    let: "args" := ref_zero ptrT in
    let: "$a0" := struct.new enterNewEpochArgs [
      "epoch" ::= (struct.loadF paxosState "epoch" (struct.loadF Server "ps" (![ptrT] "s"))) + #1
    ] in
    do:  "args" <-[ptrT] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    let: "numReplies" := ref_to uint64T #0 in
    let: "replies" := ref_zero (slice.T ptrT) in
    let: "$a0" := NewSlice ptrT (slice.len (![slice.T ptrT] "clerks")) in
    do:  "replies" <-[slice.T ptrT] "$a0";;;
    let: "mu" := ref_zero ptrT in
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  "mu" <-[ptrT] "$a0";;;
    let: "numReplies_cond" := ref_zero ptrT in
    let: "$a0" := sync.NewCond (![ptrT] "mu") in
    do:  "numReplies_cond" <-[ptrT] "$a0";;;
    let: "n" := ref_zero uint64T in
    let: "$a0" := slice.len (![slice.T ptrT] "clerks") in
    do:  "n" <-[uint64T] "$a0";;;
    do:  ForSlice ptrT "i" "ck" (![slice.T ptrT] "clerks")
      (let: "ck" := ref_zero ptrT in
      let: "$a0" := ![ptrT] "ck" in
      do:  "ck" <-[ptrT] "$a0";;;
      let: "i" := ref_zero intT in
      let: "$a0" := ![intT] "i" in
      do:  "i" <-[intT] "$a0";;;
      do:  Fork (let: "reply" := ref_zero ptrT in
            let: "$a0" := singleClerk__enterNewEpoch (![ptrT] "ck") (![ptrT] "args") in
            do:  "reply" <-[ptrT] "$a0";;;
            do:  sync.Mutex__Lock (![ptrT] "mu");;;
            do:  "numReplies" <-[uint64T] ((![uint64T] "numReplies") + #1);;;
            let: "$a0" := ![ptrT] "reply" in
            do:  SliceSet ptrT (![slice.T ptrT] "replies") (![intT] "i") "$a0";;;
            (if: (#2 * (![uint64T] "numReplies")) > (![uint64T] "n")
            then
              do:  sync.Cond__Signal (![ptrT] "numReplies_cond");;;
              do:  #()
            else #());;;
            do:  sync.Mutex__Unlock (![ptrT] "mu");;;
            do:  #());;;
      do:  #());;;
    do:  sync.Mutex__Lock (![ptrT] "mu");;;
    (for: (λ: <>, (#2 * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, Skip) := λ: <>,
      do:  sync.Cond__Wait (![ptrT] "numReplies_cond");;;
      do:  #()).

Definition Server__TryAcquire: val :=
  rec: "Server__TryAcquire" "s" :=
    let: "s" := ref_to ptrT "s" in
    let: "retErr" := ref (zero_val Error) in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    (if: (~ (struct.loadF paxosState "isLeader" (struct.loadF Server "ps" (![ptrT] "s"))))
    then
      do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
      let: "n" := ref (zero_val ptrT) in
      return: (ENotLeader, ![ptrT] "n", slice.nil);;;
      do:  #()
    else #());;;
    let: "tryRelease" := ref_zero (arrowT unitT unitT) in
    let: "$a0" := (λ: <>,
      let: "$a0" := std.SumAssumeNoOverflow (struct.loadF paxosState "nextIndex" (struct.loadF Server "ps" (![ptrT] "s"))) #1 in
      do:  struct.storeF paxosState "nextIndex" (struct.loadF Server "ps" (![ptrT] "s")) "$a0";;;
      let: "args" := ref_zero ptrT in
      let: "$a0" := struct.new applyAsFollowerArgs [
        "epoch" ::= struct.loadF paxosState "epoch" (struct.loadF Server "ps" (![ptrT] "s"));
        "nextIndex" ::= struct.loadF paxosState "nextIndex" (struct.loadF Server "ps" (![ptrT] "s"));
        "state" ::= struct.loadF paxosState "state" (struct.loadF Server "ps" (![ptrT] "s"))
      ] in
      do:  "args" <-[ptrT] "$a0";;;
      let: "waitFn" := ref_zero (arrowT unitT unitT) in
      let: "$a0" := asyncfile.AsyncFile__Write (struct.loadF Server "storage" (![ptrT] "s")) (encodePaxosState (struct.loadF Server "ps" (![ptrT] "s"))) in
      do:  "waitFn" <-[(arrowT unitT unitT)] "$a0";;;
      do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
      do:  (![(arrowT unitT unitT)] "waitFn") #();;;
      let: "clerks" := ref_zero (slice.T ptrT) in
      let: "$a0" := struct.loadF Server "clerks" (![ptrT] "s") in
      do:  "clerks" <-[slice.T ptrT] "$a0";;;
      let: "numReplies" := ref_to uint64T #0 in
      let: "replies" := ref_zero (slice.T ptrT) in
      let: "$a0" := NewSlice ptrT (slice.len (![slice.T ptrT] "clerks")) in
      do:  "replies" <-[slice.T ptrT] "$a0";;;
      let: "mu" := ref_zero ptrT in
      let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
      do:  "mu" <-[ptrT] "$a0";;;
      let: "numReplies_cond" := ref_zero ptrT in
      let: "$a0" := sync.NewCond (![ptrT] "mu") in
      do:  "numReplies_cond" <-[ptrT] "$a0";;;
      let: "n" := ref_zero uint64T in
      let: "$a0" := slice.len (![slice.T ptrT] "clerks") in
      do:  "n" <-[uint64T] "$a0";;;
      do:  ForSlice ptrT "i" "ck" (![slice.T ptrT] "clerks")
        (let: "ck" := ref_zero ptrT in
        let: "$a0" := ![ptrT] "ck" in
        do:  "ck" <-[ptrT] "$a0";;;
        let: "i" := ref_zero intT in
        let: "$a0" := ![intT] "i" in
        do:  "i" <-[intT] "$a0";;;
        do:  Fork (let: "reply" := ref_zero ptrT in
              let: "$a0" := singleClerk__applyAsFollower (![ptrT] "ck") (![ptrT] "args") in
              do:  "reply" <-[ptrT] "$a0";;;
              do:  sync.Mutex__Lock (![ptrT] "mu");;;
              do:  "numReplies" <-[uint64T] ((![uint64T] "numReplies") + #1);;;
              let: "$a0" := ![ptrT] "reply" in
              do:  SliceSet ptrT (![slice.T ptrT] "replies") (![intT] "i") "$a0";;;
              (if: (#2 * (![uint64T] "numReplies")) > (![uint64T] "n")
              then
                do:  sync.Cond__Signal (![ptrT] "numReplies_cond");;;
                do:  #()
              else #());;;
              do:  sync.Mutex__Unlock (![ptrT] "mu");;;
              do:  #());;;
        do:  #());;;
      do:  sync.Mutex__Lock (![ptrT] "mu");;;
      (for: (λ: <>, (#2 * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, Skip) := λ: <>,
        do:  sync.Cond__Wait (![ptrT] "numReplies_cond");;;
        do:  #())
      ) in
    do:  "tryRelease" <-[(arrowT unitT unitT)] "$a0";;;
    return: (ENone, struct.fieldRef paxosState "state" (struct.loadF Server "ps" (![ptrT] "s")), ![(arrowT unitT unitT)] "tryRelease");;;
    do:  #().

Definition Server__WeakRead: val :=
  rec: "Server__WeakRead" "s" :=
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF Server "mu" (![ptrT] "s"));;;
    let: "ret" := ref_zero (slice.T byteT) in
    let: "$a0" := struct.loadF paxosState "state" (struct.loadF Server "ps" (![ptrT] "s")) in
    do:  "ret" <-[slice.T byteT] "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Server "mu" (![ptrT] "s"));;;
    return: (![slice.T byteT] "ret");;;
    do:  #().

Definition makeServer: val :=
  rec: "makeServer" "fname" "initstate" "config" :=
    let: "config" := ref_to (slice.T uint64T) "config" in
    let: "initstate" := ref_to (slice.T byteT) "initstate" in
    let: "fname" := ref_to stringT "fname" in
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc Server (zero_val (struct.t Server)) in
    do:  "s" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF Server "mu" (![ptrT] "s") "$a0";;;
    let: "$a0" := NewSlice ptrT #0 in
    do:  struct.storeF Server "clerks" (![ptrT] "s") "$a0";;;
    do:  ForSlice uint64T <> "host" (![slice.T uint64T] "config")
      (let: "$a0" := SliceAppend ptrT (struct.loadF Server "clerks" (![ptrT] "s")) (MakeSingleClerk (![uint64T] "host")) in
      do:  struct.storeF Server "clerks" (![ptrT] "s") "$a0";;;
      do:  #());;;
    let: "encstate" := ref (zero_val (slice.T byteT)) in
    let: ("$a0", "$a1") := asyncfile.MakeAsyncFile (![stringT] "fname") in
    do:  struct.storeF Server "storage" (![ptrT] "s") "$a1";;;
    do:  "encstate" <-[slice.T byteT] "$a0";;;
    (if: (slice.len (![slice.T byteT] "encstate")) = #0
    then
      let: "$a0" := struct.alloc paxosState (zero_val (struct.t paxosState)) in
      do:  struct.storeF Server "ps" (![ptrT] "s") "$a0";;;
      let: "$a0" := ![slice.T byteT] "initstate" in
      do:  struct.storeF paxosState "state" (struct.loadF Server "ps" (![ptrT] "s")) "$a0";;;
      do:  #()
    else
      let: "$a0" := decodePaxosState (![slice.T byteT] "encstate") in
      do:  struct.storeF Server "ps" (![ptrT] "s") "$a0";;;
      do:  #());;;
    return: (![ptrT] "s");;;
    do:  #().

Definition StartServer: val :=
  rec: "StartServer" "fname" "initstate" "me" "config" :=
    let: "config" := ref_to (slice.T uint64T) "config" in
    let: "me" := ref_to uint64T "me" in
    let: "initstate" := ref_to (slice.T byteT) "initstate" in
    let: "fname" := ref_to stringT "fname" in
    let: "s" := ref_zero ptrT in
    let: "$a0" := makeServer (![stringT] "fname") (![slice.T byteT] "initstate") (![slice.T uint64T] "config") in
    do:  "s" <-[ptrT] "$a0";;;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      let: "reply" := ref_zero ptrT in
      let: "$a0" := struct.alloc applyAsFollowerReply (zero_val (struct.t applyAsFollowerReply)) in
      do:  "reply" <-[ptrT] "$a0";;;
      let: "args" := ref_zero ptrT in
      let: "$a0" := decodeApplyAsFollowerArgs (![slice.T byteT] "raw_args") in
      do:  "args" <-[ptrT] "$a0";;;
      do:  Server__applyAsFollower (![ptrT] "s") (![ptrT] "args") (![ptrT] "reply");;;
      let: "$a0" := encodeApplyAsFollowerReply (![ptrT] "reply") in
      do:  (![ptrT] "raw_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_APPLY_AS_FOLLOWER "$a0";;;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      let: "reply" := ref_zero ptrT in
      let: "$a0" := struct.alloc enterNewEpochReply (zero_val (struct.t enterNewEpochReply)) in
      do:  "reply" <-[ptrT] "$a0";;;
      let: "args" := ref_zero ptrT in
      let: "$a0" := decodeEnterNewEpochArgs (![slice.T byteT] "raw_args") in
      do:  "args" <-[ptrT] "$a0";;;
      do:  Server__enterNewEpoch (![ptrT] "s") (![ptrT] "args") (![ptrT] "reply");;;
      let: "$a0" := encodeEnterNewEpochReply (![ptrT] "reply") in
      do:  (![ptrT] "raw_reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_ENTER_NEW_EPOCH "$a0";;;
    let: "$a0" := (λ: "raw_args" "raw_reply",
      do:  Server__TryBecomeLeader (![ptrT] "s");;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") RPC_BECOME_LEADER "$a0";;;
    let: "r" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    do:  "r" <-[ptrT] "$a0";;;
    do:  urpc.Server__Serve (![ptrT] "r") (![uint64T] "me");;;
    return: (![ptrT] "s");;;
    do:  #().
