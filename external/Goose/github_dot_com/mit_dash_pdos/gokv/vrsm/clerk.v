(* autogenerated from github.com/mit-pdos/gokv/vrsm/clerk *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.trusted__proph.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.configservice.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.e.
From Goose Require github_dot_com.mit_dash_pdos.gokv.vrsm.replica.
From Goose Require github_dot_com.tchajed.goose.machine.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 1 second *)
Definition PreferenceRefreshTime : expr := #1000000000.

Definition Clerk := struct.decl [
  "confCk" :: ptrT;
  "replicaClerks" :: slice.T ptrT;
  "preferredReplica" :: uint64T;
  "lastPreferenceRefresh" :: uint64T
].

Definition makeClerks: val :=
  rec: "makeClerks" "servers" :=
    let: "servers" := ref_to (slice.T uint64T) "servers" in
    let: "clerks" := ref_zero (slice.T ptrT) in
    let: "$a0" := NewSlice ptrT (slice.len (![slice.T uint64T] "servers")) in
    do:  "clerks" <-[slice.T ptrT] "$a0";;;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < (slice.len (![slice.T ptrT] "clerks"))); (λ: <>, Skip) := λ: <>,
      let: "$a0" := replica.MakeClerk (SliceGet uint64T (![slice.T uint64T] "servers") (![uint64T] "i")) in
      do:  SliceSet ptrT (![slice.T ptrT] "clerks") (![uint64T] "i") "$a0";;;
      do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
      do:  #()).

Definition Make: val :=
  rec: "Make" "confHosts" :=
    let: "confHosts" := ref_to (slice.T uint64T) "confHosts" in
    let: "ck" := ref_zero ptrT in
    let: "$a0" := struct.alloc Clerk (zero_val (struct.t Clerk)) in
    do:  "ck" <-[ptrT] "$a0";;;
    let: "$a0" := configservice.MakeClerk (![slice.T uint64T] "confHosts") in
    do:  struct.storeF Clerk "confCk" (![ptrT] "ck") "$a0";;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "config" := ref_zero (slice.T uint64T) in
      let: "$a0" := configservice.Clerk__GetConfig (struct.loadF Clerk "confCk" (![ptrT] "ck")) in
      do:  "config" <-[slice.T uint64T] "$a0";;;
      (if: (slice.len (![slice.T uint64T] "config")) = #0
      then
        continue: #();;;
        do:  #()
      else
        let: "$a0" := makeClerks (![slice.T uint64T] "config") in
        do:  struct.storeF Clerk "replicaClerks" (![ptrT] "ck") "$a0";;;
        break: #();;;
        do:  #());;;
      do:  #()).

(* will retry forever *)
Definition Clerk__Apply: val :=
  rec: "Clerk__Apply" "ck" "op" :=
    let: "op" := ref_to (slice.T byteT) "op" in
    let: "ck" := ref_to ptrT "ck" in
    let: "ret" := ref (zero_val (slice.T byteT)) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := ref (zero_val uint64T) in
      let: ("$a0", "$a1") := replica.Clerk__Apply (SliceGet ptrT (struct.loadF Clerk "replicaClerks" (![ptrT] "ck")) #0) (![slice.T byteT] "op") in
      do:  "ret" <-[slice.T byteT] "$a1";;;
      do:  "err" <-[uint64T] "$a0";;;
      (if: (![uint64T] "err") = e.None
      then
        break: #();;;
        do:  #()
      else
        do:  machine.Sleep (#100 * #1000000);;;
        let: "config" := ref_zero (slice.T uint64T) in
        let: "$a0" := configservice.Clerk__GetConfig (struct.loadF Clerk "confCk" (![ptrT] "ck")) in
        do:  "config" <-[slice.T uint64T] "$a0";;;
        (if: (slice.len (![slice.T uint64T] "config")) > #0
        then
          let: "$a0" := makeClerks (![slice.T uint64T] "config") in
          do:  struct.storeF Clerk "replicaClerks" (![ptrT] "ck") "$a0";;;
          do:  #()
        else #());;;
        continue: #();;;
        do:  #());;;
      do:  #()).

Definition Clerk__maybeRefreshPreference: val :=
  rec: "Clerk__maybeRefreshPreference" "ck" :=
    let: "ck" := ref_to ptrT "ck" in
    let: <> := ref_zero uint64T in
    let: "now" := ref_zero uint64T in
    let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
    do:  "$a1";;;
    do:  "now" <-[uint64T] "$a0";;;
    (if: (![uint64T] "now") > ((struct.loadF Clerk "lastPreferenceRefresh" (![ptrT] "ck")) + PreferenceRefreshTime)
    then
      let: "$a0" := (machine.RandomUint64 #()) `rem` (slice.len (struct.loadF Clerk "replicaClerks" (![ptrT] "ck"))) in
      do:  struct.storeF Clerk "preferredReplica" (![ptrT] "ck") "$a0";;;
      let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
      do:  "$a1";;;
      do:  struct.storeF Clerk "lastPreferenceRefresh" (![ptrT] "ck") "$a0";;;
      do:  #()
    else #());;;
    do:  #().

Definition Clerk__ApplyRo2: val :=
  rec: "Clerk__ApplyRo2" "ck" "op" :=
    let: "op" := ref_to (slice.T byteT) "op" in
    let: "ck" := ref_to ptrT "ck" in
    let: "ret" := ref (zero_val (slice.T byteT)) in
    do:  Clerk__maybeRefreshPreference (![ptrT] "ck");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "offset" := ref_zero uint64T in
      let: "$a0" := struct.loadF Clerk "preferredReplica" (![ptrT] "ck") in
      do:  "offset" <-[uint64T] "$a0";;;
      let: "err" := ref (zero_val uint64T) in
      let: "i" := ref (zero_val uint64T) in
      (for: (λ: <>, (![uint64T] "i") < (slice.len (struct.loadF Clerk "replicaClerks" (![ptrT] "ck")))); (λ: <>, Skip) := λ: <>,
        let: "k" := ref_zero uint64T in
        let: "$a0" := ((![uint64T] "i") + (![uint64T] "offset")) `rem` (slice.len (struct.loadF Clerk "replicaClerks" (![ptrT] "ck"))) in
        do:  "k" <-[uint64T] "$a0";;;
        let: ("$a0", "$a1") := replica.Clerk__ApplyRo (SliceGet ptrT (struct.loadF Clerk "replicaClerks" (![ptrT] "ck")) (![uint64T] "k")) (![slice.T byteT] "op") in
        do:  "ret" <-[slice.T byteT] "$a1";;;
        do:  "err" <-[uint64T] "$a0";;;
        (if: (![uint64T] "err") = e.None
        then
          let: "$a0" := ![uint64T] "k" in
          do:  struct.storeF Clerk "preferredReplica" (![ptrT] "ck") "$a0";;;
          break: #();;;
          do:  #()
        else #());;;
        do:  "i" <-[uint64T] ((![uint64T] "i") + #1);;;
        let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
        do:  "$a1";;;
        do:  struct.storeF Clerk "lastPreferenceRefresh" (![ptrT] "ck") "$a0";;;
        continue: #();;;
        do:  #())).

Definition Clerk__ApplyRo: val :=
  rec: "Clerk__ApplyRo" "ck" "op" :=
    let: "op" := ref_to (slice.T byteT) "op" in
    let: "ck" := ref_to ptrT "ck" in
    let: "p" := ref_zero ProphIdT in
    let: "$a0" := trusted__proph.NewProph #() in
    do:  "p" <-[ProphIdT] "$a0";;;
    let: "v" := ref_zero (slice.T byteT) in
    let: "$a0" := Clerk__ApplyRo2 (![ptrT] "ck") (![slice.T byteT] "op") in
    do:  "v" <-[slice.T byteT] "$a0";;;
    do:  trusted__proph.ResolveBytes (![ProphIdT] "p") (![slice.T byteT] "v");;;
    return: (![slice.T byteT] "v");;;
    do:  #().
