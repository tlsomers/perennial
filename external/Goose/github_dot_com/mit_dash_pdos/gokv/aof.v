(* autogenerated from github.com/mit-pdos/gokv/aof *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition AppendOnlyFile := struct.decl [
  "mu" :: ptrT;
  "oldDurableCond" :: ptrT;
  "durableCond" :: ptrT;
  "lengthCond" :: ptrT;
  "membuf" :: slice.T byteT;
  "length" :: uint64T;
  "durableLength" :: uint64T;
  "closeRequested" :: boolT;
  "closed" :: boolT;
  "closedCond" :: ptrT
].

Definition CreateAppendOnlyFile: val :=
  rec: "CreateAppendOnlyFile" "fname" :=
    let: "fname" := ref_to stringT "fname" in
    let: "a" := ref_zero ptrT in
    let: "$a0" := struct.alloc AppendOnlyFile (zero_val (struct.t AppendOnlyFile)) in
    do:  "a" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF AppendOnlyFile "mu" (![ptrT] "a") "$a0";;;
    let: "$a0" := sync.NewCond (struct.loadF AppendOnlyFile "mu" (![ptrT] "a")) in
    do:  struct.storeF AppendOnlyFile "lengthCond" (![ptrT] "a") "$a0";;;
    let: "$a0" := sync.NewCond (struct.loadF AppendOnlyFile "mu" (![ptrT] "a")) in
    do:  struct.storeF AppendOnlyFile "oldDurableCond" (![ptrT] "a") "$a0";;;
    let: "$a0" := sync.NewCond (struct.loadF AppendOnlyFile "mu" (![ptrT] "a")) in
    do:  struct.storeF AppendOnlyFile "durableCond" (![ptrT] "a") "$a0";;;
    let: "$a0" := sync.NewCond (struct.loadF AppendOnlyFile "mu" (![ptrT] "a")) in
    do:  struct.storeF AppendOnlyFile "closedCond" (![ptrT] "a") "$a0";;;
    do:  Fork (do:  sync.Mutex__Lock (struct.loadF AppendOnlyFile "mu" (![ptrT] "a"));;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            (if: ((slice.len (struct.loadF AppendOnlyFile "membuf" (![ptrT] "a"))) = #0) && (~ (struct.loadF AppendOnlyFile "closeRequested" (![ptrT] "a")))
            then
              do:  sync.Cond__Wait (struct.loadF AppendOnlyFile "lengthCond" (![ptrT] "a"));;;
              continue: #();;;
              do:  #()
            else #());;;
            (if: struct.loadF AppendOnlyFile "closeRequested" (![ptrT] "a")
            then
              do:  grove__ffi.FileAppend (![stringT] "fname") (struct.loadF AppendOnlyFile "membuf" (![ptrT] "a"));;;
              let: "$a0" := NewSlice byteT #0 in
              do:  struct.storeF AppendOnlyFile "membuf" (![ptrT] "a") "$a0";;;
              let: "$a0" := struct.loadF AppendOnlyFile "length" (![ptrT] "a") in
              do:  struct.storeF AppendOnlyFile "durableLength" (![ptrT] "a") "$a0";;;
              do:  sync.Cond__Broadcast (struct.loadF AppendOnlyFile "durableCond" (![ptrT] "a"));;;
              let: "$a0" := #true in
              do:  struct.storeF AppendOnlyFile "closed" (![ptrT] "a") "$a0";;;
              do:  sync.Cond__Broadcast (struct.loadF AppendOnlyFile "closedCond" (![ptrT] "a"));;;
              do:  sync.Mutex__Unlock (struct.loadF AppendOnlyFile "mu" (![ptrT] "a"));;;
              break: #();;;
              do:  #()
            else #());;;
            let: "l" := ref_zero (slice.T byteT) in
            let: "$a0" := struct.loadF AppendOnlyFile "membuf" (![ptrT] "a") in
            do:  "l" <-[slice.T byteT] "$a0";;;
            let: "newLength" := ref_zero uint64T in
            let: "$a0" := struct.loadF AppendOnlyFile "length" (![ptrT] "a") in
            do:  "newLength" <-[uint64T] "$a0";;;
            let: "$a0" := NewSlice byteT #0 in
            do:  struct.storeF AppendOnlyFile "membuf" (![ptrT] "a") "$a0";;;
            let: "cond" := ref_zero ptrT in
            let: "$a0" := struct.loadF AppendOnlyFile "durableCond" (![ptrT] "a") in
            do:  "cond" <-[ptrT] "$a0";;;
            let: "$a0" := struct.loadF AppendOnlyFile "oldDurableCond" (![ptrT] "a") in
            do:  struct.storeF AppendOnlyFile "durableCond" (![ptrT] "a") "$a0";;;
            let: "$a0" := ![ptrT] "cond" in
            do:  struct.storeF AppendOnlyFile "oldDurableCond" (![ptrT] "a") "$a0";;;
            do:  sync.Mutex__Unlock (struct.loadF AppendOnlyFile "mu" (![ptrT] "a"));;;
            do:  grove__ffi.FileAppend (![stringT] "fname") (![slice.T byteT] "l");;;
            do:  sync.Mutex__Lock (struct.loadF AppendOnlyFile "mu" (![ptrT] "a"));;;
            let: "$a0" := ![uint64T] "newLength" in
            do:  struct.storeF AppendOnlyFile "durableLength" (![ptrT] "a") "$a0";;;
            do:  sync.Cond__Broadcast (![ptrT] "cond");;;
            continue: #();;;
            do:  #()));;;
    return: (![ptrT] "a");;;
    do:  #().

(* NOTE: cannot be called concurrently with Append() *)
Definition AppendOnlyFile__Close: val :=
  rec: "AppendOnlyFile__Close" "a" :=
    let: "a" := ref_to ptrT "a" in
    do:  sync.Mutex__Lock (struct.loadF AppendOnlyFile "mu" (![ptrT] "a"));;;
    let: "$a0" := #true in
    do:  struct.storeF AppendOnlyFile "closeRequested" (![ptrT] "a") "$a0";;;
    do:  sync.Cond__Signal (struct.loadF AppendOnlyFile "lengthCond" (![ptrT] "a"));;;
    (for: (λ: <>, (~ (struct.loadF AppendOnlyFile "closed" (![ptrT] "a")))); (λ: <>, Skip) := λ: <>,
      do:  sync.Cond__Wait (struct.loadF AppendOnlyFile "closedCond" (![ptrT] "a"));;;
      do:  #()).

(* NOTE: cannot be called concurrently with Close() *)
Definition AppendOnlyFile__Append: val :=
  rec: "AppendOnlyFile__Append" "a" "data" :=
    let: "data" := ref_to (slice.T byteT) "data" in
    let: "a" := ref_to ptrT "a" in
    do:  sync.Mutex__Lock (struct.loadF AppendOnlyFile "mu" (![ptrT] "a"));;;
    let: "$a0" := marshal.WriteBytes (struct.loadF AppendOnlyFile "membuf" (![ptrT] "a")) (![slice.T byteT] "data") in
    do:  struct.storeF AppendOnlyFile "membuf" (![ptrT] "a") "$a0";;;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF AppendOnlyFile "length" (![ptrT] "a")) (slice.len (![slice.T byteT] "data")) in
    do:  struct.storeF AppendOnlyFile "length" (![ptrT] "a") "$a0";;;
    let: "r" := ref_zero uint64T in
    let: "$a0" := struct.loadF AppendOnlyFile "length" (![ptrT] "a") in
    do:  "r" <-[uint64T] "$a0";;;
    do:  sync.Cond__Signal (struct.loadF AppendOnlyFile "lengthCond" (![ptrT] "a"));;;
    do:  sync.Mutex__Unlock (struct.loadF AppendOnlyFile "mu" (![ptrT] "a"));;;
    return: (![uint64T] "r");;;
    do:  #().

Definition AppendOnlyFile__WaitAppend: val :=
  rec: "AppendOnlyFile__WaitAppend" "a" "length" :=
    let: "length" := ref_to uint64T "length" in
    let: "a" := ref_to ptrT "a" in
    do:  sync.Mutex__Lock (struct.loadF AppendOnlyFile "mu" (![ptrT] "a"));;;
    let: "cond" := ref (zero_val ptrT) in
    (if: ((![uint64T] "length") + (slice.len (struct.loadF AppendOnlyFile "membuf" (![ptrT] "a")))) ≤ (struct.loadF AppendOnlyFile "length" (![ptrT] "a"))
    then
      let: "$a0" := struct.loadF AppendOnlyFile "oldDurableCond" (![ptrT] "a") in
      do:  "cond" <-[ptrT] "$a0";;;
      do:  #()
    else
      let: "$a0" := struct.loadF AppendOnlyFile "durableCond" (![ptrT] "a") in
      do:  "cond" <-[ptrT] "$a0";;;
      do:  #());;;
    (for: (λ: <>, (struct.loadF AppendOnlyFile "durableLength" (![ptrT] "a")) < (![uint64T] "length")); (λ: <>, Skip) := λ: <>,
      do:  sync.Cond__Wait (![ptrT] "cond");;;
      do:  #()).
