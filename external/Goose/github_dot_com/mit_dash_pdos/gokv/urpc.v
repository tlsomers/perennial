(* autogenerated from github.com/mit-pdos/gokv/urpc *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.goose_dash_lang.std.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.tchajed.goose.machine.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require log.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition Server := struct.decl [
  "handlers" :: mapT ((slice.T byteT) -> ptrT -> unitT)%ht
].

Definition Server__rpcHandle: val :=
  rec: "Server__rpcHandle" "srv" "conn" "rpcid" "seqno" "data" :=
    let: "data" := ref_to (slice.T byteT) "data" in
    let: "seqno" := ref_to uint64T "seqno" in
    let: "rpcid" := ref_to uint64T "rpcid" in
    let: "conn" := ref_to grove_ffi.Connection "conn" in
    let: "srv" := ref_to ptrT "srv" in
    let: "replyData" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "replyData" <-[ptrT] "$a0";;;
    let: "f" := ref_zero (arrowT unitT unitT) in
    let: "$a0" := Fst (MapGet (struct.loadF Server "handlers" (![ptrT] "srv")) (![uint64T] "rpcid")) in
    do:  "f" <-[(arrowT unitT unitT)] "$a0";;;
    do:  (![(arrowT unitT unitT)] "f") (![slice.T byteT] "data") (![ptrT] "replyData");;;
    let: "data1" := ref_zero (slice.T byteT) in
    let: "$a0" := NewSliceWithCap byteT #0 (#8 + (slice.len (![slice.T byteT] (![ptrT] "replyData")))) in
    do:  "data1" <-[slice.T byteT] "$a0";;;
    let: "data2" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "data1") (![uint64T] "seqno") in
    do:  "data2" <-[slice.T byteT] "$a0";;;
    let: "data3" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "data2") (![slice.T byteT] (![ptrT] "replyData")) in
    do:  "data3" <-[slice.T byteT] "$a0";;;
    do:  grove__ffi.Send (![grove_ffi.Connection] "conn") (![slice.T byteT] "data3");;;
    do:  #().

Definition MakeServer: val :=
  rec: "MakeServer" "handlers" :=
    let: "handlers" := ref_to (mapT ((slice.T byteT) -> ptrT -> unitT)%ht) "handlers" in
    return: (struct.new Server [
       "handlers" ::= ![mapT (arrowT unitT unitT)] "handlers"
     ]);;;
    do:  #().

Definition Server__readThread: val :=
  rec: "Server__readThread" "srv" "conn" :=
    let: "conn" := ref_to grove_ffi.Connection "conn" in
    let: "srv" := ref_to ptrT "srv" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "r" := ref_zero (struct.t grove_ffi.ReceiveRet) in
      let: "$a0" := grove__ffi.Receive (![grove_ffi.Connection] "conn") in
      do:  "r" <-[struct.t grove_ffi.ReceiveRet] "$a0";;;
      (if: struct.get grove_ffi.ReceiveRet "Err" (![struct.t grove_ffi.ReceiveRet] "r")
      then
        break: #();;;
        do:  #()
      else #());;;
      let: "data" := ref_zero (slice.T byteT) in
      let: "$a0" := struct.get grove_ffi.ReceiveRet "Data" (![struct.t grove_ffi.ReceiveRet] "r") in
      do:  "data" <-[slice.T byteT] "$a0";;;
      let: "rpcid" := ref_zero uint64T in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "data") in
      do:  "data" <-[slice.T byteT] "$a1";;;
      do:  "rpcid" <-[uint64T] "$a0";;;
      let: "seqno" := ref_zero uint64T in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "data") in
      do:  "data" <-[slice.T byteT] "$a1";;;
      do:  "seqno" <-[uint64T] "$a0";;;
      let: "req" := ref_zero (slice.T byteT) in
      let: "$a0" := ![slice.T byteT] "data" in
      do:  "req" <-[slice.T byteT] "$a0";;;
      do:  Fork (do:  Server__rpcHandle (![ptrT] "srv") (![grove_ffi.Connection] "conn") (![uint64T] "rpcid") (![uint64T] "seqno") (![slice.T byteT] "req");;;
            do:  #());;;
      continue: #();;;
      do:  #()).

Definition Server__Serve: val :=
  rec: "Server__Serve" "srv" "host" :=
    let: "host" := ref_to uint64T "host" in
    let: "srv" := ref_to ptrT "srv" in
    let: "listener" := ref_zero grove_ffi.Listener in
    let: "$a0" := grove__ffi.Listen (![uint64T] "host") in
    do:  "listener" <-[grove_ffi.Listener] "$a0";;;
    do:  Fork ((for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            let: "conn" := ref_zero grove_ffi.Connection in
            let: "$a0" := grove__ffi.Accept (![grove_ffi.Listener] "listener") in
            do:  "conn" <-[grove_ffi.Connection] "$a0";;;
            do:  Fork (do:  Server__readThread (![ptrT] "srv") (![grove_ffi.Connection] "conn");;;
                  do:  #());;;
            do:  #()));;;
    do:  #().

Definition callbackStateWaiting : expr := #0.

Definition callbackStateDone : expr := #1.

Definition callbackStateAborted : expr := #2.

Definition Callback := struct.decl [
  "reply" :: ptrT;
  "state" :: ptrT;
  "cond" :: ptrT
].

Definition Client := struct.decl [
  "mu" :: ptrT;
  "conn" :: grove_ffi.Connection;
  "seq" :: uint64T;
  "pending" :: mapT ptrT
].

Definition Client__replyThread: val :=
  rec: "Client__replyThread" "cl" :=
    let: "cl" := ref_to ptrT "cl" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "r" := ref_zero (struct.t grove_ffi.ReceiveRet) in
      let: "$a0" := grove__ffi.Receive (struct.loadF Client "conn" (![ptrT] "cl")) in
      do:  "r" <-[struct.t grove_ffi.ReceiveRet] "$a0";;;
      (if: struct.get grove_ffi.ReceiveRet "Err" (![struct.t grove_ffi.ReceiveRet] "r")
      then
        do:  sync.Mutex__Lock (struct.loadF Client "mu" (![ptrT] "cl"));;;
        do:  MapIter (struct.loadF Client "pending" (![ptrT] "cl")) (λ: <> "cb",
          let: "$a0" := callbackStateAborted in
          do:  (struct.loadF Callback "state" (![ptrT] "cb")) <-[uint64T] "$a0";;;
          do:  sync.Cond__Signal (struct.loadF Callback "cond" (![ptrT] "cb"));;;
          do:  #());;;
        do:  sync.Mutex__Unlock (struct.loadF Client "mu" (![ptrT] "cl"));;;
        break: #();;;
        do:  #()
      else #());;;
      let: "data" := ref_zero (slice.T byteT) in
      let: "$a0" := struct.get grove_ffi.ReceiveRet "Data" (![struct.t grove_ffi.ReceiveRet] "r") in
      do:  "data" <-[slice.T byteT] "$a0";;;
      let: "seqno" := ref_zero uint64T in
      let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "data") in
      do:  "data" <-[slice.T byteT] "$a1";;;
      do:  "seqno" <-[uint64T] "$a0";;;
      let: "reply" := ref_zero (slice.T byteT) in
      let: "$a0" := ![slice.T byteT] "data" in
      do:  "reply" <-[slice.T byteT] "$a0";;;
      do:  sync.Mutex__Lock (struct.loadF Client "mu" (![ptrT] "cl"));;;
      let: "ok" := ref_zero boolT in
      let: "cb" := ref_zero ptrT in
      let: ("$a0", "$a1") := Fst (MapGet (struct.loadF Client "pending" (![ptrT] "cl")) (![uint64T] "seqno")) in
      do:  "ok" <-[boolT] "$a1";;;
      do:  "cb" <-[ptrT] "$a0";;;
      (if: ![boolT] "ok"
      then
        do:  MapDelete (struct.loadF Client "pending" (![ptrT] "cl")) (![uint64T] "seqno");;;
        let: "$a0" := ![slice.T byteT] "reply" in
        do:  (struct.loadF Callback "reply" (![ptrT] "cb")) <-[slice.T byteT] "$a0";;;
        let: "$a0" := callbackStateDone in
        do:  (struct.loadF Callback "state" (![ptrT] "cb")) <-[uint64T] "$a0";;;
        do:  sync.Cond__Signal (struct.loadF Callback "cond" (![ptrT] "cb"));;;
        do:  #()
      else #());;;
      do:  sync.Mutex__Unlock (struct.loadF Client "mu" (![ptrT] "cl"));;;
      continue: #();;;
      do:  #()).

Definition TryMakeClient: val :=
  rec: "TryMakeClient" "host_name" :=
    let: "host_name" := ref_to uint64T "host_name" in
    let: "host" := ref_zero uint64T in
    let: "$a0" := ![uint64T] "host_name" in
    do:  "host" <-[uint64T] "$a0";;;
    let: "a" := ref_zero (struct.t grove_ffi.ConnectRet) in
    let: "$a0" := grove__ffi.Connect (![uint64T] "host") in
    do:  "a" <-[struct.t grove_ffi.ConnectRet] "$a0";;;
    let: "nilClient" := ref (zero_val ptrT) in
    (if: struct.get grove_ffi.ConnectRet "Err" (![struct.t grove_ffi.ConnectRet] "a")
    then
      return: (#1, ![ptrT] "nilClient");;;
      do:  #()
    else #());;;
    let: "cl" := ref_zero ptrT in
    let: "$a0" := struct.new Client [
      "conn" ::= struct.get grove_ffi.ConnectRet "Connection" (![struct.t grove_ffi.ConnectRet] "a");
      "mu" ::= struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex));
      "seq" ::= #1;
      "pending" ::= NewMap uint64T ptrT #()
    ] in
    do:  "cl" <-[ptrT] "$a0";;;
    do:  Fork (do:  Client__replyThread (![ptrT] "cl");;;
          do:  #());;;
    return: (#0, ![ptrT] "cl");;;
    do:  #().

Definition MakeClient: val :=
  rec: "MakeClient" "host_name" :=
    let: "host_name" := ref_to uint64T "host_name" in
    let: "cl" := ref_zero ptrT in
    let: "err" := ref_zero uint64T in
    let: ("$a0", "$a1") := TryMakeClient (![uint64T] "host_name") in
    do:  "cl" <-[ptrT] "$a1";;;
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") ≠ #0
    then
      do:  log.Printf #(str "Unable to connect to %!!(MISSING)!(MISSING)!(MISSING)!(MISSING)!(MISSING)s(MISSING)") (grove__ffi.AddressToStr (![uint64T] "host_name"));;;
      do:  #()
    else #());;;
    do:  machine.Assume ((![uint64T] "err") = #0);;;
    return: (![ptrT] "cl");;;
    do:  #().

Definition Error: ty := uint64T.

Definition ErrNone : expr := #0.

Definition ErrTimeout : expr := #1.

Definition ErrDisconnect : expr := #2.

Definition Client__CallStart: val :=
  rec: "Client__CallStart" "cl" "rpcid" "args" :=
    let: "args" := ref_to (slice.T byteT) "args" in
    let: "rpcid" := ref_to uint64T "rpcid" in
    let: "cl" := ref_to ptrT "cl" in
    let: "reply_buf" := ref_zero ptrT in
    let: "$a0" := ref (zero_val (slice.T byteT)) in
    do:  "reply_buf" <-[ptrT] "$a0";;;
    let: "cb" := ref_zero ptrT in
    let: "$a0" := struct.new Callback [
      "reply" ::= ![ptrT] "reply_buf";
      "state" ::= ref (zero_val uint64T);
      "cond" ::= sync.NewCond (struct.loadF Client "mu" (![ptrT] "cl"))
    ] in
    do:  "cb" <-[ptrT] "$a0";;;
    let: "$a0" := callbackStateWaiting in
    do:  (struct.loadF Callback "state" (![ptrT] "cb")) <-[uint64T] "$a0";;;
    do:  sync.Mutex__Lock (struct.loadF Client "mu" (![ptrT] "cl"));;;
    let: "seqno" := ref_zero uint64T in
    let: "$a0" := struct.loadF Client "seq" (![ptrT] "cl") in
    do:  "seqno" <-[uint64T] "$a0";;;
    let: "$a0" := std.SumAssumeNoOverflow (struct.loadF Client "seq" (![ptrT] "cl")) #1 in
    do:  struct.storeF Client "seq" (![ptrT] "cl") "$a0";;;
    let: "$a0" := ![ptrT] "cb" in
    do:  MapInsert (struct.loadF Client "pending" (![ptrT] "cl")) (![uint64T] "seqno") "$a0";;;
    do:  sync.Mutex__Unlock (struct.loadF Client "mu" (![ptrT] "cl"));;;
    let: "data1" := ref_zero (slice.T byteT) in
    let: "$a0" := NewSliceWithCap byteT #0 ((#8 + #8) + (slice.len (![slice.T byteT] "args"))) in
    do:  "data1" <-[slice.T byteT] "$a0";;;
    let: "data2" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "data1") (![uint64T] "rpcid") in
    do:  "data2" <-[slice.T byteT] "$a0";;;
    let: "data3" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "data2") (![uint64T] "seqno") in
    do:  "data3" <-[slice.T byteT] "$a0";;;
    let: "reqData" := ref_zero (slice.T byteT) in
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "data3") (![slice.T byteT] "args") in
    do:  "reqData" <-[slice.T byteT] "$a0";;;
    (if: grove__ffi.Send (struct.loadF Client "conn" (![ptrT] "cl")) (![slice.T byteT] "reqData")
    then
      return: (struct.new Callback [
       ], ErrDisconnect);;;
      do:  #()
    else #());;;
    return: (![ptrT] "cb", ErrNone);;;
    do:  #().

Definition Client__CallComplete: val :=
  rec: "Client__CallComplete" "cl" "cb" "reply" "timeout_ms" :=
    let: "timeout_ms" := ref_to uint64T "timeout_ms" in
    let: "reply" := ref_to ptrT "reply" in
    let: "cb" := ref_to ptrT "cb" in
    let: "cl" := ref_to ptrT "cl" in
    do:  sync.Mutex__Lock (struct.loadF Client "mu" (![ptrT] "cl"));;;
    (if: (![uint64T] (struct.loadF Callback "state" (![ptrT] "cb"))) = callbackStateWaiting
    then
      do:  machine.WaitTimeout (struct.loadF Callback "cond" (![ptrT] "cb")) (![uint64T] "timeout_ms");;;
      do:  #()
    else #());;;
    let: "state" := ref_zero uint64T in
    let: "$a0" := ![uint64T] (struct.loadF Callback "state" (![ptrT] "cb")) in
    do:  "state" <-[uint64T] "$a0";;;
    (if: (![uint64T] "state") = callbackStateDone
    then
      let: "$a0" := ![slice.T byteT] (struct.loadF Callback "reply" (![ptrT] "cb")) in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      do:  sync.Mutex__Unlock (struct.loadF Client "mu" (![ptrT] "cl"));;;
      return: (#0);;;
      do:  #()
    else
      do:  sync.Mutex__Unlock (struct.loadF Client "mu" (![ptrT] "cl"));;;
      (if: (![uint64T] "state") = callbackStateAborted
      then
        return: (ErrDisconnect);;;
        do:  #()
      else
        return: (ErrTimeout);;;
        do:  #());;;
      do:  #());;;
    do:  #().

Definition Client__Call: val :=
  rec: "Client__Call" "cl" "rpcid" "args" "reply" "timeout_ms" :=
    let: "timeout_ms" := ref_to uint64T "timeout_ms" in
    let: "reply" := ref_to ptrT "reply" in
    let: "args" := ref_to (slice.T byteT) "args" in
    let: "rpcid" := ref_to uint64T "rpcid" in
    let: "cl" := ref_to ptrT "cl" in
    let: "err" := ref_zero uint64T in
    let: "cb" := ref_zero ptrT in
    let: ("$a0", "$a1") := Client__CallStart (![ptrT] "cl") (![uint64T] "rpcid") (![slice.T byteT] "args") in
    do:  "err" <-[uint64T] "$a1";;;
    do:  "cb" <-[ptrT] "$a0";;;
    (if: (![uint64T] "err") ≠ #0
    then
      return: (![uint64T] "err");;;
      do:  #()
    else #());;;
    return: (Client__CallComplete (![ptrT] "cl") (![ptrT] "cb") (![ptrT] "reply") (![uint64T] "timeout_ms"));;;
    do:  #().
