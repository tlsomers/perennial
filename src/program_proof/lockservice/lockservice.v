(* autogenerated from lockservice *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

From Perennial.program_proof.lockservice Require Import nondet.

(* common.go *)

(* Lock(lockname) returns OK=true if the lock is not held.
   If it is held, it returns OK=false immediately. *)
Module TryLockArgs.
  Definition S := struct.decl [
    "Lockname" :: uint64T;
    "CID" :: uint64T;
    "Seq" :: uint64T
  ].
End TryLockArgs.

Module TryLockReply.
  Definition S := struct.decl [
    "OK" :: boolT;
    "Stale" :: boolT
  ].
End TryLockReply.

(* Unlock(lockname) returns OK=true if the lock was held.
   It returns OK=false if the lock was not held. *)
Module UnlockArgs.
  Definition S := struct.decl [
    "Lockname" :: uint64T;
    "CID" :: uint64T;
    "Seq" :: uint64T
  ].
End UnlockArgs.

Module UnlockReply.
  Definition S := struct.decl [
    "OK" :: boolT;
    "Stale" :: boolT
  ].
End UnlockReply.

Definition overflow_guard_incr: val :=
  rec: "overflow_guard_incr" "v" :=
    Skip;;
    (for: (λ: <>, "v" + #1 < "v"); (λ: <>, Skip) := λ: <>,
      Continue).

(* server.go *)

Module LockServer.
  Definition S := struct.decl [
    "mu" :: lockRefT;
    "locks" :: mapT boolT;
    "lastSeq" :: mapT uint64T;
    "lastReply" :: mapT boolT
  ].
End LockServer.

(* server Lock RPC handler.
   returns true iff error *)
Definition LockServer__TryLock: val :=
  rec: "LockServer__TryLock" "ls" "args" "reply" :=
    lock.acquire (struct.loadF LockServer.S "mu" "ls");;
    let: ("last", "ok") := MapGet (struct.loadF LockServer.S "lastSeq" "ls") (struct.loadF TryLockArgs.S "CID" "args") in
    struct.storeF TryLockReply.S "Stale" "reply" #false;;
    (if: "ok" && (struct.loadF TryLockArgs.S "Seq" "args" ≤ "last")
    then
      (if: struct.loadF TryLockArgs.S "Seq" "args" < "last"
      then
        struct.storeF TryLockReply.S "Stale" "reply" #true;;
        lock.release (struct.loadF LockServer.S "mu" "ls");;
        #false
      else
        struct.storeF TryLockReply.S "OK" "reply" (Fst (MapGet (struct.loadF LockServer.S "lastReply" "ls") (struct.loadF TryLockArgs.S "CID" "args")));;
        lock.release (struct.loadF LockServer.S "mu" "ls");;
        #false)
    else
      MapInsert (struct.loadF LockServer.S "lastSeq" "ls") (struct.loadF TryLockArgs.S "CID" "args") (struct.loadF TryLockArgs.S "Seq" "args");;
      let: ("locked", <>) := MapGet (struct.loadF LockServer.S "locks" "ls") (struct.loadF TryLockArgs.S "Lockname" "args") in
      (if: "locked"
      then struct.storeF TryLockReply.S "OK" "reply" #false
      else
        struct.storeF TryLockReply.S "OK" "reply" #true;;
        MapInsert (struct.loadF LockServer.S "locks" "ls") (struct.loadF TryLockArgs.S "Lockname" "args") #true);;
      MapInsert (struct.loadF LockServer.S "lastReply" "ls") (struct.loadF TryLockArgs.S "CID" "args") (struct.loadF TryLockReply.S "OK" "reply");;
      lock.release (struct.loadF LockServer.S "mu" "ls");;
      #false).

(* server Unlock RPC handler.
   returns true iff error *)
Definition LockServer__Unlock: val :=
  rec: "LockServer__Unlock" "ls" "args" "reply" :=
    lock.acquire (struct.loadF LockServer.S "mu" "ls");;
    let: ("last", "ok") := MapGet (struct.loadF LockServer.S "lastSeq" "ls") (struct.loadF UnlockArgs.S "CID" "args") in
    struct.storeF UnlockReply.S "Stale" "reply" #false;;
    (if: "ok" && (struct.loadF UnlockArgs.S "Seq" "args" ≤ "last")
    then
      (if: struct.loadF UnlockArgs.S "Seq" "args" < "last"
      then
        struct.storeF UnlockReply.S "Stale" "reply" #true;;
        lock.release (struct.loadF LockServer.S "mu" "ls");;
        #false
      else
        struct.storeF UnlockReply.S "OK" "reply" (Fst (MapGet (struct.loadF LockServer.S "lastReply" "ls") (struct.loadF UnlockArgs.S "CID" "args")));;
        lock.release (struct.loadF LockServer.S "mu" "ls");;
        #false)
    else
      MapInsert (struct.loadF LockServer.S "lastSeq" "ls") (struct.loadF UnlockArgs.S "CID" "args") (struct.loadF UnlockArgs.S "Seq" "args");;
      let: ("locked", <>) := MapGet (struct.loadF LockServer.S "locks" "ls") (struct.loadF UnlockArgs.S "Lockname" "args") in
      (if: "locked"
      then
        MapInsert (struct.loadF LockServer.S "locks" "ls") (struct.loadF UnlockArgs.S "Lockname" "args") #false;;
        struct.storeF UnlockReply.S "OK" "reply" #true
      else struct.storeF UnlockReply.S "OK" "reply" #false);;
      MapInsert (struct.loadF LockServer.S "lastReply" "ls") (struct.loadF UnlockArgs.S "CID" "args") (struct.loadF UnlockReply.S "OK" "reply");;
      lock.release (struct.loadF LockServer.S "mu" "ls");;
      #false).

Definition MakeServer: val :=
  rec: "MakeServer" <> :=
    let: "ls" := struct.alloc LockServer.S (zero_val (struct.t LockServer.S)) in
    struct.storeF LockServer.S "locks" "ls" (NewMap boolT);;
    struct.storeF LockServer.S "lastSeq" "ls" (NewMap uint64T);;
    struct.storeF LockServer.S "lastReply" "ls" (NewMap boolT);;
    struct.storeF LockServer.S "mu" "ls" (lock.new #());;
    "ls".

(* rpc.go *)

(* Returns true iff server reported error or request "timed out" *)
Definition CallTryLock: val :=
  rec: "CallTryLock" "srv" "args" "reply" :=
    Fork (let: "dummy_reply" := struct.alloc TryLockReply.S (zero_val (struct.t TryLockReply.S)) in
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            LockServer__TryLock "srv" "args" "dummy_reply";;
            Continue));;
    (if: nondet #()
    then LockServer__TryLock "srv" "args" "reply"
    else #true).

(* Returns true iff server reported error or request "timed out" *)
Definition CallUnlock: val :=
  rec: "CallUnlock" "srv" "args" "reply" :=
    Fork (let: "dummy_reply" := struct.alloc UnlockReply.S (zero_val (struct.t UnlockReply.S)) in
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            LockServer__Unlock "srv" "args" "dummy_reply";;
            Continue));;
    (if: nondet #()
    then LockServer__Unlock "srv" "args" "reply"
    else #true).

(* client.go *)

(* the lockservice Clerk lives in the client
   and maintains a little state. *)
Module Clerk.
  Definition S := struct.decl [
    "primary" :: struct.ptrT LockServer.S;
    "cid" :: uint64T;
    "seq" :: uint64T
  ].
End Clerk.

Definition MakeClerk: val :=
  rec: "MakeClerk" "primary" "cid" :=
    let: "ck" := struct.alloc Clerk.S (zero_val (struct.t Clerk.S)) in
    struct.storeF Clerk.S "primary" "ck" "primary";;
    struct.storeF Clerk.S "cid" "ck" "cid";;
    struct.storeF Clerk.S "seq" "ck" #1;;
    "ck".

Definition Clerk__TryLock: val :=
  rec: "Clerk__TryLock" "ck" "lockname" :=
    overflow_guard_incr (struct.loadF Clerk.S "seq" "ck");;
    let: "args" := ref_to (refT (struct.t TryLockArgs.S)) (struct.new TryLockArgs.S [
      "Lockname" ::= "lockname";
      "CID" ::= struct.loadF Clerk.S "cid" "ck";
      "Seq" ::= struct.loadF Clerk.S "seq" "ck"
    ]) in
    struct.storeF Clerk.S "seq" "ck" (struct.loadF Clerk.S "seq" "ck" + #1);;
    let: "errb" := ref_to boolT #false in
    let: "reply" := struct.alloc TryLockReply.S (zero_val (struct.t TryLockReply.S)) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      "errb" <-[boolT] CallTryLock (struct.loadF Clerk.S "primary" "ck") (![refT (struct.t TryLockArgs.S)] "args") "reply";;
      (if: (![boolT] "errb" = #false)
      then Break
      else Continue));;
    struct.loadF TryLockReply.S "OK" "reply".

(* ask the lock service to unlock a lock.
   returns true if the lock was previously held,
   false otherwise. *)
Definition Clerk__Unlock: val :=
  rec: "Clerk__Unlock" "ck" "lockname" :=
    overflow_guard_incr (struct.loadF Clerk.S "seq" "ck");;
    let: "args" := struct.new UnlockArgs.S [
      "Lockname" ::= "lockname";
      "CID" ::= struct.loadF Clerk.S "cid" "ck";
      "Seq" ::= struct.loadF Clerk.S "seq" "ck"
    ] in
    struct.storeF Clerk.S "seq" "ck" (struct.loadF Clerk.S "seq" "ck" + #1);;
    let: "errb" := ref (zero_val boolT) in
    let: "reply" := struct.alloc UnlockReply.S (zero_val (struct.t UnlockReply.S)) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      "errb" <-[boolT] CallUnlock (struct.loadF Clerk.S "primary" "ck") "args" "reply";;
      (if: (![boolT] "errb" = #false)
      then Break
      else Continue));;
    struct.loadF UnlockReply.S "OK" "reply".

(* Spins until we have the lock *)
Definition Clerk__Lock: val :=
  rec: "Clerk__Lock" "ck" "lockname" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: Clerk__TryLock "ck" "lockname"
      then Break
      else Continue));;
    #true.
