From iris.algebra Require Import mono_nat mono_list gmap_view gset.
From iris.algebra.lib Require Import dfrac_agree.
From Perennial.program_proof Require Import grove_prelude.
From Perennial.program_proof.tulip Require Import base.
From Perennial.program_proof.rsm Require Import big_sep.
From Perennial.program_proof.rsm.pure Require Import list fin_maps vslice.
From Perennial.program_proof.tulip Require Export res_txnsys res_group res_replica res_network.

(** This file contains resources exposed to the users or owned by multiple
subsystems. Resources onwed exclusively to one subsystem should be defined in
their respective files. *)

Section res.
  Context `{!tulip_ghostG Σ}.
  (* TODO: remove this once we have real defintions for resources. *)
  Implicit Type (γ : tulip_names).

  Section db_ptsto.

    (** Single-value logical database values. One half in the txnsys invariant,
    one half given to the client. *)

    Definition own_db_ptsto γ (k : dbkey) (v : dbval) : iProp Σ :=
      own γ.(db_ptsto) {[ k := (to_dfrac_agree (DfracOwn (1 / 2)) v) ]}.

    Definition own_db_ptstos γ (m : dbmap) : iProp Σ :=
      [∗ map] k ↦ v ∈ m, own_db_ptsto γ k v.

    Lemma db_ptsto_update {γ k v1 v2} v :
      own_db_ptsto γ k v1 -∗
      own_db_ptsto γ k v2 ==∗
      own_db_ptsto γ k v ∗ own_db_ptsto γ k v.
    Proof.
      iIntros "Hv1 Hv2".
      iCombine "Hv1 Hv2" as "Hv".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hv").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

    Lemma db_ptsto_agree γ k v1 v2 :
      own_db_ptsto γ k v1 -∗
      own_db_ptsto γ k v2 -∗
      ⌜v2 = v1⌝.
    Proof.
      iIntros "Hv1 Hv2".
      iDestruct (own_valid_2 with "Hv1 Hv2") as %Hvalid.
      rewrite singleton_op singleton_valid dfrac_agree_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

  End db_ptsto.

  Section repl_hist.

    (** History generated by replicated transactions for a certain key. One half
    owned by the txnsys invariant, the other by the key invariant. *)

    Definition own_repl_hist_half γ (k : dbkey) (h : dbhist) : iProp Σ :=
      own γ.(repl_hist) {[ k := ●ML{#(1 / 2)} h ]}.

    Definition is_repl_hist_lb γ (k : dbkey) (h : dbhist) : iProp Σ :=
      own γ.(repl_hist) {[ k := ◯ML h ]}.

    Definition is_repl_hist_at γ (k : dbkey) (ts : nat) (v : dbval) : iProp Σ :=
      ∃ lb, is_repl_hist_lb γ k lb ∗ ⌜lb !! ts = Some v⌝.

    #[global]
    Instance is_repl_hist_lb_persistent α key hist :
      Persistent (is_repl_hist_lb α key hist).
    Proof. apply _. Defined.

    Lemma repl_hist_agree {γ} k h1 h2 :
      own_repl_hist_half γ k h1 -∗
      own_repl_hist_half γ k h2 -∗
      ⌜h2 = h1⌝.
    Proof.
      iIntros "Hh1 Hh2".
      iDestruct (own_valid_2 with "Hh1 Hh2") as %Hvalid.
      rewrite singleton_op singleton_valid mono_list_auth_dfrac_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

    Lemma repl_hist_big_agree {γ histm1 histm2} :
      dom histm1 = dom histm2 ->
      ([∗ map] k ↦ ts ∈ histm1, own_repl_hist_half γ k ts) -∗
      ([∗ map] k ↦ ts ∈ histm2, own_repl_hist_half γ k ts) -∗
      ⌜histm2 = histm1⌝.
    Proof.
      iIntros (Hdom) "Hhistm1 Hhistm2".
      rewrite map_eq_iff.
      iIntros (k).
      destruct (histm1 !! k) as [h1 |] eqn:Hh1, (histm2 !! k) as [h2 |] eqn:Hh2.
      { iDestruct (big_sepM_lookup with "Hhistm1") as "Hh1"; first apply Hh1.
        iDestruct (big_sepM_lookup with "Hhistm2") as "Hh2"; first apply Hh2.
        by iDestruct (repl_hist_agree with "Hh1 Hh2") as %->.
      }
      { by rewrite -not_elem_of_dom -Hdom elem_of_dom Hh1 -eq_None_not_Some in Hh2. }
      { by rewrite -not_elem_of_dom Hdom elem_of_dom Hh2 -eq_None_not_Some in Hh1. }
      done.
    Qed.

    Lemma repl_hist_update {γ k h1} h2 :
      prefix h1 h2 ->
      own_repl_hist_half γ k h1 -∗
      own_repl_hist_half γ k h1 ==∗
      own_repl_hist_half γ k h2 ∗ own_repl_hist_half γ k h2.
    Proof.
      iIntros (Hprefix) "Hh1 Hh2".
      iCombine "Hh1 Hh2" as "Hh".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hh").
      rewrite -mono_list_auth_dfrac_op dfrac_op_own Qp.half_half.
      apply singleton_update.
      by apply mono_list_update.
    Qed.

    Lemma repl_hist_big_update {γ hs1} hs2 :
      map_Forall2 (λ _ h1 h2, prefix h1 h2) hs1 hs2 ->
      ([∗ map] k ↦ h ∈ hs1, own_repl_hist_half γ k h) -∗
      ([∗ map] k ↦ h ∈ hs1, own_repl_hist_half γ k h) ==∗
      ([∗ map] k ↦ h ∈ hs2, own_repl_hist_half γ k h) ∗
      ([∗ map] k ↦ h ∈ hs2, own_repl_hist_half γ k h).
    Proof.
      iIntros (Hprefixes) "Hhs1x Hhs1y".
      iCombine "Hhs1x Hhs1y" as "Hhs1".
      rewrite -2!big_sepM_sep.
      iApply big_sepM_bupd.
      iApply (big_sepM_impl_dom_eq with "Hhs1").
      { symmetry. apply (map_Forall2_dom_L _ _ _ Hprefixes). }
      iIntros (k h1 h2 Hh1 Hh2) "!> [Hh1x Hh1y]".
      iApply (repl_hist_update with "Hh1x Hh1y").
      apply (map_Forall2_lookup_Some _ _ _ _ _ _ Hh1 Hh2 Hprefixes).
    Qed.

    Lemma repl_hist_witness {γ k h} :
      own_repl_hist_half γ k h -∗
      is_repl_hist_lb γ k h.
    Proof.
      iApply own_mono.
      apply singleton_included_mono.
      apply mono_list_included.
    Qed.

    Lemma repl_hist_prefix {γ k h hlb} :
      own_repl_hist_half γ k h -∗
      is_repl_hist_lb γ k hlb -∗
      ⌜prefix hlb h⌝.
    Proof.
      iIntros "Hh Hlb".
      iDestruct (own_valid_2 with "Hh Hlb") as %Hvalid.
      iPureIntro. revert Hvalid.
      rewrite singleton_op singleton_valid.
      rewrite mono_list_both_dfrac_valid_L.
      by intros [_ ?].
    Qed.

    Definition repl_hist_at γ (k : dbkey) (ts : nat) (v : dbval) : iProp Σ :=
      ∃ hist, is_repl_hist_lb γ k hist ∗ ⌜hist !! ts = Some v⌝.

    Lemma repl_hist_lookup γ k h ts v :
      own_repl_hist_half γ k h -∗
      repl_hist_at γ k ts v -∗
      ⌜h !! ts = Some v⌝.
    Proof.
      iIntros "Hhalf (%lb & #Hlb & %Hv)".
      iDestruct (repl_hist_prefix with "Hhalf Hlb") as %Hprefix.
      iPureIntro.
      by eapply prefix_lookup_Some.
    Qed.

    Lemma repl_hist_lb_weaken {γ k hlb1} hlb2 :
      prefix hlb2 hlb1 ->
      is_repl_hist_lb γ k hlb1 -∗
      is_repl_hist_lb γ k hlb2.
    Proof.
      iIntros (Hprefix).
      iApply own_mono.
      apply singleton_included_mono.
      by apply mono_list_lb_mono.
    Qed.

  End repl_hist.

  Section repl_ts.

    (** Timestamped-lock generated by replicated transactions for a certain
    key. One half owned by the txnsys invariant, the other by the key
    invariant. *)

    Definition own_repl_ts_half γ (k : dbkey) (ts : nat) : iProp Σ :=
      own γ.(repl_ts) {[ k := (to_dfrac_agree (DfracOwn (1 / 2)) ts) ]}.

    Lemma repl_ts_agree {γ k ts1 ts2} :
      own_repl_ts_half γ k ts1 -∗
      own_repl_ts_half γ k ts2 -∗
      ⌜ts2 = ts1⌝.
    Proof.
      iIntros "Hv1 Hv2".
      iDestruct (own_valid_2 with "Hv1 Hv2") as %Hvalid.
      rewrite singleton_op singleton_valid dfrac_agree_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

    Lemma repl_ts_update {γ k ts1 ts2} ts' :
      own_repl_ts_half γ k ts1 -∗
      own_repl_ts_half γ k ts2 ==∗
      own_repl_ts_half γ k ts' ∗ own_repl_ts_half γ k ts'.
    Proof.
      iIntros "Hv1 Hv2".
      iCombine "Hv1 Hv2" as "Hv".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hv").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

    Lemma repl_ts_big_agree {γ tsm1 tsm2} :
      dom tsm1 = dom tsm2 ->
      ([∗ map] k ↦ ts ∈ tsm1, own_repl_ts_half γ k ts) -∗
      ([∗ map] k ↦ ts ∈ tsm2, own_repl_ts_half γ k ts) -∗
      ⌜tsm2 = tsm1⌝.
    Proof.
      iIntros (Hdom) "Htsm1 Htsm2".
      rewrite map_eq_iff.
      iIntros (k).
      destruct (tsm1 !! k) as [h1 |] eqn:Hh1, (tsm2 !! k) as [h2 |] eqn:Hh2.
      { iDestruct (big_sepM_lookup with "Htsm1") as "Hh1"; first apply Hh1.
        iDestruct (big_sepM_lookup with "Htsm2") as "Hh2"; first apply Hh2.
        by iDestruct (repl_ts_agree with "Hh1 Hh2") as %->.
      }
      { by rewrite -not_elem_of_dom -Hdom elem_of_dom Hh1 -eq_None_not_Some in Hh2. }
      { by rewrite -not_elem_of_dom Hdom elem_of_dom Hh2 -eq_None_not_Some in Hh1. }
      done.
    Qed.

    Lemma repl_ts_big_update {γ tss} tss' :
      dom tss = dom tss' ->
      ([∗ map] k ↦ t ∈ tss, own_repl_ts_half γ k t) -∗
      ([∗ map] k ↦ t ∈ tss, own_repl_ts_half γ k t) ==∗
      ([∗ map] k ↦ t ∈ tss', own_repl_ts_half γ k t) ∗
      ([∗ map] k ↦ t ∈ tss', own_repl_ts_half γ k t).
    Proof.
      iIntros (Hdom) "Hhs1x Hhs1y".
      iCombine "Hhs1x Hhs1y" as "Hhs1".
      rewrite -2!big_sepM_sep.
      iApply big_sepM_bupd.
      iApply (big_sepM_impl_dom_eq with "Hhs1"); first done.
      iIntros (k h1 h2 Hh1 Hh2) "!> [Hh1x Hh1y]".
      iApply (repl_ts_update with "Hh1x Hh1y").
    Qed.

  End repl_ts.

  Section repl_tuple.

    (** Replicated tuple [tuple_repl] simply combines [repl_hist] and [repl_ts]. *)

    Definition own_repl_tuple_half γ (k : dbkey) (t : dbtpl) : iProp Σ :=
      own_repl_hist_half γ k t.1 ∗ own_repl_ts_half γ k t.2.

  End repl_tuple.

  Section lnrz_kmod.

    (** Key-modification made by linearized transactions. One half owned by the
    txnsys invariant, and the other half by the group invariant. *)

    Definition own_lnrz_kmod_half γ (k : dbkey) (kmod : dbkmod) : iProp Σ :=
      own γ.(lnrz_kmod) {[ k := (to_dfrac_agree (DfracOwn (1 / 2)) kmod) ]}.

    Lemma lnrz_kmod_agree {γ k m1 m2} :
      own_lnrz_kmod_half γ k m1 -∗
      own_lnrz_kmod_half γ k m2 -∗
      ⌜m2 = m1⌝.
    Proof.
      iIntros "Hv1 Hv2".
      iDestruct (own_valid_2 with "Hv1 Hv2") as %Hvalid.
      rewrite singleton_op singleton_valid dfrac_agree_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

    Lemma lnrz_kmod_vslice_agree {γ k m im} :
      k ∈ keys_all ->
      ([∗ set] key ∈ keys_all, own_lnrz_kmod_half γ key (vslice m key)) -∗
      own_lnrz_kmod_half γ k im -∗
      ⌜im = vslice m k⌝.
    Proof.
      iIntros (Hin) "Hkeys Hk".
      iDestruct (big_sepS_elem_of with "Hkeys") as "Hkey"; first apply Hin.
      by iDestruct (lnrz_kmod_agree with "Hkey Hk") as %?.
    Qed.

    Lemma lnrz_kmod_update {γ k kmod1 kmod2} kmod :
      own_lnrz_kmod_half γ k kmod1 -∗
      own_lnrz_kmod_half γ k kmod2 ==∗
      own_lnrz_kmod_half γ k kmod ∗ own_lnrz_kmod_half γ k kmod.
    Proof.
      iIntros "Hv1 Hv2".
      iCombine "Hv1 Hv2" as "Hv".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hv").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

    Lemma lnrz_kmod_big_agree {γ keys kmods f} :
      dom kmods = keys ->
      ([∗ set] k ∈ keys, own_lnrz_kmod_half γ k (f k)) -∗
      ([∗ map] k ↦ kmod ∈ kmods, own_lnrz_kmod_half γ k kmod) -∗
      ⌜map_Forall (λ k kmod, kmod = f k) kmods⌝.
    Proof.
      iIntros (Hdom) "Hkeys Hkmods".
      rewrite -Hdom.
      rewrite big_sepS_big_sepM.
      iCombine "Hkmods Hkeys" as "Hkmods".
      rewrite -big_sepM_sep.
      iApply big_sepM_pure.
      iApply (big_sepM_impl with "Hkmods").
      iIntros "!>" (k kmod Hkmod) "[Hkmod Hf]".
      iApply (lnrz_kmod_agree with "Hf Hkmod").
    Qed.

    Lemma lnrz_kmod_big_update {γ keys kmods f} f' :
      dom kmods = keys ->
      ([∗ set] k ∈ keys, own_lnrz_kmod_half γ k (f k)) -∗
      ([∗ map] k ↦ kmod ∈ kmods, own_lnrz_kmod_half γ k kmod) ==∗
      ([∗ set] k ∈ keys, own_lnrz_kmod_half γ k (f' k)) ∗
      ([∗ map] k ↦ kmod ∈ kmods, own_lnrz_kmod_half γ k (f' k)).
    Proof.
      iIntros (Hdom) "Hkeys Hkmods".
      rewrite -Hdom.
      rewrite 2!big_sepS_big_sepM.
      iCombine "Hkmods Hkeys" as "Hkmods".
      rewrite -2!big_sepM_sep.
      iApply big_sepM_bupd.
      iApply (big_sepM_mono with "Hkmods").
      iIntros (k kmod Hkmod) "[Hkmod Hf]".
      iMod (lnrz_kmod_update (f' k) with "Hkmod Hf") as "[Hkmod Hf]".
      by iFrame.
    Qed.

  End lnrz_kmod.

  Section cmtd_kmod.

    (** Key-modification made by committed transactions. One half owned by the
    txnsys invariant, and the other half by the group invariant. *)

    Definition own_cmtd_kmod_half γ (k : dbkey) (kmod : dbkmod) : iProp Σ :=
      own γ.(cmtd_kmod) {[ k := (to_dfrac_agree (DfracOwn (1 / 2)) kmod) ]}.

    Lemma cmtd_kmod_agree {γ k m1 m2} :
      own_cmtd_kmod_half γ k m1 -∗
      own_cmtd_kmod_half γ k m2 -∗
      ⌜m2 = m1⌝.
    Proof.
      iIntros "Hv1 Hv2".
      iDestruct (own_valid_2 with "Hv1 Hv2") as %Hvalid.
      rewrite singleton_op singleton_valid dfrac_agree_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

    Lemma cmtd_kmod_vslice_agree {γ k m im} :
      k ∈ keys_all ->
      ([∗ set] key ∈ keys_all, own_cmtd_kmod_half γ key (vslice m key)) -∗
      own_cmtd_kmod_half γ k im -∗
      ⌜im = vslice m k⌝.
    Proof.
      iIntros (Hin) "Hkeys Hk".
      iDestruct (big_sepS_elem_of with "Hkeys") as "Hkey"; first apply Hin.
      by iDestruct (cmtd_kmod_agree with "Hkey Hk") as %?.
    Qed.

    Lemma cmtd_kmod_update {γ k kmod1 kmod2} kmod :
      own_cmtd_kmod_half γ k kmod1 -∗
      own_cmtd_kmod_half γ k kmod2 ==∗
      own_cmtd_kmod_half γ k kmod ∗ own_cmtd_kmod_half γ k kmod.
    Proof.
      iIntros "Hv1 Hv2".
      iCombine "Hv1 Hv2" as "Hv".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hv").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

    Lemma cmtd_kmod_big_agree {γ keys kmods f} :
      dom kmods = keys ->
      ([∗ set] k ∈ keys, own_cmtd_kmod_half γ k (f k)) -∗
      ([∗ map] k ↦ kmod ∈ kmods, own_cmtd_kmod_half γ k kmod) -∗
      ⌜map_Forall (λ k kmod, kmod = f k) kmods⌝.
    Proof.
      iIntros (Hdom) "Hkeys Hkmods".
      rewrite -Hdom.
      rewrite big_sepS_big_sepM.
      iCombine "Hkmods Hkeys" as "Hkmods".
      rewrite -big_sepM_sep.
      iApply big_sepM_pure.
      iApply (big_sepM_impl with "Hkmods").
      iIntros "!>" (k kmod Hkmod) "[Hkmod Hf]".
      iApply (cmtd_kmod_agree with "Hf Hkmod").
    Qed.

    Lemma cmtd_kmod_big_update {γ keys kmods f} f' :
      dom kmods = keys ->
      ([∗ set] k ∈ keys, own_cmtd_kmod_half γ k (f k)) -∗
      ([∗ map] k ↦ kmod ∈ kmods, own_cmtd_kmod_half γ k kmod) ==∗
      ([∗ set] k ∈ keys, own_cmtd_kmod_half γ k (f' k)) ∗
      ([∗ map] k ↦ kmod ∈ kmods, own_cmtd_kmod_half γ k (f' k)).
    Proof.
      iIntros (Hdom) "Hkeys Hkmods".
      rewrite -Hdom.
      rewrite 2!big_sepS_big_sepM.
      iCombine "Hkmods Hkeys" as "Hkmods".
      rewrite -2!big_sepM_sep.
      iApply big_sepM_bupd.
      iApply (big_sepM_mono with "Hkmods").
      iIntros (k kmod Hkmod) "[Hkmod Hf]".
      iMod (cmtd_kmod_update (f' k) with "Hkmod Hf") as "[Hkmod Hf]".
      by iFrame.
    Qed.

  End cmtd_kmod.

  Section txn_consensus.

    (** Consensus resource with transaction semantics. One half owned by the
    group invariant, the other half by the txnlog invariant. *)

    Definition own_txn_log_half γ (gid : u64) (log : dblog) : iProp Σ.
    Admitted.

    Definition is_txn_log_lb γ (gid : u64) (log : dblog) : iProp Σ.
    Admitted.

    #[global]
    Instance is_txn_log_lb_persistent γ gid log :
      Persistent (is_txn_log_lb γ gid log).
    Admitted.

    Definition is_txn_log_lbs γ (logs : gmap u64 dblog) : iProp Σ :=
      [∗ map] gid ↦ log ∈ logs, is_txn_log_lb γ gid log.

    Definition own_txn_cpool_half γ (gid : u64) (cpool : gset ccommand) : iProp Σ.
    Admitted.

    (* Definition is_proposed_txn_cmd γ (gid : u64) (lsn : nat) (term : nat) (c : ccommand) : iProp Σ. *)
    (* Admitted. *)

    (* #[global] *)
    (* Instance is_proposed_txn_cmd_persistent γ gid lsn term c : *)
    (*   Persistent (is_proposed_txn_cmd γ gid lsn term c). *)
    (* Admitted. *)

    Lemma txn_log_witness γ gid log :
      own_txn_log_half γ gid log -∗
      is_txn_log_lb γ gid log.
    Admitted.

    Lemma txn_log_prefix γ gid log logp :
      own_txn_log_half γ gid log -∗
      is_txn_log_lb γ gid logp -∗
      ⌜prefix logp log⌝.
    Admitted.

    Lemma txn_log_agree γ gid log1 log2 :
      own_txn_log_half γ gid log1 -∗
      own_txn_log_half γ gid log2 -∗
      ⌜log2 = log1⌝.
    Admitted.

    Lemma txn_log_lb_prefix γ gid logp1 logp2 :
      is_txn_log_lb γ gid logp1 -∗
      is_txn_log_lb γ gid logp2 -∗
      ⌜prefix logp1 logp2 ∨ prefix logp2 logp1⌝.
    Admitted.

    Lemma txn_log_lb_weaken {γ gid} logp1 logp2 :
      prefix logp1 logp2 ->
      is_txn_log_lb γ gid logp2 -∗
      is_txn_log_lb γ gid logp1.
    Admitted.

    Lemma txn_cpool_agree γ gid cpool1 cpool2 :
      own_txn_cpool_half γ gid cpool1 -∗
      own_txn_cpool_half γ gid cpool2 -∗
      ⌜cpool2 = cpool1⌝.
    Admitted.

    Definition txn_cpool_subsume_log (cpool : gset ccommand) (log : list ccommand) :=
      Forall (λ c, c ∈ cpool) log.

    Lemma txn_log_cpool_incl γ gid log cpool :
      own_txn_log_half γ gid log -∗
      own_txn_cpool_half γ gid cpool -∗
      ⌜txn_cpool_subsume_log cpool log⌝.
    Admitted.

    Lemma txn_log_extend {γ gid log cpool} logext :
      txn_cpool_subsume_log cpool logext ->
      own_txn_log_half γ gid log -∗
      own_txn_log_half γ gid log -∗
      own_txn_cpool_half γ gid cpool ==∗
      own_txn_log_half γ gid (log ++ logext) ∗
      own_txn_log_half γ gid (log ++ logext) ∗
      own_txn_cpool_half γ gid cpool.
    Admitted.

    Lemma txn_cpool_update {γ gid cpool} cpool' :
      cpool ⊆ cpool' ->
      own_txn_cpool_half γ gid cpool -∗
      own_txn_cpool_half γ gid cpool ==∗
      own_txn_cpool_half γ gid cpool' ∗
      own_txn_cpool_half γ gid cpool'.
    Admitted.

  End txn_consensus.

End res.

Section alloc.
  Context `{!tulip_ghostG Σ}.

  Definition replica_init_res γ (g : u64) : iProp Σ :=
    (* per-replica validated transaction IDs *)
    ([∗ set] r ∈ rids_all, own_replica_validated_tss γ g r ∅) ∗
    (* per-replica validation history *)
    ([∗ set] r ∈ rids_all, [∗ set] k ∈ keys_all, own_replica_key_validation γ g r k [false]) ∗
    (* per-replica consistent log *)
    ([∗ set] r ∈ rids_all, own_replica_clog_half γ g r []) ∗
    (* per-replica inconsistent log *)
    ([∗ set] r ∈ rids_all, own_replica_ilog_half γ g r []) ∗
    (* per-replica vote-history map *)
    ([∗ set] r ∈ rids_all, own_replica_ballot_map γ g r ∅) ∗
    (* per-replica backup-vote map *)
    ([∗ set] r ∈ rids_all, own_replica_backup_vote_map γ g r ∅) ∗
    (* per-replica backup-tokens map *)
    ([∗ set] r ∈ rids_all, own_replica_backup_tokens_map γ g r ∅).

  Lemma tulip_res_alloc :
    ⊢ |==> ∃ γ,
      (* database points-to | client *)
      ([∗ set] k ∈ keys_all, own_db_ptsto γ k None) ∗
      (* transaction result map | txnsys *)
      own_txn_resm γ ∅ ∗
      (* transaction write-set | txnsys *)
      own_txn_oneshot_wrsm γ ∅ ∗
      (* IDs of linearized transaction | txnsys *)
      own_lnrz_tids γ ∅ ∗
      (* IDs of transaction predicted to abort | txnsys *)
      own_wabt_tids γ ∅ ∗
      (* IDs and write-sets of transaction predicted to commit or has committed | txnsys *)
      own_cmt_tmods γ ∅ ∗
      (* exclusive transaction tokens to partition predictions | txnsys *)
      own_excl_tids γ ∅ ∗
      (* exclusive (transaction, group) tokens for ownerhsip of slow-path prepare proposal | txnsys *)
      own_txn_client_tokens γ ∅ ∗
      (* transaction post-condition | txnsys *)
      own_txn_postconds γ ∅ ∗
      (* largest assigned timestamp | txnsys *)
      own_largest_ts γ O ∗
      (* database points-to | key *)
      ([∗ set] k ∈ keys_all, own_db_ptsto γ k None) ∗
      (* per-key replicated tuples | group / key *)
      ([∗ set] k ∈ keys_all, own_repl_hist_half γ k [None]) ∗
      ([∗ set] k ∈ keys_all, own_repl_hist_half γ k [None]) ∗
      ([∗ set] k ∈ keys_all, own_repl_ts_half γ k O) ∗
      ([∗ set] k ∈ keys_all, own_repl_ts_half γ k O) ∗
      (* per-key committed history | txnsys *)
      ([∗ set] k ∈ keys_all, own_cmtd_hist γ k [None]) ∗
      (* per-key linearized history | txnsys *)
      ([∗ set] k ∈ keys_all, own_lnrz_hist γ k [None]) ∗
      (* per-key linearized modification | txnsys / key *)
      ([∗ set] k ∈ keys_all, own_lnrz_kmod_half γ k ∅) ∗
      ([∗ set] k ∈ keys_all, own_lnrz_kmod_half γ k ∅) ∗
      (* per-key committed modification | txnsys / key *)
      ([∗ set] k ∈ keys_all, own_cmtd_kmod_half γ k ∅) ∗
      ([∗ set] k ∈ keys_all, own_cmtd_kmod_half γ k ∅) ∗
      (* per-group txn consensus | group / txnlog *)
      ([∗ set] g ∈ gids_all, own_txn_log_half γ g []) ∗
      ([∗ set] g ∈ gids_all, own_txn_log_half γ g []) ∗
      ([∗ set] g ∈ gids_all, own_txn_cpool_half γ g ∅) ∗
      ([∗ set] g ∈ gids_all, own_txn_cpool_half γ g ∅) ∗
      (* per-group prepare map | group *)
      ([∗ set] g ∈ gids_all, own_group_prepm γ g ∅) ∗
      (* per-group prepare proposal map | group *)
      ([∗ set] g ∈ gids_all, own_group_prepare_proposals_map γ g ∅) ∗
      (* per-group prepare map | group *)
      ([∗ set] g ∈ gids_all, own_group_commit_map γ g ∅) ∗
      (* per-group network terminals | network *)
      ([∗ set] g ∈ gids_all, own_terminals γ g ∅ ) ∗
      (* per-replica resources *)
      ([∗ set] g ∈ gids_all, replica_init_res γ g) ∗
      (* per-replica logs | replica lock *)
      ([∗ set] g ∈ gids_all, [∗ set] r ∈ rids_all,
         own_replica_clog_half γ g r [] ∗ own_replica_ilog_half γ g r []).
  Proof.
  Admitted.

End alloc.
