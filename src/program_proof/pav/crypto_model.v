(** This file provides an operational model for:
1) an EUF-CMA signature scheme.
2) a collision-resistant random oracle hash function.

Hopefully, we can prove the admitted iProps in cryptoffi.v from it. *)

From Coq Require Import ssreflect.
From Perennial.Helpers Require Import Integers.
From stdpp Require Import prelude gmap.
From RecordUpdate Require Import RecordSet.
Import RecordSetNotations.

Section shared.

(* arb_T returns a random concrete T. *)
Definition arb_bool : bool. Admitted.
Definition arb_bytes : list w8. Admitted.
Definition arb_bytes_len (len : nat) : list w8. Admitted.

End shared.

Module signatures.

Notation sk_ty := (list w8) (only parsing).
Notation pk_ty := (list w8) (only parsing).
Notation sig_ty := (list w8) (only parsing).
Notation msg_ty := (list w8) (only parsing).

Record state_ty :=
  mk_state {
    signed: gmap sk_ty (list msg_ty);
    (* pk_to_sk and sk_to_pk are bijective,
    and dom signed = dom sk_to_pk.
    if we had a bijective object, that'd simplify things.
    it's also possible to implement sk_to_pk with preimg pk_to_sk,
    but that gets very complicated. *)
    pk_to_sk: gmap pk_ty sk_ty;
    sk_to_pk: gmap sk_ty pk_ty;
    (* make verify deterministic by memoizing outputs. *)
    verify_memo: gmap (pk_ty * msg_ty * sig_ty) bool;
  }.
Instance eta_state : Settable _ :=
  settable! mk_state <signed; pk_to_sk; sk_to_pk; verify_memo>.

Inductive op_ty : Type :=
  | key_gen : op_ty
  | sign : sk_ty → msg_ty → op_ty
  | verify : pk_ty → msg_ty → sig_ty → op_ty.

Inductive ret_ty : Type :=
  | ret_key_gen : sk_ty → pk_ty → ret_ty
  | ret_sign : sig_ty → ret_ty
  | ret_verify : bool → ret_ty.

(** the main goal is to follow the guarantees of EUF-CMA as closely as possible.
e.g., EUF-CMA says sign / verify are undefined for OOD sk's / pk's,
so we return random values.
e.g., EUF-CMA has a stateful notion of the adversary not being able to forge
signatures if it never signed the msg before.
our model tracks signed state to guarantee this.

the main divergence is in the notion of distributions.
for us, "in-distribution" means a key already gen'd by key_gen.
"out-of-distribution" means a key not yet gen'd by key_gen.
in EUF-CMA, a distribution is fixed ahead of time.

the other divergence is how we capture the constraint of a poly time adversary.
the main capability of super-poly adversaries is their ability to run crypto ops
a huge number of times to exhibit collisions.
we block this, by having the underlying machine infinite loop exactly when
it detects a collision.

one way to gain confidence in the model is to show that the traces
generated by it satisfy some core EUF-CMA trace invariants, such as:
1) you can't forge sigs.
  if verify pk m s = true at state i, then exists j ≤ i s.t. at state j, sign sk m = s'.
2) correctness.
  if sign sk m = s, not exist state i with verify pk m s = false.
3) verify is deterministic.
  if verify pk m s = b1 at state i and verify pk m s = b2 at state j, then b1 = b2. *)
Definition step (op : op_ty) (state : state_ty) : (ret_ty * state_ty) :=
  match op with
  | key_gen =>
    let sk := arb_bytes in
    let pk := arb_bytes in
    (* check for collisions, either with prior key_gen or with OOD key. *)
    match (state.(signed) !! sk, state.(pk_to_sk) !! pk,
      bool_decide (map_Exists (λ k _, k.1.1 = pk) state.(verify_memo))) with
    | (None, None, false) =>
      (* TODO: make key_gen not directly return the sk, so it's impossible
      for programs to leak it. *)
      (ret_key_gen sk pk,
        state <| signed ::= <[sk:=[]]> |>
              <| pk_to_sk ::= <[pk:=sk]> |>
              <| sk_to_pk ::= <[sk:=pk]> |>)
    | _ =>
      (* collision. infinite loop the machine. *)
      (ret_key_gen [] [], state)
    end

  | sign sk msg =>
    match (state.(signed) !! sk, state.(sk_to_pk) !! sk) with
    | (Some my_signed, Some pk) =>
      (* sign is probabilistic. might return diff sigs for same data.
      avoid sig dup in the following degenerate case:
      key_gen, verify msg sig = false, sign msg = sig, verify msg sig = ?. *)
      let sig := arb_bytes in
      match state.(verify_memo) !! (pk, msg, sig) with
      | None
      | Some true =>
        (ret_sign sig,
          state <| signed ::= <[sk:=msg::my_signed]> |>
                (* immediately memoize so verify returns the right thing. *)
                <| verify_memo ::= <[(pk,msg,sig):=true]> |>)
      | Some false =>
        (* bad sig collision (see above case). infinite loop the machine. *)
        (ret_sign [], state)
      end
    (* sign is only defined over in-distribution sk's. return random values. *)
    | _ =>
      let sig := arb_bytes in
      (ret_sign sig, state)
    end

  | verify pk msg sig =>
    match state.(verify_memo) !! (pk, msg, sig) with
    | Some ok => (ret_verify ok, state)
    | None =>
      (* memoize new verify output. *)
      (λ '(new_ok, new_state),
        (ret_verify new_ok, new_state <| verify_memo ::= <[(pk,msg,sig):=new_ok]> |>))
      match state.(pk_to_sk) !! pk with
      | None =>
        (* verify is only defined over in-distribution pk's. return random values. *)
        let ok := arb_bool in
        (ok, state)
      | Some sk =>
        match state.(signed) !! sk with
        | None =>
          (* will never happen for in-distribution pk's. return random values. *)
          let ok := arb_bool in
          (ok, state)
        | Some my_signed =>
          match list_find (λ x, x = msg) my_signed with
          | None =>
            (* if never signed msg before, should be impossible to verify. *)
            (false, state)
          | Some _ =>
            (* for already signed msgs, either:
            1) we signed this exact sig.
            in this case, memoization would run, not this code.
            2) we signed this msg, but not this sig.
            could have forged a valid sig. *)
            let ok := arb_bool in
            (* even tho verify might ret true, only update signed state via
            the sign op, not here. *)
            (ok, state)
          end
        end
      end
    end
  end.

(*
Lemma sig_unforg tr i j k gen_elem verify_elem sign_elem :
  valid_trace tr →
  i < j →
  tr !! i = Some gen_elem →
  gen_elem.(op) = key_gen →
  gen_elem.(ret) = ret_key_gen sk pk →
  tr !! j = Some verify_elem →
  verify_elem.(op) = verify pk msg sig →
  verify_elem.(ret) = ret_verify true →
  j < k →
  tr !! k = Some sign_elem →
  sign_elem.(op) = sign sk msg.
*)

End signatures.

Module triv_trace_inv.

Definition step (prev next : nat) : Prop :=
  next = S prev.

Definition valid_trace (l : list nat) :=
  ∀ i a b, l !! i = Some a → l !! S i = Some b → step a b.

Lemma only_increasing l i k a b :
  valid_trace l →
  l !! i = Some a →
  l !! (i + k) = Some b →
  a ≤ b.
Proof.
  intros **.
  generalize dependent b.
  induction k; intros **.
  - replace (i + 0) with (i) in * by lia. list_simplifier. lia.
  - assert (∃ c, l !! (i + k) = Some c) as [c Hlook0].
    { apply lookup_lt_is_Some. apply lookup_lt_Some in H1. lia. }
    specialize (IHk c Hlook0).
    rewrite /valid_trace /step in H.
    replace (i + S k) with (S (i + k)) in * by lia.
    specialize (H _ _ _ Hlook0 H1).
    lia.
Qed.

End triv_trace_inv.

Module hashes.

Notation msg_ty := (list w8) (only parsing).
Notation hash_ty := (list w8) (only parsing).
Notation hash_len := (32) (only parsing).

Record state_ty :=
  mk_hash_state {
    hashes: gmap msg_ty hash_ty;
  }.
Instance eta_state : Settable _ :=
  settable! mk_hash_state <hashes>.

Inductive op_ty : Type :=
  | hash : msg_ty → op_ty.

Inductive ret_ty : Type :=
  | ret_hash : hash_ty → ret_ty.

Record trace_elem_ty :=
  (* on state, run op and get this ret val. *)
  mk_trace_elem {
    state: state_ty;
    op: op_ty;
    ret: ret_ty;
  }.

Definition step (prev next : trace_elem_ty) : Prop :=
  match prev.(op) with
  | hash msg =>
    match prev.(state).(hashes) !! msg with
    | Some h =>
      prev.(ret) = (ret_hash h) ∧ next.(state) = prev.(state)
    | None =>
      (* maintains inv that all hashes have same len. *)
      let new_hash := arb_bytes_len hash_len in
      if bool_decide (map_Exists (λ _ h, h = new_hash) (hashes (state prev)))
      (* hash collision. infinite loop the machine. *)
      then False
      else
        prev.(ret) = (ret_hash new_hash) ∧ next.(state) = prev.(state) <| hashes ::= <[msg:=new_hash]> |>
    end
  end.

Definition valid_trace (l : list trace_elem_ty) :=
  ∀ i a b, l !! i = Some a → l !! S i = Some b → step a b.

Lemma hash_state_mono l i k a b :
  valid_trace l →
  l !! i = Some a →
  l !! (i + k) = Some b →
  hashes (state a) ⊆ hashes (state b).
Proof.
  intros **.
  generalize dependent b.
  induction k; intros **.
  - replace (i + 0) with (i) in * by lia. naive_solver.
  - assert (∃ c, l !! (i + k) = Some c) as [c Hlook0].
    { apply lookup_lt_is_Some. apply lookup_lt_Some in H1. lia. }
    specialize (IHk c Hlook0).
    replace (i + S k) with (S (i + k)) in * by lia.
    rewrite /valid_trace /step in H.
    specialize (H _ _ _ Hlook0 H1).
    (* begin new proof. reasoning that after one step, hash state monotonic.
    follows directly after unfolding code. *)
    do 2 case_match.
    + destruct_and?. by rewrite H5.
    + case_match; [done|].
      destruct_and?. rewrite H6. simplify_eq/=.
      epose proof (insert_subseteq _ _ (arb_bytes_len 32) H3) as H10.
      by etrans.
Qed.

Lemma collision_resistance l i k a b h msg0 msg1 :
  valid_trace l →
  l !! i = Some a →
  l !! (i + k) = Some b →
  ret a = ret_hash h →
  ret b = ret_hash h →
  op a = hash msg0 →
  op b = hash msg1 →
  msg0 = msg1.
Proof.
  intros **.
  destruct (decide (k = 0)).
  { simplify_eq. replace (i + 0) with (i) in H1 by lia. list_simplifier.
    rewrite H4 in H5. naive_solver. }
  assert (∃ c, l !! S i = Some c) as [c Hlook0].
  { apply lookup_lt_is_Some. apply lookup_lt_Some in H1. lia. }
  assert (hashes (state c) !! msg0 = Some h) as Hlook1.
  {
    specialize (H _ _ _ H0 Hlook0). rewrite /step in H.
    do 2 case_match.
    - destruct_and?. rewrite H8 in H2. inv H2. by rewrite H9.
    - case_match; [done|].
      destruct_and?. rewrite H10. rewrite H2 in H9. simplify_eq/=.
      by simplify_map_eq.
  }
  pose proof H1 as Hlook2.
  replace (i + k) with (S i + pred k) in Hlook2 by lia.
  epose proof (hash_state_mono _ _ _ _ _ H Hlook0 Hlook2).
  epose proof (lookup_weaken _ _ _ _ Hlook1 H6) as Hlook3.
  (* TODO: this is not actually provable.
  with both my ways of writing the trace elem state and step fn, there's issues.
  for first op, to consider step, only poss if op comes in prev trace elem.
  for last op, to consider step, only poss if op comes in next trace elem.
  not sure how to fix this.
  i'll skip for now since perennial setup must've solved it. *)
  assert (∃ d, l !! S (i + k) = Some d) as [d Hlook4] by admit.
  specialize (H _ _ _ H1 Hlook4). rewrite /step in H.
  do 2 case_match; inv H5.
  - destruct_and?. rewrite H5 in H3. inv H3.
    (* need to know that the first time we added msg1, it had collision resistance. *)
Admitted.

End hashes.
