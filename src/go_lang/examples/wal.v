(* autogenerated from awol *)
From Perennial.go_lang Require Import prelude.

(* disk FFI *)
From Perennial.go_lang Require Import ffi.disk_prelude.

(* 10 is completely arbitrary *)
Definition MaxTxnWrites : expr := #10.
Theorem MaxTxnWrites_t Γ : Γ ⊢ MaxTxnWrites : uint64T.
Proof. typecheck. Qed.

Definition logLength : expr := #1 + #2 * MaxTxnWrites.
Theorem logLength_t Γ : Γ ⊢ logLength : uint64T.
Proof. typecheck. Qed.

Module Log.
  Definition S := struct.decl [
    "l" :: lockRefT;
    "cache" :: mapT disk.blockT;
    "length" :: refT uint64T
  ].
  Definition T: ty := struct.t S.
  Definition Ptr: ty := struct.ptrT S.
  Section fields.
    Context `{ext_ty: ext_types}.
    Definition get := struct.get S.
  End fields.
End Log.

Definition intToBlock: val :=
  λ: "a",
    let: "b" := NewSlice byteT disk.BlockSize in
    UInt64Put "b" "a";;
    "b".
Theorem intToBlock_t: ⊢ intToBlock : (uint64T -> disk.blockT).
Proof. typecheck. Qed.
Hint Resolve intToBlock_t : types.

Definition blockToInt: val :=
  λ: "v",
    let: "a" := UInt64Get "v" in
    "a".
Theorem blockToInt_t: ⊢ blockToInt : (disk.blockT -> uint64T).
Proof. typecheck. Qed.
Hint Resolve blockToInt_t : types.

(* New initializes a fresh log *)
Definition New: val :=
  λ: <>,
    let: "diskSize" := disk.Size #() in
    (if: "diskSize" ≤ logLength
    then
      Panic ("disk is too small to host log");;
      #()
    else #());;
    let: "cache" := NewMap disk.blockT in
    let: "header" := intToBlock #0 in
    disk.Write #0 "header";;
    let: "lengthPtr" := ref (zero_val uint64T) in
    "lengthPtr" <- #0;;
    let: "l" := Data.newLock #() in
    struct.mk Log.S [
      "cache" ::= "cache";
      "length" ::= "lengthPtr";
      "l" ::= "l"
    ].
Theorem New_t: ⊢ New : (unitT -> Log.T).
Proof. typecheck. Qed.
Hint Resolve New_t : types.

Definition Log__lock: val :=
  λ: "l",
    Data.lockAcquire Writer (Log.get "l" "l").
Theorem Log__lock_t: ⊢ Log__lock : (Log.T -> unitT).
Proof. typecheck. Qed.
Hint Resolve Log__lock_t : types.

Definition Log__unlock: val :=
  λ: "l",
    Data.lockRelease Writer (Log.get "l" "l").
Theorem Log__unlock_t: ⊢ Log__unlock : (Log.T -> unitT).
Proof. typecheck. Qed.
Hint Resolve Log__unlock_t : types.

(* BeginTxn allocates space for a new transaction in the log.

   Returns true if the allocation succeeded. *)
Definition Log__BeginTxn: val :=
  λ: "l",
    Log__lock "l";;
    let: "length" := !(Log.get "length" "l") in
    (if: "length" = #0
    then
      Log__unlock "l";;
      #true
    else
      Log__unlock "l";;
      #false).
Theorem Log__BeginTxn_t: ⊢ Log__BeginTxn : (Log.T -> boolT).
Proof. typecheck. Qed.
Hint Resolve Log__BeginTxn_t : types.

(* Read from the logical disk.

   Reads must go through the log to return committed but un-applied writes. *)
Definition Log__Read: val :=
  λ: "l" "a",
    Log__lock "l";;
    let: ("v", "ok") := MapGet (Log.get "cache" "l") "a" in
    (if: "ok"
    then
      Log__unlock "l";;
      "v"
    else
      Log__unlock "l";;
      let: "dv" := disk.Read (logLength + "a") in
      "dv").
Theorem Log__Read_t: ⊢ Log__Read : (Log.T -> uint64T -> disk.blockT).
Proof. typecheck. Qed.
Hint Resolve Log__Read_t : types.

Definition Log__Size: val :=
  λ: "l",
    let: "sz" := disk.Size #() in
    "sz" - logLength.
Theorem Log__Size_t: ⊢ Log__Size : (Log.T -> uint64T).
Proof. typecheck. Qed.
Hint Resolve Log__Size_t : types.

(* Write to the disk through the log. *)
Definition Log__Write: val :=
  λ: "l" "a" "v",
    Log__lock "l";;
    let: "length" := !(Log.get "length" "l") in
    (if: "length" ≥ MaxTxnWrites
    then
      Panic ("transaction is at capacity");;
      #()
    else #());;
    let: "aBlock" := intToBlock "a" in
    let: "nextAddr" := #1 + #2 * "length" in
    disk.Write "nextAddr" "aBlock";;
    disk.Write ("nextAddr" + #1) "v";;
    MapInsert (Log.get "cache" "l") "a" "v";;
    Log.get "length" "l" <- "length" + #1;;
    Log__unlock "l".
Theorem Log__Write_t: ⊢ Log__Write : (Log.T -> uint64T -> disk.blockT -> unitT).
Proof. typecheck. Qed.
Hint Resolve Log__Write_t : types.

(* Commit the current transaction. *)
Definition Log__Commit: val :=
  λ: "l",
    Log__lock "l";;
    let: "length" := !(Log.get "length" "l") in
    Log__unlock "l";;
    let: "header" := intToBlock "length" in
    disk.Write #0 "header".
Theorem Log__Commit_t: ⊢ Log__Commit : (Log.T -> unitT).
Proof. typecheck. Qed.
Hint Resolve Log__Commit_t : types.

Definition getLogEntry: val :=
  λ: "logOffset",
    let: "diskAddr" := #1 + #2 * "logOffset" in
    let: "aBlock" := disk.Read "diskAddr" in
    let: "a" := blockToInt "aBlock" in
    let: "v" := disk.Read ("diskAddr" + #1) in
    ("a", "v").
Theorem getLogEntry_t: ⊢ getLogEntry : (uint64T -> (uint64T * disk.blockT)).
Proof. typecheck. Qed.
Hint Resolve getLogEntry_t : types.

(* applyLog assumes we are running sequentially *)
Definition applyLog: val :=
  λ: "length",
    let: "i" := ref #0 in
    (for: (#true); (Skip) :=
      (if: !"i" < "length"
      then
        let: ("a", "v") := getLogEntry !"i" in
        disk.Write (logLength + "a") "v";;
        "i" <- !"i" + #1;;
        Continue
      else Break)).
Theorem applyLog_t: ⊢ applyLog : (uint64T -> unitT).
Proof. typecheck. Qed.
Hint Resolve applyLog_t : types.

Definition clearLog: val :=
  λ: <>,
    let: "header" := intToBlock #0 in
    disk.Write #0 "header".
Theorem clearLog_t: ⊢ clearLog : (unitT -> unitT).
Proof. typecheck. Qed.
Hint Resolve clearLog_t : types.

(* Apply all the committed transactions.

   Frees all the space in the log. *)
Definition Log__Apply: val :=
  λ: "l",
    Log__lock "l";;
    let: "length" := !(Log.get "length" "l") in
    applyLog "length";;
    clearLog #();;
    Log.get "length" "l" <- #0;;
    Log__unlock "l".
Theorem Log__Apply_t: ⊢ Log__Apply : (Log.T -> unitT).
Proof. typecheck. Qed.
Hint Resolve Log__Apply_t : types.

(* Open recovers the log following a crash or shutdown *)
Definition Open: val :=
  λ: <>,
    let: "header" := disk.Read #0 in
    let: "length" := blockToInt "header" in
    applyLog "length";;
    clearLog #();;
    let: "cache" := NewMap disk.blockT in
    let: "lengthPtr" := ref (zero_val uint64T) in
    "lengthPtr" <- #0;;
    let: "l" := Data.newLock #() in
    struct.mk Log.S [
      "cache" ::= "cache";
      "length" ::= "lengthPtr";
      "l" ::= "l"
    ].
Theorem Open_t: ⊢ Open : (unitT -> Log.T).
Proof. typecheck. Qed.
Hint Resolve Open_t : types.
