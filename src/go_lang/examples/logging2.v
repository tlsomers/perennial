(* autogenerated from logging2 *)
From Perennial.go_lang Require Import prelude.

(* disk FFI *)
From Perennial.go_lang Require Import ffi.disk.
Existing Instances disk_op disk_model disk_ty.
Local Coercion Var' (s: string) := Var s.

Definition LogCommit : expr := #0.

Definition LogStart : expr := #1.

Module Log.
  Definition S := mkStruct [
    "logLock"; "memLock"; "logSz"; "memLog"; "memLen"; "memTxnNxt"; "logTxnNxt"
  ].
  Definition T: ty := (lockRefT * lockRefT * intT * refT (slice.T blockT) * refT intT * refT intT * refT intT)%ht.
  Section fields.
    Context `{ext_ty: ext_types}.
    Definition logLock := structF! S "logLock".
    Definition memLock := structF! S "memLock".
    Definition logSz := structF! S "logSz".
    Definition memLog := structF! S "memLog".
    Definition memLen := structF! S "memLen".
    Definition memTxnNxt := structF! S "memTxnNxt".
    Definition logTxnNxt := structF! S "logTxnNxt".
  End fields.
End Log.

Definition writeHdr: val :=
  λ: "log" "len",
    let: "hdr" := NewSlice byteT #4096 in
    UInt64Put "hdr" "len";;
    disk.Write "LogCommit" "hdr".

Definition Init: val :=
  λ: "logSz",
    let: "log" := buildStruct Log.S [
      "logLock" ::= Data.newLock #();
      "memLock" ::= Data.newLock #();
      "logSz" ::= "logSz";
      "memLog" ::= ref (zero_val (slice.T blockT));
      "memLen" ::= ref (zero_val intT);
      "memTxnNxt" ::= ref (zero_val intT);
      "logTxnNxt" ::= ref (zero_val intT)
    ] in
    writeHdr "log" #0;;
    "log".

Definition readHdr: val :=
  λ: "log",
    let: "hdr" := disk.Read "LogCommit" in
    let: "disklen" := UInt64Get "hdr" in
    "disklen".

Definition readBlocks: val :=
  λ: "log" "len",
    let: "blks" := ref (zero_val (slice.T blockT)) in
    let: "initblks" := NewSlice blockT #0 in
    "blks" <- "initblks";;
    let: "i" := ref #0 in
    for: (!"i" < "len"); ("i" <- !"i" + #1) :=
      let: "blk" := disk.Read ("LogStart" + !"i") in
      let: "oldblks" := !"blks" in
      let: "newblks" := SliceAppend "oldblks" "blk" in
      "blks" <- "newblks";;
      Continue;;
    !"blks".

Definition Read: val :=
  λ: "log",
    Data.lockAcquire Writer (Log.logLock "log");;
    let: "disklen" := readHdr "log" in
    let: "blks" := readBlocks "log" "disklen" in
    Data.lockRelease Writer (Log.logLock "log");;
    "blks".

Definition memWrite: val :=
  λ: "log" "l",
    let: "n" := slice.len "l" in
    let: "i" := ref #0 in
    for: (!"i" < "n"); ("i" <- !"i" + #1) :=
      Log.memLog "log" <- SliceAppend (!Log.memLog "log") (SliceGet "l" !"i");;
      Continue.

Definition memAppend: val :=
  λ: "log" "l",
    Data.lockAcquire Writer (Log.memLock "log");;
    if: !Log.memLen "log" + slice.len "l" ≥ Log.logSz "log"
    then
      Data.lockRelease Writer (Log.memLock "log");;
      (#false, #0)
    else
      let: "txn" := !Log.memTxnNxt "log" in
      let: "n" := !Log.memLen "log" + slice.len "l" in
      Log.memLen "log" <- "n";;
      Log.memTxnNxt "log" <- !Log.memTxnNxt "log" + #1;;
      Data.lockRelease Writer (Log.memLock "log");;
      (#true, "txn").

(* XXX just an atomic read? *)
Definition readLogTxnNxt: val :=
  λ: "log",
    Data.lockAcquire Writer (Log.memLock "log");;
    let: "n" := !Log.logTxnNxt "log" in
    Data.lockRelease Writer (Log.memLock "log");;
    "n".

Definition diskAppendWait: val :=
  λ: "log" "txn",
    Skip;;
    for: (#true); (Skip) :=
      let: "logtxn" := readLogTxnNxt "log" in
      if: "txn" < "logtxn"
      then Break
      else Continue.

Definition Append: val :=
  λ: "log" "l",
    let: ("ok", "txn") := memAppend "log" "l" in
    if: "ok"
    then
      diskAppendWait "log" "txn";;
      #()
    else #();;
    "ok".

Definition writeBlocks: val :=
  λ: "log" "l" "pos",
    let: "n" := slice.len "l" in
    let: "i" := ref #0 in
    for: (!"i" < "n"); ("i" <- !"i" + #1) :=
      let: "bk" := SliceGet "l" !"i" in
      disk.Write ("pos" + !"i") "bk";;
      Continue.

Definition diskAppend: val :=
  λ: "log",
    Data.lockAcquire Writer (Log.logLock "log");;
    let: "disklen" := readHdr "log" in
    Data.lockAcquire Writer (Log.memLock "log");;
    let: "memlen" := !Log.memLen "log" in
    let: "allblks" := !Log.memLog "log" in
    let: "blks" := SliceSkip "allblks" "disklen" in
    let: "memnxt" := !Log.memTxnNxt "log" in
    Data.lockRelease Writer (Log.memLock "log");;
    writeBlocks "log" "blks" "disklen";;
    writeHdr "log" "memlen";;
    Log.logTxnNxt "log" <- "memnxt";;
    Data.lockRelease Writer (Log.logLock "log").

Definition Logger: val :=
  λ: "log",
    Skip;;
    for: (#true); (Skip) :=
      diskAppend "log";;
      Continue.
