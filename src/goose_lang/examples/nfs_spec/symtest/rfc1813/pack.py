# Generated by rpcgen.py from /home/nickolai/proj/go-rpcgen/rfc1813/prot.x on Fri Dec  6 10:47:13 2019
import const
import types
import xdrlib
from xdrlib import Error as XDRError

class nullclass(object):
    pass

class protPacker(xdrlib.Packer):
    pack_short = xdrlib.Packer.pack_int
    pack_string = xdrlib.Packer.pack_string
    pack_ulong = xdrlib.Packer.pack_uint
    pack_opaque = xdrlib.Packer.pack_opaque
    pack_int = xdrlib.Packer.pack_int
    pack_double = xdrlib.Packer.pack_double
    pack_ushort = xdrlib.Packer.pack_uint
    pack_unsigned = xdrlib.Packer.pack_uint
    pack_long = xdrlib.Packer.pack_int
    pack_uhyper = xdrlib.Packer.pack_uhyper
    pack_char = xdrlib.Packer.pack_int
    pack_uchar = xdrlib.Packer.pack_uint
    pack_float = xdrlib.Packer.pack_float
    pack_hyper = xdrlib.Packer.pack_hyper
    pack_uint = xdrlib.Packer.pack_uint
    pack_quadruple = xdrlib.Packer.pack_double
    pack_bool = xdrlib.Packer.pack_bool
    pack_uint64 = pack_uhyper

    pack_uint32 = pack_uint

    def pack_filename3(self, data):
        self.pack_string(data)

    def pack_nfspath3(self, data):
        self.pack_string(data)

    pack_fileid3 = pack_uint64

    pack_cookie3 = pack_uint64

    def pack_cookieverf3(self, data):
        self.pack_fopaque(const.NFS3_COOKIEVERFSIZE, data)

    def pack_createverf3(self, data):
        self.pack_fopaque(const.NFS3_CREATEVERFSIZE, data)

    def pack_writeverf3(self, data):
        self.pack_fopaque(const.NFS3_WRITEVERFSIZE, data)

    pack_uid3 = pack_uint32

    pack_gid3 = pack_uint32

    pack_size3 = pack_uint64

    pack_offset3 = pack_uint64

    pack_mode3 = pack_uint32

    pack_count3 = pack_uint32

    def pack_nfsstat3(self, data):
        if data not in [const.NFS3_OK, const.NFS3ERR_PERM, const.NFS3ERR_NOENT, const.NFS3ERR_IO, const.NFS3ERR_NXIO, const.NFS3ERR_ACCES, const.NFS3ERR_EXIST, const.NFS3ERR_XDEV, const.NFS3ERR_NODEV, const.NFS3ERR_NOTDIR, const.NFS3ERR_ISDIR, const.NFS3ERR_INVAL, const.NFS3ERR_FBIG, const.NFS3ERR_NOSPC, const.NFS3ERR_ROFS, const.NFS3ERR_MLINK, const.NFS3ERR_NAMETOOLONG, const.NFS3ERR_NOTEMPTY, const.NFS3ERR_DQUOT, const.NFS3ERR_STALE, const.NFS3ERR_REMOTE, const.NFS3ERR_BADHANDLE, const.NFS3ERR_NOT_SYNC, const.NFS3ERR_BAD_COOKIE, const.NFS3ERR_NOTSUPP, const.NFS3ERR_TOOSMALL, const.NFS3ERR_SERVERFAULT, const.NFS3ERR_BADTYPE, const.NFS3ERR_JUKEBOX]:
            raise XDRError, 'value=%s not in enum nfsstat3' % data
        self.pack_int(data)

    def pack_ftype3(self, data):
        if data not in [const.NF3REG, const.NF3DIR, const.NF3BLK, const.NF3CHR, const.NF3LNK, const.NF3SOCK, const.NF3FIFO]:
            raise XDRError, 'value=%s not in enum ftype3' % data
        self.pack_int(data)

    def pack_specdata3(self, data):
        if data.specdata1 is None:
            raise TypeError, 'data.specdata1 == None'
        self.pack_uint32(data.specdata1)
        if data.specdata2 is None:
            raise TypeError, 'data.specdata2 == None'
        self.pack_uint32(data.specdata2)

    def pack_nfs_fh3(self, data):
        if data.data is None:
            raise TypeError, 'data.data == None'
        if len(data.data) > const.NFS3_FHSIZE:
            raise XDRError, 'array length too long for data.data'
        self.pack_opaque(data.data)

    def pack_nfstime3(self, data):
        if data.seconds is None:
            raise TypeError, 'data.seconds == None'
        self.pack_uint32(data.seconds)
        if data.nseconds is None:
            raise TypeError, 'data.nseconds == None'
        self.pack_uint32(data.nseconds)

    def pack_fattr3(self, data):
        if data.ftype is None:
            raise TypeError, 'data.ftype == None'
        self.pack_ftype3(data.ftype)
        if data.mode is None:
            raise TypeError, 'data.mode == None'
        self.pack_mode3(data.mode)
        if data.nlink is None:
            raise TypeError, 'data.nlink == None'
        self.pack_uint32(data.nlink)
        if data.uid is None:
            raise TypeError, 'data.uid == None'
        self.pack_uid3(data.uid)
        if data.gid is None:
            raise TypeError, 'data.gid == None'
        self.pack_gid3(data.gid)
        if data.size is None:
            raise TypeError, 'data.size == None'
        self.pack_size3(data.size)
        if data.used is None:
            raise TypeError, 'data.used == None'
        self.pack_size3(data.used)
        if data.rdev is None:
            raise TypeError, 'data.rdev == None'
        self.pack_specdata3(data.rdev)
        if data.fsid is None:
            raise TypeError, 'data.fsid == None'
        self.pack_uint64(data.fsid)
        if data.fileid is None:
            raise TypeError, 'data.fileid == None'
        self.pack_fileid3(data.fileid)
        if data.atime is None:
            raise TypeError, 'data.atime == None'
        self.pack_nfstime3(data.atime)
        if data.mtime is None:
            raise TypeError, 'data.mtime == None'
        self.pack_nfstime3(data.mtime)
        if data.ctime is None:
            raise TypeError, 'data.ctime == None'
        self.pack_nfstime3(data.ctime)

    def pack_post_op_attr(self, data):
        if data.attributes_follow is None:
            raise TypeError, 'data.attributes_follow == None'
        self.pack_bool(data.attributes_follow)
        if data.attributes_follow == const.TRUE:
            if data.attributes is None:
                raise TypeError, 'data.attributes == None'
            self.pack_fattr3(data.attributes)
        elif data.attributes_follow == const.FALSE:
            pass
        else:
            raise XDRError, 'bad switch=%s' % data.attributes_follow

    def pack_wcc_attr(self, data):
        if data.size is None:
            raise TypeError, 'data.size == None'
        self.pack_size3(data.size)
        if data.mtime is None:
            raise TypeError, 'data.mtime == None'
        self.pack_nfstime3(data.mtime)
        if data.ctime is None:
            raise TypeError, 'data.ctime == None'
        self.pack_nfstime3(data.ctime)

    def pack_pre_op_attr(self, data):
        if data.attributes_follow is None:
            raise TypeError, 'data.attributes_follow == None'
        self.pack_bool(data.attributes_follow)
        if data.attributes_follow == const.TRUE:
            if data.attributes is None:
                raise TypeError, 'data.attributes == None'
            self.pack_wcc_attr(data.attributes)
        elif data.attributes_follow == const.FALSE:
            pass
        else:
            raise XDRError, 'bad switch=%s' % data.attributes_follow

    def pack_wcc_data(self, data):
        if data.before is None:
            raise TypeError, 'data.before == None'
        self.pack_pre_op_attr(data.before)
        if data.after is None:
            raise TypeError, 'data.after == None'
        self.pack_post_op_attr(data.after)

    def pack_post_op_fh3(self, data):
        if data.handle_follows is None:
            raise TypeError, 'data.handle_follows == None'
        self.pack_bool(data.handle_follows)
        if data.handle_follows == const.TRUE:
            if data.handle is None:
                raise TypeError, 'data.handle == None'
            self.pack_nfs_fh3(data.handle)
        elif data.handle_follows == const.FALSE:
            pass
        else:
            raise XDRError, 'bad switch=%s' % data.handle_follows

    def pack_time_how(self, data):
        if data not in [const.DONT_CHANGE, const.SET_TO_SERVER_TIME, const.SET_TO_CLIENT_TIME]:
            raise XDRError, 'value=%s not in enum time_how' % data
        self.pack_int(data)

    def pack_set_mode3(self, data):
        if data.set_it is None:
            raise TypeError, 'data.set_it == None'
        self.pack_bool(data.set_it)
        if data.set_it == const.TRUE:
            if data.mode is None:
                raise TypeError, 'data.mode == None'
            self.pack_mode3(data.mode)
        else:
            pass

    def pack_set_uid3(self, data):
        if data.set_it is None:
            raise TypeError, 'data.set_it == None'
        self.pack_bool(data.set_it)
        if data.set_it == const.TRUE:
            if data.uid is None:
                raise TypeError, 'data.uid == None'
            self.pack_uid3(data.uid)
        else:
            pass

    def pack_set_gid3(self, data):
        if data.set_it is None:
            raise TypeError, 'data.set_it == None'
        self.pack_bool(data.set_it)
        if data.set_it == const.TRUE:
            if data.gid is None:
                raise TypeError, 'data.gid == None'
            self.pack_gid3(data.gid)
        else:
            pass

    def pack_set_size3(self, data):
        if data.set_it is None:
            raise TypeError, 'data.set_it == None'
        self.pack_bool(data.set_it)
        if data.set_it == const.TRUE:
            if data.size is None:
                raise TypeError, 'data.size == None'
            self.pack_size3(data.size)
        else:
            pass

    def pack_set_atime(self, data):
        if data.set_it is None:
            raise TypeError, 'data.set_it == None'
        self.pack_time_how(data.set_it)
        if data.set_it == const.SET_TO_CLIENT_TIME:
            if data.atime is None:
                raise TypeError, 'data.atime == None'
            self.pack_nfstime3(data.atime)
        else:
            pass

    def pack_set_mtime(self, data):
        if data.set_it is None:
            raise TypeError, 'data.set_it == None'
        self.pack_time_how(data.set_it)
        if data.set_it == const.SET_TO_CLIENT_TIME:
            if data.mtime is None:
                raise TypeError, 'data.mtime == None'
            self.pack_nfstime3(data.mtime)
        else:
            pass

    def pack_sattr3(self, data):
        if data.mode is None:
            raise TypeError, 'data.mode == None'
        self.pack_set_mode3(data.mode)
        if data.uid is None:
            raise TypeError, 'data.uid == None'
        self.pack_set_uid3(data.uid)
        if data.gid is None:
            raise TypeError, 'data.gid == None'
        self.pack_set_gid3(data.gid)
        if data.size is None:
            raise TypeError, 'data.size == None'
        self.pack_set_size3(data.size)
        if data.atime is None:
            raise TypeError, 'data.atime == None'
        self.pack_set_atime(data.atime)
        if data.mtime is None:
            raise TypeError, 'data.mtime == None'
        self.pack_set_mtime(data.mtime)

    def pack_diropargs3(self, data):
        if data.dir is None:
            raise TypeError, 'data.dir == None'
        self.pack_nfs_fh3(data.dir)
        if data.name is None:
            raise TypeError, 'data.name == None'
        self.pack_filename3(data.name)

    def pack_GETATTR3args(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_nfs_fh3(data.object)

    def pack_GETATTR3resok(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_fattr3(data.obj_attributes)

    def pack_GETATTR3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_GETATTR3resok(data.resok)
        else:
            pass

    def pack_sattrguard3(self, data):
        if data.check is None:
            raise TypeError, 'data.check == None'
        self.pack_bool(data.check)
        if data.check == const.TRUE:
            if data.obj_ctime is None:
                raise TypeError, 'data.obj_ctime == None'
            self.pack_nfstime3(data.obj_ctime)
        elif data.check == const.FALSE:
            pass
        else:
            raise XDRError, 'bad switch=%s' % data.check

    def pack_SETATTR3args(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_nfs_fh3(data.object)
        if data.new_attributes is None:
            raise TypeError, 'data.new_attributes == None'
        self.pack_sattr3(data.new_attributes)
        if data.guard is None:
            raise TypeError, 'data.guard == None'
        self.pack_sattrguard3(data.guard)

    def pack_SETATTR3resok(self, data):
        if data.obj_wcc is None:
            raise TypeError, 'data.obj_wcc == None'
        self.pack_wcc_data(data.obj_wcc)

    def pack_SETATTR3resfail(self, data):
        if data.obj_wcc is None:
            raise TypeError, 'data.obj_wcc == None'
        self.pack_wcc_data(data.obj_wcc)

    def pack_SETATTR3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_SETATTR3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_SETATTR3resfail(data.resfail)

    def pack_LOOKUP3args(self, data):
        if data.what is None:
            raise TypeError, 'data.what == None'
        self.pack_diropargs3(data.what)

    def pack_LOOKUP3resok(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_nfs_fh3(data.object)
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.dir_attributes is None:
            raise TypeError, 'data.dir_attributes == None'
        self.pack_post_op_attr(data.dir_attributes)

    def pack_LOOKUP3resfail(self, data):
        if data.dir_attributes is None:
            raise TypeError, 'data.dir_attributes == None'
        self.pack_post_op_attr(data.dir_attributes)

    def pack_LOOKUP3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_LOOKUP3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_LOOKUP3resfail(data.resfail)

    def pack_ACCESS3args(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_nfs_fh3(data.object)
        if data.access is None:
            raise TypeError, 'data.access == None'
        self.pack_uint32(data.access)

    def pack_ACCESS3resok(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.access is None:
            raise TypeError, 'data.access == None'
        self.pack_uint32(data.access)

    def pack_ACCESS3resfail(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)

    def pack_ACCESS3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_ACCESS3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_ACCESS3resfail(data.resfail)

    def pack_READLINK3args(self, data):
        if data.symlink is None:
            raise TypeError, 'data.symlink == None'
        self.pack_nfs_fh3(data.symlink)

    def pack_READLINK3resok(self, data):
        if data.symlink_attributes is None:
            raise TypeError, 'data.symlink_attributes == None'
        self.pack_post_op_attr(data.symlink_attributes)
        if data.data is None:
            raise TypeError, 'data.data == None'
        self.pack_nfspath3(data.data)

    def pack_READLINK3resfail(self, data):
        if data.symlink_attributes is None:
            raise TypeError, 'data.symlink_attributes == None'
        self.pack_post_op_attr(data.symlink_attributes)

    def pack_READLINK3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_READLINK3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_READLINK3resfail(data.resfail)

    def pack_READ3args(self, data):
        if data.file is None:
            raise TypeError, 'data.file == None'
        self.pack_nfs_fh3(data.file)
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset3(data.offset)
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count3(data.count)

    def pack_READ3resok(self, data):
        if data.file_attributes is None:
            raise TypeError, 'data.file_attributes == None'
        self.pack_post_op_attr(data.file_attributes)
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count3(data.count)
        if data.eof is None:
            raise TypeError, 'data.eof == None'
        self.pack_bool(data.eof)
        if data.data is None:
            raise TypeError, 'data.data == None'
        self.pack_opaque(data.data)

    def pack_READ3resfail(self, data):
        if data.file_attributes is None:
            raise TypeError, 'data.file_attributes == None'
        self.pack_post_op_attr(data.file_attributes)

    def pack_READ3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_READ3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_READ3resfail(data.resfail)

    def pack_stable_how(self, data):
        if data not in [const.UNSTABLE, const.DATA_SYNC, const.FILE_SYNC]:
            raise XDRError, 'value=%s not in enum stable_how' % data
        self.pack_int(data)

    def pack_WRITE3args(self, data):
        if data.file is None:
            raise TypeError, 'data.file == None'
        self.pack_nfs_fh3(data.file)
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset3(data.offset)
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count3(data.count)
        if data.stable is None:
            raise TypeError, 'data.stable == None'
        self.pack_stable_how(data.stable)
        if data.data is None:
            raise TypeError, 'data.data == None'
        self.pack_opaque(data.data)

    def pack_WRITE3resok(self, data):
        if data.file_wcc is None:
            raise TypeError, 'data.file_wcc == None'
        self.pack_wcc_data(data.file_wcc)
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count3(data.count)
        if data.committed is None:
            raise TypeError, 'data.committed == None'
        self.pack_stable_how(data.committed)
        if data.verf is None:
            raise TypeError, 'data.verf == None'
        self.pack_writeverf3(data.verf)

    def pack_WRITE3resfail(self, data):
        if data.file_wcc is None:
            raise TypeError, 'data.file_wcc == None'
        self.pack_wcc_data(data.file_wcc)

    def pack_WRITE3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_WRITE3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_WRITE3resfail(data.resfail)

    def pack_createmode3(self, data):
        if data not in [const.UNCHECKED, const.GUARDED, const.EXCLUSIVE]:
            raise XDRError, 'value=%s not in enum createmode3' % data
        self.pack_int(data)

    def pack_createhow3(self, data):
        if data.mode is None:
            raise TypeError, 'data.mode == None'
        self.pack_createmode3(data.mode)
        if data.mode == const.UNCHECKED or data.mode == const.GUARDED:
            if data.obj_attributes is None:
                raise TypeError, 'data.obj_attributes == None'
            self.pack_sattr3(data.obj_attributes)
        elif data.mode == const.EXCLUSIVE:
            if data.verf is None:
                raise TypeError, 'data.verf == None'
            self.pack_createverf3(data.verf)
        else:
            raise XDRError, 'bad switch=%s' % data.mode

    def pack_CREATE3args(self, data):
        if data.where is None:
            raise TypeError, 'data.where == None'
        self.pack_diropargs3(data.where)
        if data.how is None:
            raise TypeError, 'data.how == None'
        self.pack_createhow3(data.how)

    def pack_CREATE3resok(self, data):
        if data.obj is None:
            raise TypeError, 'data.obj == None'
        self.pack_post_op_fh3(data.obj)
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_CREATE3resfail(self, data):
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_CREATE3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_CREATE3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_CREATE3resfail(data.resfail)

    def pack_MKDIR3args(self, data):
        if data.where is None:
            raise TypeError, 'data.where == None'
        self.pack_diropargs3(data.where)
        if data.attributes is None:
            raise TypeError, 'data.attributes == None'
        self.pack_sattr3(data.attributes)

    def pack_MKDIR3resok(self, data):
        if data.obj is None:
            raise TypeError, 'data.obj == None'
        self.pack_post_op_fh3(data.obj)
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_MKDIR3resfail(self, data):
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_MKDIR3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_MKDIR3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_MKDIR3resfail(data.resfail)

    def pack_symlinkdata3(self, data):
        if data.symlink_attributes is None:
            raise TypeError, 'data.symlink_attributes == None'
        self.pack_sattr3(data.symlink_attributes)
        if data.symlink_data is None:
            raise TypeError, 'data.symlink_data == None'
        self.pack_nfspath3(data.symlink_data)

    def pack_SYMLINK3args(self, data):
        if data.where is None:
            raise TypeError, 'data.where == None'
        self.pack_diropargs3(data.where)
        if data.symlink is None:
            raise TypeError, 'data.symlink == None'
        self.pack_symlinkdata3(data.symlink)

    def pack_SYMLINK3resok(self, data):
        if data.obj is None:
            raise TypeError, 'data.obj == None'
        self.pack_post_op_fh3(data.obj)
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_SYMLINK3resfail(self, data):
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_SYMLINK3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_SYMLINK3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_SYMLINK3resfail(data.resfail)

    def pack_devicedata3(self, data):
        if data.dev_attributes is None:
            raise TypeError, 'data.dev_attributes == None'
        self.pack_sattr3(data.dev_attributes)
        if data.spec is None:
            raise TypeError, 'data.spec == None'
        self.pack_specdata3(data.spec)

    def pack_mknoddata3(self, data):
        if data.ftype is None:
            raise TypeError, 'data.ftype == None'
        self.pack_ftype3(data.ftype)
        if data.ftype == const.NF3CHR or data.ftype == const.NF3BLK:
            if data.device is None:
                raise TypeError, 'data.device == None'
            self.pack_devicedata3(data.device)
        elif data.ftype == const.NF3SOCK or data.ftype == const.NF3FIFO:
            if data.pipe_attributes is None:
                raise TypeError, 'data.pipe_attributes == None'
            self.pack_sattr3(data.pipe_attributes)
        else:
            pass

    def pack_MKNOD3args(self, data):
        if data.where is None:
            raise TypeError, 'data.where == None'
        self.pack_diropargs3(data.where)
        if data.what is None:
            raise TypeError, 'data.what == None'
        self.pack_mknoddata3(data.what)

    def pack_MKNOD3resok(self, data):
        if data.obj is None:
            raise TypeError, 'data.obj == None'
        self.pack_post_op_fh3(data.obj)
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_MKNOD3resfail(self, data):
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_MKNOD3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_MKNOD3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_MKNOD3resfail(data.resfail)

    def pack_REMOVE3args(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_diropargs3(data.object)

    def pack_REMOVE3resok(self, data):
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_REMOVE3resfail(self, data):
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_REMOVE3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_REMOVE3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_REMOVE3resfail(data.resfail)

    def pack_RMDIR3args(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_diropargs3(data.object)

    def pack_RMDIR3resok(self, data):
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_RMDIR3resfail(self, data):
        if data.dir_wcc is None:
            raise TypeError, 'data.dir_wcc == None'
        self.pack_wcc_data(data.dir_wcc)

    def pack_RMDIR3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_RMDIR3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_RMDIR3resfail(data.resfail)

    def pack_RENAME3args(self, data):
        if data.xfrom is None:
            raise TypeError, 'data.xfrom == None'
        self.pack_diropargs3(data.xfrom)
        if data.xto is None:
            raise TypeError, 'data.xto == None'
        self.pack_diropargs3(data.xto)

    def pack_RENAME3resok(self, data):
        if data.fromdir_wcc is None:
            raise TypeError, 'data.fromdir_wcc == None'
        self.pack_wcc_data(data.fromdir_wcc)
        if data.todir_wcc is None:
            raise TypeError, 'data.todir_wcc == None'
        self.pack_wcc_data(data.todir_wcc)

    def pack_RENAME3resfail(self, data):
        if data.fromdir_wcc is None:
            raise TypeError, 'data.fromdir_wcc == None'
        self.pack_wcc_data(data.fromdir_wcc)
        if data.todir_wcc is None:
            raise TypeError, 'data.todir_wcc == None'
        self.pack_wcc_data(data.todir_wcc)

    def pack_RENAME3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_RENAME3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_RENAME3resfail(data.resfail)

    def pack_LINK3args(self, data):
        if data.file is None:
            raise TypeError, 'data.file == None'
        self.pack_nfs_fh3(data.file)
        if data.link is None:
            raise TypeError, 'data.link == None'
        self.pack_diropargs3(data.link)

    def pack_LINK3resok(self, data):
        if data.file_attributes is None:
            raise TypeError, 'data.file_attributes == None'
        self.pack_post_op_attr(data.file_attributes)
        if data.linkdir_wcc is None:
            raise TypeError, 'data.linkdir_wcc == None'
        self.pack_wcc_data(data.linkdir_wcc)

    def pack_LINK3resfail(self, data):
        if data.file_attributes is None:
            raise TypeError, 'data.file_attributes == None'
        self.pack_post_op_attr(data.file_attributes)
        if data.linkdir_wcc is None:
            raise TypeError, 'data.linkdir_wcc == None'
        self.pack_wcc_data(data.linkdir_wcc)

    def pack_LINK3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_LINK3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_LINK3resfail(data.resfail)

    def pack_READDIR3args(self, data):
        if data.dir is None:
            raise TypeError, 'data.dir == None'
        self.pack_nfs_fh3(data.dir)
        if data.cookie is None:
            raise TypeError, 'data.cookie == None'
        self.pack_cookie3(data.cookie)
        if data.cookieverf is None:
            raise TypeError, 'data.cookieverf == None'
        self.pack_cookieverf3(data.cookieverf)
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count3(data.count)

    def pack_entry3(self, data):
        if data.fileid is None:
            raise TypeError, 'data.fileid == None'
        self.pack_fileid3(data.fileid)
        if data.name is None:
            raise TypeError, 'data.name == None'
        self.pack_filename3(data.name)
        if data.cookie is None:
            raise TypeError, 'data.cookie == None'
        self.pack_cookie3(data.cookie)
        if data.nextentry is None:
            raise TypeError, 'data.nextentry == None'
        if len(data.nextentry) > 1:
            raise XDRError, 'array length too long for data.nextentry'
        self.pack_array(data.nextentry, self.pack_entry3)

    def pack_dirlist3(self, data):
        if data.entries is None:
            raise TypeError, 'data.entries == None'
        if len(data.entries) > 1:
            raise XDRError, 'array length too long for data.entries'
        self.pack_array(data.entries, self.pack_entry3)
        if data.eof is None:
            raise TypeError, 'data.eof == None'
        self.pack_bool(data.eof)

    def pack_READDIR3resok(self, data):
        if data.dir_attributes is None:
            raise TypeError, 'data.dir_attributes == None'
        self.pack_post_op_attr(data.dir_attributes)
        if data.cookieverf is None:
            raise TypeError, 'data.cookieverf == None'
        self.pack_cookieverf3(data.cookieverf)
        if data.reply is None:
            raise TypeError, 'data.reply == None'
        self.pack_dirlist3(data.reply)

    def pack_READDIR3resfail(self, data):
        if data.dir_attributes is None:
            raise TypeError, 'data.dir_attributes == None'
        self.pack_post_op_attr(data.dir_attributes)

    def pack_READDIR3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_READDIR3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_READDIR3resfail(data.resfail)

    def pack_READDIRPLUS3args(self, data):
        if data.dir is None:
            raise TypeError, 'data.dir == None'
        self.pack_nfs_fh3(data.dir)
        if data.cookie is None:
            raise TypeError, 'data.cookie == None'
        self.pack_cookie3(data.cookie)
        if data.cookieverf is None:
            raise TypeError, 'data.cookieverf == None'
        self.pack_cookieverf3(data.cookieverf)
        if data.dircount is None:
            raise TypeError, 'data.dircount == None'
        self.pack_count3(data.dircount)
        if data.maxcount is None:
            raise TypeError, 'data.maxcount == None'
        self.pack_count3(data.maxcount)

    def pack_entryplus3(self, data):
        if data.fileid is None:
            raise TypeError, 'data.fileid == None'
        self.pack_fileid3(data.fileid)
        if data.name is None:
            raise TypeError, 'data.name == None'
        self.pack_filename3(data.name)
        if data.cookie is None:
            raise TypeError, 'data.cookie == None'
        self.pack_cookie3(data.cookie)
        if data.name_attributes is None:
            raise TypeError, 'data.name_attributes == None'
        self.pack_post_op_attr(data.name_attributes)
        if data.name_handle is None:
            raise TypeError, 'data.name_handle == None'
        self.pack_post_op_fh3(data.name_handle)
        if data.nextentry is None:
            raise TypeError, 'data.nextentry == None'
        if len(data.nextentry) > 1:
            raise XDRError, 'array length too long for data.nextentry'
        self.pack_array(data.nextentry, self.pack_entryplus3)

    def pack_dirlistplus3(self, data):
        if data.entries is None:
            raise TypeError, 'data.entries == None'
        if len(data.entries) > 1:
            raise XDRError, 'array length too long for data.entries'
        self.pack_array(data.entries, self.pack_entryplus3)
        if data.eof is None:
            raise TypeError, 'data.eof == None'
        self.pack_bool(data.eof)

    def pack_READDIRPLUS3resok(self, data):
        if data.dir_attributes is None:
            raise TypeError, 'data.dir_attributes == None'
        self.pack_post_op_attr(data.dir_attributes)
        if data.cookieverf is None:
            raise TypeError, 'data.cookieverf == None'
        self.pack_cookieverf3(data.cookieverf)
        if data.reply is None:
            raise TypeError, 'data.reply == None'
        self.pack_dirlistplus3(data.reply)

    def pack_READDIRPLUS3resfail(self, data):
        if data.dir_attributes is None:
            raise TypeError, 'data.dir_attributes == None'
        self.pack_post_op_attr(data.dir_attributes)

    def pack_READDIRPLUS3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_READDIRPLUS3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_READDIRPLUS3resfail(data.resfail)

    def pack_FSSTAT3args(self, data):
        if data.fsroot is None:
            raise TypeError, 'data.fsroot == None'
        self.pack_nfs_fh3(data.fsroot)

    def pack_FSSTAT3resok(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.tbytes is None:
            raise TypeError, 'data.tbytes == None'
        self.pack_size3(data.tbytes)
        if data.fbytes is None:
            raise TypeError, 'data.fbytes == None'
        self.pack_size3(data.fbytes)
        if data.abytes is None:
            raise TypeError, 'data.abytes == None'
        self.pack_size3(data.abytes)
        if data.tfiles is None:
            raise TypeError, 'data.tfiles == None'
        self.pack_size3(data.tfiles)
        if data.ffiles is None:
            raise TypeError, 'data.ffiles == None'
        self.pack_size3(data.ffiles)
        if data.afiles is None:
            raise TypeError, 'data.afiles == None'
        self.pack_size3(data.afiles)
        if data.invarsec is None:
            raise TypeError, 'data.invarsec == None'
        self.pack_uint32(data.invarsec)

    def pack_FSSTAT3resfail(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)

    def pack_FSSTAT3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_FSSTAT3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_FSSTAT3resfail(data.resfail)

    def pack_FSINFO3args(self, data):
        if data.fsroot is None:
            raise TypeError, 'data.fsroot == None'
        self.pack_nfs_fh3(data.fsroot)

    def pack_FSINFO3resok(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.rtmax is None:
            raise TypeError, 'data.rtmax == None'
        self.pack_uint32(data.rtmax)
        if data.rtpref is None:
            raise TypeError, 'data.rtpref == None'
        self.pack_uint32(data.rtpref)
        if data.rtmult is None:
            raise TypeError, 'data.rtmult == None'
        self.pack_uint32(data.rtmult)
        if data.wtmax is None:
            raise TypeError, 'data.wtmax == None'
        self.pack_uint32(data.wtmax)
        if data.wtpref is None:
            raise TypeError, 'data.wtpref == None'
        self.pack_uint32(data.wtpref)
        if data.wtmult is None:
            raise TypeError, 'data.wtmult == None'
        self.pack_uint32(data.wtmult)
        if data.dtpref is None:
            raise TypeError, 'data.dtpref == None'
        self.pack_uint32(data.dtpref)
        if data.maxfilesize is None:
            raise TypeError, 'data.maxfilesize == None'
        self.pack_size3(data.maxfilesize)
        if data.time_delta is None:
            raise TypeError, 'data.time_delta == None'
        self.pack_nfstime3(data.time_delta)
        if data.properties is None:
            raise TypeError, 'data.properties == None'
        self.pack_uint32(data.properties)

    def pack_FSINFO3resfail(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)

    def pack_FSINFO3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_FSINFO3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_FSINFO3resfail(data.resfail)

    def pack_PATHCONF3args(self, data):
        if data.object is None:
            raise TypeError, 'data.object == None'
        self.pack_nfs_fh3(data.object)

    def pack_PATHCONF3resok(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)
        if data.linkmax is None:
            raise TypeError, 'data.linkmax == None'
        self.pack_uint32(data.linkmax)
        if data.name_max is None:
            raise TypeError, 'data.name_max == None'
        self.pack_uint32(data.name_max)
        if data.no_trunc is None:
            raise TypeError, 'data.no_trunc == None'
        self.pack_bool(data.no_trunc)
        if data.chown_restricted is None:
            raise TypeError, 'data.chown_restricted == None'
        self.pack_bool(data.chown_restricted)
        if data.case_insensitive is None:
            raise TypeError, 'data.case_insensitive == None'
        self.pack_bool(data.case_insensitive)
        if data.case_preserving is None:
            raise TypeError, 'data.case_preserving == None'
        self.pack_bool(data.case_preserving)

    def pack_PATHCONF3resfail(self, data):
        if data.obj_attributes is None:
            raise TypeError, 'data.obj_attributes == None'
        self.pack_post_op_attr(data.obj_attributes)

    def pack_PATHCONF3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_PATHCONF3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_PATHCONF3resfail(data.resfail)

    def pack_COMMIT3args(self, data):
        if data.file is None:
            raise TypeError, 'data.file == None'
        self.pack_nfs_fh3(data.file)
        if data.offset is None:
            raise TypeError, 'data.offset == None'
        self.pack_offset3(data.offset)
        if data.count is None:
            raise TypeError, 'data.count == None'
        self.pack_count3(data.count)

    def pack_COMMIT3resok(self, data):
        if data.file_wcc is None:
            raise TypeError, 'data.file_wcc == None'
        self.pack_wcc_data(data.file_wcc)
        if data.verf is None:
            raise TypeError, 'data.verf == None'
        self.pack_writeverf3(data.verf)

    def pack_COMMIT3resfail(self, data):
        if data.file_wcc is None:
            raise TypeError, 'data.file_wcc == None'
        self.pack_wcc_data(data.file_wcc)

    def pack_COMMIT3res(self, data):
        if data.status is None:
            raise TypeError, 'data.status == None'
        self.pack_nfsstat3(data.status)
        if data.status == const.NFS3_OK:
            if data.resok is None:
                raise TypeError, 'data.resok == None'
            self.pack_COMMIT3resok(data.resok)
        else:
            if data.resfail is None:
                raise TypeError, 'data.resfail == None'
            self.pack_COMMIT3resfail(data.resfail)

    def pack_fhandle3(self, data):
        if len(data) > const.FHSIZE3:
            raise XDRError, 'array length too long for data'
        self.pack_opaque(data)

    def pack_dirpath3(self, data):
        if len(data) > const.MNTPATHLEN3:
            raise XDRError, 'array length too long for data'
        self.pack_string(data)

    def pack_name3(self, data):
        if len(data) > const.MNTNAMLEN3:
            raise XDRError, 'array length too long for data'
        self.pack_string(data)

    def pack_mountstat3(self, data):
        if data not in [const.MNT3_OK, const.MNT3ERR_PERM, const.MNT3ERR_NOENT, const.MNT3ERR_IO, const.MNT3ERR_ACCES, const.MNT3ERR_NOTDIR, const.MNT3ERR_INVAL, const.MNT3ERR_NAMETOOLONG, const.MNT3ERR_NOTSUPP, const.MNT3ERR_SERVERFAULT]:
            raise XDRError, 'value=%s not in enum mountstat3' % data
        self.pack_int(data)

    def pack_mountres3_ok(self, data):
        if data.fhandle is None:
            raise TypeError, 'data.fhandle == None'
        self.pack_fhandle3(data.fhandle)
        if data.auth_flavors is None:
            raise TypeError, 'data.auth_flavors == None'
        self.pack_array(data.auth_flavors, self.pack_uint)

    def pack_mountres3(self, data):
        if data.fhs_status is None:
            raise TypeError, 'data.fhs_status == None'
        self.pack_mountstat3(data.fhs_status)
        if data.fhs_status == const.MNT3_OK:
            if data.mountinfo is None:
                raise TypeError, 'data.mountinfo == None'
            self.pack_mountres3_ok(data.mountinfo)
        else:
            pass

    def pack_mount3(self, data):
        if data.ml_hostname is None:
            raise TypeError, 'data.ml_hostname == None'
        self.pack_name3(data.ml_hostname)
        if data.ml_directory is None:
            raise TypeError, 'data.ml_directory == None'
        self.pack_dirpath3(data.ml_directory)
        if data.ml_next is None:
            raise TypeError, 'data.ml_next == None'
        if len(data.ml_next) > 1:
            raise XDRError, 'array length too long for data.ml_next'
        self.pack_array(data.ml_next, self.pack_mount3)

    def pack_mountopt3(self, data):
        if len(data) > 1:
            raise XDRError, 'array length too long for data'
        self.pack_array(data, self.pack_mount3)

    def pack_groups3(self, data):
        if data.gr_name is None:
            raise TypeError, 'data.gr_name == None'
        self.pack_name3(data.gr_name)
        if data.gr_next is None:
            raise TypeError, 'data.gr_next == None'
        if len(data.gr_next) > 1:
            raise XDRError, 'array length too long for data.gr_next'
        self.pack_array(data.gr_next, self.pack_groups3)

    def pack_exports3(self, data):
        if data.ex_dir is None:
            raise TypeError, 'data.ex_dir == None'
        self.pack_dirpath3(data.ex_dir)
        if data.ex_groups is None:
            raise TypeError, 'data.ex_groups == None'
        if len(data.ex_groups) > 1:
            raise XDRError, 'array length too long for data.ex_groups'
        self.pack_array(data.ex_groups, self.pack_groups3)
        if data.ex_next is None:
            raise TypeError, 'data.ex_next == None'
        if len(data.ex_next) > 1:
            raise XDRError, 'array length too long for data.ex_next'
        self.pack_array(data.ex_next, self.pack_exports3)

    def pack_exportsopt3(self, data):
        if len(data) > 1:
            raise XDRError, 'array length too long for data'
        self.pack_array(data, self.pack_exports3)

class protUnpacker(xdrlib.Unpacker):
    unpack_short = xdrlib.Unpacker.unpack_int
    unpack_string = xdrlib.Unpacker.unpack_string
    unpack_ulong = xdrlib.Unpacker.unpack_uint
    unpack_opaque = xdrlib.Unpacker.unpack_opaque
    unpack_int = xdrlib.Unpacker.unpack_int
    unpack_double = xdrlib.Unpacker.unpack_double
    unpack_ushort = xdrlib.Unpacker.unpack_uint
    unpack_unsigned = xdrlib.Unpacker.unpack_uint
    unpack_long = xdrlib.Unpacker.unpack_int
    unpack_uhyper = xdrlib.Unpacker.unpack_uhyper
    unpack_char = xdrlib.Unpacker.unpack_int
    unpack_uchar = xdrlib.Unpacker.unpack_uint
    unpack_float = xdrlib.Unpacker.unpack_float
    unpack_hyper = xdrlib.Unpacker.unpack_hyper
    unpack_uint = xdrlib.Unpacker.unpack_uint
    unpack_quadruple = xdrlib.Unpacker.unpack_double
    unpack_bool = xdrlib.Unpacker.unpack_bool
    unpack_uint64 = unpack_uhyper

    unpack_uint32 = unpack_uint

    def unpack_filename3(self):
        data = self.unpack_string()
        return data

    def unpack_nfspath3(self):
        data = self.unpack_string()
        return data

    unpack_fileid3 = unpack_uint64

    unpack_cookie3 = unpack_uint64

    def unpack_cookieverf3(self):
        data = self.unpack_fopaque(const.NFS3_COOKIEVERFSIZE)
        return data

    def unpack_createverf3(self):
        data = self.unpack_fopaque(const.NFS3_CREATEVERFSIZE)
        return data

    def unpack_writeverf3(self):
        data = self.unpack_fopaque(const.NFS3_WRITEVERFSIZE)
        return data

    unpack_uid3 = unpack_uint32

    unpack_gid3 = unpack_uint32

    unpack_size3 = unpack_uint64

    unpack_offset3 = unpack_uint64

    unpack_mode3 = unpack_uint32

    unpack_count3 = unpack_uint32

    def unpack_nfsstat3(self):
        data = self.unpack_int()
        if data not in [const.NFS3_OK, const.NFS3ERR_PERM, const.NFS3ERR_NOENT, const.NFS3ERR_IO, const.NFS3ERR_NXIO, const.NFS3ERR_ACCES, const.NFS3ERR_EXIST, const.NFS3ERR_XDEV, const.NFS3ERR_NODEV, const.NFS3ERR_NOTDIR, const.NFS3ERR_ISDIR, const.NFS3ERR_INVAL, const.NFS3ERR_FBIG, const.NFS3ERR_NOSPC, const.NFS3ERR_ROFS, const.NFS3ERR_MLINK, const.NFS3ERR_NAMETOOLONG, const.NFS3ERR_NOTEMPTY, const.NFS3ERR_DQUOT, const.NFS3ERR_STALE, const.NFS3ERR_REMOTE, const.NFS3ERR_BADHANDLE, const.NFS3ERR_NOT_SYNC, const.NFS3ERR_BAD_COOKIE, const.NFS3ERR_NOTSUPP, const.NFS3ERR_TOOSMALL, const.NFS3ERR_SERVERFAULT, const.NFS3ERR_BADTYPE, const.NFS3ERR_JUKEBOX]:
            raise XDRError, 'value=%s not in enum nfsstat3' % data
        return data

    def unpack_ftype3(self):
        data = self.unpack_int()
        if data not in [const.NF3REG, const.NF3DIR, const.NF3BLK, const.NF3CHR, const.NF3LNK, const.NF3SOCK, const.NF3FIFO]:
            raise XDRError, 'value=%s not in enum ftype3' % data
        return data

    def unpack_specdata3(self):
        data = types.specdata3()
        data.specdata1 = self.unpack_uint32()
        data.specdata2 = self.unpack_uint32()
        return data

    def unpack_nfs_fh3(self):
        data = types.nfs_fh3()
        data.data = self.unpack_opaque()
        if len(data.data) > const.NFS3_FHSIZE:
            raise XDRError, 'array length too long for data.data'
        return data

    def unpack_nfstime3(self):
        data = types.nfstime3()
        data.seconds = self.unpack_uint32()
        data.nseconds = self.unpack_uint32()
        return data

    def unpack_fattr3(self):
        data = types.fattr3()
        data.ftype = self.unpack_ftype3()
        data.mode = self.unpack_mode3()
        data.nlink = self.unpack_uint32()
        data.uid = self.unpack_uid3()
        data.gid = self.unpack_gid3()
        data.size = self.unpack_size3()
        data.used = self.unpack_size3()
        data.rdev = self.unpack_specdata3()
        data.fsid = self.unpack_uint64()
        data.fileid = self.unpack_fileid3()
        data.atime = self.unpack_nfstime3()
        data.mtime = self.unpack_nfstime3()
        data.ctime = self.unpack_nfstime3()
        return data

    def unpack_post_op_attr(self):
        data = types.post_op_attr()
        data.attributes_follow = self.unpack_bool()
        if data.attributes_follow == const.TRUE:
            data.attributes = self.unpack_fattr3()
            data.arm = data.attributes
        elif data.attributes_follow == const.FALSE:
            pass
            data.arm = None
        else:
            raise XDRError, 'bad switch=%s' % data.attributes_follow
        return data

    def unpack_wcc_attr(self):
        data = types.wcc_attr()
        data.size = self.unpack_size3()
        data.mtime = self.unpack_nfstime3()
        data.ctime = self.unpack_nfstime3()
        return data

    def unpack_pre_op_attr(self):
        data = types.pre_op_attr()
        data.attributes_follow = self.unpack_bool()
        if data.attributes_follow == const.TRUE:
            data.attributes = self.unpack_wcc_attr()
            data.arm = data.attributes
        elif data.attributes_follow == const.FALSE:
            pass
            data.arm = None
        else:
            raise XDRError, 'bad switch=%s' % data.attributes_follow
        return data

    def unpack_wcc_data(self):
        data = types.wcc_data()
        data.before = self.unpack_pre_op_attr()
        data.after = self.unpack_post_op_attr()
        return data

    def unpack_post_op_fh3(self):
        data = types.post_op_fh3()
        data.handle_follows = self.unpack_bool()
        if data.handle_follows == const.TRUE:
            data.handle = self.unpack_nfs_fh3()
            data.arm = data.handle
        elif data.handle_follows == const.FALSE:
            pass
            data.arm = None
        else:
            raise XDRError, 'bad switch=%s' % data.handle_follows
        return data

    def unpack_time_how(self):
        data = self.unpack_int()
        if data not in [const.DONT_CHANGE, const.SET_TO_SERVER_TIME, const.SET_TO_CLIENT_TIME]:
            raise XDRError, 'value=%s not in enum time_how' % data
        return data

    def unpack_set_mode3(self):
        data = types.set_mode3()
        data.set_it = self.unpack_bool()
        if data.set_it == const.TRUE:
            data.mode = self.unpack_mode3()
            data.arm = data.mode
        else:
            pass
            data.arm = None
        return data

    def unpack_set_uid3(self):
        data = types.set_uid3()
        data.set_it = self.unpack_bool()
        if data.set_it == const.TRUE:
            data.uid = self.unpack_uid3()
            data.arm = data.uid
        else:
            pass
            data.arm = None
        return data

    def unpack_set_gid3(self):
        data = types.set_gid3()
        data.set_it = self.unpack_bool()
        if data.set_it == const.TRUE:
            data.gid = self.unpack_gid3()
            data.arm = data.gid
        else:
            pass
            data.arm = None
        return data

    def unpack_set_size3(self):
        data = types.set_size3()
        data.set_it = self.unpack_bool()
        if data.set_it == const.TRUE:
            data.size = self.unpack_size3()
            data.arm = data.size
        else:
            pass
            data.arm = None
        return data

    def unpack_set_atime(self):
        data = types.set_atime()
        data.set_it = self.unpack_time_how()
        if data.set_it == const.SET_TO_CLIENT_TIME:
            data.atime = self.unpack_nfstime3()
            data.arm = data.atime
        else:
            pass
            data.arm = None
        return data

    def unpack_set_mtime(self):
        data = types.set_mtime()
        data.set_it = self.unpack_time_how()
        if data.set_it == const.SET_TO_CLIENT_TIME:
            data.mtime = self.unpack_nfstime3()
            data.arm = data.mtime
        else:
            pass
            data.arm = None
        return data

    def unpack_sattr3(self):
        data = types.sattr3()
        data.mode = self.unpack_set_mode3()
        data.uid = self.unpack_set_uid3()
        data.gid = self.unpack_set_gid3()
        data.size = self.unpack_set_size3()
        data.atime = self.unpack_set_atime()
        data.mtime = self.unpack_set_mtime()
        return data

    def unpack_diropargs3(self):
        data = types.diropargs3()
        data.dir = self.unpack_nfs_fh3()
        data.name = self.unpack_filename3()
        return data

    def unpack_GETATTR3args(self):
        data = types.GETATTR3args()
        data.object = self.unpack_nfs_fh3()
        return data

    def unpack_GETATTR3resok(self):
        data = types.GETATTR3resok()
        data.obj_attributes = self.unpack_fattr3()
        return data

    def unpack_GETATTR3res(self):
        data = types.GETATTR3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_GETATTR3resok()
            data.arm = data.resok
        else:
            pass
            data.arm = None
        return data

    def unpack_sattrguard3(self):
        data = types.sattrguard3()
        data.check = self.unpack_bool()
        if data.check == const.TRUE:
            data.obj_ctime = self.unpack_nfstime3()
            data.arm = data.obj_ctime
        elif data.check == const.FALSE:
            pass
            data.arm = None
        else:
            raise XDRError, 'bad switch=%s' % data.check
        return data

    def unpack_SETATTR3args(self):
        data = types.SETATTR3args()
        data.object = self.unpack_nfs_fh3()
        data.new_attributes = self.unpack_sattr3()
        data.guard = self.unpack_sattrguard3()
        return data

    def unpack_SETATTR3resok(self):
        data = types.SETATTR3resok()
        data.obj_wcc = self.unpack_wcc_data()
        return data

    def unpack_SETATTR3resfail(self):
        data = types.SETATTR3resfail()
        data.obj_wcc = self.unpack_wcc_data()
        return data

    def unpack_SETATTR3res(self):
        data = types.SETATTR3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_SETATTR3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_SETATTR3resfail()
            data.arm = data.resfail
        return data

    def unpack_LOOKUP3args(self):
        data = types.LOOKUP3args()
        data.what = self.unpack_diropargs3()
        return data

    def unpack_LOOKUP3resok(self):
        data = types.LOOKUP3resok()
        data.object = self.unpack_nfs_fh3()
        data.obj_attributes = self.unpack_post_op_attr()
        data.dir_attributes = self.unpack_post_op_attr()
        return data

    def unpack_LOOKUP3resfail(self):
        data = types.LOOKUP3resfail()
        data.dir_attributes = self.unpack_post_op_attr()
        return data

    def unpack_LOOKUP3res(self):
        data = types.LOOKUP3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_LOOKUP3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_LOOKUP3resfail()
            data.arm = data.resfail
        return data

    def unpack_ACCESS3args(self):
        data = types.ACCESS3args()
        data.object = self.unpack_nfs_fh3()
        data.access = self.unpack_uint32()
        return data

    def unpack_ACCESS3resok(self):
        data = types.ACCESS3resok()
        data.obj_attributes = self.unpack_post_op_attr()
        data.access = self.unpack_uint32()
        return data

    def unpack_ACCESS3resfail(self):
        data = types.ACCESS3resfail()
        data.obj_attributes = self.unpack_post_op_attr()
        return data

    def unpack_ACCESS3res(self):
        data = types.ACCESS3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_ACCESS3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_ACCESS3resfail()
            data.arm = data.resfail
        return data

    def unpack_READLINK3args(self):
        data = types.READLINK3args()
        data.symlink = self.unpack_nfs_fh3()
        return data

    def unpack_READLINK3resok(self):
        data = types.READLINK3resok()
        data.symlink_attributes = self.unpack_post_op_attr()
        data.data = self.unpack_nfspath3()
        return data

    def unpack_READLINK3resfail(self):
        data = types.READLINK3resfail()
        data.symlink_attributes = self.unpack_post_op_attr()
        return data

    def unpack_READLINK3res(self):
        data = types.READLINK3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_READLINK3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_READLINK3resfail()
            data.arm = data.resfail
        return data

    def unpack_READ3args(self):
        data = types.READ3args()
        data.file = self.unpack_nfs_fh3()
        data.offset = self.unpack_offset3()
        data.count = self.unpack_count3()
        return data

    def unpack_READ3resok(self):
        data = types.READ3resok()
        data.file_attributes = self.unpack_post_op_attr()
        data.count = self.unpack_count3()
        data.eof = self.unpack_bool()
        data.data = self.unpack_opaque()
        return data

    def unpack_READ3resfail(self):
        data = types.READ3resfail()
        data.file_attributes = self.unpack_post_op_attr()
        return data

    def unpack_READ3res(self):
        data = types.READ3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_READ3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_READ3resfail()
            data.arm = data.resfail
        return data

    def unpack_stable_how(self):
        data = self.unpack_int()
        if data not in [const.UNSTABLE, const.DATA_SYNC, const.FILE_SYNC]:
            raise XDRError, 'value=%s not in enum stable_how' % data
        return data

    def unpack_WRITE3args(self):
        data = types.WRITE3args()
        data.file = self.unpack_nfs_fh3()
        data.offset = self.unpack_offset3()
        data.count = self.unpack_count3()
        data.stable = self.unpack_stable_how()
        data.data = self.unpack_opaque()
        return data

    def unpack_WRITE3resok(self):
        data = types.WRITE3resok()
        data.file_wcc = self.unpack_wcc_data()
        data.count = self.unpack_count3()
        data.committed = self.unpack_stable_how()
        data.verf = self.unpack_writeverf3()
        return data

    def unpack_WRITE3resfail(self):
        data = types.WRITE3resfail()
        data.file_wcc = self.unpack_wcc_data()
        return data

    def unpack_WRITE3res(self):
        data = types.WRITE3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_WRITE3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_WRITE3resfail()
            data.arm = data.resfail
        return data

    def unpack_createmode3(self):
        data = self.unpack_int()
        if data not in [const.UNCHECKED, const.GUARDED, const.EXCLUSIVE]:
            raise XDRError, 'value=%s not in enum createmode3' % data
        return data

    def unpack_createhow3(self):
        data = types.createhow3()
        data.mode = self.unpack_createmode3()
        if data.mode == const.UNCHECKED or data.mode == const.GUARDED:
            data.obj_attributes = self.unpack_sattr3()
            data.arm = data.obj_attributes
        elif data.mode == const.EXCLUSIVE:
            data.verf = self.unpack_createverf3()
            data.arm = data.verf
        else:
            raise XDRError, 'bad switch=%s' % data.mode
        return data

    def unpack_CREATE3args(self):
        data = types.CREATE3args()
        data.where = self.unpack_diropargs3()
        data.how = self.unpack_createhow3()
        return data

    def unpack_CREATE3resok(self):
        data = types.CREATE3resok()
        data.obj = self.unpack_post_op_fh3()
        data.obj_attributes = self.unpack_post_op_attr()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_CREATE3resfail(self):
        data = types.CREATE3resfail()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_CREATE3res(self):
        data = types.CREATE3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_CREATE3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_CREATE3resfail()
            data.arm = data.resfail
        return data

    def unpack_MKDIR3args(self):
        data = types.MKDIR3args()
        data.where = self.unpack_diropargs3()
        data.attributes = self.unpack_sattr3()
        return data

    def unpack_MKDIR3resok(self):
        data = types.MKDIR3resok()
        data.obj = self.unpack_post_op_fh3()
        data.obj_attributes = self.unpack_post_op_attr()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_MKDIR3resfail(self):
        data = types.MKDIR3resfail()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_MKDIR3res(self):
        data = types.MKDIR3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_MKDIR3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_MKDIR3resfail()
            data.arm = data.resfail
        return data

    def unpack_symlinkdata3(self):
        data = types.symlinkdata3()
        data.symlink_attributes = self.unpack_sattr3()
        data.symlink_data = self.unpack_nfspath3()
        return data

    def unpack_SYMLINK3args(self):
        data = types.SYMLINK3args()
        data.where = self.unpack_diropargs3()
        data.symlink = self.unpack_symlinkdata3()
        return data

    def unpack_SYMLINK3resok(self):
        data = types.SYMLINK3resok()
        data.obj = self.unpack_post_op_fh3()
        data.obj_attributes = self.unpack_post_op_attr()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_SYMLINK3resfail(self):
        data = types.SYMLINK3resfail()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_SYMLINK3res(self):
        data = types.SYMLINK3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_SYMLINK3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_SYMLINK3resfail()
            data.arm = data.resfail
        return data

    def unpack_devicedata3(self):
        data = types.devicedata3()
        data.dev_attributes = self.unpack_sattr3()
        data.spec = self.unpack_specdata3()
        return data

    def unpack_mknoddata3(self):
        data = types.mknoddata3()
        data.ftype = self.unpack_ftype3()
        if data.ftype == const.NF3CHR or data.ftype == const.NF3BLK:
            data.device = self.unpack_devicedata3()
            data.arm = data.device
        elif data.ftype == const.NF3SOCK or data.ftype == const.NF3FIFO:
            data.pipe_attributes = self.unpack_sattr3()
            data.arm = data.pipe_attributes
        else:
            pass
            data.arm = None
        return data

    def unpack_MKNOD3args(self):
        data = types.MKNOD3args()
        data.where = self.unpack_diropargs3()
        data.what = self.unpack_mknoddata3()
        return data

    def unpack_MKNOD3resok(self):
        data = types.MKNOD3resok()
        data.obj = self.unpack_post_op_fh3()
        data.obj_attributes = self.unpack_post_op_attr()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_MKNOD3resfail(self):
        data = types.MKNOD3resfail()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_MKNOD3res(self):
        data = types.MKNOD3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_MKNOD3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_MKNOD3resfail()
            data.arm = data.resfail
        return data

    def unpack_REMOVE3args(self):
        data = types.REMOVE3args()
        data.object = self.unpack_diropargs3()
        return data

    def unpack_REMOVE3resok(self):
        data = types.REMOVE3resok()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_REMOVE3resfail(self):
        data = types.REMOVE3resfail()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_REMOVE3res(self):
        data = types.REMOVE3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_REMOVE3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_REMOVE3resfail()
            data.arm = data.resfail
        return data

    def unpack_RMDIR3args(self):
        data = types.RMDIR3args()
        data.object = self.unpack_diropargs3()
        return data

    def unpack_RMDIR3resok(self):
        data = types.RMDIR3resok()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_RMDIR3resfail(self):
        data = types.RMDIR3resfail()
        data.dir_wcc = self.unpack_wcc_data()
        return data

    def unpack_RMDIR3res(self):
        data = types.RMDIR3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_RMDIR3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_RMDIR3resfail()
            data.arm = data.resfail
        return data

    def unpack_RENAME3args(self):
        data = types.RENAME3args()
        data.xfrom = self.unpack_diropargs3()
        data.xto = self.unpack_diropargs3()
        return data

    def unpack_RENAME3resok(self):
        data = types.RENAME3resok()
        data.fromdir_wcc = self.unpack_wcc_data()
        data.todir_wcc = self.unpack_wcc_data()
        return data

    def unpack_RENAME3resfail(self):
        data = types.RENAME3resfail()
        data.fromdir_wcc = self.unpack_wcc_data()
        data.todir_wcc = self.unpack_wcc_data()
        return data

    def unpack_RENAME3res(self):
        data = types.RENAME3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_RENAME3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_RENAME3resfail()
            data.arm = data.resfail
        return data

    def unpack_LINK3args(self):
        data = types.LINK3args()
        data.file = self.unpack_nfs_fh3()
        data.link = self.unpack_diropargs3()
        return data

    def unpack_LINK3resok(self):
        data = types.LINK3resok()
        data.file_attributes = self.unpack_post_op_attr()
        data.linkdir_wcc = self.unpack_wcc_data()
        return data

    def unpack_LINK3resfail(self):
        data = types.LINK3resfail()
        data.file_attributes = self.unpack_post_op_attr()
        data.linkdir_wcc = self.unpack_wcc_data()
        return data

    def unpack_LINK3res(self):
        data = types.LINK3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_LINK3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_LINK3resfail()
            data.arm = data.resfail
        return data

    def unpack_READDIR3args(self):
        data = types.READDIR3args()
        data.dir = self.unpack_nfs_fh3()
        data.cookie = self.unpack_cookie3()
        data.cookieverf = self.unpack_cookieverf3()
        data.count = self.unpack_count3()
        return data

    def unpack_entry3(self):
        data = types.entry3()
        data.fileid = self.unpack_fileid3()
        data.name = self.unpack_filename3()
        data.cookie = self.unpack_cookie3()
        data.nextentry = self.unpack_array(self.unpack_entry3)
        if len(data.nextentry) > 1:
            raise XDRError, 'array length too long for data.nextentry'
        return data

    def unpack_dirlist3(self):
        data = types.dirlist3()
        data.entries = self.unpack_array(self.unpack_entry3)
        if len(data.entries) > 1:
            raise XDRError, 'array length too long for data.entries'
        data.eof = self.unpack_bool()
        return data

    def unpack_READDIR3resok(self):
        data = types.READDIR3resok()
        data.dir_attributes = self.unpack_post_op_attr()
        data.cookieverf = self.unpack_cookieverf3()
        data.reply = self.unpack_dirlist3()
        return data

    def unpack_READDIR3resfail(self):
        data = types.READDIR3resfail()
        data.dir_attributes = self.unpack_post_op_attr()
        return data

    def unpack_READDIR3res(self):
        data = types.READDIR3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_READDIR3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_READDIR3resfail()
            data.arm = data.resfail
        return data

    def unpack_READDIRPLUS3args(self):
        data = types.READDIRPLUS3args()
        data.dir = self.unpack_nfs_fh3()
        data.cookie = self.unpack_cookie3()
        data.cookieverf = self.unpack_cookieverf3()
        data.dircount = self.unpack_count3()
        data.maxcount = self.unpack_count3()
        return data

    def unpack_entryplus3(self):
        data = types.entryplus3()
        data.fileid = self.unpack_fileid3()
        data.name = self.unpack_filename3()
        data.cookie = self.unpack_cookie3()
        data.name_attributes = self.unpack_post_op_attr()
        data.name_handle = self.unpack_post_op_fh3()
        data.nextentry = self.unpack_array(self.unpack_entryplus3)
        if len(data.nextentry) > 1:
            raise XDRError, 'array length too long for data.nextentry'
        return data

    def unpack_dirlistplus3(self):
        data = types.dirlistplus3()
        data.entries = self.unpack_array(self.unpack_entryplus3)
        if len(data.entries) > 1:
            raise XDRError, 'array length too long for data.entries'
        data.eof = self.unpack_bool()
        return data

    def unpack_READDIRPLUS3resok(self):
        data = types.READDIRPLUS3resok()
        data.dir_attributes = self.unpack_post_op_attr()
        data.cookieverf = self.unpack_cookieverf3()
        data.reply = self.unpack_dirlistplus3()
        return data

    def unpack_READDIRPLUS3resfail(self):
        data = types.READDIRPLUS3resfail()
        data.dir_attributes = self.unpack_post_op_attr()
        return data

    def unpack_READDIRPLUS3res(self):
        data = types.READDIRPLUS3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_READDIRPLUS3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_READDIRPLUS3resfail()
            data.arm = data.resfail
        return data

    def unpack_FSSTAT3args(self):
        data = types.FSSTAT3args()
        data.fsroot = self.unpack_nfs_fh3()
        return data

    def unpack_FSSTAT3resok(self):
        data = types.FSSTAT3resok()
        data.obj_attributes = self.unpack_post_op_attr()
        data.tbytes = self.unpack_size3()
        data.fbytes = self.unpack_size3()
        data.abytes = self.unpack_size3()
        data.tfiles = self.unpack_size3()
        data.ffiles = self.unpack_size3()
        data.afiles = self.unpack_size3()
        data.invarsec = self.unpack_uint32()
        return data

    def unpack_FSSTAT3resfail(self):
        data = types.FSSTAT3resfail()
        data.obj_attributes = self.unpack_post_op_attr()
        return data

    def unpack_FSSTAT3res(self):
        data = types.FSSTAT3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_FSSTAT3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_FSSTAT3resfail()
            data.arm = data.resfail
        return data

    def unpack_FSINFO3args(self):
        data = types.FSINFO3args()
        data.fsroot = self.unpack_nfs_fh3()
        return data

    def unpack_FSINFO3resok(self):
        data = types.FSINFO3resok()
        data.obj_attributes = self.unpack_post_op_attr()
        data.rtmax = self.unpack_uint32()
        data.rtpref = self.unpack_uint32()
        data.rtmult = self.unpack_uint32()
        data.wtmax = self.unpack_uint32()
        data.wtpref = self.unpack_uint32()
        data.wtmult = self.unpack_uint32()
        data.dtpref = self.unpack_uint32()
        data.maxfilesize = self.unpack_size3()
        data.time_delta = self.unpack_nfstime3()
        data.properties = self.unpack_uint32()
        return data

    def unpack_FSINFO3resfail(self):
        data = types.FSINFO3resfail()
        data.obj_attributes = self.unpack_post_op_attr()
        return data

    def unpack_FSINFO3res(self):
        data = types.FSINFO3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_FSINFO3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_FSINFO3resfail()
            data.arm = data.resfail
        return data

    def unpack_PATHCONF3args(self):
        data = types.PATHCONF3args()
        data.object = self.unpack_nfs_fh3()
        return data

    def unpack_PATHCONF3resok(self):
        data = types.PATHCONF3resok()
        data.obj_attributes = self.unpack_post_op_attr()
        data.linkmax = self.unpack_uint32()
        data.name_max = self.unpack_uint32()
        data.no_trunc = self.unpack_bool()
        data.chown_restricted = self.unpack_bool()
        data.case_insensitive = self.unpack_bool()
        data.case_preserving = self.unpack_bool()
        return data

    def unpack_PATHCONF3resfail(self):
        data = types.PATHCONF3resfail()
        data.obj_attributes = self.unpack_post_op_attr()
        return data

    def unpack_PATHCONF3res(self):
        data = types.PATHCONF3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_PATHCONF3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_PATHCONF3resfail()
            data.arm = data.resfail
        return data

    def unpack_COMMIT3args(self):
        data = types.COMMIT3args()
        data.file = self.unpack_nfs_fh3()
        data.offset = self.unpack_offset3()
        data.count = self.unpack_count3()
        return data

    def unpack_COMMIT3resok(self):
        data = types.COMMIT3resok()
        data.file_wcc = self.unpack_wcc_data()
        data.verf = self.unpack_writeverf3()
        return data

    def unpack_COMMIT3resfail(self):
        data = types.COMMIT3resfail()
        data.file_wcc = self.unpack_wcc_data()
        return data

    def unpack_COMMIT3res(self):
        data = types.COMMIT3res()
        data.status = self.unpack_nfsstat3()
        if data.status == const.NFS3_OK:
            data.resok = self.unpack_COMMIT3resok()
            data.arm = data.resok
        else:
            data.resfail = self.unpack_COMMIT3resfail()
            data.arm = data.resfail
        return data

    def unpack_fhandle3(self):
        data = self.unpack_opaque()
        if len(data) > const.FHSIZE3:
            raise XDRError, 'array length too long for data'
        return data

    def unpack_dirpath3(self):
        data = self.unpack_string()
        if len(data) > const.MNTPATHLEN3:
            raise XDRError, 'array length too long for data'
        return data

    def unpack_name3(self):
        data = self.unpack_string()
        if len(data) > const.MNTNAMLEN3:
            raise XDRError, 'array length too long for data'
        return data

    def unpack_mountstat3(self):
        data = self.unpack_int()
        if data not in [const.MNT3_OK, const.MNT3ERR_PERM, const.MNT3ERR_NOENT, const.MNT3ERR_IO, const.MNT3ERR_ACCES, const.MNT3ERR_NOTDIR, const.MNT3ERR_INVAL, const.MNT3ERR_NAMETOOLONG, const.MNT3ERR_NOTSUPP, const.MNT3ERR_SERVERFAULT]:
            raise XDRError, 'value=%s not in enum mountstat3' % data
        return data

    def unpack_mountres3_ok(self):
        data = types.mountres3_ok()
        data.fhandle = self.unpack_fhandle3()
        data.auth_flavors = self.unpack_array(self.unpack_uint)
        return data

    def unpack_mountres3(self):
        data = types.mountres3()
        data.fhs_status = self.unpack_mountstat3()
        if data.fhs_status == const.MNT3_OK:
            data.mountinfo = self.unpack_mountres3_ok()
            data.arm = data.mountinfo
        else:
            pass
            data.arm = None
        return data

    def unpack_mount3(self):
        data = types.mount3()
        data.ml_hostname = self.unpack_name3()
        data.ml_directory = self.unpack_dirpath3()
        data.ml_next = self.unpack_array(self.unpack_mount3)
        if len(data.ml_next) > 1:
            raise XDRError, 'array length too long for data.ml_next'
        return data

    def unpack_mountopt3(self):
        data = self.unpack_array(self.unpack_mount3)
        if len(data) > 1:
            raise XDRError, 'array length too long for data'
        return data

    def unpack_groups3(self):
        data = types.groups3()
        data.gr_name = self.unpack_name3()
        data.gr_next = self.unpack_array(self.unpack_groups3)
        if len(data.gr_next) > 1:
            raise XDRError, 'array length too long for data.gr_next'
        return data

    def unpack_exports3(self):
        data = types.exports3()
        data.ex_dir = self.unpack_dirpath3()
        data.ex_groups = self.unpack_array(self.unpack_groups3)
        if len(data.ex_groups) > 1:
            raise XDRError, 'array length too long for data.ex_groups'
        data.ex_next = self.unpack_array(self.unpack_exports3)
        if len(data.ex_next) > 1:
            raise XDRError, 'array length too long for data.ex_next'
        return data

    def unpack_exportsopt3(self):
        data = self.unpack_array(self.unpack_exports3)
        if len(data) > 1:
            raise XDRError, 'array length too long for data'
        return data

