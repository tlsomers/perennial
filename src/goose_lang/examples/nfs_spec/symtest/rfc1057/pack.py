# Generated by rpcgen.py from /home/nickolai/proj/go-rpcgen/rfc1057/prot.x on Fri Dec  6 10:47:00 2019
import const
import types
import xdrlib
from xdrlib import Error as XDRError

class nullclass(object):
    pass

class protPacker(xdrlib.Packer):
    pack_short = xdrlib.Packer.pack_int
    pack_string = xdrlib.Packer.pack_string
    pack_ulong = xdrlib.Packer.pack_uint
    pack_opaque = xdrlib.Packer.pack_opaque
    pack_int = xdrlib.Packer.pack_int
    pack_double = xdrlib.Packer.pack_double
    pack_ushort = xdrlib.Packer.pack_uint
    pack_unsigned = xdrlib.Packer.pack_uint
    pack_long = xdrlib.Packer.pack_int
    pack_uhyper = xdrlib.Packer.pack_uhyper
    pack_char = xdrlib.Packer.pack_int
    pack_uchar = xdrlib.Packer.pack_uint
    pack_float = xdrlib.Packer.pack_float
    pack_hyper = xdrlib.Packer.pack_hyper
    pack_uint = xdrlib.Packer.pack_uint
    pack_quadruple = xdrlib.Packer.pack_double
    pack_bool = xdrlib.Packer.pack_bool
    def pack_auth_flavor(self, data):
        if data not in [const.AUTH_NONE, const.AUTH_UNIX, const.AUTH_SHORT, const.AUTH_DES]:
            raise XDRError, 'value=%s not in enum auth_flavor' % data
        self.pack_int(data)

    def pack_opaque_auth(self, data):
        if data.flavor is None:
            raise TypeError, 'data.flavor == None'
        self.pack_auth_flavor(data.flavor)
        if data.body is None:
            raise TypeError, 'data.body == None'
        if len(data.body) > 400:
            raise XDRError, 'array length too long for data.body'
        self.pack_opaque(data.body)

    def pack_msg_type(self, data):
        if data not in [const.CALL, const.REPLY]:
            raise XDRError, 'value=%s not in enum msg_type' % data
        self.pack_int(data)

    def pack_reply_stat(self, data):
        if data not in [const.MSG_ACCEPTED, const.MSG_DENIED]:
            raise XDRError, 'value=%s not in enum reply_stat' % data
        self.pack_int(data)

    def pack_accept_stat(self, data):
        if data not in [const.SUCCESS, const.PROG_UNAVAIL, const.PROG_MISMATCH, const.PROC_UNAVAIL, const.GARBAGE_ARGS]:
            raise XDRError, 'value=%s not in enum accept_stat' % data
        self.pack_int(data)

    def pack_reject_stat(self, data):
        if data not in [const.RPC_MISMATCH, const.AUTH_ERROR]:
            raise XDRError, 'value=%s not in enum reject_stat' % data
        self.pack_int(data)

    def pack_auth_stat(self, data):
        if data not in [const.AUTH_BADCRED, const.AUTH_REJECTEDCRED, const.AUTH_BADVERF, const.AUTH_REJECTEDVERF, const.AUTH_TOOWEAK]:
            raise XDRError, 'value=%s not in enum auth_stat' % data
        self.pack_int(data)

    def pack_rpc_msg(self, data):
        if data.xid is None:
            raise TypeError, 'data.xid == None'
        self.pack_uint(data.xid)
        if data.body is None:
            raise TypeError, 'data.body == None'
        if data.body.mtype is None:
            raise TypeError, 'data.body.mtype == None'
        self.pack_msg_type(data.body.mtype)
        if data.body.mtype == const.CALL:
            if data.body.cbody is None:
                raise TypeError, 'data.body.cbody == None'
            self.pack_call_body(data.body.cbody)
        elif data.body.mtype == const.REPLY:
            if data.body.rbody is None:
                raise TypeError, 'data.body.rbody == None'
            self.pack_reply_body(data.body.rbody)
        else:
            raise XDRError, 'bad switch=%s' % data.body.mtype

    def pack_call_body(self, data):
        if data.rpcvers is None:
            raise TypeError, 'data.rpcvers == None'
        self.pack_uint(data.rpcvers)
        if data.prog is None:
            raise TypeError, 'data.prog == None'
        self.pack_uint(data.prog)
        if data.vers is None:
            raise TypeError, 'data.vers == None'
        self.pack_uint(data.vers)
        if data.proc is None:
            raise TypeError, 'data.proc == None'
        self.pack_uint(data.proc)
        if data.cred is None:
            raise TypeError, 'data.cred == None'
        self.pack_opaque_auth(data.cred)
        if data.verf is None:
            raise TypeError, 'data.verf == None'
        self.pack_opaque_auth(data.verf)

    def pack_reply_body(self, data):
        if data.stat is None:
            raise TypeError, 'data.stat == None'
        self.pack_reply_stat(data.stat)
        if data.stat == const.MSG_ACCEPTED:
            if data.areply is None:
                raise TypeError, 'data.areply == None'
            self.pack_accepted_reply(data.areply)
        elif data.stat == const.MSG_DENIED:
            if data.rreply is None:
                raise TypeError, 'data.rreply == None'
            self.pack_rejected_reply(data.rreply)
        else:
            raise XDRError, 'bad switch=%s' % data.stat

    def pack_accepted_reply(self, data):
        if data.verf is None:
            raise TypeError, 'data.verf == None'
        self.pack_opaque_auth(data.verf)
        if data.reply_data is None:
            raise TypeError, 'data.reply_data == None'
        if data.reply_data.stat is None:
            raise TypeError, 'data.reply_data.stat == None'
        self.pack_accept_stat(data.reply_data.stat)
        if data.reply_data.stat == const.SUCCESS:
            if data.reply_data.results is None:
                raise TypeError, 'data.reply_data.results == None'
            self.pack_fopaque(0, data.reply_data.results)
        elif data.reply_data.stat == const.PROG_MISMATCH:
            if data.reply_data.mismatch_info is None:
                raise TypeError, 'data.reply_data.mismatch_info == None'
            if data.reply_data.mismatch_info.low is None:
                raise TypeError, 'data.reply_data.mismatch_info.low == None'
            self.pack_uint(data.reply_data.mismatch_info.low)
            if data.reply_data.mismatch_info.high is None:
                raise TypeError, 'data.reply_data.mismatch_info.high == None'
            self.pack_uint(data.reply_data.mismatch_info.high)
        else:
            pass

    def pack_rejected_reply(self, data):
        if data.stat is None:
            raise TypeError, 'data.stat == None'
        self.pack_reject_stat(data.stat)
        if data.stat == const.RPC_MISMATCH:
            if data.mismatch_info is None:
                raise TypeError, 'data.mismatch_info == None'
            if data.mismatch_info.low is None:
                raise TypeError, 'data.mismatch_info.low == None'
            self.pack_uint(data.mismatch_info.low)
            if data.mismatch_info.high is None:
                raise TypeError, 'data.mismatch_info.high == None'
            self.pack_uint(data.mismatch_info.high)
        elif data.stat == const.AUTH_ERROR:
            if data.astat is None:
                raise TypeError, 'data.astat == None'
            self.pack_auth_stat(data.astat)
        else:
            raise XDRError, 'bad switch=%s' % data.stat

    def pack_auth_unix(self, data):
        if data.stamp is None:
            raise TypeError, 'data.stamp == None'
        self.pack_uint(data.stamp)
        if data.machinename is None:
            raise TypeError, 'data.machinename == None'
        if len(data.machinename) > 255:
            raise XDRError, 'array length too long for data.machinename'
        self.pack_string(data.machinename)
        if data.uid is None:
            raise TypeError, 'data.uid == None'
        self.pack_uint(data.uid)
        if data.gid is None:
            raise TypeError, 'data.gid == None'
        self.pack_uint(data.gid)
        if data.gids is None:
            raise TypeError, 'data.gids == None'
        if len(data.gids) > 16:
            raise XDRError, 'array length too long for data.gids'
        self.pack_array(data.gids, self.pack_uint)

    def pack_mapping(self, data):
        if data.prog is None:
            raise TypeError, 'data.prog == None'
        self.pack_uint(data.prog)
        if data.vers is None:
            raise TypeError, 'data.vers == None'
        self.pack_uint(data.vers)
        if data.prot is None:
            raise TypeError, 'data.prot == None'
        self.pack_uint(data.prot)
        if data.port is None:
            raise TypeError, 'data.port == None'
        self.pack_uint(data.port)

    def pack_pmaplist(self, data):
        if len(data) > 1:
            raise XDRError, 'array length too long for data'
        self.pack_array(data, self.pack_pmaplistelem)

    def pack_pmaplistelem(self, data):
        if data.map is None:
            raise TypeError, 'data.map == None'
        self.pack_mapping(data.map)
        if data.next is None:
            raise TypeError, 'data.next == None'
        self.pack_pmaplist(data.next)

    def pack_call_args(self, data):
        if data.prog is None:
            raise TypeError, 'data.prog == None'
        self.pack_uint(data.prog)
        if data.vers is None:
            raise TypeError, 'data.vers == None'
        self.pack_uint(data.vers)
        if data.proc is None:
            raise TypeError, 'data.proc == None'
        self.pack_uint(data.proc)
        if data.args is None:
            raise TypeError, 'data.args == None'
        self.pack_opaque(data.args)

    def pack_call_result(self, data):
        if data.port is None:
            raise TypeError, 'data.port == None'
        self.pack_uint(data.port)
        if data.res is None:
            raise TypeError, 'data.res == None'
        self.pack_opaque(data.res)

    pack_uint32 = pack_uint

    pack_xbool = pack_bool

class protUnpacker(xdrlib.Unpacker):
    unpack_short = xdrlib.Unpacker.unpack_int
    unpack_string = xdrlib.Unpacker.unpack_string
    unpack_ulong = xdrlib.Unpacker.unpack_uint
    unpack_opaque = xdrlib.Unpacker.unpack_opaque
    unpack_int = xdrlib.Unpacker.unpack_int
    unpack_double = xdrlib.Unpacker.unpack_double
    unpack_ushort = xdrlib.Unpacker.unpack_uint
    unpack_unsigned = xdrlib.Unpacker.unpack_uint
    unpack_long = xdrlib.Unpacker.unpack_int
    unpack_uhyper = xdrlib.Unpacker.unpack_uhyper
    unpack_char = xdrlib.Unpacker.unpack_int
    unpack_uchar = xdrlib.Unpacker.unpack_uint
    unpack_float = xdrlib.Unpacker.unpack_float
    unpack_hyper = xdrlib.Unpacker.unpack_hyper
    unpack_uint = xdrlib.Unpacker.unpack_uint
    unpack_quadruple = xdrlib.Unpacker.unpack_double
    unpack_bool = xdrlib.Unpacker.unpack_bool
    def unpack_auth_flavor(self):
        data = self.unpack_int()
        if data not in [const.AUTH_NONE, const.AUTH_UNIX, const.AUTH_SHORT, const.AUTH_DES]:
            raise XDRError, 'value=%s not in enum auth_flavor' % data
        return data

    def unpack_opaque_auth(self):
        data = types.opaque_auth()
        data.flavor = self.unpack_auth_flavor()
        data.body = self.unpack_opaque()
        if len(data.body) > 400:
            raise XDRError, 'array length too long for data.body'
        return data

    def unpack_msg_type(self):
        data = self.unpack_int()
        if data not in [const.CALL, const.REPLY]:
            raise XDRError, 'value=%s not in enum msg_type' % data
        return data

    def unpack_reply_stat(self):
        data = self.unpack_int()
        if data not in [const.MSG_ACCEPTED, const.MSG_DENIED]:
            raise XDRError, 'value=%s not in enum reply_stat' % data
        return data

    def unpack_accept_stat(self):
        data = self.unpack_int()
        if data not in [const.SUCCESS, const.PROG_UNAVAIL, const.PROG_MISMATCH, const.PROC_UNAVAIL, const.GARBAGE_ARGS]:
            raise XDRError, 'value=%s not in enum accept_stat' % data
        return data

    def unpack_reject_stat(self):
        data = self.unpack_int()
        if data not in [const.RPC_MISMATCH, const.AUTH_ERROR]:
            raise XDRError, 'value=%s not in enum reject_stat' % data
        return data

    def unpack_auth_stat(self):
        data = self.unpack_int()
        if data not in [const.AUTH_BADCRED, const.AUTH_REJECTEDCRED, const.AUTH_BADVERF, const.AUTH_REJECTEDVERF, const.AUTH_TOOWEAK]:
            raise XDRError, 'value=%s not in enum auth_stat' % data
        return data

    def unpack_rpc_msg(self):
        data = types.rpc_msg()
        data.xid = self.unpack_uint()
        data.body = nullclass()
        data.body.mtype = self.unpack_msg_type()
        if data.body.mtype == const.CALL:
            data.body.cbody = self.unpack_call_body()
            data.body.arm = data.body.cbody
        elif data.body.mtype == const.REPLY:
            data.body.rbody = self.unpack_reply_body()
            data.body.arm = data.body.rbody
        else:
            raise XDRError, 'bad switch=%s' % data.body.mtype
        return data

    def unpack_call_body(self):
        data = types.call_body()
        data.rpcvers = self.unpack_uint()
        data.prog = self.unpack_uint()
        data.vers = self.unpack_uint()
        data.proc = self.unpack_uint()
        data.cred = self.unpack_opaque_auth()
        data.verf = self.unpack_opaque_auth()
        return data

    def unpack_reply_body(self):
        data = types.reply_body()
        data.stat = self.unpack_reply_stat()
        if data.stat == const.MSG_ACCEPTED:
            data.areply = self.unpack_accepted_reply()
            data.arm = data.areply
        elif data.stat == const.MSG_DENIED:
            data.rreply = self.unpack_rejected_reply()
            data.arm = data.rreply
        else:
            raise XDRError, 'bad switch=%s' % data.stat
        return data

    def unpack_accepted_reply(self):
        data = types.accepted_reply()
        data.verf = self.unpack_opaque_auth()
        data.reply_data = nullclass()
        data.reply_data.stat = self.unpack_accept_stat()
        if data.reply_data.stat == const.SUCCESS:
            data.reply_data.results = self.unpack_fopaque(0)
            data.reply_data.arm = data.reply_data.results
        elif data.reply_data.stat == const.PROG_MISMATCH:
            data.reply_data.mismatch_info = nullclass()
            data.reply_data.mismatch_info.low = self.unpack_uint()
            data.reply_data.mismatch_info.high = self.unpack_uint()
            data.reply_data.arm = data.reply_data.mismatch_info
        else:
            pass
            data.reply_data.arm = None
        return data

    def unpack_rejected_reply(self):
        data = types.rejected_reply()
        data.stat = self.unpack_reject_stat()
        if data.stat == const.RPC_MISMATCH:
            data.mismatch_info = nullclass()
            data.mismatch_info.low = self.unpack_uint()
            data.mismatch_info.high = self.unpack_uint()
            data.arm = data.mismatch_info
        elif data.stat == const.AUTH_ERROR:
            data.astat = self.unpack_auth_stat()
            data.arm = data.astat
        else:
            raise XDRError, 'bad switch=%s' % data.stat
        return data

    def unpack_auth_unix(self):
        data = types.auth_unix()
        data.stamp = self.unpack_uint()
        data.machinename = self.unpack_string()
        if len(data.machinename) > 255:
            raise XDRError, 'array length too long for data.machinename'
        data.uid = self.unpack_uint()
        data.gid = self.unpack_uint()
        data.gids = self.unpack_array(self.unpack_uint)
        if len(data.gids) > 16:
            raise XDRError, 'array length too long for data.gids'
        return data

    def unpack_mapping(self):
        data = types.mapping()
        data.prog = self.unpack_uint()
        data.vers = self.unpack_uint()
        data.prot = self.unpack_uint()
        data.port = self.unpack_uint()
        return data

    def unpack_pmaplist(self):
        data = self.unpack_array(self.unpack_pmaplistelem)
        if len(data) > 1:
            raise XDRError, 'array length too long for data'
        return data

    def unpack_pmaplistelem(self):
        data = types.pmaplistelem()
        data.map = self.unpack_mapping()
        data.next = self.unpack_pmaplist()
        return data

    def unpack_call_args(self):
        data = types.call_args()
        data.prog = self.unpack_uint()
        data.vers = self.unpack_uint()
        data.proc = self.unpack_uint()
        data.args = self.unpack_opaque()
        return data

    def unpack_call_result(self):
        data = types.call_result()
        data.port = self.unpack_uint()
        data.res = self.unpack_opaque()
        return data

    unpack_uint32 = unpack_uint

    unpack_xbool = unpack_bool

