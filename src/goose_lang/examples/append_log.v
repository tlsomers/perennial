(* autogenerated from append_log *)
From Perennial.goose_lang Require Import prelude.

(* disk FFI *)
From Perennial.goose_lang Require Import ffi.disk_prelude.

(* Append-only, sequential, crash-safe log.

   The main interesting feature is that the log supports multi-block atomic
   appends, which are implemented by atomically updating an on-disk header with
   the number of valid blocks in the log. *)

From Goose.github_com.tchajed Require Import marshal.

Module Log.
  Definition S := struct.decl [
    "sz" :: uint64T;
    "diskSz" :: uint64T
  ].
End Log.

Definition Log__mkHdr: val :=
  λ: "log",
    let: "enc" := marshal.NewEnc disk.BlockSize in
    Enc__PutInt "enc" (struct.get Log.S "sz" "log");;
    Enc__PutInt "enc" (struct.get Log.S "diskSz" "log");;
    Enc__Finish "enc".

Definition Log__writeHdr: val :=
  λ: "log",
    disk.Write #0 (Log__mkHdr "log").

Definition Init: val :=
  λ: "diskSz",
    (if: "diskSz" < #1
    then
      (struct.mk Log.S [
         "sz" ::= #0;
         "diskSz" ::= #0
       ], #false)
    else
      let: "log" := struct.mk Log.S [
        "sz" ::= #0;
        "diskSz" ::= "diskSz"
      ] in
      Log__writeHdr "log";;
      ("log", #true)).

Definition Open: val :=
  λ: <>,
    let: "hdr" := disk.Read #0 in
    let: "dec" := marshal.NewDec "hdr" in
    let: "sz" := Dec__GetInt "dec" in
    let: "diskSz" := Dec__GetInt "dec" in
    struct.mk Log.S [
      "sz" ::= "sz";
      "diskSz" ::= "diskSz"
    ].

Definition Log__Get: val :=
  λ: "log" "i",
    let: "sz" := struct.get Log.S "sz" "log" in
    (if: "i" < "sz"
    then (disk.Read (#1 + "i"), #true)
    else (slice.nil, #false)).

Definition writeAll: val :=
  λ: "bks" "off",
    ForSlice (slice.T byteT) "i" "bk" "bks"
      (disk.Write ("off" + "i") "bk").

Definition Log__Append: val :=
  λ: "log" "bks",
    let: "sz" := struct.loadF Log.S "sz" "log" in
    (if: slice.len "bks" ≥ struct.loadF Log.S "diskSz" "log" - #1 - "sz"
    then #false
    else
      writeAll "bks" (#1 + "sz");;
      let: "newLog" := struct.mk Log.S [
        "sz" ::= "sz" + slice.len "bks";
        "diskSz" ::= struct.loadF Log.S "diskSz" "log"
      ] in
      Log__writeHdr "newLog";;
      struct.store Log.S "log" "newLog";;
      #true).

Definition Log__Reset: val :=
  λ: "log",
    let: "newLog" := struct.mk Log.S [
      "sz" ::= #0;
      "diskSz" ::= struct.loadF Log.S "diskSz" "log"
    ] in
    Log__writeHdr "newLog";;
    struct.store Log.S "log" "newLog".
