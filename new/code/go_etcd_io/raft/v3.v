(* autogenerated from go.etcd.io/raft/v3 *)
From New.golang Require Import defn.
From New.code Require bytes.
From New.code Require context.
From New.code Require crypto.rand.
From New.code Require errors.
From New.code Require fmt.
From New.code Require github_com.stretchr.testify.assert.
From New.code Require go_etcd_io.raft.v3.confchange.
From New.code Require go_etcd_io.raft.v3.quorum.
From New.code Require go_etcd_io.raft.v3.raftpb.
From New.code Require go_etcd_io.raft.v3.tracker.
From New.code Require io.
From New.code Require log.
From New.code Require math.
From New.code Require math.big.
From New.code Require math.rand.
From New.code Require os.
From New.code Require sort.
From New.code Require strings.
From New.code Require sync.
From New.code Require testing.

Section code.
Context `{ffi_syntax}.

Definition Peer : go_type := structT [
  "ID" :: uint64T;
  "Context" :: sliceT
].

Definition RawNode : go_type := structT [
  "raft" :: ptrT;
  "asyncStorageWrites" :: boolT;
  "prevSoftSt" :: ptrT;
  "prevHardSt" :: raftpb.HardState;
  "stepsOnAdvance" :: sliceT
].

Definition pkg_name' : go_string := "go.etcd.io/raft/v3".

Definition raft' : (go_string * go_string) := (pkg_name', "raft").

Definition ReadState : go_type := structT [
  "Index" :: uint64T;
  "RequestCtx" :: sliceT
].

Definition entryEncodingSize : go_type := uint64T.

Definition entryPayloadSize : go_type := uint64T.

Definition StateType : go_type := uint64T.

Definition Logger : go_type := interfaceT.

Definition TraceLogger : go_type := interfaceT.

Definition raft : go_type := structT [
  "id" :: uint64T;
  "Term" :: uint64T;
  "Vote" :: uint64T;
  "readStates" :: sliceT;
  "raftLog" :: ptrT;
  "maxMsgSize" :: entryEncodingSize;
  "maxUncommittedSize" :: entryPayloadSize;
  "trk" :: tracker.ProgressTracker;
  "state" :: StateType;
  "isLearner" :: boolT;
  "msgs" :: sliceT;
  "msgsAfterAppend" :: sliceT;
  "lead" :: uint64T;
  "leadTransferee" :: uint64T;
  "pendingConfIndex" :: uint64T;
  "disableConfChangeValidation" :: boolT;
  "uncommittedSize" :: entryPayloadSize;
  "readOnly" :: ptrT;
  "electionElapsed" :: intT;
  "heartbeatElapsed" :: intT;
  "checkQuorum" :: boolT;
  "preVote" :: boolT;
  "heartbeatTimeout" :: intT;
  "electionTimeout" :: intT;
  "randomizedElectionTimeout" :: intT;
  "disableProposalForwarding" :: boolT;
  "stepDownOnRemoval" :: boolT;
  "tickId" :: intT;
  "step" :: funcT;
  "StepHigherOrder" :: funcT;
  "logger" :: Logger;
  "pendingReadIndexMessages" :: sliceT;
  "traceLogger" :: TraceLogger
].

Definition Storage : go_type := interfaceT.

Definition unstable : go_type := structT [
  "snapshot" :: ptrT;
  "entries" :: sliceT;
  "offset" :: uint64T;
  "snapshotInProgress" :: boolT;
  "offsetInProgress" :: uint64T;
  "logger" :: Logger
].

Definition raftLog : go_type := structT [
  "storage" :: Storage;
  "unstable" :: unstable;
  "committed" :: uint64T;
  "applying" :: uint64T;
  "applied" :: uint64T;
  "logger" :: Logger;
  "maxApplyingEntsSize" :: entryEncodingSize;
  "applyingEntsSize" :: entryEncodingSize;
  "applyingEntsPaused" :: boolT
].

Definition raftLog' : (go_string * go_string) := (pkg_name', "raftLog").

Definition None : expr := #(W64 0).

Definition emptyState : (go_string * go_string) := (pkg_name', "emptyState"%go).

(* Bootstrap initializes the RawNode for first use by appending configuration
   changes for the supplied peers. This method returns an error if the Storage
   is nonempty.

   It is recommended that instead of calling this method, applications bootstrap
   their state manually by setting up a Storage that has a first index > 1 and
   which stores the desired ConfState as its InitialState.

   go: bootstrap.go:30:20 *)
Definition RawNode__Bootstrap' : val :=
  rec: "RawNode__Bootstrap'" "rn" "peers" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "peers" := (ref_ty sliceT "peers") in
    (if: (let: "$a0" := (![sliceT] "peers") in
    slice.len "$a0") = #(W64 0)
    then
      return: (let: "$a0" := #"must provide at least one peer to Bootstrap"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "lastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (![error] "err")
    else do:  #());;;
    (if: (![uint64T] "lastIndex") ≠ #(W64 0)
    then
      return: (let: "$a0" := #"can't bootstrap a nonempty Storage"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    let: "$r0" := (![raftpb.HardState] (globals.get emptyState #())) in
    do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := None in
    ((method_call raft' "becomeFollower" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0" "$a1");;;
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 raftpb.Entry (let: "$a0" := (![sliceT] "peers") in
    slice.len "$a0")) in
    do:  ("ents" <-[sliceT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "peers") in
    slice.for_range Peer "$range" (λ: "i" "peer",
      let: "i" := ref_ty uint64T "i" in
      let: "peer" := ref_ty Peer "peer" in
      let: "cc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
      let: "$r0" := (let: "$Type" := raftpb.ConfChangeAddNode in
      let: "$NodeID" := (![uint64T] (struct.field_ref Peer "ID" "peer")) in
      let: "$Context" := (![sliceT] (struct.field_ref Peer "Context" "peer")) in
      struct.make raftpb.ConfChange [{
        "Type" ::= "$Type";
        "NodeID" ::= "$NodeID";
        "Context" ::= "$Context";
        "ID" ::= zero_val uint64T
      }]) in
      do:  ("cc" <-[raftpb.ConfChange] "$r0");;;
      let: "err" := (ref_ty error (zero_val error)) in
      let: "data" := (ref_ty sliceT (zero_val sliceT)) in
      let: ("$ret0", "$ret1") := (((method_call raftpb.ConfChange' "Marshal" #()) "cc") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("data" <-[sliceT] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ #interface.nil
      then return: (![error] "err")
      else do:  #());;;
      let: "$r0" := (let: "$Type" := raftpb.EntryConfChange in
      let: "$Term" := #(W64 1) in
      let: "$Index" := ((![intT] "i") + #(W64 1)) in
      let: "$Data" := (![sliceT] "data") in
      struct.make raftpb.Entry [{
        "Term" ::= "$Term";
        "Index" ::= "$Index";
        "Type" ::= "$Type";
        "Data" ::= "$Data"
      }]) in
      do:  ((slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "i")) <-[raftpb.Entry] "$r0")));;;
    do:  (let: "$a0" := (![sliceT] "ents") in
    ((method_call raftLog' "append" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) <-[uint64T] "$r0");;;
    do:  (let: "$range" := (![sliceT] "peers") in
    slice.for_range Peer "$range" (λ: <> "peer",
      let: "peer" := ref_ty Peer "peer" in
      do:  (let: "$a0" := (((method_call raftpb.ConfChange' "AsV2" #()) (let: "$NodeID" := (![uint64T] (struct.field_ref Peer "ID" "peer")) in
      let: "$Type" := raftpb.ConfChangeAddNode in
      struct.make raftpb.ConfChange [{
        "Type" ::= "$Type";
        "NodeID" ::= "$NodeID";
        "Context" ::= zero_val sliceT;
        "ID" ::= zero_val uint64T
      }])) #()) in
      ((method_call raft' "applyConfChange" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")));;;
    return: (#interface.nil)).

Definition newLogWithSize : (go_string * go_string) := (pkg_name', "newLogWithSize"%go).

Definition noLimit : Z := math.MaxUint64.

(* newLog returns log using the given storage and default options. It
   recovers the log to the state that it just commits and applies the
   latest snapshot.

   go: log.go:67:6 *)
Definition newLog' : val :=
  rec: "newLog'" "storage" "logger" :=
    exception_do (let: "logger" := (ref_ty Logger "logger") in
    let: "storage" := (ref_ty Storage "storage") in
    return: (let: "$a0" := (![Storage] "storage") in
     let: "$a1" := (![Logger] "logger") in
     let: "$a2" := #(W64 noLimit) in
     (func_call newLogWithSize #()) "$a0" "$a1" "$a2")).

Definition newLog : (go_string * go_string) := (pkg_name', "newLog"%go).

(* newLogWithSize returns a log using the given storage and max
   message size.

   go: log.go:73:6 *)
Definition newLogWithSize' : val :=
  rec: "newLogWithSize'" "storage" "logger" "maxApplyingEntsSize" :=
    exception_do (let: "maxApplyingEntsSize" := (ref_ty entryEncodingSize "maxApplyingEntsSize") in
    let: "logger" := (ref_ty Logger "logger") in
    let: "storage" := (ref_ty Storage "storage") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "firstIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "FirstIndex" (![Storage] "storage")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("firstIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    let: "lastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] "storage")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    return: (ref_ty raftLog (let: "$storage" := (![Storage] "storage") in
     let: "$unstable" := (let: "$offset" := ((![uint64T] "lastIndex") + #(W64 1)) in
     let: "$offsetInProgress" := ((![uint64T] "lastIndex") + #(W64 1)) in
     let: "$logger" := (![Logger] "logger") in
     struct.make unstable [{
       "snapshot" ::= zero_val ptrT;
       "entries" ::= zero_val sliceT;
       "offset" ::= "$offset";
       "snapshotInProgress" ::= zero_val boolT;
       "offsetInProgress" ::= "$offsetInProgress";
       "logger" ::= "$logger"
     }]) in
     let: "$maxApplyingEntsSize" := (![entryEncodingSize] "maxApplyingEntsSize") in
     let: "$committed" := ((![uint64T] "firstIndex") - #(W64 1)) in
     let: "$applying" := ((![uint64T] "firstIndex") - #(W64 1)) in
     let: "$applied" := ((![uint64T] "firstIndex") - #(W64 1)) in
     let: "$logger" := (![Logger] "logger") in
     struct.make raftLog [{
       "storage" ::= "$storage";
       "unstable" ::= "$unstable";
       "committed" ::= "$committed";
       "applying" ::= "$applying";
       "applied" ::= "$applied";
       "logger" ::= "$logger";
       "maxApplyingEntsSize" ::= "$maxApplyingEntsSize";
       "applyingEntsSize" ::= zero_val entryEncodingSize;
       "applyingEntsPaused" ::= zero_val boolT
     }]))).

(* go: log.go:100:19 *)
Definition raftLog__String' : val :=
  rec: "raftLog__String'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (let: "$a0" := #"committed=%d, applied=%d, applying=%d, unstable.offset=%d, unstable.offsetInProgress=%d, len(unstable.Entries)=%d"%go in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
     let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l")))) in
     let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l")))) in
     let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))) in
     let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref unstable "offsetInProgress" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))) in
     let: "$sl5" := (interface.make int' (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
     slice.len "$a0")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
     (func_call fmt.Sprintf #()) "$a0" "$a1")).

Definition entryID : go_type := structT [
  "term" :: uint64T;
  "index" :: uint64T
].

Definition logSlice : go_type := structT [
  "term" :: uint64T;
  "prev" :: entryID;
  "entries" :: sliceT
].

(* maybeAppend returns (0, false) if the entries cannot be appended. Otherwise,
   it returns (last index of new entries, true).

   go: log.go:107:19 *)
Definition raftLog__maybeAppend' : val :=
  rec: "raftLog__maybeAppend'" "l" "a" "committed" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "committed" := (ref_ty uint64T "committed") in
    let: "a" := (ref_ty logSlice "a") in
    let: "lastnewi" := (ref_ty uint64T (zero_val uint64T)) in
    (if: (~ (let: "$a0" := (![entryID] (struct.field_ref logSlice "prev" "a")) in
    ((method_call raftLog' "matchTerm" #()) (![ptrT] "l")) "$a0"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) + (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
    slice.len "$a0")) in
    do:  ("lastnewi" <-[uint64T] "$r0");;;
    let: "ci" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
    ((method_call raftLog' "findConflict" #()) (![ptrT] "l")) "$a0") in
    do:  ("ci" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] "ci") = #(W64 0))
    then do:  #()
    else
      (if: "$sw" = ((![uint64T] "ci") ≤ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))))
      then
        do:  (let: "$a0" := #"entry %d conflict with committed entry [committed(%d)]"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "ci")) in
        let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else
        let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) + #(W64 1)) in
        do:  ("offset" <-[uint64T] "$r0");;;
        (if: ((![uint64T] "ci") - (![uint64T] "offset")) > (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
        slice.len "$a0")
        then
          do:  (let: "$a0" := #"index, %d, is out of range [%d]"%go in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64' ((![uint64T] "ci") - (![uint64T] "offset"))) in
          let: "$sl1" := (interface.make int' (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
          slice.len "$a0")) in
          slice.literal interfaceT ["$sl0"; "$sl1"])) in
          (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
        else do:  #());;;
        do:  (let: "$a0" := (let: "$s" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
        slice.slice raftpb.Entry "$s" ((![uint64T] "ci") - (![uint64T] "offset")) (slice.len "$s")) in
        ((method_call raftLog' "append" #()) (![ptrT] "l")) "$a0")));;;
    do:  (let: "$a0" := (let: "$a0" := (![uint64T] "committed") in
    let: "$a1" := (![uint64T] "lastnewi") in
    (minUint64 2) "$a0" "$a1") in
    ((method_call raftLog' "commitTo" #()) (![ptrT] "l")) "$a0");;;
    return: (![uint64T] "lastnewi", #true)).

Definition unstable' : (go_string * go_string) := (pkg_name', "unstable").

(* go: log.go:132:19 *)
Definition raftLog__append' : val :=
  rec: "raftLog__append'" "l" "ents" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "ents" := (ref_ty sliceT "ents") in
    (if: (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") = #(W64 0)
    then return: (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #())
    else do:  #());;;
    (let: "after" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0)))) - #(W64 1)) in
    do:  ("after" <-[uint64T] "$r0");;;
    (if: (![uint64T] "after") < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))
    then
      do:  (let: "$a0" := #"after(%d) is out of range [committed(%d)]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "after")) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #()));;;
    do:  (let: "$a0" := (![sliceT] "ents") in
    ((method_call unstable' "truncateAndAppend" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0");;;
    return: (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #())).

Definition pbEntryID : (go_string * go_string) := (pkg_name', "pbEntryID"%go).

(* findConflict finds the index of the conflict.
   It returns the first pair of conflicting entries between the existing
   entries and the given entries, if there are any.
   If there is no conflicting entries, and the existing entries contains
   all the given entries, zero will be returned.
   If there is no conflicting entries, but the given entries contains new
   entries, the index of the first new entry will be returned.
   An entry is considered to be conflicting if it has the same index but
   a different term.
   The index of the given entries MUST be continuously increasing.

   go: log.go:153:19 *)
Definition raftLog__findConflict' : val :=
  rec: "raftLog__findConflict'" "l" "ents" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "ents" := (ref_ty sliceT "ents") in
    do:  (let: "$range" := (![sliceT] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      (let: "id" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "i")) in
      (func_call pbEntryID #()) "$a0") in
      do:  ("id" <-[entryID] "$r0");;;
      (if: (~ (let: "$a0" := (![entryID] "id") in
      ((method_call raftLog' "matchTerm" #()) (![ptrT] "l")) "$a0"))
      then
        (if: (![uint64T] (struct.field_ref entryID "index" "id")) ≤ (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #())
        then
          do:  (let: "$a0" := #"found conflict at index %d [existing term: %d, conflicting term: %d]"%go in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "id"))) in
          let: "$sl1" := (interface.make uint64' (let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
          ((method_call raftLog' "term" #()) (![ptrT] "l")) "$a0")) in
          let: "$a0" := "$ret0" in
          let: "$a1" := "$ret1" in
          ((method_call raftLog' "zeroTermOnOutOfBounds" #()) (![ptrT] "l")) "$a0" "$a1")) in
          let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "id"))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
        else do:  #());;;
        return: (![uint64T] (struct.field_ref entryID "index" "id"))
      else do:  #()))));;;
    return: (#(W64 0))).

(* findConflictByTerm returns a best guess on where this log ends matching
   another log, given that the only information known about the other log is the
   (index, term) of its single entry.

   Specifically, the first returned value is the max guessIndex <= index, such
   that term(guessIndex) <= term or term(guessIndex) is not known (because this
   index is compacted or not yet stored).

   The second returned value is the term(guessIndex), or 0 if it is unknown.

   This function is used by a follower and leader to resolve log conflicts after
   an unsuccessful append to a follower, and ultimately restore the steady flow
   of appends.

   go: log.go:181:19 *)
Definition raftLog__findConflictByTerm' : val :=
  rec: "raftLog__findConflictByTerm'" "l" "index" "term" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "term" := (ref_ty uint64T "term") in
    let: "index" := (ref_ty uint64T "index") in
    (for: (λ: <>, (![uint64T] "index") > #(W64 0)); (λ: <>, do:  ("index" <-[uint64T] ((![uint64T] "index") - #(W64 1)))) := λ: <>,
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "ourTerm" := (ref_ty uint64T (zero_val uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "index") in
      ((method_call raftLog' "term" #()) (![ptrT] "l")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ourTerm" <-[uint64T] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ #interface.nil
      then return: (![uint64T] "index", #(W64 0))
      else
        (if: (![uint64T] "ourTerm") ≤ (![uint64T] "term")
        then return: (![uint64T] "index", ![uint64T] "ourTerm")
        else do:  #()))));;;
    return: (#(W64 0), #(W64 0))).

(* nextUnstableEnts returns all entries that are available to be written to the
   local stable log and are not already in-progress.

   go: log.go:197:19 *)
Definition raftLog__nextUnstableEnts' : val :=
  rec: "raftLog__nextUnstableEnts'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (((method_call unstable' "nextEntries" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

(* hasNextUnstableEnts returns if there are any entries that are available to be
   written to the local stable log and are not already in-progress.

   go: log.go:203:19 *)
Definition raftLog__hasNextUnstableEnts' : val :=
  rec: "raftLog__hasNextUnstableEnts'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (int_gt (let: "$a0" := (((method_call raftLog' "nextUnstableEnts" #()) (![ptrT] "l")) #()) in
     slice.len "$a0") #(W64 0))).

(* hasNextOrInProgressUnstableEnts returns if there are any entries that are
   available to be written to the local stable log or in the process of being
   written to the local stable log.

   go: log.go:210:19 *)
Definition raftLog__hasNextOrInProgressUnstableEnts' : val :=
  rec: "raftLog__hasNextOrInProgressUnstableEnts'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (int_gt (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
     slice.len "$a0") #(W64 0))).

Definition entryEncodingSize' : (go_string * go_string) := (pkg_name', "entryEncodingSize").

(* nextCommittedEnts returns all the available entries for execution.
   Entries can be committed even when the local raft instance has not durably
   appended them to the local raft log yet. If allowUnstable is true, committed
   entries from the unstable log may be returned; otherwise, only entries known
   to reside locally on stable storage will be returned.

   go: log.go:219:19 *)
Definition raftLog__nextCommittedEnts' : val :=
  rec: "raftLog__nextCommittedEnts'" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    (if: ![boolT] (struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l"))
    then return: (#slice.nil)
    else do:  #());;;
    (if: ((method_call raftLog' "hasNextOrInProgressSnapshot" #()) (![ptrT] "l")) #()
    then return: (#slice.nil)
    else do:  #());;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) + #(W64 1)) in
    let: "$r1" := ((let: "$a0" := (![boolT] "allowUnstable") in
    ((method_call raftLog' "maxAppliableIndex" #()) (![ptrT] "l")) "$a0") + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    (if: (![uint64T] "lo") ≥ (![uint64T] "hi")
    then return: (#slice.nil)
    else do:  #());;;
    let: "maxSize" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := ((![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l"))) - (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")))) in
    do:  ("maxSize" <-[entryEncodingSize] "$r0");;;
    (if: (![entryEncodingSize] "maxSize") ≤ #(W64 0)
    then
      do:  (let: "$a0" := #"applying entry size (%d-%d)=%d not positive"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make entryEncodingSize' (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) in
      let: "$sl1" := (interface.make entryEncodingSize' (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make entryEncodingSize' (![entryEncodingSize] "maxSize")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    ((method_call raftLog' "slice" #()) (![ptrT] "l")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := #"unexpected error when getting unapplied entries (%v)"%go in
      let: "$a1" := ((let: "$sl0" := (![error] "err") in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (![sliceT] "ents")).

(* hasNextCommittedEnts returns if there is any available entries for execution.
   This is a fast check without heavy raftLog.slice() in nextCommittedEnts().

   go: log.go:248:19 *)
Definition raftLog__hasNextCommittedEnts' : val :=
  rec: "raftLog__hasNextCommittedEnts'" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    (if: ![boolT] (struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l"))
    then return: (#false)
    else do:  #());;;
    (if: ((method_call raftLog' "hasNextOrInProgressSnapshot" #()) (![ptrT] "l")) #()
    then return: (#false)
    else do:  #());;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) + #(W64 1)) in
    let: "$r1" := ((let: "$a0" := (![boolT] "allowUnstable") in
    ((method_call raftLog' "maxAppliableIndex" #()) (![ptrT] "l")) "$a0") + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    return: ((![uint64T] "lo") < (![uint64T] "hi"))).

(* maxAppliableIndex returns the maximum committed index that can be applied.
   If allowUnstable is true, committed entries from the unstable log can be
   applied; otherwise, only entries known to reside locally on stable storage
   can be applied.

   go: log.go:267:19 *)
Definition raftLog__maxAppliableIndex' : val :=
  rec: "raftLog__maxAppliableIndex'" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) in
    do:  ("hi" <-[uint64T] "$r0");;;
    (if: (~ (![boolT] "allowUnstable"))
    then
      let: "$r0" := (let: "$a0" := (![uint64T] "hi") in
      let: "$a1" := ((![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) - #(W64 1)) in
      (minUint64 2) "$a0" "$a1") in
      do:  ("hi" <-[uint64T] "$r0")
    else do:  #());;;
    return: (![uint64T] "hi")).

(* nextUnstableSnapshot returns the snapshot, if present, that is available to
   be applied to the local storage and is not already in-progress.

   go: log.go:277:19 *)
Definition raftLog__nextUnstableSnapshot' : val :=
  rec: "raftLog__nextUnstableSnapshot'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (((method_call unstable' "nextSnapshot" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

(* hasNextUnstableSnapshot returns if there is a snapshot that is available to
   be applied to the local storage and is not already in-progress.

   go: log.go:283:19 *)
Definition raftLog__hasNextUnstableSnapshot' : val :=
  rec: "raftLog__hasNextUnstableSnapshot'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: ((((method_call unstable' "nextSnapshot" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) ≠ #null)).

(* hasNextOrInProgressSnapshot returns if there is pending snapshot waiting for
   applying or in the process of being applied.

   go: log.go:289:19 *)
Definition raftLog__hasNextOrInProgressSnapshot' : val :=
  rec: "raftLog__hasNextOrInProgressSnapshot'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: ((![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) ≠ #null)).

(* go: log.go:293:19 *)
Definition raftLog__snapshot' : val :=
  rec: "raftLog__snapshot'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) ≠ #null
    then return: (![raftpb.Snapshot] (![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))), #interface.nil)
    else do:  #());;;
    let: ("$ret0", "$ret1") := (((interface.get "Snapshot" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #())) in
    return: ("$ret0", "$ret1")).

(* go: log.go:300:19 *)
Definition raftLog__firstIndex' : val :=
  rec: "raftLog__firstIndex'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (((method_call unstable' "maybeFirstIndex" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "i")
    else do:  #()));;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "FirstIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("index" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    return: (![uint64T] "index")).

(* go: log.go:311:19 *)
Definition raftLog__lastIndex' : val :=
  rec: "raftLog__lastIndex'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (((method_call unstable' "maybeLastIndex" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "i")
    else do:  #()));;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    return: (![uint64T] "i")).

(* go: log.go:322:19 *)
Definition raftLog__commitTo' : val :=
  rec: "raftLog__commitTo'" "l" "tocommit" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "tocommit" := (ref_ty uint64T "tocommit") in
    (if: (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "tocommit")
    then
      (if: (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #()) < (![uint64T] "tocommit")
      then
        do:  (let: "$a0" := #"tocommit(%d) is out of range [lastIndex(%d)]. Was the raft log corrupted, truncated, or lost?"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "tocommit")) in
        let: "$sl1" := (interface.make uint64' (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #())) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (![uint64T] "tocommit") in
      do:  ((struct.field_ref raftLog "committed" (![ptrT] "l")) <-[uint64T] "$r0")
    else do:  #())).

(* go: log.go:332:19 *)
Definition raftLog__appliedTo' : val :=
  rec: "raftLog__appliedTo'" "l" "i" "size" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "i" := (ref_ty uint64T "i") in
    (if: ((![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "i")) || ((![uint64T] "i") < (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l"))))
    then
      do:  (let: "$a0" := #"applied(%d) is out of range [prevApplied(%d), committed(%d)]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftLog "applied" (![ptrT] "l")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) in
    let: "$a1" := (![uint64T] "i") in
    (maxUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref raftLog "applying" (![ptrT] "l")) <-[uint64T] "$r0");;;
    (if: (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) > (![entryEncodingSize] "size")
    then do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) - (![entryEncodingSize] "size")))
    else
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] "$r0"));;;
    let: "$r0" := ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) ≥ (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) in
    do:  ((struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l")) <-[boolT] "$r0")).

(* go: log.go:347:19 *)
Definition raftLog__acceptApplying' : val :=
  rec: "raftLog__acceptApplying'" "l" "i" "size" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "i")
    then
      do:  (let: "$a0" := #"applying(%d) is out of range [prevApplying(%d), committed(%d)]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftLog "applying" (![ptrT] "l")) <-[uint64T] "$r0");;;
    do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) + (![entryEncodingSize] "size")));;;
    let: "$r0" := (((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) ≥ (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) || ((![uint64T] "i") < (let: "$a0" := (![boolT] "allowUnstable") in
    ((method_call raftLog' "maxAppliableIndex" #()) (![ptrT] "l")) "$a0"))) in
    do:  ((struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l")) <-[boolT] "$r0")).

(* go: log.go:367:19 *)
Definition raftLog__stableTo' : val :=
  rec: "raftLog__stableTo'" "l" "id" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "id" := (ref_ty entryID "id") in
    do:  (let: "$a0" := (![entryID] "id") in
    ((method_call unstable' "stableTo" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

(* go: log.go:369:19 *)
Definition raftLog__stableSnapTo' : val :=
  rec: "raftLog__stableSnapTo'" "l" "i" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "i" := (ref_ty uint64T "i") in
    do:  (let: "$a0" := (![uint64T] "i") in
    ((method_call unstable' "stableSnapTo" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

(* acceptUnstable indicates that the application has started persisting the
   unstable entries in storage, and that the current unstable entries are thus
   to be marked as being in-progress, to avoid returning them with future calls
   to Ready().

   go: log.go:375:19 *)
Definition raftLog__acceptUnstable' : val :=
  rec: "raftLog__acceptUnstable'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    do:  (((method_call unstable' "acceptInProgress" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

(* lastEntryID returns the ID of the last entry in the log.

   go: log.go:378:19 *)
Definition raftLog__lastEntryID' : val :=
  rec: "raftLog__lastEntryID'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #()) in
    do:  ("index" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "index") in
    ((method_call raftLog' "term" #()) (![ptrT] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := #"unexpected error when getting the last term at %d: %v"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "index")) in
      let: "$sl1" := (![error] "err") in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (let: "$term" := (![uint64T] "t") in
     let: "$index" := (![uint64T] "index") in
     struct.make entryID [{
       "term" ::= "$term";
       "index" ::= "$index"
     }])).

Definition ErrCompacted : (go_string * go_string) := (pkg_name', "ErrCompacted"%go).

Definition ErrUnavailable : (go_string * go_string) := (pkg_name', "ErrUnavailable"%go).

(* go: log.go:387:19 *)
Definition raftLog__term' : val :=
  rec: "raftLog__term'" "l" "i" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "i" := (ref_ty uint64T "i") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "i") in
    ((method_call unstable' "maybeTerm" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "t", #interface.nil)
    else do:  #()));;;
    (if: ((![uint64T] "i") + #(W64 1)) < (((method_call raftLog' "firstIndex" #()) (![ptrT] "l")) #())
    then return: (#(W64 0), ![error] (globals.get ErrCompacted #()))
    else do:  #());;;
    (if: (![uint64T] "i") > (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #())
    then return: (#(W64 0), ![error] (globals.get ErrUnavailable #()))
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "i") in
    (interface.get "Term" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = #interface.nil
    then return: (![uint64T] "t", #interface.nil)
    else do:  #());;;
    (if: ((![error] "err") = (![error] (globals.get ErrCompacted #()))) || ((![error] "err") = (![error] (globals.get ErrUnavailable #())))
    then return: (#(W64 0), ![error] "err")
    else do:  #());;;
    do:  (let: "$a0" := (![error] "err") in
    Panic "$a0")).

(* go: log.go:415:19 *)
Definition raftLog__entries' : val :=
  rec: "raftLog__entries'" "l" "i" "maxSize" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] "i") > (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #())
    then return: (#slice.nil, #interface.nil)
    else do:  #());;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] "i") in
    let: "$a1" := ((((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #()) + #(W64 1)) in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    ((method_call raftLog' "slice" #()) (![ptrT] "l")) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* allEntries returns all entries in the log.

   go: log.go:423:19 *)
Definition raftLog__allEntries' : val :=
  rec: "raftLog__allEntries'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (((method_call raftLog' "firstIndex" #()) (![ptrT] "l")) #()) in
    let: "$a1" := #(W64 noLimit) in
    ((method_call raftLog' "entries" #()) (![ptrT] "l")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = #interface.nil
    then return: (![sliceT] "ents")
    else do:  #());;;
    (if: (![error] "err") = (![error] (globals.get ErrCompacted #()))
    then return: (((method_call raftLog' "allEntries" #()) (![ptrT] "l")) #())
    else do:  #());;;
    do:  (let: "$a0" := (![error] "err") in
    Panic "$a0")).

(* isUpToDate determines if a log with the given last entry is more up-to-date
   by comparing the index and term of the last entries in the existing logs.

   If the logs have last entries with different terms, then the log with the
   later term is more up-to-date. If the logs end with the same term, then
   whichever log has the larger lastIndex is more up-to-date. If the logs are
   the same, the given log is up-to-date.

   go: log.go:442:19 *)
Definition raftLog__isUpToDate' : val :=
  rec: "raftLog__isUpToDate'" "l" "their" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "their" := (ref_ty entryID "their") in
    let: "our" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] "l")) #()) in
    do:  ("our" <-[entryID] "$r0");;;
    return: (((![uint64T] (struct.field_ref entryID "term" "their")) > (![uint64T] (struct.field_ref entryID "term" "our"))) || (((![uint64T] (struct.field_ref entryID "term" "their")) = (![uint64T] (struct.field_ref entryID "term" "our"))) && ((![uint64T] (struct.field_ref entryID "index" "their")) ≥ (![uint64T] (struct.field_ref entryID "index" "our")))))).

(* go: log.go:447:19 *)
Definition raftLog__matchTerm' : val :=
  rec: "raftLog__matchTerm'" "l" "id" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "id" := (ref_ty entryID "id") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
    ((method_call raftLog' "term" #()) (![ptrT] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (#false)
    else do:  #());;;
    return: ((![uint64T] "t") = (![uint64T] (struct.field_ref entryID "term" "id")))).

(* go: log.go:455:19 *)
Definition raftLog__maybeCommit' : val :=
  rec: "raftLog__maybeCommit'" "l" "at" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "at" := (ref_ty entryID "at") in
    (if: (((![uint64T] (struct.field_ref entryID "term" "at")) ≠ #(W64 0)) && ((![uint64T] (struct.field_ref entryID "index" "at")) > (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))))) && (let: "$a0" := (![entryID] "at") in
    ((method_call raftLog' "matchTerm" #()) (![ptrT] "l")) "$a0")
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "at")) in
      ((method_call raftLog' "commitTo" #()) (![ptrT] "l")) "$a0");;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: log.go:466:19 *)
Definition raftLog__restore' : val :=
  rec: "raftLog__restore'" "l" "s" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] "l")) <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![raftpb.Snapshot] "s") in
    ((method_call unstable' "restore" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

(* scan visits all log entries in the [lo, hi) range, returning them via the
   given callback. The callback can be invoked multiple times, with consecutive
   sub-ranges of the requested range. Returns up to pageSize bytes worth of
   entries at a time. May return more if a single entry size exceeds the limit.

   The entries in [lo, hi) must exist, otherwise scan() eventually returns an
   error (possibly after passing some entries through the callback).

   If the callback returns an error, scan terminates and returns this error
   immediately. This can be used to stop the scan early ("break" the loop).

   go: log.go:482:19 *)
Definition raftLog__scan' : val :=
  rec: "raftLog__scan'" "l" "lo" "hi" "pageSize" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty funcT "v") in
    let: "pageSize" := (ref_ty entryEncodingSize "pageSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (for: (λ: <>, (![uint64T] "lo") < (![uint64T] "hi")); (λ: <>, Skip) := λ: <>,
      let: "err" := (ref_ty error (zero_val error)) in
      let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
      let: "$a1" := (![uint64T] "hi") in
      let: "$a2" := (![entryEncodingSize] "pageSize") in
      ((method_call raftLog' "slice" #()) (![ptrT] "l")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ents" <-[sliceT] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ #interface.nil
      then return: (![error] "err")
      else
        (if: (let: "$a0" := (![sliceT] "ents") in
        slice.len "$a0") = #(W64 0)
        then
          return: (let: "$a0" := #"got 0 entries in [%d, %d)"%go in
           let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "lo")) in
           let: "$sl1" := (interface.make uint64' (![uint64T] "hi")) in
           slice.literal interfaceT ["$sl0"; "$sl1"])) in
           (func_call fmt.Errorf #()) "$a0" "$a1")
        else do:  #()));;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
      (![funcT] "v") "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ #interface.nil
      then return: (![error] "err")
      else do:  #()));;;
      do:  ("lo" <-[uint64T] ((![uint64T] "lo") + (let: "$a0" := (![sliceT] "ents") in
      slice.len "$a0"))));;;
    return: (#interface.nil)).

Definition extend : (go_string * go_string) := (pkg_name', "extend"%go).

Definition entsSize : (go_string * go_string) := (pkg_name', "entsSize"%go).

Definition limitSize : (go_string * go_string) := (pkg_name', "limitSize"%go).

(* slice returns a slice of log entries from lo through hi-1, inclusive.

   go: log.go:499:19 *)
Definition raftLog__slice' : val :=
  rec: "raftLog__slice'" "l" "lo" "hi" "maxSize" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    ((method_call raftLog' "mustCheckOutOfBounds" #()) (![ptrT] "l")) "$a0" "$a1") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (#slice.nil, ![error] "err")
    else do:  #()));;;
    (if: (![uint64T] "lo") = (![uint64T] "hi")
    then return: (#slice.nil, #interface.nil)
    else do:  #());;;
    (if: (![uint64T] "lo") ≥ (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))
    then
      let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![uint64T] "lo") in
      let: "$a1" := (![uint64T] "hi") in
      ((method_call unstable' "slice" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0" "$a1") in
      let: "$a1" := (![entryEncodingSize] "maxSize") in
      (func_call limitSize #()) "$a0" "$a1") in
      do:  ("ents" <-[sliceT] "$r0");;;
      return: (let: "$s" := (![sliceT] "ents") in
       slice.full_slice raftpb.Entry "$s" #(W64 0) (let: "$a0" := (![sliceT] "ents") in
       slice.len "$a0") (let: "$a0" := (![sliceT] "ents") in
       slice.len "$a0"), #interface.nil)
    else do:  #());;;
    let: "cut" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "hi") in
    let: "$a1" := (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("cut" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "cut") in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (interface.get "Entries" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = (![error] (globals.get ErrCompacted #()))
    then return: (#slice.nil, ![error] "err")
    else
      (if: (![error] "err") = (![error] (globals.get ErrUnavailable #()))
      then
        do:  (let: "$a0" := #"entries[%d:%d) is unavailable from storage"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "lo")) in
        let: "$sl1" := (interface.make uint64' (![uint64T] "cut")) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else
        (if: (![error] "err") ≠ #interface.nil
        then
          do:  (let: "$a0" := (![error] "err") in
          Panic "$a0")
        else do:  #())));;;
    (if: (![uint64T] "hi") ≤ (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))
    then return: (![sliceT] "ents", #interface.nil)
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") < ((![uint64T] "cut") - (![uint64T] "lo"))
    then return: (![sliceT] "ents", #interface.nil)
    else do:  #());;;
    let: "size" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
    (func_call entsSize #()) "$a0") in
    do:  ("size" <-[entryEncodingSize] "$r0");;;
    (if: (![entryEncodingSize] "size") ≥ (![entryEncodingSize] "maxSize")
    then return: (![sliceT] "ents", #interface.nil)
    else do:  #());;;
    let: "unstable" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
    let: "$a1" := (![uint64T] "hi") in
    ((method_call unstable' "slice" #()) (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0" "$a1") in
    let: "$a1" := ((![entryEncodingSize] "maxSize") - (![entryEncodingSize] "size")) in
    (func_call limitSize #()) "$a0" "$a1") in
    do:  ("unstable" <-[sliceT] "$r0");;;
    (if: ((let: "$a0" := (![sliceT] "unstable") in
    slice.len "$a0") = #(W64 1)) && (((![entryEncodingSize] "size") + (let: "$a0" := (![sliceT] "unstable") in
    (func_call entsSize #()) "$a0")) > (![entryEncodingSize] "maxSize"))
    then return: (![sliceT] "ents", #interface.nil)
    else do:  #());;;
    return: (let: "$a0" := (![sliceT] "ents") in
     let: "$a1" := (![sliceT] "unstable") in
     (func_call extend #()) "$a0" "$a1", #interface.nil)).

(* l.firstIndex <= lo <= hi <= l.firstIndex + len(l.entries)

   go: log.go:551:19 *)
Definition raftLog__mustCheckOutOfBounds' : val :=
  rec: "raftLog__mustCheckOutOfBounds'" "l" "lo" "hi" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (if: (![uint64T] "lo") > (![uint64T] "hi")
    then
      do:  (let: "$a0" := #"invalid slice %d > %d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64' (![uint64T] "hi")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "fi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((method_call raftLog' "firstIndex" #()) (![ptrT] "l")) #()) in
    do:  ("fi" <-[uint64T] "$r0");;;
    (if: (![uint64T] "lo") < (![uint64T] "fi")
    then return: (![error] (globals.get ErrCompacted #()))
    else do:  #());;;
    let: "length" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #()) + #(W64 1)) - (![uint64T] "fi")) in
    do:  ("length" <-[uint64T] "$r0");;;
    (if: (![uint64T] "hi") > ((![uint64T] "fi") + (![uint64T] "length"))
    then
      do:  (let: "$a0" := #"slice[%d,%d) out of bound [%d,%d]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64' (![uint64T] "hi")) in
      let: "$sl2" := (interface.make uint64' (![uint64T] "fi")) in
      let: "$sl3" := (interface.make uint64' (((method_call raftLog' "lastIndex" #()) (![ptrT] "l")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (#interface.nil)).

(* go: log.go:567:19 *)
Definition raftLog__zeroTermOnOutOfBounds' : val :=
  rec: "raftLog__zeroTermOnOutOfBounds'" "l" "t" "err" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "err" := (ref_ty error "err") in
    let: "t" := (ref_ty uint64T "t") in
    (if: (![error] "err") = #interface.nil
    then return: (![uint64T] "t")
    else do:  #());;;
    (if: ((![error] "err") = (![error] (globals.get ErrCompacted #()))) || ((![error] "err") = (![error] (globals.get ErrUnavailable #())))
    then return: (#(W64 0))
    else do:  #());;;
    do:  (let: "$a0" := #"unexpected error (%v)"%go in
    let: "$a1" := ((let: "$sl0" := (![error] "err") in
    slice.literal interfaceT ["$sl0"])) in
    (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1");;;
    return: (#(W64 0))).

(* maybeFirstIndex returns the index of the first possible entry in entries
   if it has a snapshot.

   go: log_unstable.go:54:20 *)
Definition unstable__maybeFirstIndex' : val :=
  rec: "unstable__maybeFirstIndex'" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then return: ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) + #(W64 1), #true)
    else do:  #());;;
    return: (#(W64 0), #false)).

(* maybeLastIndex returns the last index if it has at least one
   unstable entry or snapshot.

   go: log_unstable.go:63:20 *)
Definition unstable__maybeLastIndex' : val :=
  rec: "unstable__maybeLastIndex'" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (let: "l" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") in
    do:  ("l" <-[intT] "$r0");;;
    (if: (![intT] "l") ≠ #(W64 0)
    then return: (((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (![intT] "l")) - #(W64 1), #true)
    else do:  #()));;;
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then return: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))))), #true)
    else do:  #());;;
    return: (#(W64 0), #false)).

(* maybeTerm returns the term of the entry at index i, if there
   is any.

   go: log_unstable.go:75:20 *)
Definition unstable__maybeTerm' : val :=
  rec: "unstable__maybeTerm'" "u" "i" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] "i") < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))
    then
      (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null) && ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) = (![uint64T] "i"))
      then return: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))))), #true)
      else do:  #());;;
      return: (#(W64 0), #false)
    else do:  #());;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "last" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (((method_call unstable' "maybeLastIndex" #()) (![ptrT] "u")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("last" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    (if: (![uint64T] "i") > (![uint64T] "last")
    then return: (#(W64 0), #false)
    else do:  #());;;
    return: (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) ((![uint64T] "i") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))))), #true)).

(* nextEntries returns the unstable entries that are not already in the process
   of being written to storage.

   go: log_unstable.go:96:20 *)
Definition unstable__nextEntries' : val :=
  rec: "unstable__nextEntries'" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "inProgress" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
    do:  ("inProgress" <-[intT] "$r0");;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") = (![intT] "inProgress")
    then return: (#slice.nil)
    else do:  #());;;
    return: (let: "$s" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
     slice.slice raftpb.Entry "$s" (![intT] "inProgress") (slice.len "$s"))).

(* nextSnapshot returns the unstable snapshot, if one exists that is not already
   in the process of being written to storage.

   go: log_unstable.go:106:20 *)
Definition unstable__nextSnapshot' : val :=
  rec: "unstable__nextSnapshot'" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) = #null) || (![boolT] (struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")))
    then return: (#null)
    else do:  #());;;
    return: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))).

(* acceptInProgress marks all entries and the snapshot, if any, in the unstable
   as having begun the process of being written to storage. The entries/snapshot
   will no longer be returned from nextEntries/nextSnapshot. However, new
   entries/snapshots added after a call to acceptInProgress will be returned
   from those methods, until the next call to acceptInProgress.

   go: log_unstable.go:118:20 *)
Definition unstable__acceptInProgress' : val :=
  rec: "unstable__acceptInProgress'" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") #(W64 0)
    then
      let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) ((let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.len "$a0") - #(W64 1))))) + #(W64 1)) in
      do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then
      let: "$r0" := #true in
      do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")
    else do:  #())).

(* stableTo marks entries up to the entry with the specified (index, term) as
   being successfully written to stable storage.

   The method should only be called when the caller can attest that the entries
   can not be overwritten by an in-progress log append. See the related comment
   in newStorageAppendRespMsg.

   go: log_unstable.go:134:20 *)
Definition unstable__stableTo' : val :=
  rec: "unstable__stableTo'" "u" "id" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "id" := (ref_ty entryID "id") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "gt" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
    ((method_call unstable' "maybeTerm" #()) (![ptrT] "u")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("gt" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then
      do:  (let: "$a0" := #"entry at index %d missing from unstable log; ignoring"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "id"))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref entryID "index" "id")) < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))
    then
      do:  (let: "$a0" := #"entry at index %d matched unstable snapshot; ignoring"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "id"))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (![uint64T] "gt") ≠ (![uint64T] (struct.field_ref entryID "term" "id"))
    then
      do:  (let: "$a0" := #("entry at (index,term)=(%d,%d) mismatched with "%go ++ "entry at (%d,%d) in unstable log; ignoring"%go) in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "id"))) in
      let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl3" := (interface.make uint64' (![uint64T] "gt")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    let: "num" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (((![uint64T] (struct.field_ref entryID "index" "id")) + #(W64 1)) - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
    do:  ("num" <-[intT] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.slice raftpb.Entry "$s" (![intT] "num") (slice.len "$s")) in
    do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0");;;
    let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" "id")) + #(W64 1)) in
    do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) in
    let: "$a1" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
    (maxUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0");;;
    do:  (((method_call unstable' "shrinkEntriesArray" #()) (![ptrT] "u")) #())).

Definition lenMultiple : Z := 2.

(* go: log_unstable.go:168:20 *)
Definition unstable__shrinkEntriesArray' : val :=
  rec: "unstable__shrinkEntriesArray'" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") = #(W64 0)
    then
      let: "$r0" := #slice.nil in
      do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0")
    else
      (if: int_lt ((let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.len "$a0") * #(W64 lenMultiple)) (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.cap "$a0")
      then
        let: "newEntries" := (ref_ty sliceT (zero_val sliceT)) in
        let: "$r0" := (slice.make2 raftpb.Entry (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
        slice.len "$a0")) in
        do:  ("newEntries" <-[sliceT] "$r0");;;
        do:  (let: "$a0" := (![sliceT] "newEntries") in
        let: "$a1" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
        (slice.copy raftpb.Entry) "$a0" "$a1");;;
        let: "$r0" := (![sliceT] "newEntries") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0")
      else do:  #()))).

(* go: log_unstable.go:182:20 *)
Definition unstable__stableSnapTo' : val :=
  rec: "unstable__stableSnapTo'" "u" "i" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "i" := (ref_ty uint64T "i") in
    (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null) && ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) = (![uint64T] "i"))
    then
      let: "$r0" := #null in
      do:  ((struct.field_ref unstable "snapshot" (![ptrT] "u")) <-[ptrT] "$r0");;;
      let: "$r0" := #false in
      do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")
    else do:  #())).

(* go: log_unstable.go:189:20 *)
Definition unstable__restore' : val :=
  rec: "unstable__restore'" "u" "s" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) + #(W64 1)) in
    do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
    do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0");;;
    let: "$r0" := "s" in
    do:  ((struct.field_ref unstable "snapshot" (![ptrT] "u")) <-[ptrT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")).

(* go: log_unstable.go:197:20 *)
Definition unstable__truncateAndAppend' : val :=
  rec: "unstable__truncateAndAppend'" "u" "ents" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "ents" := (ref_ty sliceT "ents") in
    let: "fromIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0)))) in
    do:  ("fromIndex" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] "fromIndex") = ((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0")))
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      let: "$a1" := (![sliceT] "ents") in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0")
    else
      (if: "$sw" = ((![uint64T] "fromIndex") ≤ (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))))
      then
        do:  (let: "$a0" := #"replace the unstable entries from index %d"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "fromIndex")) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
        let: "$r0" := (![sliceT] "ents") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0");;;
        let: "$r0" := (![uint64T] "fromIndex") in
        do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
        let: "$r0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
        do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")
      else
        do:  (let: "$a0" := #"truncate the unstable entries before index %d"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "fromIndex")) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
        let: "keep" := (ref_ty sliceT (zero_val sliceT)) in
        let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
        let: "$a1" := (![uint64T] "fromIndex") in
        ((method_call unstable' "slice" #()) (![ptrT] "u")) "$a0" "$a1") in
        do:  ("keep" <-[sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] "keep") in
        let: "$a1" := (![sliceT] "ents") in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) in
        let: "$a1" := (![uint64T] "fromIndex") in
        (minUint64 2) "$a0" "$a1") in
        do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")))).

(* slice returns the entries from the unstable log with indexes in the range
   [lo, hi). The entire range must be stored in the unstable log or the method
   will panic. The returned slice can be appended to, but the entries in it must
   not be changed because they are still shared with unstable.

   TODO(pavelkalinnikov): this, and similar []raftpb.Entry slices, may bubble up all
   the way to the application code through Ready struct. Protect other slices
   similarly, and document how the client can use them.

   go: log_unstable.go:229:20 *)
Definition unstable__slice' : val :=
  rec: "unstable__slice'" "u" "lo" "hi" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    do:  (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    ((method_call unstable' "mustCheckOutOfBounds" #()) (![ptrT] "u")) "$a0" "$a1");;;
    return: (let: "$s" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
     slice.full_slice raftpb.Entry "$s" ((![uint64T] "lo") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) ((![uint64T] "hi") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) ((![uint64T] "hi") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))))).

(* u.offset <= lo <= hi <= u.offset+len(u.entries)

   go: log_unstable.go:238:20 *)
Definition unstable__mustCheckOutOfBounds' : val :=
  rec: "unstable__mustCheckOutOfBounds'" "u" "lo" "hi" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (if: (![uint64T] "lo") > (![uint64T] "hi")
    then
      do:  (let: "$a0" := #"invalid unstable.slice %d > %d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64' (![uint64T] "hi")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1")
    else do:  #());;;
    let: "upper" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0")) in
    do:  ("upper" <-[uint64T] "$r0");;;
    (if: ((![uint64T] "lo") < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) || ((![uint64T] "hi") > (![uint64T] "upper"))
    then
      do:  (let: "$a0" := #"unstable.slice[%d,%d) out of bound [%d,%d]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64' (![uint64T] "hi")) in
      let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
      let: "$sl3" := (interface.make uint64' (![uint64T] "upper")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1")
    else do:  #())).

Definition Logger' : (go_string * go_string) := (pkg_name', "Logger").

Definition raftLoggerMu : (go_string * go_string) := (pkg_name', "raftLoggerMu"%go).

Definition raftLogger : (go_string * go_string) := (pkg_name', "raftLogger"%go).

(* go: logger.go:45:6 *)
Definition SetLogger' : val :=
  rec: "SetLogger'" "l" :=
    exception_do (let: "l" := (ref_ty Logger "l") in
    do:  (((method_call sync.Mutex' "Lock" #()) (globals.get raftLoggerMu #())) #());;;
    let: "$r0" := (![Logger] "l") in
    do:  ((globals.get raftLogger #()) <-[Logger] "$r0");;;
    do:  (((method_call sync.Mutex' "Unlock" #()) (globals.get raftLoggerMu #())) #())).

Definition SetLogger : (go_string * go_string) := (pkg_name', "SetLogger"%go).

Definition defaultLogger : (go_string * go_string) := (pkg_name', "defaultLogger"%go).

(* go: logger.go:51:6 *)
Definition ResetDefaultLogger' : val :=
  rec: "ResetDefaultLogger'" <> :=
    exception_do (do:  (let: "$a0" := (interface.make DefaultLogger'ptr (![ptrT] (globals.get defaultLogger #()))) in
    (func_call SetLogger #()) "$a0")).

Definition ResetDefaultLogger : (go_string * go_string) := (pkg_name', "ResetDefaultLogger"%go).

(* go: logger.go:55:6 *)
Definition getLogger' : val :=
  rec: "getLogger'" <> :=
    with_defer: (do:  (((method_call sync.Mutex' "Lock" #()) (globals.get raftLoggerMu #())) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (globals.get raftLoggerMu #())) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    return: (![Logger] (globals.get raftLogger #()))).

Definition getLogger : (go_string * go_string) := (pkg_name', "getLogger"%go).

Definition discardLogger : (go_string * go_string) := (pkg_name', "discardLogger"%go).

Definition calldepth : Z := 2.

Definition DefaultLogger : go_type := structT [
  "Logger" :: ptrT;
  "debug" :: boolT
].

Definition DefaultLogger' : (go_string * go_string) := (pkg_name', "DefaultLogger").

(* go: logger.go:78:25 *)
Definition DefaultLogger__EnableTimestamps' : val :=
  rec: "DefaultLogger__EnableTimestamps'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    do:  (let: "$a0" := (((((method_call log.Logger' "Flags" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) #()) `or` #(W64 log.Ldate)) `or` #(W64 log.Ltime)) in
    ((method_call log.Logger' "SetFlags" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0")).

(* go: logger.go:82:25 *)
Definition DefaultLogger__EnableDebug' : val :=
  rec: "DefaultLogger__EnableDebug'" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "$r0" := #true in
    do:  ((struct.field_ref DefaultLogger "debug" (![ptrT] "l")) <-[boolT] "$r0")).

Definition header : (go_string * go_string) := (pkg_name', "header"%go).

(* go: logger.go:86:25 *)
Definition DefaultLogger__Debug' : val :=
  rec: "DefaultLogger__Debug'" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    (if: ![boolT] (struct.field_ref DefaultLogger "debug" (![ptrT] "l"))
    then
      do:  (let: "$a0" := #(W64 calldepth) in
      let: "$a1" := (let: "$a0" := #"DEBUG"%go in
      let: "$a1" := (let: "$a0" := (![sliceT] "v") in
      (func_call fmt.Sprint #()) "$a0") in
      (func_call header #()) "$a0" "$a1") in
      ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #())).

(* go: logger.go:92:25 *)
Definition DefaultLogger__Debugf' : val :=
  rec: "DefaultLogger__Debugf'" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    (if: ![boolT] (struct.field_ref DefaultLogger "debug" (![ptrT] "l"))
    then
      do:  (let: "$a0" := #(W64 calldepth) in
      let: "$a1" := (let: "$a0" := #"DEBUG"%go in
      let: "$a1" := (let: "$a0" := (![stringT] "format") in
      let: "$a1" := (![sliceT] "v") in
      (func_call fmt.Sprintf #()) "$a0" "$a1") in
      (func_call header #()) "$a0" "$a1") in
      ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #())).

(* go: logger.go:98:25 *)
Definition DefaultLogger__Info' : val :=
  rec: "DefaultLogger__Info'" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"INFO"%go in
    let: "$a1" := (let: "$a0" := (![sliceT] "v") in
    (func_call fmt.Sprint #()) "$a0") in
    (func_call header #()) "$a0" "$a1") in
    ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:102:25 *)
Definition DefaultLogger__Infof' : val :=
  rec: "DefaultLogger__Infof'" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"INFO"%go in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    (func_call fmt.Sprintf #()) "$a0" "$a1") in
    (func_call header #()) "$a0" "$a1") in
    ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:106:25 *)
Definition DefaultLogger__Error' : val :=
  rec: "DefaultLogger__Error'" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"ERROR"%go in
    let: "$a1" := (let: "$a0" := (![sliceT] "v") in
    (func_call fmt.Sprint #()) "$a0") in
    (func_call header #()) "$a0" "$a1") in
    ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:110:25 *)
Definition DefaultLogger__Errorf' : val :=
  rec: "DefaultLogger__Errorf'" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"ERROR"%go in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    (func_call fmt.Sprintf #()) "$a0" "$a1") in
    (func_call header #()) "$a0" "$a1") in
    ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:114:25 *)
Definition DefaultLogger__Warning' : val :=
  rec: "DefaultLogger__Warning'" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"WARN"%go in
    let: "$a1" := (let: "$a0" := (![sliceT] "v") in
    (func_call fmt.Sprint #()) "$a0") in
    (func_call header #()) "$a0" "$a1") in
    ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:118:25 *)
Definition DefaultLogger__Warningf' : val :=
  rec: "DefaultLogger__Warningf'" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"WARN"%go in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    (func_call fmt.Sprintf #()) "$a0" "$a1") in
    (func_call header #()) "$a0" "$a1") in
    ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:122:25 *)
Definition DefaultLogger__Fatal' : val :=
  rec: "DefaultLogger__Fatal'" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"FATAL"%go in
    let: "$a1" := (let: "$a0" := (![sliceT] "v") in
    (func_call fmt.Sprint #()) "$a0") in
    (func_call header #()) "$a0" "$a1") in
    ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1");;;
    do:  (let: "$a0" := #(W64 1) in
    (func_call os.Exit #()) "$a0")).

(* go: logger.go:127:25 *)
Definition DefaultLogger__Fatalf' : val :=
  rec: "DefaultLogger__Fatalf'" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"FATAL"%go in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    (func_call fmt.Sprintf #()) "$a0" "$a1") in
    (func_call header #()) "$a0" "$a1") in
    ((method_call log.Logger' "Output" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1");;;
    do:  (let: "$a0" := #(W64 1) in
    (func_call os.Exit #()) "$a0")).

(* go: logger.go:132:25 *)
Definition DefaultLogger__Panic' : val :=
  rec: "DefaultLogger__Panic'" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := (![sliceT] "v") in
    ((method_call log.Logger' "Panic" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0")).

(* go: logger.go:136:25 *)
Definition DefaultLogger__Panicf' : val :=
  rec: "DefaultLogger__Panicf'" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    ((method_call log.Logger' "Panicf" #()) (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:140:6 *)
Definition header' : val :=
  rec: "header'" "lvl" "msg" :=
    exception_do (let: "msg" := (ref_ty stringT "msg") in
    let: "lvl" := (ref_ty stringT "lvl") in
    return: (let: "$a0" := #"%s: %s"%go in
     let: "$a1" := ((let: "$sl0" := (interface.make string' (![stringT] "lvl")) in
     let: "$sl1" := (interface.make string' (![stringT] "msg")) in
     slice.literal interfaceT ["$sl0"; "$sl1"])) in
     (func_call fmt.Sprintf #()) "$a0" "$a1")).

Definition SnapshotStatus : go_type := intT.

Definition SnapshotStatus' : (go_string * go_string) := (pkg_name', "SnapshotStatus").

Definition SnapshotFinish : expr := #(W64 1).

Definition SnapshotFailure : expr := #(W64 2).

Definition ErrStopped : (go_string * go_string) := (pkg_name', "ErrStopped"%go).

Definition SoftState : go_type := structT [
  "Lead" :: uint64T;
  "RaftState" :: StateType
].

Definition SoftState' : (go_string * go_string) := (pkg_name', "SoftState").

(* go: node.go:45:21 *)
Definition SoftState__equal' : val :=
  rec: "SoftState__equal'" "a" "b" :=
    exception_do (let: "a" := (ref_ty ptrT "a") in
    let: "b" := (ref_ty ptrT "b") in
    return: (((![uint64T] (struct.field_ref SoftState "Lead" (![ptrT] "a"))) = (![uint64T] (struct.field_ref SoftState "Lead" (![ptrT] "b")))) && ((![StateType] (struct.field_ref SoftState "RaftState" (![ptrT] "a"))) = (![StateType] (struct.field_ref SoftState "RaftState" (![ptrT] "b")))))).

Definition Ready : go_type := structT [
  "SoftState" :: ptrT;
  "HardState" :: raftpb.HardState;
  "ReadStates" :: sliceT;
  "Entries" :: sliceT;
  "Snapshot" :: raftpb.Snapshot;
  "CommittedEntries" :: sliceT;
  "Messages" :: sliceT;
  "MustSync" :: boolT
].

Definition Ready' : (go_string * go_string) := (pkg_name', "Ready").

(* go: node.go:117:6 *)
Definition isHardStateEqual' : val :=
  rec: "isHardStateEqual'" "a" "b" :=
    exception_do (let: "b" := (ref_ty raftpb.HardState "b") in
    let: "a" := (ref_ty raftpb.HardState "a") in
    return: ((((![uint64T] (struct.field_ref raftpb.HardState "Term" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Term" "b"))) && ((![uint64T] (struct.field_ref raftpb.HardState "Vote" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Vote" "b")))) && ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Commit" "b"))))).

Definition isHardStateEqual : (go_string * go_string) := (pkg_name', "isHardStateEqual"%go).

(* IsEmptyHardState returns true if the given HardState is empty.

   go: node.go:122:6 *)
Definition IsEmptyHardState' : val :=
  rec: "IsEmptyHardState'" "st" :=
    exception_do (let: "st" := (ref_ty raftpb.HardState "st") in
    return: (let: "$a0" := (![raftpb.HardState] "st") in
     let: "$a1" := (![raftpb.HardState] (globals.get emptyState #())) in
     (func_call isHardStateEqual #()) "$a0" "$a1")).

Definition IsEmptyHardState : (go_string * go_string) := (pkg_name', "IsEmptyHardState"%go).

(* IsEmptySnap returns true if the given Snapshot is empty.

   go: node.go:127:6 *)
Definition IsEmptySnap' : val :=
  rec: "IsEmptySnap'" "sp" :=
    exception_do (let: "sp" := (ref_ty raftpb.Snapshot "sp") in
    return: ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "sp"))) = #(W64 0))).

Definition IsEmptySnap : (go_string * go_string) := (pkg_name', "IsEmptySnap"%go).

Definition Node : go_type := interfaceT.

Definition Node' : (go_string * go_string) := (pkg_name', "Node").

Definition Peer' : (go_string * go_string) := (pkg_name', "Peer").

Definition msgWithResult : go_type := structT [
  "m" :: raftpb.Message;
  "result" :: chanT error
].

Definition BasicStatus : go_type := structT [
  "ID" :: uint64T;
  "HardState" :: raftpb.HardState;
  "SoftState" :: SoftState;
  "Applied" :: uint64T;
  "LeadTransferee" :: uint64T
].

Definition Status : go_type := structT [
  "BasicStatus" :: BasicStatus;
  "Config" :: tracker.Config;
  "Progress" :: mapT uint64T tracker.Progress
].

Definition node : go_type := structT [
  "propc" :: chanT msgWithResult;
  "recvc" :: chanT raftpb.Message;
  "confc" :: chanT raftpb.ConfChangeV2;
  "confstatec" :: chanT raftpb.ConfState;
  "readyc" :: chanT Ready;
  "advancec" :: chanT (structT [
  ]);
  "tickc" :: chanT (structT [
  ]);
  "done" :: chanT (structT [
  ]);
  "stop" :: chanT (structT [
  ]);
  "status" :: chanT (chanT Status);
  "rn" :: ptrT
].

Definition newNode : (go_string * go_string) := (pkg_name', "newNode"%go).

Definition ReadOnlyOption : go_type := intT.

Definition Config : go_type := structT [
  "ID" :: uint64T;
  "ElectionTick" :: intT;
  "HeartbeatTick" :: intT;
  "Storage" :: Storage;
  "Applied" :: uint64T;
  "AsyncStorageWrites" :: boolT;
  "MaxSizePerMsg" :: uint64T;
  "MaxCommittedSizePerReady" :: uint64T;
  "MaxUncommittedEntriesSize" :: uint64T;
  "MaxInflightMsgs" :: intT;
  "MaxInflightBytes" :: uint64T;
  "CheckQuorum" :: boolT;
  "PreVote" :: boolT;
  "ReadOnlyOption" :: ReadOnlyOption;
  "Logger" :: Logger;
  "DisableProposalForwarding" :: boolT;
  "DisableConfChangeValidation" :: boolT;
  "StepDownOnRemoval" :: boolT;
  "TraceLogger" :: TraceLogger
].

Definition RawNode' : (go_string * go_string) := (pkg_name', "RawNode").

Definition NewRawNode : (go_string * go_string) := (pkg_name', "NewRawNode"%go).

(* go: node.go:250:6 *)
Definition setupNode' : val :=
  rec: "setupNode'" "c" "peers" :=
    exception_do (let: "peers" := (ref_ty sliceT "peers") in
    let: "c" := (ref_ty ptrT "c") in
    (if: (let: "$a0" := (![sliceT] "peers") in
    slice.len "$a0") = #(W64 0)
    then
      do:  (let: "$a0" := (interface.make string' #"no peers given; use RestartNode instead"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![ptrT] "c") in
    (func_call NewRawNode #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rn" <-[ptrT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![sliceT] "peers") in
    ((method_call RawNode' "Bootstrap" #()) (![ptrT] "rn")) "$a0") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := #"error occurred during starting a new node: %v"%go in
      let: "$a1" := ((let: "$sl0" := (![error] "err") in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c")))) "$a0" "$a1")
    else do:  #());;;
    let: "n" := (ref_ty node (zero_val node)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "rn") in
    (func_call newNode #()) "$a0") in
    do:  ("n" <-[node] "$r0");;;
    return: ("n")).

Definition setupNode : (go_string * go_string) := (pkg_name', "setupNode"%go).

Definition node' : (go_string * go_string) := (pkg_name', "node").

(* StartNode returns a new Node given configuration and a list of raft peers.
   It appends a ConfChangeAddNode entry for each given peer to the initial log.

   Peers must not be zero length; call RestartNode in that case.

   go: node.go:271:6 *)
Definition StartNode' : val :=
  rec: "StartNode'" "c" "peers" :=
    exception_do (let: "peers" := (ref_ty sliceT "peers") in
    let: "c" := (ref_ty ptrT "c") in
    let: "n" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "c") in
    let: "$a1" := (![sliceT] "peers") in
    (func_call setupNode #()) "$a0" "$a1") in
    do:  ("n" <-[ptrT] "$r0");;;
    let: "$go" := ((method_call node' "run" #()) (![ptrT] "n")) in
    do:  (Fork ("$go" #()));;;
    return: (interface.make node'ptr (![ptrT] "n"))).

Definition StartNode : (go_string * go_string) := (pkg_name', "StartNode"%go).

(* RestartNode is similar to StartNode but does not take a list of peers.
   The current membership of the cluster will be restored from the Storage.
   If the caller has an existing state machine, pass in the last log index that
   has been applied to it; otherwise use zero.

   go: node.go:281:6 *)
Definition RestartNode' : val :=
  rec: "RestartNode'" "c" :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![ptrT] "c") in
    (func_call NewRawNode #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rn" <-[ptrT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    let: "n" := (ref_ty node (zero_val node)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "rn") in
    (func_call newNode #()) "$a0") in
    do:  ("n" <-[node] "$r0");;;
    let: "$go" := ((method_call node' "run" #()) "n") in
    do:  (Fork ("$go" #()));;;
    return: (interface.make node'ptr "n")).

Definition RestartNode : (go_string * go_string) := (pkg_name', "RestartNode"%go).

Definition msgWithResult' : (go_string * go_string) := (pkg_name', "msgWithResult").

(* go: node.go:312:6 *)
Definition newNode' : val :=
  rec: "newNode'" "rn" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$propc" := (chan.make msgWithResult #()) in
     let: "$recvc" := (chan.make raftpb.Message #()) in
     let: "$confc" := (chan.make raftpb.ConfChangeV2 #()) in
     let: "$confstatec" := (chan.make raftpb.ConfState #()) in
     let: "$readyc" := (chan.make Ready #()) in
     let: "$advancec" := (chan.make (structT [
     ]) #()) in
     let: "$tickc" := (chan.make (structT [
     ]) #()) in
     let: "$done" := (chan.make (structT [
     ]) #()) in
     let: "$stop" := (chan.make (structT [
     ]) #()) in
     let: "$status" := (chan.make (chanT Status) #()) in
     let: "$rn" := (![ptrT] "rn") in
     struct.make node [{
       "propc" ::= "$propc";
       "recvc" ::= "$recvc";
       "confc" ::= "$confc";
       "confstatec" ::= "$confstatec";
       "readyc" ::= "$readyc";
       "advancec" ::= "$advancec";
       "tickc" ::= "$tickc";
       "done" ::= "$done";
       "stop" ::= "$stop";
       "status" ::= "$status";
       "rn" ::= "$rn"
     }])).

(* go: node.go:331:16 *)
Definition node__Stop' : val :=
  rec: "node__Stop'" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        return: (#())
        ))] (InjLV #()));;;
    do:  (Fst (chan.receive (![chanT (structT [
    ])] (struct.field_ref node "done" (![ptrT] "n")))))).

Definition IsResponseMsg : (go_string * go_string) := (pkg_name', "IsResponseMsg"%go).

Definition IsLocalMsgTarget : (go_string * go_string) := (pkg_name', "IsLocalMsgTarget"%go).

Definition getStatus : (go_string * go_string) := (pkg_name', "getStatus"%go).

(* go: node.go:343:16 *)
Definition node__run' : val :=
  rec: "node__run'" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "propc" := (ref_ty (chanT msgWithResult) (zero_val (chanT msgWithResult))) in
    let: "readyc" := (ref_ty (chanT Ready) (zero_val (chanT Ready))) in
    let: "advancec" := (ref_ty (chanT (structT [
    ])) (zero_val (chanT (structT [
    ])))) in
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n"))))) in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "lead" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := None in
    do:  ("lead" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: ((![chanT (structT [
      ])] "advancec") = #null) && (((method_call RawNode' "HasReady" #()) (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #())
      then
        let: "$r0" := (((method_call RawNode' "readyWithoutAccept" #()) (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #()) in
        do:  ("rd" <-[Ready] "$r0");;;
        let: "$r0" := (![chanT Ready] (struct.field_ref node "readyc" (![ptrT] "n"))) in
        do:  ("readyc" <-[chanT Ready] "$r0")
      else do:  #());;;
      (if: (![uint64T] "lead") ≠ (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))
      then
        (if: ((method_call raft' "hasLeader" #()) (![ptrT] "r")) #()
        then
          (if: (![uint64T] "lead") = None
          then
            do:  (let: "$a0" := #"raft.node: %x elected leader %x at term %d"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            do:  (let: "$a0" := #"raft.node: %x changed leader from %x to %x at term %d"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] "lead")) in
            let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
            let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
          let: "$r0" := (![chanT msgWithResult] (struct.field_ref node "propc" (![ptrT] "n"))) in
          do:  ("propc" <-[chanT msgWithResult] "$r0")
        else
          do:  (let: "$a0" := #"raft.node: %x lost leader %x at term %d"%go in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64' (![uint64T] "lead")) in
          let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          let: "$r0" := #null in
          do:  ("propc" <-[chanT msgWithResult] "$r0"));;;
        let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
        do:  ("lead" <-[uint64T] "$r0")
      else do:  #());;;
      do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
          do:  (let: "$a0" := (![Ready] "rd") in
          ((method_call RawNode' "acceptReady" #()) (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) "$a0");;;
          (if: (~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n"))))))
          then
            let: "$r0" := (![chanT (structT [
            ])] (struct.field_ref node "advancec" (![ptrT] "n"))) in
            do:  ("advancec" <-[chanT (structT [
            ])] "$r0")
          else
            let: "$r0" := (struct.make Ready [{
              "SoftState" ::= zero_val ptrT;
              "HardState" ::= zero_val raftpb.HardState;
              "ReadStates" ::= zero_val sliceT;
              "Entries" ::= zero_val sliceT;
              "Snapshot" ::= zero_val raftpb.Snapshot;
              "CommittedEntries" ::= zero_val sliceT;
              "Messages" ::= zero_val sliceT;
              "MustSync" ::= zero_val boolT
            }]) in
            do:  ("rd" <-[Ready] "$r0"));;;
          let: "$r0" := #null in
          do:  ("readyc" <-[chanT Ready] "$r0")
          ))] [("$recvChan0", (λ: "$recvVal",
          let: "pm" := (ref_ty msgWithResult (zero_val msgWithResult)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("pm" <-[msgWithResult] "$r0");;;
          let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (![raftpb.Message] (struct.field_ref msgWithResult "m" "pm")) in
          do:  ("m" <-[raftpb.Message] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
          do:  ((struct.field_ref raftpb.Message "From" "m") <-[uint64T] "$r0");;;
          let: "err" := (ref_ty error (zero_val error)) in
          let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
          ((method_call raft' "Step" #()) (![ptrT] "r")) "$a0") in
          do:  ("err" <-[error] "$r0");;;
          (if: (![chanT error] (struct.field_ref msgWithResult "result" "pm")) ≠ #null
          then
            do:  (let: "$chan" := (![chanT error] (struct.field_ref msgWithResult "result" "pm")) in
            let: "$v" := (![error] "err") in
            chan.send "$chan" "$v");;;
            do:  (let: "$a0" := (![chanT error] (struct.field_ref msgWithResult "result" "pm")) in
            chan.close "$a0")
          else do:  #())
          )); ("$recvChan1", (λ: "$recvVal",
          let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("m" <-[raftpb.Message] "$r0");;;
          (if: ((let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
          (func_call IsResponseMsg #()) "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          (func_call IsLocalMsgTarget #()) "$a0"))) && ((Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) = #null)
          then break: #()
          else do:  #());;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          ((method_call raft' "Step" #()) (![ptrT] "r")) "$a0")
          )); ("$recvChan2", (λ: "$recvVal",
          let: "cc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("cc" <-[raftpb.ConfChangeV2] "$r0");;;
          let: "okBefore" := (ref_ty boolT (zero_val boolT)) in
          let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  "$r0";;;
          do:  ("okBefore" <-[boolT] "$r1");;;
          let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
          let: "$r0" := (let: "$a0" := (![raftpb.ConfChangeV2] "cc") in
          ((method_call raft' "applyConfChange" #()) (![ptrT] "r")) "$a0") in
          do:  ("cs" <-[raftpb.ConfState] "$r0");;;
          (let: "okAfter" := (ref_ty boolT (zero_val boolT)) in
          let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  "$r0";;;
          do:  ("okAfter" <-[boolT] "$r1");;;
          (if: (![boolT] "okBefore") && (~ (![boolT] "okAfter"))
          then
            let: "found" := (ref_ty boolT (zero_val boolT)) in
            do:  (let: "$range" := ((let: "$sl0" := (![sliceT] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
            let: "$sl1" := (![sliceT] (struct.field_ref raftpb.ConfState "VotersOutgoing" "cs")) in
            slice.literal sliceT ["$sl0"; "$sl1"])) in
            slice.for_range sliceT "$range" (λ: <> "sl",
              let: "sl" := ref_ty sliceT "sl" in
              do:  (let: "$range" := (![sliceT] "sl") in
              slice.for_range uint64T "$range" (λ: <> "id",
                let: "id" := ref_ty uint64T "id" in
                (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
                then
                  let: "$r0" := #true in
                  do:  ("found" <-[boolT] "$r0");;;
                  break: #()
                else do:  #())));;;
              (if: ![boolT] "found"
              then break: #()
              else do:  #())));;;
            (if: (~ (![boolT] "found"))
            then
              let: "$r0" := #null in
              do:  ("propc" <-[chanT msgWithResult] "$r0")
            else do:  #())
          else do:  #()));;;
          do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
              do:  #()
              ))] [("$recvChan0", (λ: "$recvVal",
              do:  #()
              ))] (InjLV #()))
          )); ("$recvChan3", (λ: "$recvVal",
          do:  (((method_call RawNode' "Tick" #()) (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #())
          )); ("$recvChan4", (λ: "$recvVal",
          do:  (let: "$a0" := (![Ready] "rd") in
          ((method_call RawNode' "Advance" #()) (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) "$a0");;;
          let: "$r0" := (struct.make Ready [{
            "SoftState" ::= zero_val ptrT;
            "HardState" ::= zero_val raftpb.HardState;
            "ReadStates" ::= zero_val sliceT;
            "Entries" ::= zero_val sliceT;
            "Snapshot" ::= zero_val raftpb.Snapshot;
            "CommittedEntries" ::= zero_val sliceT;
            "Messages" ::= zero_val sliceT;
            "MustSync" ::= zero_val boolT
          }]) in
          do:  ("rd" <-[Ready] "$r0");;;
          let: "$r0" := #null in
          do:  ("advancec" <-[chanT (structT [
          ])] "$r0")
          )); ("$recvChan5", (λ: "$recvVal",
          let: "c" := (ref_ty (chanT Status) (zero_val (chanT Status))) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("c" <-[chanT Status] "$r0");;;
          do:  (let: "$chan" := (![chanT Status] "c") in
          let: "$v" := (let: "$a0" := (![ptrT] "r") in
          (func_call getStatus #()) "$a0") in
          chan.send "$chan" "$v")
          )); ("$recvChan6", (λ: "$recvVal",
          do:  (let: "$a0" := (![chanT (structT [
          ])] (struct.field_ref node "done" (![ptrT] "n"))) in
          chan.close "$a0");;;
          return: (#())
          ))] (InjLV #())))).

(* Tick increments the internal logical clock for this Node. Election timeouts
   and heartbeat timeouts are in units of ticks.

   go: node.go:458:16 *)
Definition node__Tick' : val :=
  rec: "node__Tick'" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjR (λ: <>,
      do:  (let: "$a0" := #"%x A tick missed to fire. Node blocks too long!"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))))))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))))))) "$a0" "$a1")
      )))).

(* go: node.go:467:16 *)
Definition node__Campaign' : val :=
  rec: "node__Campaign'" "n" "ctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (let: "$Type" := raftpb.MsgHup in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= zero_val uint64T;
       "From" ::= zero_val uint64T;
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= zero_val sliceT;
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }]) in
     ((method_call node' "step" #()) (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:471:16 *)
Definition node__Propose' : val :=
  rec: "node__Propose'" "n" "ctx" "data" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "data" := (ref_ty sliceT "data") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (let: "$Type" := raftpb.MsgProp in
     let: "$Entries" := ((let: "$sl0" := (let: "$Data" := (![sliceT] "data") in
     struct.make raftpb.Entry [{
       "Term" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Type" ::= zero_val raftpb.EntryType;
       "Data" ::= "$Data"
     }]) in
     slice.literal raftpb.Entry ["$sl0"])) in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= zero_val uint64T;
       "From" ::= zero_val uint64T;
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= "$Entries";
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }]) in
     ((method_call node' "stepWait" #()) (![ptrT] "n")) "$a0" "$a1")).

Definition IsLocalMsg : (go_string * go_string) := (pkg_name', "IsLocalMsg"%go).

(* go: node.go:475:16 *)
Definition node__Step' : val :=
  rec: "node__Step'" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    (if: (let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (func_call IsLocalMsg #()) "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    (func_call IsLocalMsgTarget #()) "$a0"))
    then return: (#interface.nil)
    else do:  #());;;
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     ((method_call node' "step" #()) (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:484:6 *)
Definition confChangeToMsg' : val :=
  rec: "confChangeToMsg'" "c" :=
    exception_do (let: "c" := (ref_ty raftpb.ConfChangeI "c") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "data" := (ref_ty sliceT (zero_val sliceT)) in
    let: "typ" := (ref_ty raftpb.EntryType (zero_val raftpb.EntryType)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![raftpb.ConfChangeI] "c") in
    (func_call raftpb.MarshalConfChange #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("typ" <-[raftpb.EntryType] "$r0");;;
    do:  ("data" <-[sliceT] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      return: (struct.make raftpb.Message [{
         "Type" ::= zero_val raftpb.MessageType;
         "To" ::= zero_val uint64T;
         "From" ::= zero_val uint64T;
         "Term" ::= zero_val uint64T;
         "LogTerm" ::= zero_val uint64T;
         "Index" ::= zero_val uint64T;
         "Entries" ::= zero_val sliceT;
         "Commit" ::= zero_val uint64T;
         "Vote" ::= zero_val uint64T;
         "Snapshot" ::= zero_val ptrT;
         "Reject" ::= zero_val boolT;
         "RejectHint" ::= zero_val uint64T;
         "Context" ::= zero_val sliceT;
         "Responses" ::= zero_val sliceT
       }], ![error] "err")
    else do:  #());;;
    return: (let: "$Type" := raftpb.MsgProp in
     let: "$Entries" := ((let: "$sl0" := (let: "$Type" := (![raftpb.EntryType] "typ") in
     let: "$Data" := (![sliceT] "data") in
     struct.make raftpb.Entry [{
       "Term" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Type" ::= "$Type";
       "Data" ::= "$Data"
     }]) in
     slice.literal raftpb.Entry ["$sl0"])) in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= zero_val uint64T;
       "From" ::= zero_val uint64T;
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= "$Entries";
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }], #interface.nil)).

Definition confChangeToMsg : (go_string * go_string) := (pkg_name', "confChangeToMsg"%go).

(* go: node.go:492:16 *)
Definition node__ProposeConfChange' : val :=
  rec: "node__ProposeConfChange'" "n" "ctx" "cc" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "msg" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
    (func_call confChangeToMsg #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("msg" <-[raftpb.Message] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (![error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "msg") in
     ((method_call node' "Step" #()) (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:500:16 *)
Definition node__step' : val :=
  rec: "node__step'" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := #false in
     ((method_call node' "stepWithWaitOption" #()) (![ptrT] "n")) "$a0" "$a1" "$a2")).

(* go: node.go:504:16 *)
Definition node__stepWait' : val :=
  rec: "node__stepWait'" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := #true in
     ((method_call node' "stepWithWaitOption" #()) (![ptrT] "n")) "$a0" "$a1" "$a2")).

(* Step advances the state machine using msgs. The ctx.Err() will be returned,
   if any.

   go: node.go:510:16 *)
Definition node__stepWithWaitOption' : val :=
  rec: "node__stepWithWaitOption'" "n" "ctx" "m" "wait" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "wait" := (ref_ty boolT "wait") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgProp
    then
      do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
          return: (#interface.nil)
          ))] [("$recvChan0", (λ: "$recvVal",
          return: ((interface.get "Err" (![context.Context] "ctx")) #())
          )); ("$recvChan1", (λ: "$recvVal",
          return: (![error] (globals.get ErrStopped #()))
          ))] (InjLV #()))
    else do:  #());;;
    let: "ch" := (ref_ty (chanT msgWithResult) (zero_val (chanT msgWithResult))) in
    let: "$r0" := (![chanT msgWithResult] (struct.field_ref node "propc" (![ptrT] "n"))) in
    do:  ("ch" <-[chanT msgWithResult] "$r0");;;
    let: "pm" := (ref_ty msgWithResult (zero_val msgWithResult)) in
    let: "$r0" := (let: "$m" := (![raftpb.Message] "m") in
    struct.make msgWithResult [{
      "m" ::= "$m";
      "result" ::= zero_val (chanT error)
    }]) in
    do:  ("pm" <-[msgWithResult] "$r0");;;
    (if: ![boolT] "wait"
    then
      let: "$r0" := (chan.make error #()) in
      do:  ((struct.field_ref msgWithResult "result" "pm") <-[chanT error] "$r0")
    else do:  #());;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        (if: (~ (![boolT] "wait"))
        then return: (#interface.nil)
        else do:  #())
        ))] [("$recvChan0", (λ: "$recvVal",
        return: ((interface.get "Err" (![context.Context] "ctx")) #())
        )); ("$recvChan1", (λ: "$recvVal",
        return: (![error] (globals.get ErrStopped #()))
        ))] (InjLV #()));;;
    do:  (chan.select [] [("$recvChan0", (λ: "$recvVal",
        let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (Fst "$recvVal") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ #interface.nil
        then return: (![error] "err")
        else do:  #())
        )); ("$recvChan1", (λ: "$recvVal",
        return: ((interface.get "Err" (![context.Context] "ctx")) #())
        )); ("$recvChan2", (λ: "$recvVal",
        return: (![error] (globals.get ErrStopped #()))
        ))] (InjLV #()));;;
    return: (#interface.nil)).

(* go: node.go:549:16 *)
Definition node__Ready' : val :=
  rec: "node__Ready'" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    return: (![chanT Ready] (struct.field_ref node "readyc" (![ptrT] "n")))).

(* go: node.go:551:16 *)
Definition node__Advance' : val :=
  rec: "node__Advance'" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:558:16 *)
Definition node__ApplyConfChange' : val :=
  rec: "node__ApplyConfChange'" "n" "cc" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()));;;
    do:  (chan.select [] [("$recvChan0", (λ: "$recvVal",
        let: "$r0" := (Fst "$recvVal") in
        do:  ("cs" <-[raftpb.ConfState] "$r0");;;
        do:  #()
        )); ("$recvChan1", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()));;;
    return: ("cs")).

(* go: node.go:571:16 *)
Definition node__Status' : val :=
  rec: "node__Status'" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "c" := (ref_ty (chanT Status) (zero_val (chanT Status))) in
    let: "$r0" := (chan.make Status #()) in
    do:  ("c" <-[chanT Status] "$r0");;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        return: (Fst (chan.receive (![chanT Status] "c")))
        ))] [("$recvChan0", (λ: "$recvVal",
        return: (struct.make Status [{
           "BasicStatus" ::= zero_val BasicStatus;
           "Config" ::= zero_val tracker.Config;
           "Progress" ::= zero_val (mapT uint64T tracker.Progress)
         }])
        ))] (InjLV #()))).

(* go: node.go:581:16 *)
Definition node__ReportUnreachable' : val :=
  rec: "node__ReportUnreachable'" "n" "id" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "id" := (ref_ty uint64T "id") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:588:16 *)
Definition node__ReportSnapshot' : val :=
  rec: "node__ReportSnapshot'" "n" "id" "status" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "status" := (ref_ty SnapshotStatus "status") in
    let: "id" := (ref_ty uint64T "id") in
    let: "rej" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := ((![SnapshotStatus] "status") = SnapshotFailure) in
    do:  ("rej" <-[boolT] "$r0");;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:597:16 *)
Definition node__TransferLeadership' : val :=
  rec: "node__TransferLeadership'" "n" "ctx" "lead" "transferee" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "transferee" := (ref_ty uint64T "transferee") in
    let: "lead" := (ref_ty uint64T "lead") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        )); ("$recvChan1", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:606:16 *)
Definition node__ForgetLeader' : val :=
  rec: "node__ForgetLeader'" "n" "ctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (let: "$Type" := raftpb.MsgForgetLeader in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= zero_val uint64T;
       "From" ::= zero_val uint64T;
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= zero_val sliceT;
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }]) in
     ((method_call node' "step" #()) (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:610:16 *)
Definition node__ReadIndex' : val :=
  rec: "node__ReadIndex'" "n" "ctx" "rctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "rctx" := (ref_ty sliceT "rctx") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (let: "$Type" := raftpb.MsgReadIndex in
     let: "$Entries" := ((let: "$sl0" := (let: "$Data" := (![sliceT] "rctx") in
     struct.make raftpb.Entry [{
       "Term" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Type" ::= zero_val raftpb.EntryType;
       "Data" ::= "$Data"
     }]) in
     slice.literal raftpb.Entry ["$sl0"])) in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= zero_val uint64T;
       "From" ::= zero_val uint64T;
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= "$Entries";
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }]) in
     ((method_call node' "step" #()) (![ptrT] "n")) "$a0" "$a1")).

Definition LocalAppendThread : expr := #(W64 math.MaxUint64).

Definition LocalApplyThread : expr := #(W64 (math.MaxUint64 - 1)).

Definition StateFollower : expr := #(W64 0).

Definition StateCandidate : expr := #(W64 1).

Definition StateLeader : expr := #(W64 2).

Definition StatePreCandidate : expr := #(W64 3).

Definition numStates : expr := #(W64 4).

Definition ReadOnlyOption' : (go_string * go_string) := (pkg_name', "ReadOnlyOption").

Definition ReadOnlySafe : expr := #(W64 0).

Definition ReadOnlyLeaseBased : expr := #(W64 1).

Definition campaignPreElection : expr := #"CampaignPreElection"%go.

Definition campaignElection : expr := #"CampaignElection"%go.

Definition campaignTransfer : expr := #"CampaignTransfer"%go.

Definition ErrProposalDropped : (go_string * go_string) := (pkg_name', "ErrProposalDropped"%go).

Definition lockedRand : go_type := structT [
  "mu" :: sync.Mutex
].

Definition lockedRand' : (go_string * go_string) := (pkg_name', "lockedRand").

(* go: raft.go:95:22 *)
Definition lockedRand__Intn' : val :=
  rec: "lockedRand__Intn'" "r" "n" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "n" := (ref_ty intT "n") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref lockedRand "mu" (![ptrT] "r"))) #());;;
    let: "v" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![io.Reader] (globals.get rand.Reader #())) in
    let: "$a1" := (let: "$a0" := (![intT] "n") in
    (func_call big.NewInt #()) "$a0") in
    (func_call rand.Int #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[ptrT] "$r0");;;
    do:  "$r1";;;
    do:  (((method_call sync.Mutex' "Unlock" #()) (struct.field_ref lockedRand "mu" (![ptrT] "r"))) #());;;
    return: (((method_call big.Int' "Int64" #()) (![ptrT] "v")) #())).

Definition globalRand : (go_string * go_string) := (pkg_name', "globalRand"%go).

Definition CampaignType : go_type := stringT.

Definition CampaignType' : (go_string * go_string) := (pkg_name', "CampaignType").

Definition StateType' : (go_string * go_string) := (pkg_name', "StateType").

Definition stmap : (go_string * go_string) := (pkg_name', "stmap"%go).

(* go: raft.go:119:21 *)
Definition StateType__String' : val :=
  rec: "StateType__String'" "st" <> :=
    exception_do (let: "st" := (ref_ty StateType "st") in
    return: (![stringT] (array.elem_ref stringT (![arrayT 4 stringT] (globals.get stmap #())) (![StateType] "st")))).

Definition Config' : (go_string * go_string) := (pkg_name', "Config").

(* go: raft.go:291:18 *)
Definition Config__validate' : val :=
  rec: "Config__validate'" "c" <> :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    (if: (![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"))) = None
    then
      return: (let: "$a0" := #"cannot use none as id"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    (if: let: "$a0" := (![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"))) in
    (func_call IsLocalMsgTarget #()) "$a0"
    then
      return: (let: "$a0" := #"cannot use local target as id"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c"))) #(W64 0)
    then
      return: (let: "$a0" := #"heartbeat tick must be greater than 0"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "ElectionTick" (![ptrT] "c"))) (![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c")))
    then
      return: (let: "$a0" := #"election tick must be greater than heartbeat tick"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    (if: (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c"))) = #interface.nil
    then
      return: (let: "$a0" := #"storage cannot be nil"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := #(W64 noLimit) in
      do:  ((struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := (![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c"))) in
      do:  ((struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "MaxInflightMsgs" (![ptrT] "c"))) #(W64 0)
    then
      return: (let: "$a0" := #"max inflight messages must be greater than 0"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := #(W64 noLimit) in
      do:  ((struct.field_ref Config "MaxInflightBytes" (![ptrT] "c")) <-[uint64T] "$r0")
    else
      (if: (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) < (![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c")))
      then
        return: (let: "$a0" := #"max inflight bytes must be >= max message size"%go in
         (func_call errors.New #()) "$a0")
      else do:  #()));;;
    (if: (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"))) = #interface.nil
    then
      let: "$r0" := ((func_call getLogger #()) #()) in
      do:  ((struct.field_ref Config "Logger" (![ptrT] "c")) <-[Logger] "$r0")
    else do:  #());;;
    (if: ((![ReadOnlyOption] (struct.field_ref Config "ReadOnlyOption" (![ptrT] "c"))) = ReadOnlyLeaseBased) && (~ (![boolT] (struct.field_ref Config "CheckQuorum" (![ptrT] "c"))))
    then
      return: (let: "$a0" := #"CheckQuorum must be enabled when ReadOnlyOption is ReadOnlyLeaseBased"%go in
       (func_call errors.New #()) "$a0")
    else do:  #());;;
    return: (#interface.nil)).

Definition tickElectionId : expr := #(W64 0).

Definition tickHeartbeatId : expr := #(W64 1).

Definition assertConfStatesEquivalent : (go_string * go_string) := (pkg_name', "assertConfStatesEquivalent"%go).

Definition traceInitState : (go_string * go_string) := (pkg_name', "traceInitState"%go).

Definition newReadOnly : (go_string * go_string) := (pkg_name', "newReadOnly"%go).

(* go: raft.go:444:6 *)
Definition newRaft' : val :=
  rec: "newRaft'" "c" :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (((method_call Config' "validate" #()) (![ptrT] "c")) #()) in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (interface.make string' ((interface.get "Error" (![error] "err")) #())) in
      Panic "$a0")
    else do:  #()));;;
    let: "raftlog" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c"))) in
    let: "$a1" := (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"))) in
    let: "$a2" := (![uint64T] (struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c"))) in
    (func_call newLogWithSize #()) "$a0" "$a1" "$a2") in
    do:  ("raftlog" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "hs" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((interface.get "InitialState" (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("hs" <-[raftpb.HardState] "$r0");;;
    do:  ("cs" <-[raftpb.ConfState] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty raft (let: "$id" := (![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"))) in
    let: "$lead" := None in
    let: "$isLearner" := #false in
    let: "$raftLog" := (![ptrT] "raftlog") in
    let: "$maxMsgSize" := (![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c"))) in
    let: "$maxUncommittedSize" := (![uint64T] (struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c"))) in
    let: "$trk" := (let: "$a0" := (![intT] (struct.field_ref Config "MaxInflightMsgs" (![ptrT] "c"))) in
    let: "$a1" := (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) in
    (func_call tracker.MakeProgressTracker #()) "$a0" "$a1") in
    let: "$electionTimeout" := (![intT] (struct.field_ref Config "ElectionTick" (![ptrT] "c"))) in
    let: "$heartbeatTimeout" := (![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c"))) in
    let: "$logger" := (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"))) in
    let: "$checkQuorum" := (![boolT] (struct.field_ref Config "CheckQuorum" (![ptrT] "c"))) in
    let: "$preVote" := (![boolT] (struct.field_ref Config "PreVote" (![ptrT] "c"))) in
    let: "$readOnly" := (let: "$a0" := (![ReadOnlyOption] (struct.field_ref Config "ReadOnlyOption" (![ptrT] "c"))) in
    (func_call newReadOnly #()) "$a0") in
    let: "$disableProposalForwarding" := (![boolT] (struct.field_ref Config "DisableProposalForwarding" (![ptrT] "c"))) in
    let: "$disableConfChangeValidation" := (![boolT] (struct.field_ref Config "DisableConfChangeValidation" (![ptrT] "c"))) in
    let: "$stepDownOnRemoval" := (![boolT] (struct.field_ref Config "StepDownOnRemoval" (![ptrT] "c"))) in
    let: "$traceLogger" := (![TraceLogger] (struct.field_ref Config "TraceLogger" (![ptrT] "c"))) in
    struct.make raft [{
      "id" ::= "$id";
      "Term" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "readStates" ::= zero_val sliceT;
      "raftLog" ::= "$raftLog";
      "maxMsgSize" ::= "$maxMsgSize";
      "maxUncommittedSize" ::= "$maxUncommittedSize";
      "trk" ::= "$trk";
      "state" ::= zero_val StateType;
      "isLearner" ::= "$isLearner";
      "msgs" ::= zero_val sliceT;
      "msgsAfterAppend" ::= zero_val sliceT;
      "lead" ::= "$lead";
      "leadTransferee" ::= zero_val uint64T;
      "pendingConfIndex" ::= zero_val uint64T;
      "disableConfChangeValidation" ::= "$disableConfChangeValidation";
      "uncommittedSize" ::= zero_val entryPayloadSize;
      "readOnly" ::= "$readOnly";
      "electionElapsed" ::= zero_val intT;
      "heartbeatElapsed" ::= zero_val intT;
      "checkQuorum" ::= "$checkQuorum";
      "preVote" ::= "$preVote";
      "heartbeatTimeout" ::= "$heartbeatTimeout";
      "electionTimeout" ::= "$electionTimeout";
      "randomizedElectionTimeout" ::= zero_val intT;
      "disableProposalForwarding" ::= "$disableProposalForwarding";
      "stepDownOnRemoval" ::= "$stepDownOnRemoval";
      "tickId" ::= zero_val intT;
      "step" ::= zero_val funcT;
      "StepHigherOrder" ::= zero_val funcT;
      "logger" ::= "$logger";
      "pendingReadIndexMessages" ::= zero_val sliceT;
      "traceLogger" ::= "$traceLogger"
    }])) in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "$r0" := ((method_call raft' "Step" #()) (![ptrT] "r")) in
    do:  ((struct.field_ref raft "StepHigherOrder" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    (func_call traceInitState #()) "$a0");;;
    let: "lastID" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("lastID" <-[entryID] "$r0");;;
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (let: "$Tracker" := (![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"))) in
    let: "$LastIndex" := (![uint64T] (struct.field_ref entryID "index" "lastID")) in
    struct.make confchange.Changer [{
      "Tracker" ::= "$Tracker";
      "LastIndex" ::= "$LastIndex"
    }]) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    (func_call confchange.Restore #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![Logger] (struct.field_ref raft "logger" (![ptrT] "r"))) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    let: "$a2" := (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![tracker.ProgressMap] "trk") in
    ((method_call raft' "switchToConfig" #()) (![ptrT] "r")) "$a0" "$a1") in
    (func_call assertConfStatesEquivalent #()) "$a0" "$a1" "$a2");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hs") in
    (func_call IsEmptyHardState #()) "$a0"))
    then
      do:  (let: "$a0" := (![raftpb.HardState] "hs") in
      ((method_call raft' "loadState" #()) (![ptrT] "r")) "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "Applied" (![ptrT] "c"))) > #(W64 0)
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref Config "Applied" (![ptrT] "c"))) in
      let: "$a1" := #(W64 0) in
      ((method_call raftLog' "appliedTo" #()) (![ptrT] "raftlog")) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
    let: "$a1" := None in
    ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1");;;
    let: "nodesStrs" := (ref_ty sliceT (zero_val sliceT)) in
    do:  (let: "$range" := (((method_call tracker.ProgressTracker' "VoterNodes" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) #()) in
    slice.for_range uint64T "$range" (λ: <> "n",
      let: "n" := ref_ty uint64T "n" in
      let: "$r0" := (let: "$a0" := (![sliceT] "nodesStrs") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := #"%x"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "n")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Sprintf #()) "$a0" "$a1") in
      slice.literal stringT ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("nodesStrs" <-[sliceT] "$r0")));;;
    do:  (let: "$a0" := #"newRaft %x [peers: [%s], term: %d, commit: %d, applied: %d, lastindex: %d, lastterm: %d]"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make string' (let: "$a0" := (![sliceT] "nodesStrs") in
    let: "$a1" := #","%go in
    (func_call strings.Join #()) "$a0" "$a1")) in
    let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
    let: "$sl6" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    return: (![ptrT] "r")).

Definition newRaft : (go_string * go_string) := (pkg_name', "newRaft"%go).

(* go: raft.go:506:16 *)
Definition raft__hasLeader' : val :=
  rec: "raft__hasLeader'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None)).

(* go: raft.go:508:16 *)
Definition raft__softState' : val :=
  rec: "raft__softState'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (let: "$Lead" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
     let: "$RaftState" := (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) in
     struct.make SoftState [{
       "Lead" ::= "$Lead";
       "RaftState" ::= "$RaftState"
     }])).

(* go: raft.go:510:16 *)
Definition raft__hardState' : val :=
  rec: "raft__hardState'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (let: "$Term" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
     let: "$Vote" := (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"))) in
     let: "$Commit" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
     struct.make raftpb.HardState [{
       "Term" ::= "$Term";
       "Vote" ::= "$Vote";
       "Commit" ::= "$Commit"
     }])).

Definition traceSendMessage : (go_string * go_string) := (pkg_name', "traceSendMessage"%go).

(* send schedules persisting state to a stable storage and AFTER that
   sending the message (as part of next Ready message processing).

   go: raft.go:520:16 *)
Definition raft__send' : val :=
  rec: "raft__send'" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    (if: (![uint64T] (struct.field_ref raftpb.Message "From" "m")) = None
    then
      let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Message "From" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: ((((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVoteResp)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp)
    then
      (if: (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) = #(W64 0)
      then
        do:  (let: "$a0" := #"term should be set when sending %s"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #())
    else
      (if: (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) ≠ #(W64 0)
      then
        do:  (let: "$a0" := #"term should not be set when sending %s (was %d)"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #());;;
      (if: ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgProp) && ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgReadIndex)
      then
        let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
        do:  ((struct.field_ref raftpb.Message "Term" "m") <-[uint64T] "$r0")
      else do:  #()));;;
    (if: (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgAppResp) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVoteResp)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp)
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref raft "msgsAfterAppend" (![ptrT] "r")) <-[sliceT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := "m" in
      (func_call traceSendMessage #()) "$a0" "$a1")
    else
      (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        do:  (let: "$a0" := #"message should not be self-addressed when sending %s"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref raft "msgs" (![ptrT] "r")) <-[sliceT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := "m" in
      (func_call traceSendMessage #()) "$a0" "$a1"))).

(* sendAppend sends an append RPC with new entries (if any) and the
   current commit index to the given peer.

   go: raft.go:611:16 *)
Definition raft__sendAppend' : val :=
  rec: "raft__sendAppend'" "r" "to" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "to" := (ref_ty uint64T "to") in
    do:  (let: "$a0" := (![uint64T] "to") in
    let: "$a1" := #true in
    ((method_call raft' "maybeSendAppend" #()) (![ptrT] "r")) "$a0" "$a1")).

Definition payloadsSize : (go_string * go_string) := (pkg_name', "payloadsSize"%go).

(* maybeSendAppend sends an append RPC with new entries to the given peer,
   if necessary. Returns true if a message was sent. The sendIfEmpty
   argument controls whether messages with no entries will be sent
   ("empty" messages are useful to convey updated Commit indexes, but
   are undesirable when we're sending multiple messages in a batch).

   TODO(pav-kv): make invocation of maybeSendAppend stateless. The Progress
   struct contains all the state necessary for deciding whether to send a
   message.

   go: raft.go:624:16 *)
Definition raft__maybeSendAppend' : val :=
  rec: "raft__maybeSendAppend'" "r" "to" "sendIfEmpty" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "sendIfEmpty" := (ref_ty boolT "sendIfEmpty") in
    let: "to" := (ref_ty uint64T "to") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] "to"))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    (if: ((method_call tracker.Progress' "IsPaused" #()) (![ptrT] "pr")) #()
    then return: (#false)
    else do:  #());;;
    let: "prevIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref tracker.Progress "Next" (![ptrT] "pr"))) - #(W64 1)) in
    do:  ("prevIndex" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "prevTerm" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "prevIndex") in
    ((method_call raftLog' "term" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("prevTerm" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      return: (let: "$a0" := (![uint64T] "to") in
       let: "$a1" := (![ptrT] "pr") in
       ((method_call raft' "maybeSendSnapshot" #()) (![ptrT] "r")) "$a0" "$a1")
    else do:  #());;;
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    (if: ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) ≠ tracker.StateReplicate) || (~ (((method_call tracker.Inflights' "Full" #()) (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) #()))
    then
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref tracker.Progress "Next" (![ptrT] "pr"))) in
      let: "$a1" := (![entryEncodingSize] (struct.field_ref raft "maxMsgSize" (![ptrT] "r"))) in
      ((method_call raftLog' "entries" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ents" <-[sliceT] "$r0");;;
      do:  ("err" <-[error] "$r1")
    else do:  #());;;
    (if: ((let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") = #(W64 0)) && (~ (![boolT] "sendIfEmpty"))
    then return: (#false)
    else do:  #());;;
    (if: (![error] "err") ≠ #interface.nil
    then
      return: (let: "$a0" := (![uint64T] "to") in
       let: "$a1" := (![ptrT] "pr") in
       ((method_call raft' "maybeSendSnapshot" #()) (![ptrT] "r")) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (let: "$To" := (![uint64T] "to") in
    let: "$Type" := raftpb.MsgApp in
    let: "$Index" := (![uint64T] "prevIndex") in
    let: "$LogTerm" := (![uint64T] "prevTerm") in
    let: "$Entries" := (![sliceT] "ents") in
    let: "$Commit" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= zero_val uint64T;
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= "$LogTerm";
      "Index" ::= "$Index";
      "Entries" ::= "$Entries";
      "Commit" ::= "$Commit";
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "send" #()) (![ptrT] "r")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") in
    let: "$a1" := (let: "$a0" := (![sliceT] "ents") in
    (func_call payloadsSize #()) "$a0") in
    ((method_call tracker.Progress' "SentEntries" #()) (![ptrT] "pr")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    ((method_call tracker.Progress' "SentCommit" #()) (![ptrT] "pr")) "$a0");;;
    return: (#true)).

Definition ErrSnapshotTemporarilyUnavailable : (go_string * go_string) := (pkg_name', "ErrSnapshotTemporarilyUnavailable"%go).

(* maybeSendSnapshot fetches a snapshot from Storage, and sends it to the given
   node. Returns true iff the snapshot message has been emitted successfully.

   go: raft.go:672:16 *)
Definition raft__maybeSendSnapshot' : val :=
  rec: "raft__maybeSendSnapshot'" "r" "to" "pr" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "pr" := (ref_ty ptrT "pr") in
    let: "to" := (ref_ty uint64T "to") in
    (if: (~ (![boolT] (struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr"))))
    then
      do:  (let: "$a0" := #"ignore sending snapshot to %x since it is not recently active"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "to")) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "snapshot" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
    let: ("$ret0", "$ret1") := (((method_call raftLog' "snapshot" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("snapshot" <-[raftpb.Snapshot] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      (if: (![error] "err") = (![error] (globals.get ErrSnapshotTemporarilyUnavailable #()))
      then
        do:  (let: "$a0" := #"%x failed to send snapshot to %x because snapshot is temporarily unavailable"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64' (![uint64T] "to")) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        return: (#false)
      else do:  #());;;
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    (if: let: "$a0" := (![raftpb.Snapshot] "snapshot") in
    (func_call IsEmptySnap #()) "$a0"
    then
      do:  (let: "$a0" := (interface.make string' #"need non-empty snapshot"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "sterm" := (ref_ty uint64T (zero_val uint64T)) in
    let: "sindex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snapshot"))) in
    let: "$r1" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "snapshot"))) in
    do:  ("sindex" <-[uint64T] "$r0");;;
    do:  ("sterm" <-[uint64T] "$r1");;;
    do:  (let: "$a0" := #"%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (((method_call raftLog' "firstIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
    let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl3" := (interface.make uint64' (![uint64T] "sindex")) in
    let: "$sl4" := (interface.make uint64' (![uint64T] "sterm")) in
    let: "$sl5" := (interface.make uint64' (![uint64T] "to")) in
    let: "$sl6" := (interface.make tracker.Progress'ptr (![ptrT] "pr")) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![uint64T] "sindex") in
    ((method_call tracker.Progress' "BecomeSnapshot" #()) (![ptrT] "pr")) "$a0");;;
    do:  (let: "$a0" := #"%x paused sending replication messages to %x [%s]"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (![uint64T] "to")) in
    let: "$sl2" := (interface.make tracker.Progress'ptr (![ptrT] "pr")) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (let: "$To" := (![uint64T] "to") in
    let: "$Type" := raftpb.MsgSnap in
    let: "$Snapshot" := "snapshot" in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= zero_val uint64T;
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= "$Snapshot";
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "send" #()) (![ptrT] "r")) "$a0");;;
    return: (#true)).

(* sendHeartbeat sends a heartbeat RPC to the given peer.

   go: raft.go:700:16 *)
Definition raft__sendHeartbeat' : val :=
  rec: "raft__sendHeartbeat'" "r" "to" "ctx" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ctx" := (ref_ty sliceT "ctx") in
    let: "to" := (ref_ty uint64T "to") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] "to"))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    let: "commit" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) in
    let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("commit" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (let: "$To" := (![uint64T] "to") in
    let: "$Type" := raftpb.MsgHeartbeat in
    let: "$Commit" := (![uint64T] "commit") in
    let: "$Context" := (![sliceT] "ctx") in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= zero_val uint64T;
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= zero_val sliceT;
      "Commit" ::= "$Commit";
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= "$Context";
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "send" #()) (![ptrT] "r")) "$a0");;;
    do:  (let: "$a0" := (![uint64T] "commit") in
    ((method_call tracker.Progress' "SentCommit" #()) (![ptrT] "pr")) "$a0")).

(* bcastAppend sends RPC, with entries to all peers that are not up-to-date
   according to the progress recorded in r.trk.

   go: raft.go:720:16 *)
Definition raft__bcastAppend' : val :=
  rec: "raft__bcastAppend'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  (let: "$a0" := (λ: "id" <>,
      exception_do (let: <> := (ref_ty ptrT "_") in
      let: "id" := (ref_ty uint64T "id") in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![uint64T] "id") in
      ((method_call raft' "sendAppend" #()) (![ptrT] "r")) "$a0"))
      ) in
    ((method_call tracker.ProgressTracker' "Visit" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0")).

Definition readOnly' : (go_string * go_string) := (pkg_name', "readOnly").

(* bcastHeartbeat sends RPC, without entries to all the peers.

   go: raft.go:730:16 *)
Definition raft__bcastHeartbeat' : val :=
  rec: "raft__bcastHeartbeat'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "lastCtx" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (((method_call readOnly' "lastPendingRequestCtx" #()) (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) #()) in
    do:  ("lastCtx" <-[stringT] "$r0");;;
    (if: (let: "$a0" := (![stringT] "lastCtx") in
    StringLength "$a0") = #(W64 0)
    then
      do:  (let: "$a0" := #slice.nil in
      ((method_call raft' "bcastHeartbeatWithCtx" #()) (![ptrT] "r")) "$a0")
    else
      do:  (let: "$a0" := (string.to_bytes (![stringT] "lastCtx")) in
      ((method_call raft' "bcastHeartbeatWithCtx" #()) (![ptrT] "r")) "$a0"))).

(* go: raft.go:739:16 *)
Definition raft__bcastHeartbeatWithCtx' : val :=
  rec: "raft__bcastHeartbeatWithCtx'" "r" "ctx" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ctx" := (ref_ty sliceT "ctx") in
    do:  (let: "$a0" := (λ: "id" <>,
      exception_do (let: <> := (ref_ty ptrT "_") in
      let: "id" := (ref_ty uint64T "id") in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![uint64T] "id") in
      let: "$a1" := (![sliceT] "ctx") in
      ((method_call raft' "sendHeartbeat" #()) (![ptrT] "r")) "$a0" "$a1"))
      ) in
    ((method_call tracker.ProgressTracker' "Visit" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0")).

(* go: raft.go:748:16 *)
Definition raft__appliedTo' : val :=
  rec: "raft__appliedTo'" "r" "index" "size" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "index" := (ref_ty uint64T "index") in
    let: "oldApplied" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ("oldApplied" <-[uint64T] "$r0");;;
    let: "newApplied" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "index") in
    let: "$a1" := (![uint64T] "oldApplied") in
    (maxUint64 2) "$a0" "$a1") in
    do:  ("newApplied" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "newApplied") in
    let: "$a1" := (![entryEncodingSize] "size") in
    ((method_call raftLog' "appliedTo" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1");;;
    (if: ((![boolT] (struct.field_ref tracker.Config "AutoLeave" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) && ((![uint64T] "newApplied") ≥ (![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r"))))) && ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader)
    then
      let: "err" := (ref_ty error (zero_val error)) in
      let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := #interface.nil in
      (func_call confChangeToMsg #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("m" <-[raftpb.Message] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ #interface.nil
      then
        do:  (let: "$a0" := (![error] "err") in
        Panic "$a0")
      else do:  #());;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (![funcT] (struct.field_ref raft "StepHigherOrder" (![ptrT] "r"))) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ #interface.nil
      then
        do:  (let: "$a0" := #"not initiating automatic transition out of joint configuration %s: %v"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make tracker.Config' (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
        let: "$sl1" := (![error] "err") in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else
        do:  (let: "$a0" := #"initiating automatic transition out of joint configuration %s"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make tracker.Config' (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")))
    else do:  #())).

(* go: raft.go:777:16 *)
Definition raft__appliedSnap' : val :=
  rec: "raft__appliedSnap'" "r" "snap" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "snap" := (ref_ty ptrT "snap") in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] "snap")))) in
    do:  ("index" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "index") in
    ((method_call raftLog' "stableSnapTo" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    do:  (let: "$a0" := (![uint64T] "index") in
    let: "$a1" := #(W64 0) in
    ((method_call raft' "appliedTo" #()) (![ptrT] "r")) "$a0" "$a1")).

Definition traceCommit : (go_string * go_string) := (pkg_name', "traceCommit"%go).

(* maybeCommit attempts to advance the commit index. Returns true if the commit
   index changed (in which case the caller should call r.bcastAppend). This can
   only be called in StateLeader.

   go: raft.go:786:16 *)
Definition raft__maybeCommit' : val :=
  rec: "raft__maybeCommit'" "r" <> :=
    with_defer: (let: "r" := (ref_ty ptrT "r") in
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$f" := (func_call traceCommit #()) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" "a0";;
      "$oldf" #()
      )));;;
    return: (let: "$a0" := (let: "$term" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
     let: "$index" := (((method_call tracker.ProgressTracker' "Committed" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) #()) in
     struct.make entryID [{
       "term" ::= "$term";
       "index" ::= "$index"
     }]) in
     ((method_call raftLog' "maybeCommit" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")).

Definition readOnly : go_type := structT [
  "option" :: ReadOnlyOption;
  "pendingReadIndex" :: mapT stringT ptrT;
  "readIndexQueue" :: sliceT
].

(* go: raft.go:792:16 *)
Definition raft__reset' : val :=
  rec: "raft__reset'" "r" "term" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "term" := (ref_ty uint64T "term") in
    (if: (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) ≠ (![uint64T] "term")
    then
      let: "$r0" := (![uint64T] "term") in
      do:  ((struct.field_ref raft "Term" (![ptrT] "r")) <-[uint64T] "$r0");;;
      let: "$r0" := None in
      do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")
    else do:  #());;;
    let: "$r0" := None in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
    do:  (((method_call raft' "resetRandomizedElectionTimeout" #()) (![ptrT] "r")) #());;;
    do:  (((method_call raft' "abortLeaderTransfer" #()) (![ptrT] "r")) #());;;
    do:  (((method_call tracker.ProgressTracker' "ResetVotes" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) #());;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "$r0" := (let: "$Match" := #(W64 0) in
      let: "$Next" := ((((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) + #(W64 1)) in
      let: "$Inflights" := (let: "$a0" := (![intT] (struct.field_ref tracker.ProgressTracker "MaxInflight" (struct.field_ref raft "trk" (![ptrT] "r")))) in
      let: "$a1" := (![uint64T] (struct.field_ref tracker.ProgressTracker "MaxInflightBytes" (struct.field_ref raft "trk" (![ptrT] "r")))) in
      (func_call tracker.NewInflights #()) "$a0" "$a1") in
      let: "$IsLearner" := (![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))) in
      struct.make tracker.Progress [{
        "Match" ::= "$Match";
        "Next" ::= "$Next";
        "sentCommit" ::= zero_val uint64T;
        "State" ::= zero_val tracker.StateType;
        "PendingSnapshot" ::= zero_val uint64T;
        "RecentActive" ::= zero_val boolT;
        "MsgAppFlowPaused" ::= zero_val boolT;
        "Inflights" ::= "$Inflights";
        "IsLearner" ::= "$IsLearner"
      }]) in
      do:  ((![ptrT] "pr") <-[tracker.Progress] "$r0");;;
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        let: "$r0" := (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
        do:  ((struct.field_ref tracker.Progress "Match" (![ptrT] "pr")) <-[uint64T] "$r0")
      else do:  #()))
      ) in
    ((method_call tracker.ProgressTracker' "Visit" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] "$r0");;;
    let: "$r0" := (let: "$a0" := (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) in
    (func_call newReadOnly #()) "$a0") in
    do:  ((struct.field_ref raft "readOnly" (![ptrT] "r")) <-[ptrT] "$r0")).

Definition traceReplicate : (go_string * go_string) := (pkg_name', "traceReplicate"%go).

(* returns: accepted

   go: raft.go:824:16 *)
Definition raft__appendEntry' : val :=
  rec: "raft__appendEntry'" "r" "es" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "es" := (ref_ty sliceT "es") in
    let: "li" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("li" <-[uint64T] "$r0");;;
    do:  (let: "$range" := (![sliceT] "es") in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] "es") (![intT] "i"))) <-[uint64T] "$r0");;;
      let: "$r0" := (((![uint64T] "li") + #(W64 1)) + (![intT] "i")) in
      do:  ((struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "es") (![intT] "i"))) <-[uint64T] "$r0")));;;
    (if: (~ (let: "$a0" := (![sliceT] "es") in
    ((method_call raft' "increaseUncommittedSize" #()) (![ptrT] "r")) "$a0"))
    then
      do:  (let: "$a0" := #"%x appending new entries to log would exceed uncommitted entry size limit; dropping proposal"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$a1" := (![sliceT] "es") in
    (func_call traceReplicate #()) "$a0" "$a1");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "es") in
    ((method_call raftLog' "append" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0") in
    do:  ("li" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    let: "$Type" := raftpb.MsgAppResp in
    let: "$Index" := (![uint64T] "li") in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= zero_val uint64T;
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= "$Index";
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "send" #()) (![ptrT] "r")) "$a0");;;
    return: (#true)).

(* go: raft.go:858:16 *)
Definition raft__tick' : val :=
  rec: "raft__tick'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![intT] (struct.field_ref raft "tickId" (![ptrT] "r"))) in
    (if: "$sw" = tickElectionId
    then do:  (((method_call raft' "tickElection" #()) (![ptrT] "r")) #())
    else
      (if: "$sw" = tickHeartbeatId
      then do:  (((method_call raft' "tickHeartbeat" #()) (![ptrT] "r")) #())
      else #()))).

(* tickElection is run by followers and candidates after r.electionTimeout.

   go: raft.go:868:16 *)
Definition raft__tickElection' : val :=
  rec: "raft__tickElection'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    (if: (((method_call raft' "promotable" #()) (![ptrT] "r")) #()) && (((method_call raft' "pastElectionTimeout" #()) (![ptrT] "r")) #())
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (let: "$From" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
      let: "$Type" := raftpb.MsgHup in
      struct.make raftpb.Message [{
        "Type" ::= "$Type";
        "To" ::= zero_val uint64T;
        "From" ::= "$From";
        "Term" ::= zero_val uint64T;
        "LogTerm" ::= zero_val uint64T;
        "Index" ::= zero_val uint64T;
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= zero_val sliceT;
        "Responses" ::= zero_val sliceT
      }]) in
      ((method_call raft' "Step" #()) (![ptrT] "r")) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ #interface.nil
      then
        do:  (let: "$a0" := #"error occurred during election: %v"%go in
        let: "$a1" := ((let: "$sl0" := (![error] "err") in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #()))
    else do:  #())).

(* tickHeartbeat is run by leaders to send a MsgBeat after r.heartbeatTimeout.

   go: raft.go:880:16 *)
Definition raft__tickHeartbeat' : val :=
  rec: "raft__tickHeartbeat'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "heartbeatElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    (if: int_geq (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (if: ![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))
      then
        (let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (let: "$a0" := (let: "$From" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
        let: "$Type" := raftpb.MsgCheckQuorum in
        struct.make raftpb.Message [{
          "Type" ::= "$Type";
          "To" ::= zero_val uint64T;
          "From" ::= "$From";
          "Term" ::= zero_val uint64T;
          "LogTerm" ::= zero_val uint64T;
          "Index" ::= zero_val uint64T;
          "Entries" ::= zero_val sliceT;
          "Commit" ::= zero_val uint64T;
          "Vote" ::= zero_val uint64T;
          "Snapshot" ::= zero_val ptrT;
          "Reject" ::= zero_val boolT;
          "RejectHint" ::= zero_val uint64T;
          "Context" ::= zero_val sliceT;
          "Responses" ::= zero_val sliceT
        }]) in
        ((method_call raft' "Step" #()) (![ptrT] "r")) "$a0") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ #interface.nil
        then
          do:  (let: "$a0" := #"error occurred during checking sending heartbeat: %v"%go in
          let: "$a1" := ((let: "$sl0" := (![error] "err") in
          slice.literal interfaceT ["$sl0"])) in
          (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
        else do:  #()))
      else do:  #());;;
      (if: ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader) && ((![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ None)
      then do:  (((method_call raft' "abortLeaderTransfer" #()) (![ptrT] "r")) #())
      else do:  #())
    else do:  #());;;
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateLeader
    then return: (#())
    else do:  #());;;
    (if: int_geq (![intT] (struct.field_ref raft "heartbeatElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "heartbeatTimeout" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (let: "$From" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
      let: "$Type" := raftpb.MsgBeat in
      struct.make raftpb.Message [{
        "Type" ::= "$Type";
        "To" ::= zero_val uint64T;
        "From" ::= "$From";
        "Term" ::= zero_val uint64T;
        "LogTerm" ::= zero_val uint64T;
        "Index" ::= zero_val uint64T;
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= zero_val sliceT;
        "Responses" ::= zero_val sliceT
      }]) in
      ((method_call raft' "Step" #()) (![ptrT] "r")) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ #interface.nil
      then
        do:  (let: "$a0" := #"error occurred during checking sending heartbeat: %v"%go in
        let: "$a1" := ((let: "$sl0" := (![error] "err") in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #()))
    else do:  #())).

Definition traceBecomeFollower : (go_string * go_string) := (pkg_name', "traceBecomeFollower"%go).

Definition stepFollowerGlobal : (go_string * go_string) := (pkg_name', "stepFollowerGlobal"%go).

(* go: raft.go:909:16 *)
Definition raft__becomeFollower' : val :=
  rec: "raft__becomeFollower'" "r" "term" "lead" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "lead" := (ref_ty uint64T "lead") in
    let: "term" := (ref_ty uint64T "term") in
    let: "$r0" := (![funcT] (globals.get stepFollowerGlobal #())) in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "term") in
    ((method_call raft' "reset" #()) (![ptrT] "r")) "$a0");;;
    let: "$r0" := tickElectionId in
    do:  ((struct.field_ref raft "tickId" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := (![uint64T] "lead") in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateFollower in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became follower at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    (func_call traceBecomeFollower #()) "$a0")).

Definition traceBecomeCandidate : (go_string * go_string) := (pkg_name', "traceBecomeCandidate"%go).

Definition stepCandidateGlobal : (go_string * go_string) := (pkg_name', "stepCandidateGlobal"%go).

(* go: raft.go:920:16 *)
Definition raft__becomeCandidate' : val :=
  rec: "raft__becomeCandidate'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := (interface.make string' #"invalid transition [leader -> candidate]"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (![funcT] (globals.get stepCandidateGlobal #())) in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (let: "$a0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
    ((method_call raft' "reset" #()) (![ptrT] "r")) "$a0");;;
    let: "$r0" := tickElectionId in
    do:  ((struct.field_ref raft "tickId" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateCandidate in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became candidate at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    (func_call traceBecomeCandidate #()) "$a0")).

(* go: raft.go:935:16 *)
Definition raft__becomePreCandidate' : val :=
  rec: "raft__becomePreCandidate'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := (interface.make string' #"invalid transition [leader -> pre-candidate]"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (![funcT] (globals.get stepCandidateGlobal #())) in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (((method_call tracker.ProgressTracker' "ResetVotes" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) #());;;
    let: "$r0" := tickElectionId in
    do:  ((struct.field_ref raft "tickId" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := None in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StatePreCandidate in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became pre-candidate at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")).

Definition traceBecomeLeader : (go_string * go_string) := (pkg_name', "traceBecomeLeader"%go).

Definition stepLeaderGlobal : (go_string * go_string) := (pkg_name', "stepLeaderGlobal"%go).

(* go: raft.go:951:16 *)
Definition raft__becomeLeader' : val :=
  rec: "raft__becomeLeader'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateFollower
    then
      do:  (let: "$a0" := (interface.make string' #"invalid transition [follower -> leader]"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (![funcT] (globals.get stepLeaderGlobal #())) in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
    ((method_call raft' "reset" #()) (![ptrT] "r")) "$a0");;;
    let: "$r0" := tickHeartbeatId in
    do:  ((struct.field_ref raft "tickId" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateLeader in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    do:  (((method_call tracker.Progress' "BecomeReplicate" #()) (![ptrT] "pr")) #());;;
    let: "$r0" := #true in
    do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
    let: "$r0" := (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    (func_call traceBecomeLeader #()) "$a0");;;
    let: "emptyEnt" := (ref_ty raftpb.Entry (zero_val raftpb.Entry)) in
    let: "$r0" := (let: "$Data" := #slice.nil in
    struct.make raftpb.Entry [{
      "Term" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Type" ::= zero_val raftpb.EntryType;
      "Data" ::= "$Data"
    }]) in
    do:  ("emptyEnt" <-[raftpb.Entry] "$r0");;;
    (if: (~ (let: "$a0" := ((let: "$sl0" := (![raftpb.Entry] "emptyEnt") in
    slice.literal raftpb.Entry ["$sl0"])) in
    ((method_call raft' "appendEntry" #()) (![ptrT] "r")) "$a0"))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string' #"empty entry was dropped"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panic" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #"%x became leader at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")).

(* go: raft.go:991:16 *)
Definition raft__hup' : val :=
  rec: "raft__hup'" "r" "t" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "t" := (ref_ty CampaignType "t") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := #"%x ignoring MsgHup because already leader"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (~ (((method_call raft' "promotable" #()) (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := #"%x is unpromotable and can not campaign"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: ((method_call raft' "hasUnappliedConfChanges" #()) (![ptrT] "r")) #()
    then
      do:  (let: "$a0" := #"%x cannot campaign at term %d since there are still pending configuration changes to apply"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    do:  (let: "$a0" := #"%x is starting a new election at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![CampaignType] "t") in
    ((method_call raft' "campaign" #()) (![ptrT] "r")) "$a0")).

Definition errBreak : (go_string * go_string) := (pkg_name', "errBreak"%go).

(* go: raft.go:1013:16 *)
Definition raft__hasUnappliedConfChanges' : val :=
  rec: "raft__hasUnappliedConfChanges'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) ≥ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then return: (#false)
    else do:  #());;;
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("found" <-[boolT] "$r0");;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) + #(W64 1)) in
    let: "$r1" := ((![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    let: "pageSize" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ("pageSize" <-[entryEncodingSize] "$r0");;;
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    let: "$a2" := (![entryEncodingSize] "pageSize") in
    let: "$a3" := (λ: "ents",
      exception_do (let: "ents" := (ref_ty sliceT "ents") in
      do:  (let: "$range" := (![sliceT] "ents") in
      slice.for_range raftpb.Entry "$range" (λ: "i" <>,
        let: "i" := ref_ty uint64T "i" in
        (if: ((![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "i")))) = raftpb.EntryConfChange) || ((![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "i")))) = raftpb.EntryConfChangeV2)
        then
          let: "$r0" := #true in
          do:  ("found" <-[boolT] "$r0");;;
          return: (![error] (globals.get errBreak #()))
        else do:  #())));;;
      return: (#interface.nil))
      ) in
    ((method_call raftLog' "scan" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[error] "$r0");;;
    (if: ((![error] "err") ≠ #interface.nil) && ((![error] "err") ≠ (![error] (globals.get errBreak #())))
    then
      do:  (let: "$a0" := #"error scanning unapplied entries [%d, %d): %v"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64' (![uint64T] "hi")) in
      let: "$sl2" := (![error] "err") in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #()));;;
    return: (![boolT] "found")).

Definition voteRespMsgType : (go_string * go_string) := (pkg_name', "voteRespMsgType"%go).

(* campaign transitions the raft instance to candidate state. This must only be
   called after verifying that this is a legitimate transition.

   go: raft.go:1043:16 *)
Definition raft__campaign' : val :=
  rec: "raft__campaign'" "r" "t" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "t" := (ref_ty CampaignType "t") in
    (if: (~ (((method_call raft' "promotable" #()) (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := #"%x is unpromotable; campaign() should have been called"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #());;;
    let: "term" := (ref_ty uint64T (zero_val uint64T)) in
    let: "voteMsg" := (ref_ty raftpb.MessageType (zero_val raftpb.MessageType)) in
    (if: (![CampaignType] "t") = campaignPreElection
    then
      do:  (((method_call raft' "becomePreCandidate" #()) (![ptrT] "r")) #());;;
      let: "$r0" := raftpb.MsgPreVote in
      do:  ("voteMsg" <-[raftpb.MessageType] "$r0");;;
      let: "$r0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
      do:  ("term" <-[uint64T] "$r0")
    else
      do:  (((method_call raft' "becomeCandidate" #()) (![ptrT] "r")) #());;;
      let: "$r0" := raftpb.MsgVote in
      do:  ("voteMsg" <-[raftpb.MessageType] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
      do:  ("term" <-[uint64T] "$r0"));;;
    let: "ids" := (ref_ty sliceT (zero_val sliceT)) in
    let: "idMap" := (ref_ty (mapT uint64T (structT [
    ])) (zero_val (mapT uint64T (structT [
    ])))) in
    let: "$r0" := (((method_call quorum.JointConfig' "IDs" #()) (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) #()) in
    do:  ("idMap" <-[mapT uint64T (structT [
    ])] "$r0");;;
    let: "$r0" := (slice.make3 uint64T #(W64 0) (let: "$a0" := (![mapT uint64T (structT [
    ])] "idMap") in
    map.len "$a0")) in
    do:  ("ids" <-[sliceT] "$r0");;;
    do:  (map.for_range (![mapT uint64T (structT [
    ])] "idMap") (λ: "id" <>,
      let: "$r0" := (let: "$a0" := (![sliceT] "ids") in
      let: "$a1" := ((let: "$sl0" := (![uint64T] "id") in
      slice.literal uint64T ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("ids" <-[sliceT] "$r0")));;;
    do:  (let: "$a0" := (interface.make slice' (![sliceT] "ids")) in
    let: "$a1" := (λ: "i" "j",
      exception_do (let: "j" := (ref_ty intT "j") in
      let: "i" := (ref_ty intT "i") in
      return: ((![uint64T] (slice.elem_ref uint64T (![sliceT] "ids") (![intT] "i"))) < (![uint64T] (slice.elem_ref uint64T (![sliceT] "ids") (![intT] "j")))))
      ) in
    (func_call sort.Slice #()) "$a0" "$a1");;;
    do:  (let: "$range" := (![sliceT] "ids") in
    slice.for_range uint64T "$range" (λ: <> "id",
      let: "id" := ref_ty uint64T "id" in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        do:  (let: "$a0" := (let: "$To" := (![uint64T] "id") in
        let: "$Term" := (![uint64T] "term") in
        let: "$Type" := (let: "$a0" := (![raftpb.MessageType] "voteMsg") in
        (func_call voteRespMsgType #()) "$a0") in
        struct.make raftpb.Message [{
          "Type" ::= "$Type";
          "To" ::= "$To";
          "From" ::= zero_val uint64T;
          "Term" ::= "$Term";
          "LogTerm" ::= zero_val uint64T;
          "Index" ::= zero_val uint64T;
          "Entries" ::= zero_val sliceT;
          "Commit" ::= zero_val uint64T;
          "Vote" ::= zero_val uint64T;
          "Snapshot" ::= zero_val ptrT;
          "Reject" ::= zero_val boolT;
          "RejectHint" ::= zero_val uint64T;
          "Context" ::= zero_val sliceT;
          "Responses" ::= zero_val sliceT
        }]) in
        ((method_call raft' "send" #()) (![ptrT] "r")) "$a0");;;
        continue: #()
      else do:  #());;;
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      do:  (let: "$a0" := #"%x [logterm: %d, index: %d] sent %s request to %x at term %d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "last"))) in
      let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "last"))) in
      let: "$sl3" := (interface.make raftpb.MessageType' (![raftpb.MessageType] "voteMsg")) in
      let: "$sl4" := (interface.make uint64' (![uint64T] "id")) in
      let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      let: "ctx" := (ref_ty sliceT (zero_val sliceT)) in
      (if: (![CampaignType] "t") = campaignTransfer
      then
        let: "$r0" := (string.to_bytes (![CampaignType] "t")) in
        do:  ("ctx" <-[sliceT] "$r0")
      else do:  #());;;
      do:  (let: "$a0" := (let: "$To" := (![uint64T] "id") in
      let: "$Term" := (![uint64T] "term") in
      let: "$Type" := (![raftpb.MessageType] "voteMsg") in
      let: "$Index" := (![uint64T] (struct.field_ref entryID "index" "last")) in
      let: "$LogTerm" := (![uint64T] (struct.field_ref entryID "term" "last")) in
      let: "$Context" := (![sliceT] "ctx") in
      struct.make raftpb.Message [{
        "Type" ::= "$Type";
        "To" ::= "$To";
        "From" ::= zero_val uint64T;
        "Term" ::= "$Term";
        "LogTerm" ::= "$LogTerm";
        "Index" ::= "$Index";
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= "$Context";
        "Responses" ::= zero_val sliceT
      }]) in
      ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")))).

(* returns (granted, rejected, result)

   go: raft.go:1094:16 *)
Definition raft__poll' : val :=
  rec: "raft__poll'" "r" "id" "t" "v" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "v" := (ref_ty boolT "v") in
    let: "t" := (ref_ty raftpb.MessageType "t") in
    let: "id" := (ref_ty uint64T "id") in
    (if: ![boolT] "v"
    then
      do:  (let: "$a0" := #"%x received %s from %x at term %d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.MessageType' (![raftpb.MessageType] "t")) in
      let: "$sl2" := (interface.make uint64' (![uint64T] "id")) in
      let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else
      do:  (let: "$a0" := #"%x received %s rejection from %x at term %d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.MessageType' (![raftpb.MessageType] "t")) in
      let: "$sl2" := (interface.make uint64' (![uint64T] "id")) in
      let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
    do:  (let: "$a0" := (![uint64T] "id") in
    let: "$a1" := (![boolT] "v") in
    ((method_call tracker.ProgressTracker' "RecordVote" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0" "$a1");;;
    let: (("$ret0", "$ret1"), "$ret2") := ((((method_call tracker.ProgressTracker' "TallyVotes" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) #())) in
    return: ("$ret0", "$ret1", "$ret2")).

Definition traceReceiveMessage : (go_string * go_string) := (pkg_name', "traceReceiveMessage"%go).

(* go: raft.go:1104:16 *)
Definition raft__Step' : val :=
  rec: "raft__Step'" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$a1" := "m" in
    (func_call traceReceiveMessage #()) "$a0" "$a1");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) = #(W64 0))
    then do:  #()
    else
      (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) > (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))
      then
        (if: ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)
        then
          let: "force" := (ref_ty boolT (zero_val boolT)) in
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Context" "m")) in
          let: "$a1" := (string.to_bytes campaignTransfer) in
          (func_call bytes.Equal #()) "$a0" "$a1") in
          do:  ("force" <-[boolT] "$r0");;;
          let: "inLease" := (ref_ty boolT (zero_val boolT)) in
          let: "$r0" := (((![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))) && ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None)) && (int_lt (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))))) in
          do:  ("inLease" <-[boolT] "$r0");;;
          (if: (~ (![boolT] "force")) && (![boolT] "inLease")
          then
            let: "last" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
            do:  ("last" <-[entryID] "$r0");;;
            do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "last"))) in
            let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "last"))) in
            let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
            let: "$sl4" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
            let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl6" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
            let: "$sl7" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
            let: "$sl8" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl9" := (interface.make int' ((![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) - (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            return: (#interface.nil)
          else do:  #())
        else do:  #());;;
        let: "$sw" := #true in
        (if: "$sw" = ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)
        then do:  #()
        else
          (if: "$sw" = (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp) && (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m"))))
          then do:  #()
          else
            do:  (let: "$a0" := #"%x [term: %d] received a %s message with higher term from %x [term: %d]"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
            let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            (if: (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgApp) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgHeartbeat)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgSnap)
            then
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
              let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1")
            else
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
              let: "$a1" := None in
              ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1"))))
      else
        (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) < (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))
        then
          (if: ((![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))) || (![boolT] (struct.field_ref raft "preVote" (![ptrT] "r")))) && (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgHeartbeat) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgApp))
          then
            do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            let: "$Type" := raftpb.MsgAppResp in
            struct.make raftpb.Message [{
              "Type" ::= "$Type";
              "To" ::= "$To";
              "From" ::= zero_val uint64T;
              "Term" ::= zero_val uint64T;
              "LogTerm" ::= zero_val uint64T;
              "Index" ::= zero_val uint64T;
              "Entries" ::= zero_val sliceT;
              "Commit" ::= zero_val uint64T;
              "Vote" ::= zero_val uint64T;
              "Snapshot" ::= zero_val ptrT;
              "Reject" ::= zero_val boolT;
              "RejectHint" ::= zero_val uint64T;
              "Context" ::= zero_val sliceT;
              "Responses" ::= zero_val sliceT
            }]) in
            ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
          else
            (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote
            then
              let: "last" := (ref_ty entryID (zero_val entryID)) in
              let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
              do:  ("last" <-[entryID] "$r0");;;
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d"%go in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "last"))) in
              let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "last"))) in
              let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
              let: "$sl7" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
              let: "$sl8" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              let: "$Term" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
              let: "$Type" := raftpb.MsgPreVoteResp in
              let: "$Reject" := #true in
              struct.make raftpb.Message [{
                "Type" ::= "$Type";
                "To" ::= "$To";
                "From" ::= zero_val uint64T;
                "Term" ::= "$Term";
                "LogTerm" ::= zero_val uint64T;
                "Index" ::= zero_val uint64T;
                "Entries" ::= zero_val sliceT;
                "Commit" ::= zero_val uint64T;
                "Vote" ::= zero_val uint64T;
                "Snapshot" ::= zero_val ptrT;
                "Reject" ::= "$Reject";
                "RejectHint" ::= zero_val uint64T;
                "Context" ::= zero_val sliceT;
                "Responses" ::= zero_val sliceT
              }]) in
              ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
            else
              (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgStorageAppendResp
              then
                (if: (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) ≠ #(W64 0)
                then
                  do:  (let: "$a0" := #"%x [term: %d] ignored entry appends from a %s message with lower term [term: %d]"%go in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
                  let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
                else do:  #());;;
                (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
                then
                  do:  (let: "$a0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
                  ((method_call raft' "appliedSnap" #()) (![ptrT] "r")) "$a0")
                else do:  #())
              else
                do:  (let: "$a0" := #"%x [term: %d] ignored a %s message with lower term from %x [term: %d]"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
                let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"))));;;
          return: (#interface.nil)
        else #())));;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgHup
    then
      (if: ![boolT] (struct.field_ref raft "preVote" (![ptrT] "r"))
      then
        do:  (let: "$a0" := campaignPreElection in
        ((method_call raft' "hup" #()) (![ptrT] "r")) "$a0")
      else
        do:  (let: "$a0" := campaignElection in
        ((method_call raft' "hup" #()) (![ptrT] "r")) "$a0"))
    else
      (if: "$sw" = raftpb.MsgStorageAppendResp
      then
        (if: (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) ≠ #(W64 0)
        then
          do:  (let: "$a0" := (let: "$term" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) in
          let: "$index" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
          struct.make entryID [{
            "term" ::= "$term";
            "index" ::= "$index"
          }]) in
          ((method_call raftLog' "stableTo" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
        else do:  #());;;
        (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
        then
          do:  (let: "$a0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
          ((method_call raft' "appliedSnap" #()) (![ptrT] "r")) "$a0")
        else do:  #())
      else
        (if: "$sw" = raftpb.MsgStorageApplyResp
        then
          (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.len "$a0") #(W64 0)
          then
            let: "index" := (ref_ty uint64T (zero_val uint64T)) in
            let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) ((let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
            slice.len "$a0") - #(W64 1))))) in
            do:  ("index" <-[uint64T] "$r0");;;
            do:  (let: "$a0" := (![uint64T] "index") in
            let: "$a1" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
            (func_call entsSize #()) "$a0") in
            ((method_call raft' "appliedTo" #()) (![ptrT] "r")) "$a0" "$a1");;;
            do:  (let: "$a0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
            (func_call payloadsSize #()) "$a0") in
            ((method_call raft' "reduceUncommittedSize" #()) (![ptrT] "r")) "$a0")
          else do:  #())
        else
          (if: ("$sw" = raftpb.MsgPreVote) || ("$sw" = raftpb.MsgVote)
          then
            let: "canVote" := (ref_ty boolT (zero_val boolT)) in
            let: "$r0" := ((((![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"))) = (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) || (((![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"))) = None) && ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None))) || (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote) && ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) > (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))))) in
            do:  ("canVote" <-[boolT] "$r0");;;
            let: "lastID" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
            do:  ("lastID" <-[entryID] "$r0");;;
            let: "candLastID" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := (let: "$term" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) in
            let: "$index" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
            struct.make entryID [{
              "term" ::= "$term";
              "index" ::= "$index"
            }]) in
            do:  ("candLastID" <-[entryID] "$r0");;;
            (if: (![boolT] "canVote") && (let: "$a0" := (![entryID] "candLastID") in
            ((method_call raftLog' "isUpToDate" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
            then
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] cast %s for %x [logterm: %d, index: %d] at term %d"%go in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
              let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
              let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "candLastID"))) in
              let: "$sl7" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "candLastID"))) in
              let: "$sl8" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              let: "$Term" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
              let: "$Type" := (let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
              (func_call voteRespMsgType #()) "$a0") in
              struct.make raftpb.Message [{
                "Type" ::= "$Type";
                "To" ::= "$To";
                "From" ::= zero_val uint64T;
                "Term" ::= "$Term";
                "LogTerm" ::= zero_val uint64T;
                "Index" ::= zero_val uint64T;
                "Entries" ::= zero_val sliceT;
                "Commit" ::= zero_val uint64T;
                "Vote" ::= zero_val uint64T;
                "Snapshot" ::= zero_val ptrT;
                "Reject" ::= zero_val boolT;
                "RejectHint" ::= zero_val uint64T;
                "Context" ::= zero_val sliceT;
                "Responses" ::= zero_val sliceT
              }]) in
              ((method_call raft' "send" #()) (![ptrT] "r")) "$a0");;;
              (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote
              then
                let: "$r0" := #(W64 0) in
                do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
                let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
                do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")
              else do:  #())
            else
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d"%go in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
              let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
              let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "candLastID"))) in
              let: "$sl7" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "candLastID"))) in
              let: "$sl8" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              let: "$Term" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
              let: "$Type" := (let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
              (func_call voteRespMsgType #()) "$a0") in
              let: "$Reject" := #true in
              struct.make raftpb.Message [{
                "Type" ::= "$Type";
                "To" ::= "$To";
                "From" ::= zero_val uint64T;
                "Term" ::= "$Term";
                "LogTerm" ::= zero_val uint64T;
                "Index" ::= zero_val uint64T;
                "Entries" ::= zero_val sliceT;
                "Commit" ::= zero_val uint64T;
                "Vote" ::= zero_val uint64T;
                "Snapshot" ::= zero_val ptrT;
                "Reject" ::= "$Reject";
                "RejectHint" ::= zero_val uint64T;
                "Context" ::= zero_val sliceT;
                "Responses" ::= zero_val sliceT
              }]) in
              ((method_call raft' "send" #()) (![ptrT] "r")) "$a0"))
          else
            let: "err" := (ref_ty error (zero_val error)) in
            let: "$r0" := (let: "$a0" := (![ptrT] "r") in
            let: "$a1" := (![raftpb.Message] "m") in
            (![funcT] (struct.field_ref raft "step" (![ptrT] "r"))) "$a0" "$a1") in
            do:  ("err" <-[error] "$r0");;;
            (if: (![error] "err") ≠ #interface.nil
            then return: (![error] "err")
            else do:  #())))));;;
    return: (#interface.nil)).

Definition stepFunc : go_type := funcT.

Definition stepFunc' : (go_string * go_string) := (pkg_name', "stepFunc").

Definition readIndexStatus : go_type := structT [
  "req" :: raftpb.Message;
  "index" :: uint64T;
  "acks" :: mapT uint64T boolT
].

Definition releasePendingReadIndexMessages : (go_string * go_string) := (pkg_name', "releasePendingReadIndexMessages"%go).

Definition sendMsgReadIndexResponse : (go_string * go_string) := (pkg_name', "sendMsgReadIndexResponse"%go).

Definition traceChangeConfEvent : (go_string * go_string) := (pkg_name', "traceChangeConfEvent"%go).

(* go: raft.go:1288:6 *)
Definition stepLeader' : val :=
  rec: "stepLeader'" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgBeat
    then
      do:  (((method_call raft' "bcastHeartbeat" #()) (![ptrT] "r")) #());;;
      return: (#interface.nil)
    else
      (if: "$sw" = raftpb.MsgCheckQuorum
      then
        (if: (~ (((method_call tracker.ProgressTracker' "QuorumActive" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) #()))
        then
          do:  (let: "$a0" := #"%x stepped down to follower since quorum is not active"%go in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"])) in
          (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
          let: "$a1" := None in
          ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1")
        else do:  #());;;
        do:  (let: "$a0" := (λ: "id" "pr",
          exception_do (let: "pr" := (ref_ty ptrT "pr") in
          let: "id" := (ref_ty uint64T "id") in
          (if: (![uint64T] "id") ≠ (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
          then
            let: "$r0" := #false in
            do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0")
          else do:  #()))
          ) in
        ((method_call tracker.ProgressTracker' "Visit" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
        return: (#interface.nil)
      else
        (if: "$sw" = raftpb.MsgProp
        then
          (if: (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.len "$a0") = #(W64 0)
          then
            do:  (let: "$a0" := #"%x stepped empty MsgProp"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"])) in
            (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else do:  #());;;
          (if: (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) = #null
          then return: (![error] (globals.get ErrProposalDropped #()))
          else do:  #());;;
          (if: (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ None
          then
            do:  (let: "$a0" := #"%x [term %d] transfer leadership to %x is in progress; dropping proposal"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            return: (![error] (globals.get ErrProposalDropped #()))
          else do:  #());;;
          do:  (let: "$range" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.for_range raftpb.Entry "$range" (λ: "i" <>,
            let: "i" := ref_ty uint64T "i" in
            let: "e" := (ref_ty ptrT (zero_val ptrT)) in
            let: "$r0" := (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) (![intT] "i")) in
            do:  ("e" <-[ptrT] "$r0");;;
            let: "cc" := (ref_ty raftpb.ConfChangeI (zero_val raftpb.ConfChangeI)) in
            (if: (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (![ptrT] "e"))) = raftpb.EntryConfChange
            then
              let: "ccc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
              (let: "err" := (ref_ty error (zero_val error)) in
              let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (![ptrT] "e"))) in
              ((method_call raftpb.ConfChange' "Unmarshal" #()) "ccc") "$a0") in
              do:  ("err" <-[error] "$r0");;;
              (if: (![error] "err") ≠ #interface.nil
              then
                do:  (let: "$a0" := (![error] "err") in
                Panic "$a0")
              else do:  #()));;;
              let: "$r0" := (interface.make raftpb.ConfChange' (![raftpb.ConfChange] "ccc")) in
              do:  ("cc" <-[raftpb.ConfChangeI] "$r0")
            else
              (if: (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (![ptrT] "e"))) = raftpb.EntryConfChangeV2
              then
                let: "ccc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
                (let: "err" := (ref_ty error (zero_val error)) in
                let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (![ptrT] "e"))) in
                ((method_call raftpb.ConfChangeV2' "Unmarshal" #()) "ccc") "$a0") in
                do:  ("err" <-[error] "$r0");;;
                (if: (![error] "err") ≠ #interface.nil
                then
                  do:  (let: "$a0" := (![error] "err") in
                  Panic "$a0")
                else do:  #()));;;
                let: "$r0" := (interface.make raftpb.ConfChangeV2' (![raftpb.ConfChangeV2] "ccc")) in
                do:  ("cc" <-[raftpb.ConfChangeI] "$r0")
              else do:  #()));;;
            (if: (![raftpb.ConfChangeI] "cc") ≠ #interface.nil
            then
              let: "alreadyPending" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := ((![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r"))) > (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
              do:  ("alreadyPending" <-[boolT] "$r0");;;
              let: "alreadyJoint" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := (int_gt (let: "$a0" := (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) #(W64 1))) in
              map.len "$a0") #(W64 0)) in
              do:  ("alreadyJoint" <-[boolT] "$r0");;;
              let: "wantsLeaveJoint" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := ((let: "$a0" := (struct.field_get raftpb.ConfChangeV2 "Changes" ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #())) in
              slice.len "$a0") = #(W64 0)) in
              do:  ("wantsLeaveJoint" <-[boolT] "$r0");;;
              let: "failedCheck" := (ref_ty stringT (zero_val stringT)) in
              (if: ![boolT] "alreadyPending"
              then
                let: "$r0" := (let: "$a0" := #"possible unapplied conf change at index %d (applied to %d)"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
                slice.literal interfaceT ["$sl0"; "$sl1"])) in
                (func_call fmt.Sprintf #()) "$a0" "$a1") in
                do:  ("failedCheck" <-[stringT] "$r0")
              else
                (if: (![boolT] "alreadyJoint") && (~ (![boolT] "wantsLeaveJoint"))
                then
                  let: "$r0" := #"must transition out of joint config first"%go in
                  do:  ("failedCheck" <-[stringT] "$r0")
                else
                  (if: (~ (![boolT] "alreadyJoint")) && (![boolT] "wantsLeaveJoint")
                  then
                    let: "$r0" := #"not in joint state; refusing empty conf change"%go in
                    do:  ("failedCheck" <-[stringT] "$r0")
                  else do:  #())));;;
              (if: ((![stringT] "failedCheck") ≠ #""%go) && (~ (![boolT] (struct.field_ref raft "disableConfChangeValidation" (![ptrT] "r"))))
              then
                do:  (let: "$a0" := #"%x ignoring conf change %v at config %s: %s"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (![raftpb.ConfChangeI] "cc") in
                let: "$sl2" := (interface.make tracker.Config' (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
                let: "$sl3" := (interface.make string' (![stringT] "failedCheck")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                let: "$r0" := (let: "$Type" := raftpb.EntryNormal in
                struct.make raftpb.Entry [{
                  "Term" ::= zero_val uint64T;
                  "Index" ::= zero_val uint64T;
                  "Type" ::= "$Type";
                  "Data" ::= zero_val sliceT
                }]) in
                do:  ((slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) (![intT] "i")) <-[raftpb.Entry] "$r0")
              else
                let: "$r0" := (((((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) + (![intT] "i")) + #(W64 1)) in
                do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
                do:  (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
                let: "$a1" := (![ptrT] "r") in
                (func_call traceChangeConfEvent #()) "$a0" "$a1"))
            else do:  #())));;;
          (if: (~ (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
          ((method_call raft' "appendEntry" #()) (![ptrT] "r")) "$a0"))
          then return: (![error] (globals.get ErrProposalDropped #()))
          else do:  #());;;
          do:  (((method_call raft' "bcastAppend" #()) (![ptrT] "r")) #());;;
          return: (#interface.nil)
        else
          (if: "$sw" = raftpb.MsgReadIndex
          then
            (if: ((method_call tracker.ProgressTracker' "IsSingleton" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) #()
            then
              (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
              let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
              let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
              ((method_call raft' "responseToReadIndexReq" #()) (![ptrT] "r")) "$a0" "$a1") in
              do:  ("resp" <-[raftpb.Message] "$r0");;;
              (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
              then
                do:  (let: "$a0" := (![raftpb.Message] "resp") in
                ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
              else do:  #()));;;
              return: (#interface.nil)
            else do:  #());;;
            (if: (~ (((method_call raft' "committedEntryInCurrentTerm" #()) (![ptrT] "r")) #()))
            then
              let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
              let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
              slice.literal raftpb.Message ["$sl0"])) in
              (slice.append sliceT) "$a0" "$a1") in
              do:  ((struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r")) <-[sliceT] "$r0");;;
              return: (#interface.nil)
            else do:  #());;;
            do:  (let: "$a0" := (![ptrT] "r") in
            let: "$a1" := (![raftpb.Message] "m") in
            (func_call sendMsgReadIndexResponse #()) "$a0" "$a1");;;
            return: (#interface.nil)
          else
            (if: "$sw" = raftpb.MsgForgetLeader
            then return: (#interface.nil)
            else #())))));;;
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    (if: (![ptrT] "pr") = #null
    then
      do:  (let: "$a0" := #"%x no progress available for %x"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#interface.nil)
    else do:  #());;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgAppResp
    then
      let: "$r0" := #true in
      do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
      (if: ![boolT] (struct.field_ref raftpb.Message "Reject" "m")
      then
        do:  (let: "$a0" := #"%x received MsgAppResp(rejected, hint: (index %d, term %d)) from %x for index %d"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m"))) in
        let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
        let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
        let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        let: "nextProbeIdx" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m")) in
        do:  ("nextProbeIdx" <-[uint64T] "$r0");;;
        (if: (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) > #(W64 0)
        then
          let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m")) in
          let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) in
          ((method_call raftLog' "findConflictByTerm" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("nextProbeIdx" <-[uint64T] "$r0");;;
          do:  "$r1"
        else do:  #());;;
        (if: let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
        let: "$a1" := (![uint64T] "nextProbeIdx") in
        ((method_call tracker.Progress' "MaybeDecrTo" #()) (![ptrT] "pr")) "$a0" "$a1"
        then
          do:  (let: "$a0" := #"%x decreased progress of %x to [%s]"%go in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
          let: "$sl2" := (interface.make tracker.Progress'ptr (![ptrT] "pr")) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate
          then do:  (((method_call tracker.Progress' "BecomeProbe" #()) (![ptrT] "pr")) #())
          else do:  #());;;
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          ((method_call raft' "sendAppend" #()) (![ptrT] "r")) "$a0")
        else do:  #())
      else
        (if: (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
        ((method_call tracker.Progress' "MaybeUpdate" #()) (![ptrT] "pr")) "$a0") || (((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) && ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe))
        then
          let: "$sw" := #true in
          (if: "$sw" = ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe)
          then do:  (((method_call tracker.Progress' "BecomeReplicate" #()) (![ptrT] "pr")) #())
          else
            (if: "$sw" = (((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateSnapshot) && (((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) + #(W64 1)) ≥ (((method_call raftLog' "firstIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())))
            then
              do:  (let: "$a0" := #"%x recovered from needing snapshot, resumed sending replication messages to %x [%s]"%go in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl2" := (interface.make tracker.Progress'ptr (![ptrT] "pr")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
              (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (((method_call tracker.Progress' "BecomeProbe" #()) (![ptrT] "pr")) #());;;
              do:  (((method_call tracker.Progress' "BecomeReplicate" #()) (![ptrT] "pr")) #())
            else
              (if: "$sw" = ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate)
              then
                do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
                ((method_call tracker.Inflights' "FreeLE" #()) (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) "$a0")
              else #())));;;
          (if: ((method_call raft' "maybeCommit" #()) (![ptrT] "r")) #()
          then
            do:  (let: "$a0" := (![ptrT] "r") in
            (func_call releasePendingReadIndexMessages #()) "$a0");;;
            do:  (((method_call raft' "bcastAppend" #()) (![ptrT] "r")) #())
          else
            (if: ((![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) ≠ (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) && (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
            ((method_call tracker.Progress' "CanBumpCommit" #()) (![ptrT] "pr")) "$a0")
            then
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              ((method_call raft' "sendAppend" #()) (![ptrT] "r")) "$a0")
            else do:  #()));;;
          (if: (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) ≠ (![uint64T] (struct.field_ref raftpb.Message "From" "m"))
          then
            (for: (λ: <>, let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            let: "$a1" := #false in
            ((method_call raft' "maybeSendAppend" #()) (![ptrT] "r")) "$a0" "$a1"); (λ: <>, Skip) := λ: <>,
              do:  #())
          else do:  #());;;
          (if: ((![uint64T] (struct.field_ref raftpb.Message "From" "m")) = (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) && ((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()))
          then
            do:  (let: "$a0" := #"%x sent MsgTimeoutNow to %x after received MsgAppResp"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            slice.literal interfaceT ["$sl0"; "$sl1"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            ((method_call raft' "sendTimeoutNow" #()) (![ptrT] "r")) "$a0")
          else do:  #())
        else do:  #()))
    else
      (if: "$sw" = raftpb.MsgHeartbeatResp
      then
        let: "$r0" := #true in
        do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref tracker.Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0");;;
        (if: ((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) < (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) || ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe)
        then
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          ((method_call raft' "sendAppend" #()) (![ptrT] "r")) "$a0")
        else do:  #());;;
        (if: ((![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) ≠ ReadOnlySafe) || ((let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Context" "m")) in
        slice.len "$a0") = #(W64 0))
        then return: (#interface.nil)
        else do:  #());;;
        (if: (let: "$a0" := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        let: "$a1" := (![sliceT] (struct.field_ref raftpb.Message "Context" "m")) in
        ((method_call readOnly' "recvAck" #()) (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1") in
        ((method_call quorum.JointConfig' "VoteResult" #()) (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) "$a0") ≠ quorum.VoteWon
        then return: (#interface.nil)
        else do:  #());;;
        let: "rss" := (ref_ty sliceT (zero_val sliceT)) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        ((method_call readOnly' "advance" #()) (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0") in
        do:  ("rss" <-[sliceT] "$r0");;;
        do:  (let: "$range" := (![sliceT] "rss") in
        slice.for_range ptrT "$range" (λ: <> "rs",
          let: "rs" := ref_ty ptrT "rs" in
          (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (let: "$a0" := (![raftpb.Message] (struct.field_ref readIndexStatus "req" (![ptrT] "rs"))) in
          let: "$a1" := (![uint64T] (struct.field_ref readIndexStatus "index" (![ptrT] "rs"))) in
          ((method_call raft' "responseToReadIndexReq" #()) (![ptrT] "r")) "$a0" "$a1") in
          do:  ("resp" <-[raftpb.Message] "$r0");;;
          (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
          then
            do:  (let: "$a0" := (![raftpb.Message] "resp") in
            ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
          else do:  #()))))
      else
        (if: "$sw" = raftpb.MsgSnapStatus
        then
          (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) ≠ tracker.StateSnapshot
          then return: (#interface.nil)
          else do:  #());;;
          (if: (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m")))
          then
            do:  (((method_call tracker.Progress' "BecomeProbe" #()) (![ptrT] "pr")) #());;;
            do:  (let: "$a0" := #"%x snapshot succeeded, resumed sending replication messages to %x [%s]"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress'ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            let: "$r0" := #(W64 0) in
            do:  ((struct.field_ref tracker.Progress "PendingSnapshot" (![ptrT] "pr")) <-[uint64T] "$r0");;;
            do:  (((method_call tracker.Progress' "BecomeProbe" #()) (![ptrT] "pr")) #());;;
            do:  (let: "$a0" := #"%x snapshot failed, resumed sending replication messages to %x [%s]"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress'ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
          let: "$r0" := #true in
          do:  ((struct.field_ref tracker.Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0")
        else
          (if: "$sw" = raftpb.MsgUnreachable
          then
            (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate
            then do:  (((method_call tracker.Progress' "BecomeProbe" #()) (![ptrT] "pr")) #())
            else do:  #());;;
            do:  (let: "$a0" := #"%x failed to send message to %x because it is unreachable [%s]"%go in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress'ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            (if: "$sw" = raftpb.MsgTransferLeader
            then
              (if: ![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))
              then
                do:  (let: "$a0" := #"%x is learner. Ignored transferring leadership"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (#interface.nil)
              else do:  #());;;
              let: "leadTransferee" := (ref_ty uint64T (zero_val uint64T)) in
              let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              do:  ("leadTransferee" <-[uint64T] "$r0");;;
              let: "lastLeadTransferee" := (ref_ty uint64T (zero_val uint64T)) in
              let: "$r0" := (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) in
              do:  ("lastLeadTransferee" <-[uint64T] "$r0");;;
              (if: (![uint64T] "lastLeadTransferee") ≠ None
              then
                (if: (![uint64T] "lastLeadTransferee") = (![uint64T] "leadTransferee")
                then
                  do:  (let: "$a0" := #"%x [term %d] transfer leadership to %x is in progress, ignores request to same node %x"%go in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64' (![uint64T] "leadTransferee")) in
                  let: "$sl3" := (interface.make uint64' (![uint64T] "leadTransferee")) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  return: (#interface.nil)
                else do:  #());;;
                do:  (((method_call raft' "abortLeaderTransfer" #()) (![ptrT] "r")) #());;;
                do:  (let: "$a0" := #"%x [term %d] abort previous transferring leadership to %x"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make uint64' (![uint64T] "lastLeadTransferee")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else do:  #());;;
              (if: (![uint64T] "leadTransferee") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
              then
                do:  (let: "$a0" := #"%x is already leader. Ignored transferring leadership to self"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (#interface.nil)
              else do:  #());;;
              do:  (let: "$a0" := #"%x [term %d] starts to transfer leadership to %x"%go in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              let: "$sl2" := (interface.make uint64' (![uint64T] "leadTransferee")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              let: "$r0" := #(W64 0) in
              do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
              let: "$r0" := (![uint64T] "leadTransferee") in
              do:  ((struct.field_ref raft "leadTransferee" (![ptrT] "r")) <-[uint64T] "$r0");;;
              (if: (![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())
              then
                do:  (let: "$a0" := (![uint64T] "leadTransferee") in
                ((method_call raft' "sendTimeoutNow" #()) (![ptrT] "r")) "$a0");;;
                do:  (let: "$a0" := #"%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64' (![uint64T] "leadTransferee")) in
                let: "$sl2" := (interface.make uint64' (![uint64T] "leadTransferee")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else
                do:  (let: "$a0" := (![uint64T] "leadTransferee") in
                ((method_call raft' "sendAppend" #()) (![ptrT] "r")) "$a0"))
            else #())))));;;
    return: (#interface.nil)).

Definition stepLeader : (go_string * go_string) := (pkg_name', "stepLeader"%go).

(* stepCandidate is shared by StateCandidate and StatePreCandidate; the difference is
   whether they respond to MsgVoteResp or MsgPreVoteResp.

   go: raft.go:1691:6 *)
Definition stepCandidate' : val :=
  rec: "stepCandidate'" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "myVoteRespType" := (ref_ty raftpb.MessageType (zero_val raftpb.MessageType)) in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StatePreCandidate
    then
      let: "$r0" := raftpb.MsgPreVoteResp in
      do:  ("myVoteRespType" <-[raftpb.MessageType] "$r0")
    else
      let: "$r0" := raftpb.MsgVoteResp in
      do:  ("myVoteRespType" <-[raftpb.MessageType] "$r0"));;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgProp
    then
      do:  (let: "$a0" := #"%x no leader at term %d; dropping proposal"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (![error] (globals.get ErrProposalDropped #()))
    else
      (if: "$sw" = raftpb.MsgApp
      then
        do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
        let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1");;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        ((method_call raft' "handleAppendEntries" #()) (![ptrT] "r")) "$a0")
      else
        (if: "$sw" = raftpb.MsgHeartbeat
        then
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
          let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1");;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          ((method_call raft' "handleHeartbeat" #()) (![ptrT] "r")) "$a0")
        else
          (if: "$sw" = raftpb.MsgSnap
          then
            do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
            let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1");;;
            do:  (let: "$a0" := (![raftpb.Message] "m") in
            ((method_call raft' "handleSnapshot" #()) (![ptrT] "r")) "$a0")
          else
            (if: "$sw" = (![raftpb.MessageType] "myVoteRespType")
            then
              let: "res" := (ref_ty quorum.VoteResult (zero_val quorum.VoteResult)) in
              let: "rj" := (ref_ty intT (zero_val intT)) in
              let: "gr" := (ref_ty intT (zero_val intT)) in
              let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              let: "$a1" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
              let: "$a2" := (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m"))) in
              ((method_call raft' "poll" #()) (![ptrT] "r")) "$a0" "$a1" "$a2") in
              let: "$r0" := "$ret0" in
              let: "$r1" := "$ret1" in
              let: "$r2" := "$ret2" in
              do:  ("gr" <-[intT] "$r0");;;
              do:  ("rj" <-[intT] "$r1");;;
              do:  ("res" <-[quorum.VoteResult] "$r2");;;
              do:  (let: "$a0" := #"%x has received %d %s votes and %d vote rejections"%go in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make int' (![intT] "gr")) in
              let: "$sl2" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl3" := (interface.make int' (![intT] "rj")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              let: "$sw" := (![quorum.VoteResult] "res") in
              (if: "$sw" = quorum.VoteWon
              then
                (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StatePreCandidate
                then
                  do:  (let: "$a0" := campaignElection in
                  ((method_call raft' "campaign" #()) (![ptrT] "r")) "$a0")
                else
                  do:  (((method_call raft' "becomeLeader" #()) (![ptrT] "r")) #());;;
                  do:  (((method_call raft' "bcastAppend" #()) (![ptrT] "r")) #()))
              else
                (if: "$sw" = quorum.VoteLost
                then
                  do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
                  let: "$a1" := None in
                  ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1")
                else #()))
            else
              (if: "$sw" = raftpb.MsgTimeoutNow
              then
                do:  (let: "$a0" := #"%x [term %d state %v] ignored MsgTimeoutNow from %x"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make StateType' (![StateType] (struct.field_ref raft "state" (![ptrT] "r")))) in
                let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else #()))))));;;
    return: (#interface.nil)).

Definition stepCandidate : (go_string * go_string) := (pkg_name', "stepCandidate"%go).

(* go: raft.go:1738:6 *)
Definition stepFollower' : val :=
  rec: "stepFollower'" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgProp
    then
      (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
      then
        do:  (let: "$a0" := #"%x no leader at term %d; dropping proposal"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        return: (![error] (globals.get ErrProposalDropped #()))
      else
        (if: ![boolT] (struct.field_ref raft "disableProposalForwarding" (![ptrT] "r"))
        then
          do:  (let: "$a0" := #"%x not forwarding to leader %x at term %d; dropping proposal"%go in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
          let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          return: (![error] (globals.get ErrProposalDropped #()))
        else do:  #()));;;
      let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
      do:  (let: "$a0" := (![raftpb.Message] "m") in
      ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
    else
      (if: "$sw" = raftpb.MsgApp
      then
        let: "$r0" := #(W64 0) in
        do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
        let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        ((method_call raft' "handleAppendEntries" #()) (![ptrT] "r")) "$a0")
      else
        (if: "$sw" = raftpb.MsgHeartbeat
        then
          let: "$r0" := #(W64 0) in
          do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          ((method_call raft' "handleHeartbeat" #()) (![ptrT] "r")) "$a0")
        else
          (if: "$sw" = raftpb.MsgSnap
          then
            let: "$r0" := #(W64 0) in
            do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
            let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
            do:  (let: "$a0" := (![raftpb.Message] "m") in
            ((method_call raft' "handleSnapshot" #()) (![ptrT] "r")) "$a0")
          else
            (if: "$sw" = raftpb.MsgTransferLeader
            then
              (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
              then
                do:  (let: "$a0" := #"%x no leader at term %d; dropping leader transfer msg"%go in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"; "$sl1"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (#interface.nil)
              else do:  #());;;
              let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
              do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
              do:  (let: "$a0" := (![raftpb.Message] "m") in
              ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
            else
              (if: "$sw" = raftpb.MsgForgetLeader
              then
                (if: (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) = ReadOnlyLeaseBased
                then
                  do:  (let: "$a0" := ((let: "$sl0" := (interface.make string' #"ignoring MsgForgetLeader due to ReadOnlyLeaseBased"%go) in
                  slice.literal interfaceT ["$sl0"])) in
                  (interface.get "Error" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0");;;
                  return: (#interface.nil)
                else do:  #());;;
                (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None
                then
                  do:  (let: "$a0" := #"%x forgetting leader %x at term %d"%go in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  let: "$r0" := None in
                  do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0")
                else do:  #())
              else
                (if: "$sw" = raftpb.MsgTimeoutNow
                then
                  do:  (let: "$a0" := #"%x [term %d] received MsgTimeoutNow from %x and starts an election to get leadership."%go in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  do:  (let: "$a0" := campaignTransfer in
                  ((method_call raft' "hup" #()) (![ptrT] "r")) "$a0")
                else
                  (if: "$sw" = raftpb.MsgReadIndex
                  then
                    (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
                    then
                      do:  (let: "$a0" := #"%x no leader at term %d; dropping index reading msg"%go in
                      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                      slice.literal interfaceT ["$sl0"; "$sl1"])) in
                      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                      return: (#interface.nil)
                    else do:  #());;;
                    let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
                    do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
                    do:  (let: "$a0" := (![raftpb.Message] "m") in
                    ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
                  else
                    (if: "$sw" = raftpb.MsgReadIndexResp
                    then
                      (if: (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
                      slice.len "$a0") ≠ #(W64 1)
                      then
                        do:  (let: "$a0" := #"%x invalid format of MsgReadIndexResp from %x, entries count: %d"%go in
                        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                        let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                        let: "$sl2" := (interface.make int' (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
                        slice.len "$a0")) in
                        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                        (interface.get "Errorf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                        return: (#interface.nil)
                      else do:  #());;;
                      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
                      let: "$a1" := ((let: "$sl0" := (let: "$Index" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
                      let: "$RequestCtx" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))) in
                      struct.make ReadState [{
                        "Index" ::= "$Index";
                        "RequestCtx" ::= "$RequestCtx"
                      }]) in
                      slice.literal ReadState ["$sl0"])) in
                      (slice.append sliceT) "$a0" "$a1") in
                      do:  ((struct.field_ref raft "readStates" (![ptrT] "r")) <-[sliceT] "$r0")
                    else #())))))))));;;
    return: (#interface.nil)).

Definition stepFollower : (go_string * go_string) := (pkg_name', "stepFollower"%go).

(* logSliceFromMsgApp extracts the appended logSlice from a MsgApp message.

   go: raft.go:1802:6 *)
Definition logSliceFromMsgApp' : val :=
  rec: "logSliceFromMsgApp'" "m" :=
    exception_do (let: "m" := (ref_ty ptrT "m") in
    return: (let: "$term" := (![uint64T] (struct.field_ref raftpb.Message "Term" (![ptrT] "m"))) in
     let: "$prev" := (let: "$term" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" (![ptrT] "m"))) in
     let: "$index" := (![uint64T] (struct.field_ref raftpb.Message "Index" (![ptrT] "m"))) in
     struct.make entryID [{
       "term" ::= "$term";
       "index" ::= "$index"
     }]) in
     let: "$entries" := (![sliceT] (struct.field_ref raftpb.Message "Entries" (![ptrT] "m"))) in
     struct.make logSlice [{
       "term" ::= "$term";
       "prev" ::= "$prev";
       "entries" ::= "$entries"
     }])).

Definition logSliceFromMsgApp : (go_string * go_string) := (pkg_name', "logSliceFromMsgApp"%go).

(* go: raft.go:1811:16 *)
Definition raft__handleAppendEntries' : val :=
  rec: "raft__handleAppendEntries'" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "a" := (ref_ty logSlice (zero_val logSlice)) in
    let: "$r0" := (let: "$a0" := "m" in
    (func_call logSliceFromMsgApp #()) "$a0") in
    do:  ("a" <-[logSlice] "$r0");;;
    (if: (![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then
      do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
      let: "$Type" := raftpb.MsgAppResp in
      let: "$Index" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
      struct.make raftpb.Message [{
        "Type" ::= "$Type";
        "To" ::= "$To";
        "From" ::= zero_val uint64T;
        "Term" ::= zero_val uint64T;
        "LogTerm" ::= zero_val uint64T;
        "Index" ::= "$Index";
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= zero_val sliceT;
        "Responses" ::= zero_val sliceT
      }]) in
      ((method_call raft' "send" #()) (![ptrT] "r")) "$a0");;;
      return: (#())
    else do:  #());;;
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "mlastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![logSlice] "a") in
    let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) in
    ((method_call raftLog' "maybeAppend" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("mlastIndex" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
      let: "$Type" := raftpb.MsgAppResp in
      let: "$Index" := (![uint64T] "mlastIndex") in
      struct.make raftpb.Message [{
        "Type" ::= "$Type";
        "To" ::= "$To";
        "From" ::= zero_val uint64T;
        "Term" ::= zero_val uint64T;
        "LogTerm" ::= zero_val uint64T;
        "Index" ::= "$Index";
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= zero_val sliceT;
        "Responses" ::= zero_val sliceT
      }]) in
      ((method_call raft' "send" #()) (![ptrT] "r")) "$a0");;;
      return: (#())
    else do:  #()));;;
    do:  (let: "$a0" := #"%x [logterm: %d, index: %d] rejected MsgApp [logterm: %d, index: %d] from %x"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
    ((method_call raftLog' "term" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    ((method_call raftLog' "zeroTermOnOutOfBounds" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1")) in
    let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
    let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    let: "hintIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
    let: "$a1" := (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("hintIndex" <-[uint64T] "$r0");;;
    let: "hintTerm" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "hintIndex") in
    let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) in
    ((method_call raftLog' "findConflictByTerm" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("hintIndex" <-[uint64T] "$r0");;;
    do:  ("hintTerm" <-[uint64T] "$r1");;;
    do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    let: "$Type" := raftpb.MsgAppResp in
    let: "$Index" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
    let: "$Reject" := #true in
    let: "$RejectHint" := (![uint64T] "hintIndex") in
    let: "$LogTerm" := (![uint64T] "hintTerm") in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= zero_val uint64T;
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= "$LogTerm";
      "Index" ::= "$Index";
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= "$Reject";
      "RejectHint" ::= "$RejectHint";
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")).

(* go: raft.go:1855:16 *)
Definition raft__handleHeartbeat' : val :=
  rec: "raft__handleHeartbeat'" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) in
    ((method_call raftLog' "commitTo" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    let: "$Type" := raftpb.MsgHeartbeatResp in
    let: "$Context" := (![sliceT] (struct.field_ref raftpb.Message "Context" "m")) in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= zero_val uint64T;
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= "$Context";
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")).

(* go: raft.go:1860:16 *)
Definition raft__handleSnapshot' : val :=
  rec: "raft__handleSnapshot'" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "s" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
    (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
    then
      let: "$r0" := (![raftpb.Snapshot] (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m"))) in
      do:  ("s" <-[raftpb.Snapshot] "$r0")
    else do:  #());;;
    let: "sterm" := (ref_ty uint64T (zero_val uint64T)) in
    let: "sindex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    let: "$r1" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ("sindex" <-[uint64T] "$r0");;;
    do:  ("sterm" <-[uint64T] "$r1");;;
    (if: let: "$a0" := (![raftpb.Snapshot] "s") in
    ((method_call raft' "restore" #()) (![ptrT] "r")) "$a0"
    then
      do:  (let: "$a0" := #"%x [commit: %d] restored snapshot [index: %d, term: %d]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64' (![uint64T] "sindex")) in
      let: "$sl3" := (interface.make uint64' (![uint64T] "sterm")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
      let: "$Type" := raftpb.MsgAppResp in
      let: "$Index" := (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      struct.make raftpb.Message [{
        "Type" ::= "$Type";
        "To" ::= "$To";
        "From" ::= zero_val uint64T;
        "Term" ::= zero_val uint64T;
        "LogTerm" ::= zero_val uint64T;
        "Index" ::= "$Index";
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= zero_val sliceT;
        "Responses" ::= zero_val sliceT
      }]) in
      ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
    else
      do:  (let: "$a0" := #"%x [commit: %d] ignored snapshot [index: %d, term: %d]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64' (![uint64T] "sindex")) in
      let: "$sl3" := (interface.make uint64' (![uint64T] "sterm")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
      let: "$Type" := raftpb.MsgAppResp in
      let: "$Index" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
      struct.make raftpb.Message [{
        "Type" ::= "$Type";
        "To" ::= "$To";
        "From" ::= zero_val uint64T;
        "Term" ::= zero_val uint64T;
        "LogTerm" ::= zero_val uint64T;
        "Index" ::= "$Index";
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= zero_val sliceT;
        "Responses" ::= zero_val sliceT
      }]) in
      ((method_call raft' "send" #()) (![ptrT] "r")) "$a0"))).

(* restore recovers the state machine from a snapshot. It restores the log and the
   configuration of state machine. If this method returns false, the snapshot was
   ignored, either because it was obsolete or because of an error.

   go: raft.go:1882:16 *)
Definition raft__restore' : val :=
  rec: "raft__restore'" "r" "s" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    (if: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) ≤ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then return: (#false)
    else do:  #());;;
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateFollower
    then
      do:  (let: "$a0" := #"%x attempted to restore snapshot as leader; should never happen"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
      let: "$a1" := None in
      ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("found" <-[boolT] "$r0");;;
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := (![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    do:  (let: "$range" := ((let: "$sl0" := (![sliceT] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
    let: "$sl1" := (![sliceT] (struct.field_ref raftpb.ConfState "Learners" "cs")) in
    let: "$sl2" := (![sliceT] (struct.field_ref raftpb.ConfState "VotersOutgoing" "cs")) in
    slice.literal sliceT ["$sl0"; "$sl1"; "$sl2"])) in
    slice.for_range sliceT "$range" (λ: <> "set",
      let: "set" := ref_ty sliceT "set" in
      do:  (let: "$range" := (![sliceT] "set") in
      slice.for_range uint64T "$range" (λ: <> "id",
        let: "id" := ref_ty uint64T "id" in
        (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then
          let: "$r0" := #true in
          do:  ("found" <-[boolT] "$r0");;;
          break: #()
        else do:  #())));;;
      (if: ![boolT] "found"
      then break: #()
      else do:  #())));;;
    (if: (~ (![boolT] "found"))
    then
      do:  (let: "$a0" := #"%x attempted to restore snapshot but it is not in the ConfState %v; should never happen"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.ConfState' (![raftpb.ConfState] "cs")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "id" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (let: "$term" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    let: "$index" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    struct.make entryID [{
      "term" ::= "$term";
      "index" ::= "$index"
    }]) in
    do:  ("id" <-[entryID] "$r0");;;
    (if: let: "$a0" := (![entryID] "id") in
    ((method_call raftLog' "matchTerm" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0"
    then
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      do:  (let: "$a0" := #"%x [commit: %d, lastindex: %d, lastterm: %d] fast-forwarded commit to snapshot [index: %d, term: %d]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "last"))) in
      let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "last"))) in
      let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "id"))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
      ((method_call raftLog' "commitTo" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
      return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![raftpb.Snapshot] "s") in
    ((method_call raftLog' "restore" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    let: "$r0" := (let: "$a0" := (![intT] (struct.field_ref tracker.ProgressTracker "MaxInflight" (struct.field_ref raft "trk" (![ptrT] "r")))) in
    let: "$a1" := (![uint64T] (struct.field_ref tracker.ProgressTracker "MaxInflightBytes" (struct.field_ref raft "trk" (![ptrT] "r")))) in
    (func_call tracker.MakeProgressTracker #()) "$a0" "$a1") in
    do:  ((struct.field_ref raft "trk" (![ptrT] "r")) <-[tracker.ProgressTracker] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (let: "$Tracker" := (![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"))) in
    let: "$LastIndex" := (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    struct.make confchange.Changer [{
      "Tracker" ::= "$Tracker";
      "LastIndex" ::= "$LastIndex"
    }]) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    (func_call confchange.Restore #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (interface.make string' (let: "$a0" := #"unable to restore config %+v: %s"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make raftpb.ConfState' (![raftpb.ConfState] "cs")) in
      let: "$sl1" := (![error] "err") in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (func_call fmt.Sprintf #()) "$a0" "$a1")) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![Logger] (struct.field_ref raft "logger" (![ptrT] "r"))) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    let: "$a2" := (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![tracker.ProgressMap] "trk") in
    ((method_call raft' "switchToConfig" #()) (![ptrT] "r")) "$a0" "$a1") in
    (func_call assertConfStatesEquivalent #()) "$a0" "$a1" "$a2");;;
    let: "last" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("last" <-[entryID] "$r0");;;
    do:  (let: "$a0" := #"%x [commit: %d, lastindex: %d, lastterm: %d] restored snapshot [index: %d, term: %d]"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "last"))) in
    let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "last"))) in
    let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "index" "id"))) in
    let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref entryID "term" "id"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    return: (#true)).

(* promotable indicates whether state machine can be promoted to leader,
   which is true when its own id is in progress list.

   go: raft.go:1967:16 *)
Definition raft__promotable' : val :=
  rec: "raft__promotable'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    return: ((((![ptrT] "pr") ≠ #null) && (~ (![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))))) && (~ (((method_call raftLog' "hasNextOrInProgressSnapshot" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())))).

(* go: raft.go:1972:16 *)
Definition raft__applyConfChange' : val :=
  rec: "raft__applyConfChange'" "r" "cc" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "cc" := (ref_ty raftpb.ConfChangeV2 "cc") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((λ: <>,
      exception_do (let: "changer" := (ref_ty confchange.Changer (zero_val confchange.Changer)) in
      let: "$r0" := (let: "$Tracker" := (![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"))) in
      let: "$LastIndex" := (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      struct.make confchange.Changer [{
        "Tracker" ::= "$Tracker";
        "LastIndex" ::= "$LastIndex"
      }]) in
      do:  ("changer" <-[confchange.Changer] "$r0");;;
      (if: ((method_call raftpb.ConfChangeV2' "LeaveJoint" #()) (![raftpb.ConfChangeV2] "cc")) #()
      then
        let: (("$ret0", "$ret1"), "$ret2") := ((((method_call confchange.Changer' "LeaveJoint" #()) (![confchange.Changer] "changer")) #())) in
        return: ("$ret0", "$ret1", "$ret2")
      else
        (let: "ok" := (ref_ty boolT (zero_val boolT)) in
        let: "autoLeave" := (ref_ty boolT (zero_val boolT)) in
        let: ("$ret0", "$ret1") := (((method_call raftpb.ConfChangeV2' "EnterJoint" #()) (![raftpb.ConfChangeV2] "cc")) #()) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("autoLeave" <-[boolT] "$r0");;;
        do:  ("ok" <-[boolT] "$r1");;;
        (if: ![boolT] "ok"
        then
          let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![boolT] "autoLeave") in
          let: "$a1" := (![sliceT] (struct.field_ref raftpb.ConfChangeV2 "Changes" "cc")) in
          ((method_call confchange.Changer' "EnterJoint" #()) (![confchange.Changer] "changer")) "$a0" "$a1")) in
          return: ("$ret0", "$ret1", "$ret2")
        else do:  #())));;;
      let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![sliceT] (struct.field_ref raftpb.ConfChangeV2 "Changes" "cc")) in
      ((method_call confchange.Changer' "Simple" #()) (![confchange.Changer] "changer")) "$a0")) in
      return: ("$ret0", "$ret1", "$ret2"))
      ) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    return: (let: "$a0" := (![tracker.Config] "cfg") in
     let: "$a1" := (![tracker.ProgressMap] "trk") in
     ((method_call raft' "switchToConfig" #()) (![ptrT] "r")) "$a0" "$a1")).

Definition traceConfChangeEvent : (go_string * go_string) := (pkg_name', "traceConfChangeEvent"%go).

(* switchToConfig reconfigures this node to use the provided configuration. It
   updates the in-memory state and, when necessary, carries out additional
   actions such as reacting to the removal of nodes or changed quorum
   requirements.

   The inputs usually result from restoring a ConfState or applying a ConfChange.

   go: raft.go:2000:16 *)
Definition raft__switchToConfig' : val :=
  rec: "raft__switchToConfig'" "r" "cfg" "trk" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "trk" := (ref_ty tracker.ProgressMap "trk") in
    let: "cfg" := (ref_ty tracker.Config "cfg") in
    do:  (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![ptrT] "r") in
    (func_call traceConfChangeEvent #()) "$a0" "$a1");;;
    let: "$r0" := (![tracker.Config] "cfg") in
    do:  ((struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))) <-[tracker.Config] "$r0");;;
    let: "$r0" := (![tracker.ProgressMap] "trk") in
    do:  ((struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r"))) <-[tracker.ProgressMap] "$r0");;;
    do:  (let: "$a0" := #"%x switched to configuration %s"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make tracker.Config' (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := (((method_call tracker.ProgressTracker' "ConfState" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) #()) in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pr" <-[ptrT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    let: "$r0" := ((![boolT] "ok") && (![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr")))) in
    do:  ((struct.field_ref raft "isLearner" (![ptrT] "r")) <-[boolT] "$r0");;;
    (if: ((~ (![boolT] "ok")) || (![boolT] (struct.field_ref raft "isLearner" (![ptrT] "r")))) && ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader)
    then
      (if: ![boolT] (struct.field_ref raft "stepDownOnRemoval" (![ptrT] "r"))
      then
        do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
        let: "$a1" := None in
        ((method_call raft' "becomeFollower" #()) (![ptrT] "r")) "$a0" "$a1")
      else do:  #());;;
      return: (![raftpb.ConfState] "cs")
    else do:  #());;;
    (if: ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateLeader) || ((let: "$a0" := (![sliceT] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
    slice.len "$a0") = #(W64 0))
    then return: (![raftpb.ConfState] "cs")
    else do:  #());;;
    (if: ((method_call raft' "maybeCommit" #()) (![ptrT] "r")) #()
    then do:  (((method_call raft' "bcastAppend" #()) (![ptrT] "r")) #())
    else
      do:  (let: "$a0" := (λ: "id" <>,
        exception_do (let: <> := (ref_ty ptrT "_") in
        let: "id" := (ref_ty uint64T "id") in
        (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then return: (#())
        else do:  #());;;
        do:  (let: "$a0" := (![uint64T] "id") in
        let: "$a1" := #false in
        ((method_call raft' "maybeSendAppend" #()) (![ptrT] "r")) "$a0" "$a1"))
        ) in
      ((method_call tracker.ProgressTracker' "Visit" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0"));;;
    (let: "tOK" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (map.get (((method_call quorum.JointConfig' "IDs" #()) (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) #()) (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("tOK" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "tOK")) && ((![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ #(W64 0))
    then do:  (((method_call raft' "abortLeaderTransfer" #()) (![ptrT] "r")) #())
    else do:  #()));;;
    return: (![raftpb.ConfState] "cs")).

(* go: raft.go:2058:16 *)
Definition raft__loadState' : val :=
  rec: "raft__loadState'" "r" "state" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "state" := (ref_ty raftpb.HardState "state") in
    (if: ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) || ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) > (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()))
    then
      do:  (let: "$a0" := #"%x state.commit %d is out of range [%d, %d]"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.HardState "Commit" "state"))) in
      let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl3" := (interface.make uint64' (((method_call raftLog' "lastIndex" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Term" "state")) in
    do:  ((struct.field_ref raft "Term" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Vote" "state")) in
    do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")).

(* pastElectionTimeout returns true if r.electionElapsed is greater
   than or equal to the randomized election timeout in
   [electiontimeout, 2 * electiontimeout - 1].

   go: raft.go:2070:16 *)
Definition raft__pastElectionTimeout' : val :=
  rec: "raft__pastElectionTimeout'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (int_geq (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "randomizedElectionTimeout" (![ptrT] "r"))))).

(* go: raft.go:2074:16 *)
Definition raft__resetRandomizedElectionTimeout' : val :=
  rec: "raft__resetRandomizedElectionTimeout'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "$r0" := ((![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) + (let: "$a0" := (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) in
    ((method_call lockedRand' "Intn" #()) (![ptrT] (globals.get globalRand #()))) "$a0")) in
    do:  ((struct.field_ref raft "randomizedElectionTimeout" (![ptrT] "r")) <-[intT] "$r0")).

(* go: raft.go:2078:16 *)
Definition raft__sendTimeoutNow' : val :=
  rec: "raft__sendTimeoutNow'" "r" "to" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "to" := (ref_ty uint64T "to") in
    do:  (let: "$a0" := (let: "$To" := (![uint64T] "to") in
    let: "$Type" := raftpb.MsgTimeoutNow in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= zero_val uint64T;
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")).

(* go: raft.go:2082:16 *)
Definition raft__abortLeaderTransfer' : val :=
  rec: "raft__abortLeaderTransfer'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "$r0" := None in
    do:  ((struct.field_ref raft "leadTransferee" (![ptrT] "r")) <-[uint64T] "$r0")).

(* committedEntryInCurrentTerm return true if the peer has committed an entry in its term.

   go: raft.go:2087:16 *)
Definition raft__committedEntryInCurrentTerm' : val :=
  rec: "raft__committedEntryInCurrentTerm'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: ((let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
     ((method_call raftLog' "term" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")) in
     let: "$a0" := "$ret0" in
     let: "$a1" := "$ret1" in
     ((method_call raftLog' "zeroTermOnOutOfBounds" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") = (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))).

(* responseToReadIndexReq constructs a response for `req`. If `req` comes from the peer
   itself, a blank value will be returned.

   go: raft.go:2095:16 *)
Definition raft__responseToReadIndexReq' : val :=
  rec: "raft__responseToReadIndexReq'" "r" "req" "readIndex" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "readIndex" := (ref_ty uint64T "readIndex") in
    let: "req" := (ref_ty raftpb.Message "req") in
    (if: ((![uint64T] (struct.field_ref raftpb.Message "From" "req")) = None) || ((![uint64T] (struct.field_ref raftpb.Message "From" "req")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (let: "$Index" := (![uint64T] "readIndex") in
      let: "$RequestCtx" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "req")) #(W64 0)))) in
      struct.make ReadState [{
        "Index" ::= "$Index";
        "RequestCtx" ::= "$RequestCtx"
      }]) in
      slice.literal ReadState ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref raft "readStates" (![ptrT] "r")) <-[sliceT] "$r0");;;
      return: (struct.make raftpb.Message [{
         "Type" ::= zero_val raftpb.MessageType;
         "To" ::= zero_val uint64T;
         "From" ::= zero_val uint64T;
         "Term" ::= zero_val uint64T;
         "LogTerm" ::= zero_val uint64T;
         "Index" ::= zero_val uint64T;
         "Entries" ::= zero_val sliceT;
         "Commit" ::= zero_val uint64T;
         "Vote" ::= zero_val uint64T;
         "Snapshot" ::= zero_val ptrT;
         "Reject" ::= zero_val boolT;
         "RejectHint" ::= zero_val uint64T;
         "Context" ::= zero_val sliceT;
         "Responses" ::= zero_val sliceT
       }])
    else do:  #());;;
    return: (let: "$Type" := raftpb.MsgReadIndexResp in
     let: "$To" := (![uint64T] (struct.field_ref raftpb.Message "From" "req")) in
     let: "$Index" := (![uint64T] "readIndex") in
     let: "$Entries" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "req")) in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= "$To";
       "From" ::= zero_val uint64T;
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= "$Index";
       "Entries" ::= "$Entries";
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }])).

(* increaseUncommittedSize computes the size of the proposed entries and
   determines whether they would push leader over its maxUncommittedSize limit.
   If the new entries would exceed the limit, the method returns false. If not,
   the increase in uncommitted entry size is recorded and the method returns
   true.

   Empty payloads are never refused. This is used both for appending an empty
   entry at a new leader's term, as well as leaving a joint configuration.

   go: raft.go:2119:16 *)
Definition raft__increaseUncommittedSize' : val :=
  rec: "raft__increaseUncommittedSize'" "r" "ents" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ents" := (ref_ty sliceT "ents") in
    let: "s" := (ref_ty entryPayloadSize (zero_val entryPayloadSize)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
    (func_call payloadsSize #()) "$a0") in
    do:  ("s" <-[entryPayloadSize] "$r0");;;
    (if: (((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) > #(W64 0)) && ((![entryPayloadSize] "s") > #(W64 0))) && (((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) + (![entryPayloadSize] "s")) > (![entryPayloadSize] (struct.field_ref raft "maxUncommittedSize" (![ptrT] "r"))))
    then return: (#false)
    else do:  #());;;
    do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] ((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) + (![entryPayloadSize] "s")));;;
    return: (#true)).

(* reduceUncommittedSize accounts for the newly committed entries by decreasing
   the uncommitted entry size limit.

   go: raft.go:2137:16 *)
Definition raft__reduceUncommittedSize' : val :=
  rec: "raft__reduceUncommittedSize'" "r" "s" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty entryPayloadSize "s") in
    (if: (![entryPayloadSize] "s") > (![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] "$r0")
    else do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] ((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) - (![entryPayloadSize] "s"))))).

(* go: raft.go:2148:6 *)
Definition releasePendingReadIndexMessages' : val :=
  rec: "releasePendingReadIndexMessages'" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (let: "$a0" := (![sliceT] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    (if: (~ (((method_call raft' "committedEntryInCurrentTerm" #()) (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string' #"pending MsgReadIndex should be released only after first commit in current term"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Error" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0");;;
      return: (#())
    else do:  #());;;
    let: "msgs" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
    do:  ("msgs" <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r")) <-[sliceT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "msgs") in
    slice.for_range raftpb.Message "$range" (λ: <> "m",
      let: "m" := ref_ty raftpb.Message "m" in
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![raftpb.Message] "m") in
      (func_call sendMsgReadIndexResponse #()) "$a0" "$a1")))).

(* go: raft.go:2167:6 *)
Definition sendMsgReadIndexResponse' : val :=
  rec: "sendMsgReadIndexResponse'" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) in
    (if: "$sw" = ReadOnlySafe
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
      let: "$a1" := (![raftpb.Message] "m") in
      ((method_call readOnly' "addRequest" #()) (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
      let: "$a1" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))) in
      ((method_call readOnly' "recvAck" #()) (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))) in
      ((method_call raft' "bcastHeartbeatWithCtx" #()) (![ptrT] "r")) "$a0")
    else
      (if: "$sw" = ReadOnlyLeaseBased
      then
        (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
        ((method_call raft' "responseToReadIndexReq" #()) (![ptrT] "r")) "$a0" "$a1") in
        do:  ("resp" <-[raftpb.Message] "$r0");;;
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
        then
          do:  (let: "$a0" := (![raftpb.Message] "resp") in
          ((method_call raft' "send" #()) (![ptrT] "r")) "$a0")
        else do:  #()))
      else #()))).

(* go: raft2.go:10:6 *)
Definition newTestConfig' : val :=
  rec: "newTestConfig'" "id" "election" "heartbeat" "storage" :=
    exception_do (let: "storage" := (ref_ty Storage "storage") in
    let: "heartbeat" := (ref_ty intT "heartbeat") in
    let: "election" := (ref_ty intT "election") in
    let: "id" := (ref_ty uint64T "id") in
    return: (ref_ty Config (let: "$ID" := (![uint64T] "id") in
     let: "$ElectionTick" := (![intT] "election") in
     let: "$HeartbeatTick" := (![intT] "heartbeat") in
     let: "$Storage" := (![Storage] "storage") in
     let: "$MaxSizePerMsg" := #(W64 noLimit) in
     let: "$MaxInflightMsgs" := #(W64 256) in
     struct.make Config [{
       "ID" ::= "$ID";
       "ElectionTick" ::= "$ElectionTick";
       "HeartbeatTick" ::= "$HeartbeatTick";
       "Storage" ::= "$Storage";
       "Applied" ::= zero_val uint64T;
       "AsyncStorageWrites" ::= zero_val boolT;
       "MaxSizePerMsg" ::= "$MaxSizePerMsg";
       "MaxCommittedSizePerReady" ::= zero_val uint64T;
       "MaxUncommittedEntriesSize" ::= zero_val uint64T;
       "MaxInflightMsgs" ::= "$MaxInflightMsgs";
       "MaxInflightBytes" ::= zero_val uint64T;
       "CheckQuorum" ::= zero_val boolT;
       "PreVote" ::= zero_val boolT;
       "ReadOnlyOption" ::= zero_val ReadOnlyOption;
       "Logger" ::= zero_val Logger;
       "DisableProposalForwarding" ::= zero_val boolT;
       "DisableConfChangeValidation" ::= zero_val boolT;
       "StepDownOnRemoval" ::= zero_val boolT;
       "TraceLogger" ::= zero_val TraceLogger
     }]))).

Definition newTestConfig : (go_string * go_string) := (pkg_name', "newTestConfig"%go).

Definition MemoryStorage' : (go_string * go_string) := (pkg_name', "MemoryStorage").

Definition NewMemoryStorage : (go_string * go_string) := (pkg_name', "NewMemoryStorage"%go).

(* go: raft2.go:21:6 *)
Definition entsWithConfig' : val :=
  rec: "entsWithConfig'" "configFunc" "terms" :=
    exception_do (let: "terms" := (ref_ty sliceT "terms") in
    let: "configFunc" := (ref_ty funcT "configFunc") in
    let: "storage" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := ((func_call NewMemoryStorage #()) #()) in
    do:  ("storage" <-[ptrT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "terms") in
    slice.for_range uint64T "$range" (λ: "i" "term",
      let: "i" := ref_ty uint64T "i" in
      let: "term" := ref_ty uint64T "term" in
      do:  (let: "$a0" := ((let: "$sl0" := (let: "$Index" := ((![intT] "i") + #(W64 1)) in
      let: "$Term" := (![uint64T] "term") in
      struct.make raftpb.Entry [{
        "Term" ::= "$Term";
        "Index" ::= "$Index";
        "Type" ::= zero_val raftpb.EntryType;
        "Data" ::= zero_val sliceT
      }]) in
      slice.literal raftpb.Entry ["$sl0"])) in
      ((method_call MemoryStorage' "Append" #()) (![ptrT] "storage")) "$a0")));;;
    let: "cfg" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 1) in
    let: "$a1" := #(W64 5) in
    let: "$a2" := #(W64 1) in
    let: "$a3" := (interface.make MemoryStorage'ptr (![ptrT] "storage")) in
    (func_call newTestConfig #()) "$a0" "$a1" "$a2" "$a3") in
    do:  ("cfg" <-[ptrT] "$r0");;;
    (if: (![funcT] "configFunc") ≠ #func.nil
    then
      do:  (let: "$a0" := (![ptrT] "cfg") in
      (![funcT] "configFunc") "$a0")
    else do:  #());;;
    let: "sm" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "cfg") in
    (func_call newRaft #()) "$a0") in
    do:  ("sm" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "terms") ((let: "$a0" := (![sliceT] "terms") in
    slice.len "$a0") - #(W64 1)))) in
    ((method_call raft' "reset" #()) (![ptrT] "sm")) "$a0");;;
    return: (![ptrT] "sm")).

Definition entsWithConfig : (go_string * go_string) := (pkg_name', "entsWithConfig"%go).

Definition blackHole : go_type := structT [
].

Definition blackHole' : (go_string * go_string) := (pkg_name', "blackHole").

(* go: raft2.go:37:18 *)
Definition blackHole__Step' : val :=
  rec: "blackHole__Step'" <> "" :=
    exception_do (let: <> := (ref_ty blackHole "_") in
    let: "" := (ref_ty raftpb.Message "") in
    return: (#interface.nil)).

(* go: raft2.go:38:18 *)
Definition blackHole__readMessages' : val :=
  rec: "blackHole__readMessages'" <> <> :=
    exception_do (let: <> := (ref_ty blackHole "_") in
    return: (#slice.nil)).

(* go: raft2.go:39:18 *)
Definition blackHole__advanceMessagesAfterAppend' : val :=
  rec: "blackHole__advanceMessagesAfterAppend'" <> <> :=
    exception_do (let: <> := (ref_ty blackHole "_") in
    do:  #()).

Definition nopStepper : (go_string * go_string) := (pkg_name', "nopStepper"%go).

(* go: raft2.go:43:6 *)
Definition preVoteConfig' : val :=
  rec: "preVoteConfig'" "c" :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    let: "$r0" := #true in
    do:  ((struct.field_ref Config "PreVote" (![ptrT] "c")) <-[boolT] "$r0")).

Definition preVoteConfig : (go_string * go_string) := (pkg_name', "preVoteConfig"%go).

Definition stateMachine : go_type := interfaceT.

Definition stateMachine' : (go_string * go_string) := (pkg_name', "stateMachine").

Definition connem : go_type := structT [
  "from" :: uint64T;
  "to" :: uint64T
].

Definition connem' : (go_string * go_string) := (pkg_name', "connem").

Definition network : go_type := structT [
  "t" :: ptrT;
  "peers" :: mapT uint64T stateMachine;
  "storage" :: mapT uint64T ptrT;
  "dropm64" :: mapT connem uint64T;
  "ignorem" :: mapT raftpb.MessageType boolT;
  "msgHook" :: funcT
].

Definition network' : (go_string * go_string) := (pkg_name', "network").

(* go: raft2.go:70:6 *)
Definition idsBySize' : val :=
  rec: "idsBySize'" "size" :=
    exception_do (let: "size" := (ref_ty intT "size") in
    let: "ids" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T (![intT] "size")) in
    do:  ("ids" <-[sliceT] "$r0");;;
    (let: "i" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[intT] "$r0");;;
    (for: (λ: <>, int_lt (![intT] "i") (![intT] "size")); (λ: <>, do:  ("i" <-[intT] ((![intT] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (#(W64 1) + (![intT] "i")) in
      do:  ((slice.elem_ref uint64T (![sliceT] "ids") (![intT] "i")) <-[uint64T] "$r0")));;;
    return: (![sliceT] "ids")).

Definition idsBySize : (go_string * go_string) := (pkg_name', "idsBySize"%go).

Definition inMemStorageCallStats : go_type := structT [
  "initialState" :: intT;
  "firstIndex" :: intT;
  "lastIndex" :: intT;
  "entries" :: intT;
  "term" :: intT;
  "snapshot" :: intT
].

Definition MemoryStorage : go_type := structT [
  "Mutex" :: sync.Mutex;
  "hardState" :: raftpb.HardState;
  "snapshot" :: raftpb.Snapshot;
  "ents" :: sliceT;
  "callStats" :: inMemStorageCallStats
].

Definition testMemoryStorageOptions : go_type := funcT.

(* go: raft2.go:78:6 *)
Definition withPeers' : val :=
  rec: "withPeers'" "peers" :=
    exception_do (let: "peers" := (ref_ty sliceT "peers") in
    return: ((λ: "ms",
       exception_do (let: "ms" := (ref_ty ptrT "ms") in
       let: "$r0" := (![sliceT] "peers") in
       do:  ((struct.field_ref raftpb.ConfState "Voters" (struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms"))))) <-[sliceT] "$r0"))
       ))).

Definition withPeers : (go_string * go_string) := (pkg_name', "withPeers"%go).

Definition testMemoryStorageOptions' : (go_string * go_string) := (pkg_name', "testMemoryStorageOptions").

(* go: raft2.go:86:6 *)
Definition newTestMemoryStorage' : val :=
  rec: "newTestMemoryStorage'" "opts" :=
    exception_do (let: "opts" := (ref_ty sliceT "opts") in
    let: "ms" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := ((func_call NewMemoryStorage #()) #()) in
    do:  ("ms" <-[ptrT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "opts") in
    slice.for_range testMemoryStorageOptions "$range" (λ: <> "o",
      let: "o" := ref_ty testMemoryStorageOptions "o" in
      do:  (let: "$a0" := (![ptrT] "ms") in
      (![testMemoryStorageOptions] "o") "$a0")));;;
    return: (![ptrT] "ms")).

Definition newTestMemoryStorage : (go_string * go_string) := (pkg_name', "newTestMemoryStorage"%go).

(* go: raft2.go:94:16 *)
Definition raft__readMessages' : val :=
  rec: "raft__readMessages'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  (((method_call raft' "advanceMessagesAfterAppend" #()) (![ptrT] "r")) #());;;
    let: "msgs" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
    do:  ("msgs" <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "msgs" (![ptrT] "r")) <-[sliceT] "$r0");;;
    return: (![sliceT] "msgs")).

(* go: raft2.go:101:16 *)
Definition raft__takeMessagesAfterAppend' : val :=
  rec: "raft__takeMessagesAfterAppend'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "msgs" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
    do:  ("msgs" <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "msgsAfterAppend" (![ptrT] "r")) <-[sliceT] "$r0");;;
    return: (![sliceT] "msgs")).

(* go: raft2.go:107:16 *)
Definition raft__stepOrSend' : val :=
  rec: "raft__stepOrSend'" "r" "msgs" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "msgs" := (ref_ty sliceT "msgs") in
    do:  (let: "$range" := (![sliceT] "msgs") in
    slice.for_range raftpb.Message "$range" (λ: <> "m",
      let: "m" := ref_ty raftpb.Message "m" in
      (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        (let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        ((method_call raft' "Step" #()) (![ptrT] "r")) "$a0") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ #interface.nil
        then return: (![error] "err")
        else do:  #()))
      else
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref raft "msgs" (![ptrT] "r")) <-[sliceT] "$r0"))));;;
    return: (#interface.nil)).

(* go: raft2.go:120:16 *)
Definition raft__advanceMessagesAfterAppend' : val :=
  rec: "raft__advanceMessagesAfterAppend'" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "msgs" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (((method_call raft' "takeMessagesAfterAppend" #()) (![ptrT] "r")) #()) in
      do:  ("msgs" <-[sliceT] "$r0");;;
      (if: (let: "$a0" := (![sliceT] "msgs") in
      slice.len "$a0") = #(W64 0)
      then break: #()
      else do:  #());;;
      do:  (let: "$a0" := (![sliceT] "msgs") in
      ((method_call raft' "stepOrSend" #()) (![ptrT] "r")) "$a0"))).

(* go: raft2.go:130:6 *)
Definition newNetworkWithConfigInit' : val :=
  rec: "newNetworkWithConfigInit'" "configFunc" "peers" :=
    exception_do (let: "peers" := (ref_ty sliceT "peers") in
    let: "configFunc" := (ref_ty funcT "configFunc") in
    let: "size" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "peers") in
    slice.len "$a0") in
    do:  ("size" <-[intT] "$r0");;;
    let: "peerAddrs" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![intT] "size") in
    (func_call idsBySize #()) "$a0") in
    do:  ("peerAddrs" <-[sliceT] "$r0");;;
    let: "npeers" := (ref_ty (mapT uint64T stateMachine) (zero_val (mapT uint64T stateMachine))) in
    let: "$r0" := (map.make uint64T stateMachine #()) in
    do:  ("npeers" <-[mapT uint64T stateMachine] "$r0");;;
    let: "nstorage" := (ref_ty (mapT uint64T ptrT) (zero_val (mapT uint64T ptrT))) in
    let: "$r0" := (map.make uint64T ptrT #()) in
    do:  ("nstorage" <-[mapT uint64T ptrT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "peers") in
    slice.for_range stateMachine "$range" (λ: "j" "p",
      let: "j" := ref_ty uint64T "j" in
      let: "p" := ref_ty stateMachine "p" in
      let: "id" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "peerAddrs") (![intT] "j"))) in
      do:  ("id" <-[uint64T] "$r0");;;
      (if: (![stateMachine] "p") = #interface.nil
      then
        let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![sliceT] "peerAddrs") in
        (func_call withPeers #()) "$a0") in
        slice.literal testMemoryStorageOptions ["$sl0"])) in
        (func_call newTestMemoryStorage #()) "$a0") in
        do:  (map.insert (![mapT uint64T ptrT] "nstorage") (![uint64T] "id") "$r0");;;
        let: "cfg" := (ref_ty ptrT (zero_val ptrT)) in
        let: "$r0" := (let: "$a0" := (![uint64T] "id") in
        let: "$a1" := #(W64 10) in
        let: "$a2" := #(W64 1) in
        let: "$a3" := (interface.make MemoryStorage'ptr (Fst (map.get (![mapT uint64T ptrT] "nstorage") (![uint64T] "id")))) in
        (func_call newTestConfig #()) "$a0" "$a1" "$a2" "$a3") in
        do:  ("cfg" <-[ptrT] "$r0");;;
        (if: (![funcT] "configFunc") ≠ #func.nil
        then
          do:  (let: "$a0" := (![ptrT] "cfg") in
          (![funcT] "configFunc") "$a0")
        else do:  #());;;
        let: "sm" := (ref_ty ptrT (zero_val ptrT)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "cfg") in
        (func_call newRaft #()) "$a0") in
        do:  ("sm" <-[ptrT] "$r0");;;
        let: "$r0" := (interface.make raft'ptr (![ptrT] "sm")) in
        do:  (map.insert (![mapT uint64T stateMachine] "npeers") (![uint64T] "id") "$r0")
      else
        let: "$r0" := (![stateMachine] "p") in
        do:  (map.insert (![mapT uint64T stateMachine] "npeers") (![uint64T] "id") "$r0"))));;;
    return: (ref_ty network (let: "$peers" := (![mapT uint64T stateMachine] "npeers") in
     let: "$storage" := (![mapT uint64T ptrT] "nstorage") in
     let: "$dropm64" := (map.make connem uint64T #()) in
     let: "$ignorem" := (map.make raftpb.MessageType boolT #()) in
     struct.make network [{
       "t" ::= zero_val ptrT;
       "peers" ::= "$peers";
       "storage" ::= "$storage";
       "dropm64" ::= "$dropm64";
       "ignorem" ::= "$ignorem";
       "msgHook" ::= zero_val funcT
     }]))).

Definition newNetworkWithConfigInit : (go_string * go_string) := (pkg_name', "newNetworkWithConfigInit"%go).

(* go: raft2.go:159:20 *)
Definition network__filter' : val :=
  rec: "network__filter'" "nw" "msgs" :=
    exception_do (let: "nw" := (ref_ty ptrT "nw") in
    let: "msgs" := (ref_ty sliceT "msgs") in
    let: "mm" := (ref_ty sliceT (zero_val sliceT)) in
    do:  (let: "$range" := (![sliceT] "msgs") in
    slice.for_range raftpb.Message "$range" (λ: <> "m",
      let: "m" := ref_ty raftpb.Message "m" in
      (if: Fst (map.get (![mapT raftpb.MessageType boolT] (struct.field_ref network "ignorem" (![ptrT] "nw"))) (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")))
      then continue: #()
      else do:  #());;;
      let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
      (if: "$sw" = raftpb.MsgHup
      then
        do:  (let: "$a0" := (interface.make string' #"unexpected msgHup"%go) in
        Panic "$a0")
      else
        let: "perc64" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (Fst (map.get (![mapT connem uint64T] (struct.field_ref network "dropm64" (![ptrT] "nw"))) (struct.make connem [{
          "from" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
          "to" ::= ![uint64T] (struct.field_ref raftpb.Message "To" "m")
        }]))) in
        do:  ("perc64" <-[uint64T] "$r0");;;
        (let: "n" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := ((func_call rand.Uint64 #()) #()) in
        do:  ("n" <-[uint64T] "$r0");;;
        (if: (![uint64T] "n") < (![uint64T] "perc64")
        then continue: #()
        else do:  #())));;;
      (if: (![funcT] (struct.field_ref network "msgHook" (![ptrT] "nw"))) ≠ #func.nil
      then
        (if: (~ (let: "$a0" := (![raftpb.Message] "m") in
        (![funcT] (struct.field_ref network "msgHook" (![ptrT] "nw"))) "$a0"))
        then continue: #()
        else do:  #())
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![sliceT] "mm") in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("mm" <-[sliceT] "$r0")));;;
    return: (![sliceT] "mm")).

Definition DescribeMessage : (go_string * go_string) := (pkg_name', "DescribeMessage"%go).

(* go: raft2.go:185:20 *)
Definition network__send' : val :=
  rec: "network__send'" "nw" "msgs" :=
    exception_do (let: "nw" := (ref_ty ptrT "nw") in
    let: "msgs" := (ref_ty sliceT "msgs") in
    (for: (λ: <>, int_gt (let: "$a0" := (![sliceT] "msgs") in
    slice.len "$a0") #(W64 0)); (λ: <>, Skip) := λ: <>,
      let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
      let: "$r0" := (![raftpb.Message] (slice.elem_ref raftpb.Message (![sliceT] "msgs") #(W64 0))) in
      do:  ("m" <-[raftpb.Message] "$r0");;;
      let: "p" := (ref_ty stateMachine (zero_val stateMachine)) in
      let: "$r0" := (Fst (map.get (![mapT uint64T stateMachine] (struct.field_ref network "peers" (![ptrT] "nw"))) (![uint64T] (struct.field_ref raftpb.Message "To" "m")))) in
      do:  ("p" <-[stateMachine] "$r0");;;
      (if: (![ptrT] (struct.field_ref network "t" (![ptrT] "nw"))) ≠ #null
      then
        do:  (let: "$a0" := ((let: "$sl0" := (interface.make string' (let: "$a0" := (![raftpb.Message] "m") in
        let: "$a1" := #func.nil in
        (func_call DescribeMessage #()) "$a0" "$a1")) in
        slice.literal interfaceT ["$sl0"])) in
        ((method_call testing.common' "Log" #()) (struct.field_ref testing.T "common" (![ptrT] (struct.field_ref network "t" (![ptrT] "nw"))))) "$a0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (interface.get "Step" (![stateMachine] "p")) "$a0") in
      do:  "$r0";;;
      do:  ((interface.get "advanceMessagesAfterAppend" (![stateMachine] "p")) #());;;
      let: "$r0" := (let: "$a0" := (let: "$s" := (![sliceT] "msgs") in
      slice.slice raftpb.Message "$s" #(W64 1) (slice.len "$s")) in
      let: "$a1" := (let: "$a0" := ((interface.get "readMessages" (![stateMachine] "p")) #()) in
      ((method_call network' "filter" #()) (![ptrT] "nw")) "$a0") in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("msgs" <-[sliceT] "$r0"))).

Definition testLeaderElectionStruct : go_type := structT [
  "network" :: ptrT;
  "state" :: StateType;
  "expTerm" :: uint64T
].

Definition testLeaderElectionStruct' : (go_string * go_string) := (pkg_name', "testLeaderElectionStruct").

(* go: raft2.go:204:6 *)
Definition testLeaderElection2' : val :=
  rec: "testLeaderElection2'" "t" "preVote" :=
    exception_do (let: "preVote" := (ref_ty boolT "preVote") in
    let: "t" := (ref_ty ptrT "t") in
    let: "cfg" := (ref_ty funcT (zero_val funcT)) in
    let: "candState" := (ref_ty StateType (zero_val StateType)) in
    let: "$r0" := StateCandidate in
    do:  ("candState" <-[StateType] "$r0");;;
    let: "candTerm" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("candTerm" <-[uint64T] "$r0");;;
    (if: ![boolT] "preVote"
    then
      let: "$r0" := (func_call preVoteConfig #()) in
      do:  ("cfg" <-[funcT] "$r0");;;
      let: "$r0" := StatePreCandidate in
      do:  ("candState" <-[StateType] "$r0");;;
      let: "$r0" := #(W64 0) in
      do:  ("candTerm" <-[uint64T] "$r0")
    else do:  #());;;
    let: "nopStepper" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty blackHole (struct.make blackHole [{
    }])) in
    do:  ("nopStepper" <-[ptrT] "$r0");;;
    let: "tests" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := ((let: "$sl0" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := #interface.nil in
      let: "$sl2" := #interface.nil in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"])) in
      (func_call newNetworkWithConfigInit #()) "$a0" "$a1";
      "state" ::= StateLeader;
      "expTerm" ::= #(W64 1)
    }]) in
    let: "$sl1" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := #interface.nil in
      let: "$sl2" := (interface.make blackHole'ptr (![ptrT] "nopStepper")) in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"])) in
      (func_call newNetworkWithConfigInit #()) "$a0" "$a1";
      "state" ::= StateLeader;
      "expTerm" ::= #(W64 1)
    }]) in
    let: "$sl2" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := (interface.make blackHole'ptr (![ptrT] "nopStepper")) in
      let: "$sl2" := (interface.make blackHole'ptr (![ptrT] "nopStepper")) in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"])) in
      (func_call newNetworkWithConfigInit #()) "$a0" "$a1";
      "state" ::= ![StateType] "candState";
      "expTerm" ::= ![uint64T] "candTerm"
    }]) in
    let: "$sl3" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := (interface.make blackHole'ptr (![ptrT] "nopStepper")) in
      let: "$sl2" := (interface.make blackHole'ptr (![ptrT] "nopStepper")) in
      let: "$sl3" := #interface.nil in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (func_call newNetworkWithConfigInit #()) "$a0" "$a1";
      "state" ::= ![StateType] "candState";
      "expTerm" ::= ![uint64T] "candTerm"
    }]) in
    let: "$sl4" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := (interface.make blackHole'ptr (![ptrT] "nopStepper")) in
      let: "$sl2" := (interface.make blackHole'ptr (![ptrT] "nopStepper")) in
      let: "$sl3" := #interface.nil in
      let: "$sl4" := #interface.nil in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
      (func_call newNetworkWithConfigInit #()) "$a0" "$a1";
      "state" ::= StateLeader;
      "expTerm" ::= #(W64 1)
    }]) in
    let: "$sl5" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := (interface.make raft'ptr (let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #(W64 1) in
      slice.literal uint64T ["$sl0"])) in
      (func_call entsWithConfig #()) "$a0" "$a1")) in
      let: "$sl2" := (interface.make raft'ptr (let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #(W64 1) in
      slice.literal uint64T ["$sl0"])) in
      (func_call entsWithConfig #()) "$a0" "$a1")) in
      let: "$sl3" := (interface.make raft'ptr (let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #(W64 1) in
      let: "$sl1" := #(W64 1) in
      slice.literal uint64T ["$sl0"; "$sl1"])) in
      (func_call entsWithConfig #()) "$a0" "$a1")) in
      let: "$sl4" := #interface.nil in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
      (func_call newNetworkWithConfigInit #()) "$a0" "$a1";
      "state" ::= StateFollower;
      "expTerm" ::= #(W64 1)
    }]) in
    slice.literal testLeaderElectionStruct ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
    do:  ("tests" <-[sliceT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "tests") in
    slice.for_range testLeaderElectionStruct "$range" (λ: "i" "tt",
      let: "i" := ref_ty uint64T "i" in
      let: "tt" := ref_ty testLeaderElectionStruct "tt" in
      do:  (let: "$a0" := ((let: "$sl0" := (let: "$From" := #(W64 1) in
      let: "$To" := #(W64 1) in
      let: "$Type" := raftpb.MsgHup in
      struct.make raftpb.Message [{
        "Type" ::= "$Type";
        "To" ::= "$To";
        "From" ::= "$From";
        "Term" ::= zero_val uint64T;
        "LogTerm" ::= zero_val uint64T;
        "Index" ::= zero_val uint64T;
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= zero_val sliceT;
        "Responses" ::= zero_val sliceT
      }]) in
      slice.literal raftpb.Message ["$sl0"])) in
      ((method_call network' "send" #()) (![ptrT] (struct.field_ref testLeaderElectionStruct "network" "tt"))) "$a0");;;
      let: "sm" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (Fst (map.get (![mapT uint64T stateMachine] (struct.field_ref network "peers" (![ptrT] (struct.field_ref testLeaderElectionStruct "network" "tt")))) #(W64 1))) in
      do:  ("sm" <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (interface.make testing.T'ptr (![ptrT] "t")) in
      let: "$a1" := (interface.make StateType' (![StateType] (struct.field_ref testLeaderElectionStruct "state" "tt"))) in
      let: "$a2" := (interface.make StateType' (![StateType] (struct.field_ref raft "state" (![ptrT] "sm")))) in
      let: "$a3" := ((let: "$sl0" := (interface.make string' #"#%d"%go) in
      let: "$sl1" := (interface.make int' (![intT] "i")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (func_call assert.Equal #()) "$a0" "$a1" "$a2" "$a3");;;
      do:  (let: "$a0" := (interface.make testing.T'ptr (![ptrT] "t")) in
      let: "$a1" := (interface.make uint64' (![uint64T] (struct.field_ref testLeaderElectionStruct "expTerm" "tt"))) in
      let: "$a2" := (interface.make uint64' (![uint64T] (struct.field_ref raft "Term" (![ptrT] "sm")))) in
      let: "$a3" := ((let: "$sl0" := (interface.make string' #"#%d"%go) in
      let: "$sl1" := (interface.make int' (![intT] "i")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (func_call assert.Equal #()) "$a0" "$a1" "$a2" "$a3")))).

Definition testLeaderElection2 : (go_string * go_string) := (pkg_name', "testLeaderElection2"%go).

Definition ErrStepLocalMsg : (go_string * go_string) := (pkg_name', "ErrStepLocalMsg"%go).

Definition ErrStepPeerNotFound : (go_string * go_string) := (pkg_name', "ErrStepPeerNotFound"%go).

(* NewRawNode instantiates a RawNode from the given configuration.

   See Bootstrap() for bootstrapping an initial state; this replaces the former
   'peers' argument to this method (with identical behavior). However, It is
   recommended that instead of calling Bootstrap, applications bootstrap their
   state manually by setting up a Storage that has a first index > 1 and which
   stores the desired ConfState as its InitialState.

   go: rawnode.go:51:6 *)
Definition NewRawNode' : val :=
  rec: "NewRawNode'" "config" :=
    exception_do (let: "config" := (ref_ty ptrT "config") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "config") in
    (func_call newRaft #()) "$a0") in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty RawNode (let: "$raft" := (![ptrT] "r") in
    struct.make RawNode [{
      "raft" ::= "$raft";
      "asyncStorageWrites" ::= zero_val boolT;
      "prevSoftSt" ::= zero_val ptrT;
      "prevHardSt" ::= zero_val raftpb.HardState;
      "stepsOnAdvance" ::= zero_val sliceT
    }])) in
    do:  ("rn" <-[ptrT] "$r0");;;
    let: "$r0" := (![boolT] (struct.field_ref Config "AsyncStorageWrites" (![ptrT] "config"))) in
    do:  ((struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn")) <-[boolT] "$r0");;;
    let: "ss" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := (((method_call raft' "softState" #()) (![ptrT] "r")) #()) in
    do:  ("ss" <-[SoftState] "$r0");;;
    let: "$r0" := "ss" in
    do:  ((struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn")) <-[ptrT] "$r0");;;
    let: "$r0" := (((method_call raft' "hardState" #()) (![ptrT] "r")) #()) in
    do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0");;;
    return: (![ptrT] "rn", #interface.nil)).

(* Tick advances the internal logical clock by a single tick.

   go: rawnode.go:64:20 *)
Definition RawNode__Tick' : val :=
  rec: "RawNode__Tick'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    do:  (((method_call raft' "tick" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) #())).

(* TickQuiesced advances the internal logical clock by a single tick without
   performing any other state machine processing. It allows the caller to avoid
   periodic heartbeats and elections when all of the peers in a Raft group are
   known to be at the same state. Expected usage is to periodically invoke Tick
   or TickQuiesced depending on whether the group is "active" or "quiesced".

   WARNING: Be very careful about using this method as it subverts the Raft
   state machine. You should probably be using Tick instead.

   DEPRECATED: This method will be removed in a future release.

   go: rawnode.go:78:20 *)
Definition RawNode__TickQuiesced' : val :=
  rec: "RawNode__TickQuiesced'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) + #(W64 1)))).

(* Campaign causes this RawNode to transition to candidate state.

   go: rawnode.go:83:20 *)
Definition RawNode__Campaign' : val :=
  rec: "RawNode__Campaign'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (let: "$Type" := raftpb.MsgHup in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= zero_val uint64T;
       "From" ::= zero_val uint64T;
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= zero_val sliceT;
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }]) in
     ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* Propose proposes data be appended to the raft log.

   go: rawnode.go:90:20 *)
Definition RawNode__Propose' : val :=
  rec: "RawNode__Propose'" "rn" "data" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "data" := (ref_ty sliceT "data") in
    return: (let: "$a0" := (let: "$Type" := raftpb.MsgProp in
     let: "$From" := (![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) in
     let: "$Entries" := ((let: "$sl0" := (let: "$Data" := (![sliceT] "data") in
     struct.make raftpb.Entry [{
       "Term" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Type" ::= zero_val raftpb.EntryType;
       "Data" ::= "$Data"
     }]) in
     slice.literal raftpb.Entry ["$sl0"])) in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= zero_val uint64T;
       "From" ::= "$From";
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= "$Entries";
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }]) in
     ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ProposeConfChange proposes a config change. See (Node).ProposeConfChange for
   details.

   go: rawnode.go:101:20 *)
Definition RawNode__ProposeConfChange' : val :=
  rec: "RawNode__ProposeConfChange'" "rn" "cc" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
    (func_call confChangeToMsg #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (![error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![raftpb.Message] "m") in
     ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ApplyConfChange applies a config change to the local node. The app must call
   this when it applies a configuration change, except when it decides to reject
   the configuration change, in which case no call must take place.

   go: rawnode.go:112:20 *)
Definition RawNode__ApplyConfChange' : val :=
  rec: "RawNode__ApplyConfChange'" "rn" "cc" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := (let: "$a0" := ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #()) in
    ((method_call raft' "applyConfChange" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    return: ("cs")).

(* Step advances the state machine using the given message.

   go: rawnode.go:118:20 *)
Definition RawNode__Step' : val :=
  rec: "RawNode__Step'" "rn" "m" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "m" := (ref_ty raftpb.Message "m") in
    (if: (let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (func_call IsLocalMsg #()) "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    (func_call IsLocalMsgTarget #()) "$a0"))
    then return: (![error] (globals.get ErrStepLocalMsg #()))
    else do:  #());;;
    (if: ((let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (func_call IsResponseMsg #()) "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    (func_call IsLocalMsgTarget #()) "$a0"))) && ((Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) = #null)
    then return: (![error] (globals.get ErrStepPeerNotFound #()))
    else do:  #());;;
    return: (let: "$a0" := (![raftpb.Message] "m") in
     ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* Ready returns the outstanding work that the application needs to handle. This
   includes appending and applying entries or a snapshot, updating the HardState,
   and sending messages. The returned Ready() *must* be handled and subsequently
   passed back via Advance().

   go: rawnode.go:133:20 *)
Definition RawNode__Ready' : val :=
  rec: "RawNode__Ready'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "$r0" := (((method_call RawNode' "readyWithoutAccept" #()) (![ptrT] "rn")) #()) in
    do:  ("rd" <-[Ready] "$r0");;;
    do:  (let: "$a0" := (![Ready] "rd") in
    ((method_call RawNode' "acceptReady" #()) (![ptrT] "rn")) "$a0");;;
    return: (![Ready] "rd")).

Definition needStorageApplyMsg : (go_string * go_string) := (pkg_name', "needStorageApplyMsg"%go).

Definition newStorageApplyMsg : (go_string * go_string) := (pkg_name', "newStorageApplyMsg"%go).

Definition needStorageAppendMsg : (go_string * go_string) := (pkg_name', "needStorageAppendMsg"%go).

Definition newStorageAppendMsg : (go_string * go_string) := (pkg_name', "newStorageAppendMsg"%go).

Definition MustSync : (go_string * go_string) := (pkg_name', "MustSync"%go).

(* readyWithoutAccept returns a Ready. This is a read-only operation, i.e. there
   is no obligation that the Ready must be handled.

   go: rawnode.go:141:20 *)
Definition RawNode__readyWithoutAccept' : val :=
  rec: "RawNode__readyWithoutAccept'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "$r0" := (let: "$Entries" := (((method_call raftLog' "nextUnstableEnts" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    let: "$CommittedEntries" := (let: "$a0" := (((method_call RawNode' "applyUnstableEntries" #()) (![ptrT] "rn")) #()) in
    ((method_call raftLog' "nextCommittedEnts" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0") in
    let: "$Messages" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
    struct.make Ready [{
      "SoftState" ::= zero_val ptrT;
      "HardState" ::= zero_val raftpb.HardState;
      "ReadStates" ::= zero_val sliceT;
      "Entries" ::= "$Entries";
      "Snapshot" ::= zero_val raftpb.Snapshot;
      "CommittedEntries" ::= "$CommittedEntries";
      "Messages" ::= "$Messages";
      "MustSync" ::= zero_val boolT
    }]) in
    do:  ("rd" <-[Ready] "$r0");;;
    (let: "softSt" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := (((method_call raft' "softState" #()) (![ptrT] "r")) #()) in
    do:  ("softSt" <-[SoftState] "$r0");;;
    (if: (~ (let: "$a0" := (![ptrT] (struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn"))) in
    ((method_call SoftState' "equal" #()) "softSt") "$a0"))
    then
      let: "escapingSoftSt" := (ref_ty SoftState (zero_val SoftState)) in
      let: "$r0" := (![SoftState] "softSt") in
      do:  ("escapingSoftSt" <-[SoftState] "$r0");;;
      let: "$r0" := "escapingSoftSt" in
      do:  ((struct.field_ref Ready "SoftState" "rd") <-[ptrT] "$r0")
    else do:  #()));;;
    (let: "hardSt" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: "$r0" := (((method_call raft' "hardState" #()) (![ptrT] "r")) #()) in
    do:  ("hardSt" <-[raftpb.HardState] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    (func_call isHardStateEqual #()) "$a0" "$a1"))
    then
      let: "$r0" := (![raftpb.HardState] "hardSt") in
      do:  ((struct.field_ref Ready "HardState" "rd") <-[raftpb.HardState] "$r0")
    else do:  #()));;;
    (if: ((method_call raftLog' "hasNextUnstableSnapshot" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then
      let: "$r0" := (![raftpb.Snapshot] (((method_call raftLog' "nextUnstableSnapshot" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
      do:  ((struct.field_ref Ready "Snapshot" "rd") <-[raftpb.Snapshot] "$r0")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
    slice.len "$a0") ≠ #(W64 0)
    then
      let: "$r0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
      do:  ((struct.field_ref Ready "ReadStates" "rd") <-[sliceT] "$r0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (((method_call raft' "hardState" #()) (![ptrT] "r")) #()) in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    let: "$a2" := (let: "$a0" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
    slice.len "$a0") in
    (func_call MustSync #()) "$a0" "$a1" "$a2") in
    do:  ((struct.field_ref Ready "MustSync" "rd") <-[boolT] "$r0");;;
    (if: ![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))
    then
      (if: let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![Ready] "rd") in
      (func_call needStorageAppendMsg #()) "$a0" "$a1"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "r") in
        let: "$a1" := (![Ready] "rd") in
        (func_call newStorageAppendMsg #()) "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT] "$r0")
      else do:  #());;;
      (if: let: "$a0" := (![Ready] "rd") in
      (func_call needStorageApplyMsg #()) "$a0"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "r") in
        let: "$a1" := (![Ready] "rd") in
        (func_call newStorageApplyMsg #()) "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT] "$r0")
      else do:  #())
    else
      do:  (let: "$range" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) ≠ (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
          let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
          slice.literal raftpb.Message ["$sl0"])) in
          (slice.append sliceT) "$a0" "$a1") in
          do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT] "$r0")
        else do:  #()))));;;
    return: (![Ready] "rd")).

(* MustSync returns true if the hard state and count of Raft entries indicate
   that a synchronous write to persistent storage is required.

   go: rawnode.go:193:6 *)
Definition MustSync' : val :=
  rec: "MustSync'" "st" "prevst" "entsnum" :=
    exception_do (let: "entsnum" := (ref_ty intT "entsnum") in
    let: "prevst" := (ref_ty raftpb.HardState "prevst") in
    let: "st" := (ref_ty raftpb.HardState "st") in
    return: ((((![intT] "entsnum") ≠ #(W64 0)) || ((![uint64T] (struct.field_ref raftpb.HardState "Vote" "st")) ≠ (![uint64T] (struct.field_ref raftpb.HardState "Vote" "prevst")))) || ((![uint64T] (struct.field_ref raftpb.HardState "Term" "st")) ≠ (![uint64T] (struct.field_ref raftpb.HardState "Term" "prevst"))))).

(* go: rawnode.go:202:6 *)
Definition needStorageAppendMsg' : val :=
  rec: "needStorageAppendMsg'" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    return: ((((int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
     slice.len "$a0") #(W64 0)) || (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
     (func_call IsEmptyHardState #()) "$a0"))) || (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
     (func_call IsEmptySnap #()) "$a0"))) || (int_gt (let: "$a0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
     slice.len "$a0") #(W64 0)))).

(* go: rawnode.go:212:6 *)
Definition needStorageAppendRespMsg' : val :=
  rec: "needStorageAppendRespMsg'" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    return: ((((method_call raftLog' "hasNextOrInProgressUnstableEnts" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) || (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
     (func_call IsEmptySnap #()) "$a0")))).

Definition needStorageAppendRespMsg : (go_string * go_string) := (pkg_name', "needStorageAppendRespMsg"%go).

Definition newStorageAppendRespMsg : (go_string * go_string) := (pkg_name', "newStorageAppendRespMsg"%go).

(* newStorageAppendMsg creates the message that should be sent to the local
   append thread to instruct it to append log entries, write an updated hard
   state, and apply a snapshot. The message also carries a set of responses
   that should be delivered after the rest of the message is processed. Used
   with AsyncStorageWrites.

   go: rawnode.go:225:6 *)
Definition newStorageAppendMsg' : val :=
  rec: "newStorageAppendMsg'" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: "$r0" := (let: "$Type" := raftpb.MsgStorageAppend in
    let: "$To" := LocalAppendThread in
    let: "$From" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    let: "$Entries" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= "$From";
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= "$Entries";
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    (func_call IsEmptyHardState #()) "$a0"))
    then
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Term" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Term" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Vote" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Vote" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Commit" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Commit" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    (func_call IsEmptySnap #()) "$a0"))
    then
      let: "snap" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
      let: "$r0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      do:  ("snap" <-[raftpb.Snapshot] "$r0");;;
      let: "$r0" := "snap" in
      do:  ((struct.field_ref raftpb.Message "Snapshot" "m") <-[ptrT] "$r0")
    else do:  #());;;
    let: "$r0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
    do:  ((struct.field_ref raftpb.Message "Responses" "m") <-[sliceT] "$r0");;;
    (if: let: "$a0" := (![ptrT] "r") in
    let: "$a1" := (![Ready] "rd") in
    (func_call needStorageAppendRespMsg #()) "$a0" "$a1"
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Responses" "m")) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![Ready] "rd") in
      (func_call newStorageAppendRespMsg #()) "$a0" "$a1") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref raftpb.Message "Responses" "m") <-[sliceT] "$r0")
    else do:  #());;;
    return: (![raftpb.Message] "m")).

(* newStorageAppendRespMsg creates the message that should be returned to node
   after the unstable log entries, hard state, and snapshot in the current Ready
   (along with those in all prior Ready structs) have been saved to stable
   storage.

   go: rawnode.go:268:6 *)
Definition newStorageAppendRespMsg' : val :=
  rec: "newStorageAppendRespMsg'" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: "$r0" := (let: "$Type" := raftpb.MsgStorageAppendResp in
    let: "$To" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    let: "$From" := LocalAppendThread in
    let: "$Term" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= "$To";
      "From" ::= "$From";
      "Term" ::= "$Term";
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    (if: ((method_call raftLog' "hasNextOrInProgressUnstableEnts" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (((method_call raftLog' "lastEntryID" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref entryID "index" "last")) in
      do:  ((struct.field_ref raftpb.Message "Index" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref entryID "term" "last")) in
      do:  ((struct.field_ref raftpb.Message "LogTerm" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    (func_call IsEmptySnap #()) "$a0"))
    then
      let: "snap" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
      let: "$r0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      do:  ("snap" <-[raftpb.Snapshot] "$r0");;;
      let: "$r0" := "snap" in
      do:  ((struct.field_ref raftpb.Message "Snapshot" "m") <-[ptrT] "$r0")
    else do:  #());;;
    return: (![raftpb.Message] "m")).

(* go: rawnode.go:368:6 *)
Definition needStorageApplyMsg' : val :=
  rec: "needStorageApplyMsg'" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    return: (int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
     slice.len "$a0") #(W64 0))).

(* go: rawnode.go:369:6 *)
Definition needStorageApplyRespMsg' : val :=
  rec: "needStorageApplyRespMsg'" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    return: (let: "$a0" := (![Ready] "rd") in
     (func_call needStorageApplyMsg #()) "$a0")).

Definition needStorageApplyRespMsg : (go_string * go_string) := (pkg_name', "needStorageApplyRespMsg"%go).

Definition newStorageApplyRespMsg : (go_string * go_string) := (pkg_name', "newStorageApplyRespMsg"%go).

(* newStorageApplyMsg creates the message that should be sent to the local
   apply thread to instruct it to apply committed log entries. The message
   also carries a response that should be delivered after the rest of the
   message is processed. Used with AsyncStorageWrites.

   go: rawnode.go:375:6 *)
Definition newStorageApplyMsg' : val :=
  rec: "newStorageApplyMsg'" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
    do:  ("ents" <-[sliceT] "$r0");;;
    return: (let: "$Type" := raftpb.MsgStorageApply in
     let: "$To" := LocalApplyThread in
     let: "$From" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
     let: "$Term" := #(W64 0) in
     let: "$Entries" := (![sliceT] "ents") in
     let: "$Responses" := ((let: "$sl0" := (let: "$a0" := (![ptrT] "r") in
     let: "$a1" := (![sliceT] "ents") in
     (func_call newStorageApplyRespMsg #()) "$a0" "$a1") in
     slice.literal raftpb.Message ["$sl0"])) in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= "$To";
       "From" ::= "$From";
       "Term" ::= "$Term";
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= "$Entries";
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= "$Responses"
     }])).

(* newStorageApplyRespMsg creates the message that should be returned to node
   after the committed entries in the current Ready (along with those in all
   prior Ready structs) have been applied to the local state machine.

   go: rawnode.go:392:6 *)
Definition newStorageApplyRespMsg' : val :=
  rec: "newStorageApplyRespMsg'" "r" "ents" :=
    exception_do (let: "ents" := (ref_ty sliceT "ents") in
    let: "r" := (ref_ty ptrT "r") in
    return: (let: "$Type" := raftpb.MsgStorageApplyResp in
     let: "$To" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
     let: "$From" := LocalApplyThread in
     let: "$Term" := #(W64 0) in
     let: "$Entries" := (![sliceT] "ents") in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= "$To";
       "From" ::= "$From";
       "Term" ::= "$Term";
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= "$Entries";
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }])).

Definition traceReady : (go_string * go_string) := (pkg_name', "traceReady"%go).

(* acceptReady is called when the consumer of the RawNode has decided to go
   ahead and handle a Ready. Nothing must alter the state of the RawNode between
   this call and the prior call to Ready().

   go: rawnode.go:405:20 *)
Definition RawNode__acceptReady' : val :=
  rec: "RawNode__acceptReady'" "rn" "rd" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rd" := (ref_ty Ready "rd") in
    (if: (![ptrT] (struct.field_ref Ready "SoftState" "rd")) ≠ #null
    then
      let: "$r0" := (![ptrT] (struct.field_ref Ready "SoftState" "rd")) in
      do:  ((struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn")) <-[ptrT] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    (func_call IsEmptyHardState #()) "$a0"))
    then
      let: "$r0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
      do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref Ready "ReadStates" "rd")) in
    slice.len "$a0") ≠ #(W64 0)
    then
      let: "$r0" := #slice.nil in
      do:  ((struct.field_ref raft "readStates" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT] "$r0")
    else do:  #());;;
    (if: (~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))))
    then
      (if: (let: "$a0" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
      slice.len "$a0") ≠ #(W64 0)
      then
        do:  (let: "$a0" := #"two accepted Ready structs without call to Advance"%go in
        let: "$a1" := #slice.nil in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1")
      else do:  #());;;
      do:  (let: "$range" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))
        then
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
          let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
          slice.literal raftpb.Message ["$sl0"])) in
          (slice.append sliceT) "$a0" "$a1") in
          do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT] "$r0")
        else do:  #())));;;
      (if: let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
      let: "$a1" := (![Ready] "rd") in
      (func_call needStorageAppendRespMsg #()) "$a0" "$a1"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
        let: "$a1" := (![Ready] "rd") in
        (func_call newStorageAppendRespMsg #()) "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT] "$r0")
      else do:  #());;;
      (if: let: "$a0" := (![Ready] "rd") in
      (func_call needStorageApplyRespMsg #()) "$a0"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
        let: "$a1" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
        (func_call newStorageApplyRespMsg #()) "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT] "$r0")
      else do:  #())
    else do:  #());;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "msgs" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "msgsAfterAppend" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT] "$r0");;;
    do:  (((method_call raftLog' "acceptUnstable" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
      do:  ("ents" <-[sliceT] "$r0");;;
      let: "index" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "ents") ((let: "$a0" := (![sliceT] "ents") in
      slice.len "$a0") - #(W64 1))))) in
      do:  ("index" <-[uint64T] "$r0");;;
      do:  (let: "$a0" := (![uint64T] "index") in
      let: "$a1" := (let: "$a0" := (![sliceT] "ents") in
      (func_call entsSize #()) "$a0") in
      let: "$a2" := (((method_call RawNode' "applyUnstableEntries" #()) (![ptrT] "rn")) #()) in
      ((method_call raftLog' "acceptApplying" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1" "$a2")
    else do:  #());;;
    do:  (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    (func_call traceReady #()) "$a0")).

(* applyUnstableEntries returns whether entries are allowed to be applied once
   they are known to be committed but before they have been written locally to
   stable storage.

   go: rawnode.go:448:20 *)
Definition RawNode__applyUnstableEntries' : val :=
  rec: "RawNode__applyUnstableEntries'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: ((~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn")))))).

(* HasReady called when RawNode user need to check if any Ready pending.

   go: rawnode.go:453:20 *)
Definition RawNode__HasReady' : val :=
  rec: "RawNode__HasReady'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    do:  ("r" <-[ptrT] "$r0");;;
    (let: "softSt" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := (((method_call raft' "softState" #()) (![ptrT] "r")) #()) in
    do:  ("softSt" <-[SoftState] "$r0");;;
    (if: (~ (let: "$a0" := (![ptrT] (struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn"))) in
    ((method_call SoftState' "equal" #()) "softSt") "$a0"))
    then return: (#true)
    else do:  #()));;;
    (let: "hardSt" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: "$r0" := (((method_call raft' "hardState" #()) (![ptrT] "r")) #()) in
    do:  ("hardSt" <-[raftpb.HardState] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    (func_call IsEmptyHardState #()) "$a0")) && (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    (func_call isHardStateEqual #()) "$a0" "$a1"))
    then return: (#true)
    else do:  #()));;;
    (if: ((method_call raftLog' "hasNextUnstableSnapshot" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then return: (#true)
    else do:  #());;;
    (if: (int_gt (let: "$a0" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
    slice.len "$a0") #(W64 0)) || (int_gt (let: "$a0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
    slice.len "$a0") #(W64 0))
    then return: (#true)
    else do:  #());;;
    (if: (((method_call raftLog' "hasNextUnstableEnts" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) || (let: "$a0" := (((method_call RawNode' "applyUnstableEntries" #()) (![ptrT] "rn")) #()) in
    ((method_call raftLog' "hasNextCommittedEnts" #()) (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
    then return: (#true)
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
    slice.len "$a0") ≠ #(W64 0)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* Advance notifies the RawNode that the application has applied and saved progress in the
   last Ready results.

   NOTE: Advance must not be called when using AsyncStorageWrites. Response messages from
   the local append and apply threads take its place.

   go: rawnode.go:482:20 *)
Definition RawNode__Advance' : val :=
  rec: "RawNode__Advance'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: <> := (ref_ty Ready "_") in
    (if: ![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))
    then
      do:  (let: "$a0" := #"Advance must not be called when using AsyncStorageWrites"%go in
      let: "$a1" := #slice.nil in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$range" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
    slice.for_range raftpb.Message "$range" (λ: "i" "m",
      let: "i" := ref_ty uint64T "i" in
      let: "m" := ref_ty raftpb.Message "m" in
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
      do:  "$r0";;;
      let: "$r0" := (struct.make raftpb.Message [{
        "Type" ::= zero_val raftpb.MessageType;
        "To" ::= zero_val uint64T;
        "From" ::= zero_val uint64T;
        "Term" ::= zero_val uint64T;
        "LogTerm" ::= zero_val uint64T;
        "Index" ::= zero_val uint64T;
        "Entries" ::= zero_val sliceT;
        "Commit" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Snapshot" ::= zero_val ptrT;
        "Reject" ::= zero_val boolT;
        "RejectHint" ::= zero_val uint64T;
        "Context" ::= zero_val sliceT;
        "Responses" ::= zero_val sliceT
      }]) in
      do:  ((slice.elem_ref raftpb.Message (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) (![intT] "i")) <-[raftpb.Message] "$r0")));;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
    slice.slice raftpb.Message "$s" #(W64 0) #(W64 0)) in
    do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT] "$r0")).

(* Status returns the current status of the given group. This allocates, see
   BasicStatus and WithProgress for allocation-friendlier choices.

   go: rawnode.go:498:20 *)
Definition RawNode__Status' : val :=
  rec: "RawNode__Status'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "status" := (ref_ty Status (zero_val Status)) in
    let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    (func_call getStatus #()) "$a0") in
    do:  ("status" <-[Status] "$r0");;;
    return: (![Status] "status")).

Definition getBasicStatus : (go_string * go_string) := (pkg_name', "getBasicStatus"%go).

(* BasicStatus returns a BasicStatus. Notably this does not contain the
   Progress map; see WithProgress for an allocation-free way to inspect it.

   go: rawnode.go:505:20 *)
Definition RawNode__BasicStatus' : val :=
  rec: "RawNode__BasicStatus'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
     (func_call getBasicStatus #()) "$a0")).

Definition ProgressType : go_type := byteT.

Definition ProgressType' : (go_string * go_string) := (pkg_name', "ProgressType").

Definition ProgressTypePeer : expr := #(W8 0).

Definition ProgressTypeLearner : expr := #(W8 1).

(* WithProgress is a helper to introspect the Progress for this node and its
   peers.

   go: rawnode.go:521:20 *)
Definition RawNode__WithProgress' : val :=
  rec: "RawNode__WithProgress'" "rn" "visitor" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "visitor" := (ref_ty funcT "visitor") in
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "typ" := (ref_ty ProgressType (zero_val ProgressType)) in
      let: "$r0" := ProgressTypePeer in
      do:  ("typ" <-[ProgressType] "$r0");;;
      (if: ![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))
      then
        let: "$r0" := ProgressTypeLearner in
        do:  ("typ" <-[ProgressType] "$r0")
      else do:  #());;;
      let: "p" := (ref_ty tracker.Progress (zero_val tracker.Progress)) in
      let: "$r0" := (![tracker.Progress] (![ptrT] "pr")) in
      do:  ("p" <-[tracker.Progress] "$r0");;;
      let: "$r0" := #null in
      do:  ((struct.field_ref tracker.Progress "Inflights" "p") <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![uint64T] "id") in
      let: "$a1" := (![ProgressType] "typ") in
      let: "$a2" := (![tracker.Progress] "p") in
      (![funcT] "visitor") "$a0" "$a1" "$a2"))
      ) in
    ((method_call tracker.ProgressTracker' "Visit" #()) (struct.field_ref raft "trk" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) "$a0")).

(* ReportUnreachable reports the given node is not reachable for the last send.

   go: rawnode.go:534:20 *)
Definition RawNode__ReportUnreachable' : val :=
  rec: "RawNode__ReportUnreachable'" "rn" "id" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "id" := (ref_ty uint64T "id") in
    let: "$r0" := (let: "$a0" := (let: "$Type" := raftpb.MsgUnreachable in
    let: "$From" := (![uint64T] "id") in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= zero_val uint64T;
      "From" ::= "$From";
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* ReportSnapshot reports the status of the sent snapshot.

   go: rawnode.go:539:20 *)
Definition RawNode__ReportSnapshot' : val :=
  rec: "RawNode__ReportSnapshot'" "rn" "id" "status" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "status" := (ref_ty SnapshotStatus "status") in
    let: "id" := (ref_ty uint64T "id") in
    let: "rej" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := ((![SnapshotStatus] "status") = SnapshotFailure) in
    do:  ("rej" <-[boolT] "$r0");;;
    let: "$r0" := (let: "$a0" := (let: "$Type" := raftpb.MsgSnapStatus in
    let: "$From" := (![uint64T] "id") in
    let: "$Reject" := (![boolT] "rej") in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= zero_val uint64T;
      "From" ::= "$From";
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= "$Reject";
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* TransferLeader tries to transfer leadership to the given transferee.

   go: rawnode.go:546:20 *)
Definition RawNode__TransferLeader' : val :=
  rec: "RawNode__TransferLeader'" "rn" "transferee" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "transferee" := (ref_ty uint64T "transferee") in
    let: "$r0" := (let: "$a0" := (let: "$Type" := raftpb.MsgTransferLeader in
    let: "$From" := (![uint64T] "transferee") in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= zero_val uint64T;
      "From" ::= "$From";
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= zero_val sliceT;
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* ForgetLeader forgets a follower's current leader, changing it to None.
   See (Node).ForgetLeader for details.

   go: rawnode.go:552:20 *)
Definition RawNode__ForgetLeader' : val :=
  rec: "RawNode__ForgetLeader'" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (let: "$Type" := raftpb.MsgForgetLeader in
     struct.make raftpb.Message [{
       "Type" ::= "$Type";
       "To" ::= zero_val uint64T;
       "From" ::= zero_val uint64T;
       "Term" ::= zero_val uint64T;
       "LogTerm" ::= zero_val uint64T;
       "Index" ::= zero_val uint64T;
       "Entries" ::= zero_val sliceT;
       "Commit" ::= zero_val uint64T;
       "Vote" ::= zero_val uint64T;
       "Snapshot" ::= zero_val ptrT;
       "Reject" ::= zero_val boolT;
       "RejectHint" ::= zero_val uint64T;
       "Context" ::= zero_val sliceT;
       "Responses" ::= zero_val sliceT
     }]) in
     ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ReadIndex requests a read state. The read state will be set in ready.
   Read State has a read index. Once the application advances further than the read
   index, any linearizable read requests issued before the read request can be
   processed safely. The read state will have the same rctx attached.

   go: rawnode.go:560:20 *)
Definition RawNode__ReadIndex' : val :=
  rec: "RawNode__ReadIndex'" "rn" "rctx" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rctx" := (ref_ty sliceT "rctx") in
    let: "$r0" := (let: "$a0" := (let: "$Type" := raftpb.MsgReadIndex in
    let: "$Entries" := ((let: "$sl0" := (let: "$Data" := (![sliceT] "rctx") in
    struct.make raftpb.Entry [{
      "Term" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Type" ::= zero_val raftpb.EntryType;
      "Data" ::= "$Data"
    }]) in
    slice.literal raftpb.Entry ["$sl0"])) in
    struct.make raftpb.Message [{
      "Type" ::= "$Type";
      "To" ::= zero_val uint64T;
      "From" ::= zero_val uint64T;
      "Term" ::= zero_val uint64T;
      "LogTerm" ::= zero_val uint64T;
      "Index" ::= zero_val uint64T;
      "Entries" ::= "$Entries";
      "Commit" ::= zero_val uint64T;
      "Vote" ::= zero_val uint64T;
      "Snapshot" ::= zero_val ptrT;
      "Reject" ::= zero_val boolT;
      "RejectHint" ::= zero_val uint64T;
      "Context" ::= zero_val sliceT;
      "Responses" ::= zero_val sliceT
    }]) in
    ((method_call raft' "Step" #()) (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

Definition ReadState' : (go_string * go_string) := (pkg_name', "ReadState").

Definition readIndexStatus' : (go_string * go_string) := (pkg_name', "readIndexStatus").

(* go: read_only.go:45:6 *)
Definition newReadOnly' : val :=
  rec: "newReadOnly'" "option" :=
    exception_do (let: "option" := (ref_ty ReadOnlyOption "option") in
    return: (ref_ty readOnly (let: "$option" := (![ReadOnlyOption] "option") in
     let: "$pendingReadIndex" := (map.make stringT ptrT #()) in
     struct.make readOnly [{
       "option" ::= "$option";
       "pendingReadIndex" ::= "$pendingReadIndex";
       "readIndexQueue" ::= zero_val sliceT
     }]))).

(* addRequest adds a read only request into readonly struct.
   `index` is the commit index of the raft state machine when it received
   the read only request.
   `m` is the original read only request message from the local or remote node.

   go: read_only.go:56:21 *)
Definition readOnly__addRequest' : val :=
  rec: "readOnly__addRequest'" "ro" "index" "m" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "index" := (ref_ty uint64T "index") in
    let: "s" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (string.from_bytes (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0))))) in
    do:  ("s" <-[stringT] "$r0");;;
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "s")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (#())
    else do:  #()));;;
    let: "$r0" := (ref_ty readIndexStatus (let: "$index" := (![uint64T] "index") in
    let: "$req" := (![raftpb.Message] "m") in
    let: "$acks" := (map.make uint64T boolT #()) in
    struct.make readIndexStatus [{
      "req" ::= "$req";
      "index" ::= "$index";
      "acks" ::= "$acks"
    }])) in
    do:  (map.insert (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "s") "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    let: "$a1" := ((let: "$sl0" := (![stringT] "s") in
    slice.literal stringT ["$sl0"])) in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ((struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro")) <-[sliceT] "$r0")).

(* recvAck notifies the readonly struct that the raft state machine received
   an acknowledgment of the heartbeat that attached with the read only request
   context.

   go: read_only.go:68:21 *)
Definition readOnly__recvAck' : val :=
  rec: "readOnly__recvAck'" "ro" "id" "context" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "context" := (ref_ty sliceT "context") in
    let: "id" := (ref_ty uint64T "id") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "rs" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (string.from_bytes (![sliceT] "context"))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rs" <-[ptrT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then return: (#null)
    else do:  #());;;
    let: "$r0" := #true in
    do:  (map.insert (![mapT uint64T boolT] (struct.field_ref readIndexStatus "acks" (![ptrT] "rs"))) (![uint64T] "id") "$r0");;;
    return: (![mapT uint64T boolT] (struct.field_ref readIndexStatus "acks" (![ptrT] "rs")))).

(* advance advances the read only request queue kept by the readonly struct.
   It dequeues the requests until it finds the read only request that has
   the same context as the given `m`.

   go: read_only.go:81:21 *)
Definition readOnly__advance' : val :=
  rec: "readOnly__advance'" "ro" "m" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty intT (zero_val intT)) in
    let: "ctx" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (string.from_bytes (![sliceT] (struct.field_ref raftpb.Message "Context" "m"))) in
    do:  ("ctx" <-[stringT] "$r0");;;
    let: "rss" := (ref_ty sliceT (zero_val sliceT)) in
    do:  (let: "$range" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    slice.for_range stringT "$range" (λ: <> "okctx",
      let: "okctx" := ref_ty stringT "okctx" in
      do:  ("i" <-[intT] ((![intT] "i") + #(W64 1)));;;
      let: "ok" := (ref_ty boolT (zero_val boolT)) in
      let: "rs" := (ref_ty ptrT (zero_val ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "okctx")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("rs" <-[ptrT] "$r0");;;
      do:  ("ok" <-[boolT] "$r1");;;
      (if: (~ (![boolT] "ok"))
      then
        do:  (let: "$a0" := (interface.make string' #"cannot find corresponding read state from pending map"%go) in
        Panic "$a0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![sliceT] "rss") in
      let: "$a1" := ((let: "$sl0" := (![ptrT] "rs") in
      slice.literal ptrT ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("rss" <-[sliceT] "$r0");;;
      (if: (![stringT] "okctx") = (![stringT] "ctx")
      then
        let: "$r0" := #true in
        do:  ("found" <-[boolT] "$r0");;;
        break: #()
      else do:  #())));;;
    (if: ![boolT] "found"
    then
      let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
      slice.slice stringT "$s" (![intT] "i") (slice.len "$s")) in
      do:  ((struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro")) <-[sliceT] "$r0");;;
      do:  (let: "$range" := (![sliceT] "rss") in
      slice.for_range ptrT "$range" (λ: <> "rs",
        let: "rs" := ref_ty ptrT "rs" in
        do:  (let: "$a0" := (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) in
        let: "$a1" := (string.from_bytes (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" (struct.field_ref readIndexStatus "req" (![ptrT] "rs")))) #(W64 0))))) in
        map.delete "$a0" "$a1")));;;
      return: (![sliceT] "rss")
    else do:  #());;;
    return: (#slice.nil)).

(* lastPendingRequestCtx returns the context of the last pending read only
   request in readonly struct.

   go: read_only.go:116:21 *)
Definition readOnly__lastPendingRequestCtx' : val :=
  rec: "readOnly__lastPendingRequestCtx'" "ro" <> :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    (if: (let: "$a0" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    slice.len "$a0") = #(W64 0)
    then return: (#""%go)
    else do:  #());;;
    return: (![stringT] (slice.elem_ref stringT (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) ((let: "$a0" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
     slice.len "$a0") - #(W64 1))))).

Definition StateTraceDeployed : expr := #false.

Definition TraceLogger' : (go_string * go_string) := (pkg_name', "TraceLogger").

Definition TracingEvent : go_type := structT [
].

Definition TracingEvent' : (go_string * go_string) := (pkg_name', "TracingEvent").

(* go: state_trace_nop.go:30:6 *)
Definition traceInitState' : val :=
  rec: "traceInitState'" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: state_trace_nop.go:32:6 *)
Definition traceReady' : val :=
  rec: "traceReady'" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: state_trace_nop.go:34:6 *)
Definition traceCommit' : val :=
  rec: "traceCommit'" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: state_trace_nop.go:36:6 *)
Definition traceReplicate' : val :=
  rec: "traceReplicate'" "" "" :=
    exception_do (let: "" := (ref_ty sliceT "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: state_trace_nop.go:38:6 *)
Definition traceBecomeFollower' : val :=
  rec: "traceBecomeFollower'" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: state_trace_nop.go:40:6 *)
Definition traceBecomeCandidate' : val :=
  rec: "traceBecomeCandidate'" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: state_trace_nop.go:42:6 *)
Definition traceBecomeLeader' : val :=
  rec: "traceBecomeLeader'" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: state_trace_nop.go:44:6 *)
Definition traceChangeConfEvent' : val :=
  rec: "traceChangeConfEvent'" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty raftpb.ConfChangeI "") in
    do:  #()).

(* go: state_trace_nop.go:46:6 *)
Definition traceConfChangeEvent' : val :=
  rec: "traceConfChangeEvent'" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty tracker.Config "") in
    do:  #()).

(* go: state_trace_nop.go:48:6 *)
Definition traceSendMessage' : val :=
  rec: "traceSendMessage'" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: state_trace_nop.go:50:6 *)
Definition traceReceiveMessage' : val :=
  rec: "traceReceiveMessage'" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

Definition Status' : (go_string * go_string) := (pkg_name', "Status").

Definition BasicStatus' : (go_string * go_string) := (pkg_name', "BasicStatus").

(* go: status.go:44:6 *)
Definition getProgressCopy' : val :=
  rec: "getProgressCopy'" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty (mapT uint64T tracker.Progress) (zero_val (mapT uint64T tracker.Progress))) in
    let: "$r0" := (map.make uint64T tracker.Progress #()) in
    do:  ("m" <-[mapT uint64T tracker.Progress] "$r0");;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "p" := (ref_ty tracker.Progress (zero_val tracker.Progress)) in
      let: "$r0" := (![tracker.Progress] (![ptrT] "pr")) in
      do:  ("p" <-[tracker.Progress] "$r0");;;
      let: "$r0" := (((method_call tracker.Inflights' "Clone" #()) (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) #()) in
      do:  ((struct.field_ref tracker.Progress "Inflights" "p") <-[ptrT] "$r0");;;
      let: "$r0" := #null in
      do:  ("pr" <-[ptrT] "$r0");;;
      let: "$r0" := (![tracker.Progress] "p") in
      do:  (map.insert (![mapT uint64T tracker.Progress] "m") (![uint64T] "id") "$r0"))
      ) in
    ((method_call tracker.ProgressTracker' "Visit" #()) (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
    return: (![mapT uint64T tracker.Progress] "m")).

Definition getProgressCopy : (go_string * go_string) := (pkg_name', "getProgressCopy"%go).

(* go: status.go:56:6 *)
Definition getBasicStatus' : val :=
  rec: "getBasicStatus'" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty BasicStatus (zero_val BasicStatus)) in
    let: "$r0" := (let: "$ID" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    let: "$LeadTransferee" := (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) in
    struct.make BasicStatus [{
      "ID" ::= "$ID";
      "HardState" ::= zero_val raftpb.HardState;
      "SoftState" ::= zero_val SoftState;
      "Applied" ::= zero_val uint64T;
      "LeadTransferee" ::= "$LeadTransferee"
    }]) in
    do:  ("s" <-[BasicStatus] "$r0");;;
    let: "$r0" := (((method_call raft' "hardState" #()) (![ptrT] "r")) #()) in
    do:  ((struct.field_ref BasicStatus "HardState" "s") <-[raftpb.HardState] "$r0");;;
    let: "$r0" := (((method_call raft' "softState" #()) (![ptrT] "r")) #()) in
    do:  ((struct.field_ref BasicStatus "SoftState" "s") <-[SoftState] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ((struct.field_ref BasicStatus "Applied" "s") <-[uint64T] "$r0");;;
    return: (![BasicStatus] "s")).

(* getStatus gets a copy of the current raft status.

   go: status.go:68:6 *)
Definition getStatus' : val :=
  rec: "getStatus'" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty Status (zero_val Status)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "r") in
    (func_call getBasicStatus #()) "$a0") in
    do:  ((struct.field_ref Status "BasicStatus" "s") <-[BasicStatus] "$r0");;;
    (if: (![StateType] (struct.field_ref SoftState "RaftState" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s")))) = StateLeader
    then
      let: "$r0" := (let: "$a0" := (![ptrT] "r") in
      (func_call getProgressCopy #()) "$a0") in
      do:  ((struct.field_ref Status "Progress" "s") <-[mapT uint64T tracker.Progress] "$r0")
    else do:  #());;;
    let: "$r0" := (((method_call tracker.Config' "Clone" #()) (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))) #()) in
    do:  ((struct.field_ref Status "Config" "s") <-[tracker.Config] "$r0");;;
    return: (![Status] "s")).

(* MarshalJSON translates the raft status into JSON.
   TODO: try to simplify this by introducing ID type into raft

   go: status.go:80:17 *)
Definition Status__MarshalJSON' : val :=
  rec: "Status__MarshalJSON'" "s" <> :=
    exception_do (let: "s" := (ref_ty Status "s") in
    let: "j" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (let: "$a0" := #"{""id"":""%x"",""term"":%d,""vote"":""%x"",""commit"":%d,""lead"":""%x"",""raftState"":%q,""applied"":%d,""progress"":{"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref BasicStatus "ID" (struct.field_ref Status "BasicStatus" "s")))) in
    let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.HardState "Term" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.HardState "Vote" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl3" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.HardState "Commit" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref SoftState "Lead" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl5" := (interface.make StateType' (![StateType] (struct.field_ref SoftState "RaftState" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl6" := (interface.make uint64' (![uint64T] (struct.field_ref BasicStatus "Applied" (struct.field_ref Status "BasicStatus" "s")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (func_call fmt.Sprintf #()) "$a0" "$a1") in
    do:  ("j" <-[stringT] "$r0");;;
    (if: (let: "$a0" := (![mapT uint64T tracker.Progress] (struct.field_ref Status "Progress" "s")) in
    map.len "$a0") = #(W64 0)
    then do:  ("j" <-[stringT] ((![stringT] "j") + #"},"%go))
    else
      do:  (map.for_range (![mapT uint64T tracker.Progress] (struct.field_ref Status "Progress" "s")) (λ: "k" "v",
        let: "subj" := (ref_ty stringT (zero_val stringT)) in
        let: "$r0" := (let: "$a0" := #"""%x"":{""match"":%d,""next"":%d,""state"":%q},"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "k")) in
        let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref tracker.Progress "Match" "v"))) in
        let: "$sl2" := (interface.make uint64' (![uint64T] (struct.field_ref tracker.Progress "Next" "v"))) in
        let: "$sl3" := (interface.make tracker.StateType' (![tracker.StateType] (struct.field_ref tracker.Progress "State" "v"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
        (func_call fmt.Sprintf #()) "$a0" "$a1") in
        do:  ("subj" <-[stringT] "$r0");;;
        do:  ("j" <-[stringT] ((![stringT] "j") + (![stringT] "subj")))));;;
      let: "$r0" := ((string.from_bytes (let: "$s" := (string.to_bytes (![stringT] "j")) in
      slice.slice byteT "$s" #(W64 0) ((let: "$a0" := (![stringT] "j") in
      StringLength "$a0") - #(W64 1)))) + #"},"%go) in
      do:  ("j" <-[stringT] "$r0"));;;
    do:  ("j" <-[stringT] ((![stringT] "j") + (let: "$a0" := #"""leadtransferee"":""%x""}"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref BasicStatus "LeadTransferee" (struct.field_ref Status "BasicStatus" "s")))) in
    slice.literal interfaceT ["$sl0"])) in
    (func_call fmt.Sprintf #()) "$a0" "$a1")));;;
    return: (string.to_bytes (![stringT] "j"), #interface.nil)).

(* go: status.go:99:17 *)
Definition Status__String' : val :=
  rec: "Status__String'" "s" <> :=
    exception_do (let: "s" := (ref_ty Status "s") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "b" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (((method_call Status' "MarshalJSON" #()) (![Status] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("b" <-[sliceT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := #"unexpected error: %v"%go in
      let: "$a1" := ((let: "$sl0" := (![error] "err") in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panicf" ((func_call getLogger #()) #())) "$a0" "$a1")
    else do:  #());;;
    return: (string.from_bytes (![sliceT] "b"))).

Definition ErrSnapOutOfDate : (go_string * go_string) := (pkg_name', "ErrSnapOutOfDate"%go).

Definition Storage' : (go_string * go_string) := (pkg_name', "Storage").

Definition inMemStorageCallStats' : (go_string * go_string) := (pkg_name', "inMemStorageCallStats").

(* NewMemoryStorage creates an empty MemoryStorage.

   go: storage.go:113:6 *)
Definition NewMemoryStorage' : val :=
  rec: "NewMemoryStorage'" <> :=
    exception_do (return: (ref_ty MemoryStorage (let: "$ents" := (slice.make2 raftpb.Entry #(W64 1)) in
     struct.make MemoryStorage [{
       "Mutex" ::= zero_val sync.Mutex;
       "hardState" ::= zero_val raftpb.HardState;
       "snapshot" ::= zero_val raftpb.Snapshot;
       "ents" ::= "$ents";
       "callStats" ::= zero_val inMemStorageCallStats
     }]))).

(* InitialState implements the Storage interface.

   go: storage.go:121:26 *)
Definition MemoryStorage__InitialState' : val :=
  rec: "MemoryStorage__InitialState'" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((struct.field_ref inMemStorageCallStats "initialState" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "initialState" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: (![raftpb.HardState] (struct.field_ref MemoryStorage "hardState" (![ptrT] "ms")), ![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))), #interface.nil)).

(* SetHardState saves the current HardState.

   go: storage.go:127:26 *)
Definition MemoryStorage__SetHardState' : val :=
  rec: "MemoryStorage__SetHardState'" "ms" "st" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "st" := (ref_ty raftpb.HardState "st") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := (![raftpb.HardState] "st") in
    do:  ((struct.field_ref MemoryStorage "hardState" (![ptrT] "ms")) <-[raftpb.HardState] "$r0");;;
    return: (#interface.nil)).

(* Entries implements the Storage interface.

   go: storage.go:135:26 *)
Definition MemoryStorage__Entries' : val :=
  rec: "MemoryStorage__Entries'" "ms" "lo" "hi" "maxSize" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "maxSize" := (ref_ty uint64T "maxSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "entries" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "entries" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "lo") ≤ (![uint64T] "offset")
    then return: (#slice.nil, ![error] (globals.get ErrCompacted #()))
    else do:  #());;;
    (if: (![uint64T] "hi") > ((((method_call MemoryStorage' "lastIndex" #()) (![ptrT] "ms")) #()) + #(W64 1))
    then
      do:  (let: "$a0" := #"entries' hi(%d) is out of bound lastindex(%d)"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "hi")) in
      let: "$sl1" := (interface.make uint64' (((method_call MemoryStorage' "lastIndex" #()) (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" ((func_call getLogger #()) #())) "$a0" "$a1")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") = #(W64 1)
    then return: (#slice.nil, ![error] (globals.get ErrUnavailable #()))
    else do:  #());;;
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (let: "$s" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.slice raftpb.Entry "$s" ((![uint64T] "lo") - (![uint64T] "offset")) ((![uint64T] "hi") - (![uint64T] "offset"))) in
    let: "$a1" := (![uint64T] "maxSize") in
    (func_call limitSize #()) "$a0" "$a1") in
    do:  ("ents" <-[sliceT] "$r0");;;
    return: (let: "$s" := (![sliceT] "ents") in
     slice.full_slice raftpb.Entry "$s" #(W64 0) (let: "$a0" := (![sliceT] "ents") in
     slice.len "$a0") (let: "$a0" := (![sliceT] "ents") in
     slice.len "$a0"), #interface.nil)).

(* Term implements the Storage interface.

   go: storage.go:159:26 *)
Definition MemoryStorage__Term' : val :=
  rec: "MemoryStorage__Term'" "ms" "i" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "i" := (ref_ty uint64T "i") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "term" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "term" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "i") < (![uint64T] "offset")
    then return: (#(W64 0), ![error] (globals.get ErrCompacted #()))
    else do:  #());;;
    (if: int_geq ((![uint64T] "i") - (![uint64T] "offset")) (let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0")
    then return: (#(W64 0), ![error] (globals.get ErrUnavailable #()))
    else do:  #());;;
    return: (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) ((![uint64T] "i") - (![uint64T] "offset")))), #interface.nil)).

(* LastIndex implements the Storage interface.

   go: storage.go:174:26 *)
Definition MemoryStorage__LastIndex' : val :=
  rec: "MemoryStorage__LastIndex'" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "lastIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "lastIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: (((method_call MemoryStorage' "lastIndex" #()) (![ptrT] "ms")) #(), #interface.nil)).

(* go: storage.go:181:26 *)
Definition MemoryStorage__lastIndex' : val :=
  rec: "MemoryStorage__lastIndex'" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    return: (((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) + (let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
     slice.len "$a0")) - #(W64 1))).

(* FirstIndex implements the Storage interface.

   go: storage.go:186:26 *)
Definition MemoryStorage__FirstIndex' : val :=
  rec: "MemoryStorage__FirstIndex'" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "firstIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "firstIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: (((method_call MemoryStorage' "firstIndex" #()) (![ptrT] "ms")) #(), #interface.nil)).

(* go: storage.go:193:26 *)
Definition MemoryStorage__firstIndex' : val :=
  rec: "MemoryStorage__firstIndex'" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    return: ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) + #(W64 1))).

(* Snapshot implements the Storage interface.

   go: storage.go:198:26 *)
Definition MemoryStorage__Snapshot' : val :=
  rec: "MemoryStorage__Snapshot'" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "snapshot" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "snapshot" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: (![raftpb.Snapshot] (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")), #interface.nil)).

(* ApplySnapshot overwrites the contents of this Storage object with
   those of the given snapshot.

   go: storage.go:207:26 *)
Definition MemoryStorage__ApplySnapshot' : val :=
  rec: "MemoryStorage__ApplySnapshot'" "ms" "snap" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "snap" := (ref_ty raftpb.Snapshot "snap") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "msIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms"))))) in
    do:  ("msIndex" <-[uint64T] "$r0");;;
    let: "snapIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snap"))) in
    do:  ("snapIndex" <-[uint64T] "$r0");;;
    (if: (![uint64T] "msIndex") ≥ (![uint64T] "snapIndex")
    then return: (![error] (globals.get ErrSnapOutOfDate #()))
    else do:  #());;;
    let: "$r0" := (![raftpb.Snapshot] "snap") in
    do:  ((struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")) <-[raftpb.Snapshot] "$r0");;;
    let: "$r0" := ((let: "$sl0" := (let: "$Term" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "snap"))) in
    let: "$Index" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snap"))) in
    struct.make raftpb.Entry [{
      "Term" ::= "$Term";
      "Index" ::= "$Index";
      "Type" ::= zero_val raftpb.EntryType;
      "Data" ::= zero_val sliceT
    }]) in
    slice.literal raftpb.Entry ["$sl0"])) in
    do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT] "$r0");;;
    return: (#interface.nil)).

(* CreateSnapshot makes a snapshot which can be retrieved with Snapshot() and
   can be used to reconstruct the state at that point.
   If any configuration changes have been made since the last compaction,
   the result of the last ApplyConfChange must be passed in.

   go: storage.go:227:26 *)
Definition MemoryStorage__CreateSnapshot' : val :=
  rec: "MemoryStorage__CreateSnapshot'" "ms" "i" "cs" "data" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "data" := (ref_ty sliceT "data") in
    let: "cs" := (ref_ty ptrT "cs") in
    let: "i" := (ref_ty uint64T "i") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: (![uint64T] "i") ≤ (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))))
    then
      return: (struct.make raftpb.Snapshot [{
         "Data" ::= zero_val sliceT;
         "Metadata" ::= zero_val raftpb.SnapshotMetadata
       }], ![error] (globals.get ErrSnapOutOfDate #()))
    else do:  #());;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "i") > (((method_call MemoryStorage' "lastIndex" #()) (![ptrT] "ms")) #())
    then
      do:  (let: "$a0" := #"snapshot %d is out of bound lastindex(%d)"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64' (((method_call MemoryStorage' "lastIndex" #()) (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" ((func_call getLogger #()) #())) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) ((![uint64T] "i") - (![uint64T] "offset"))))) in
    do:  ((struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[uint64T] "$r0");;;
    (if: (![ptrT] "cs") ≠ #null
    then
      let: "$r0" := (![raftpb.ConfState] (![ptrT] "cs")) in
      do:  ((struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[raftpb.ConfState] "$r0")
    else do:  #());;;
    let: "$r0" := (![sliceT] "data") in
    do:  ((struct.field_ref raftpb.Snapshot "Data" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms"))) <-[sliceT] "$r0");;;
    return: (![raftpb.Snapshot] (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")), #interface.nil)).

(* Compact discards all log entries prior to compactIndex.
   It is the application's responsibility to not attempt to compact an index
   greater than raftLog.applied.

   go: storage.go:251:26 *)
Definition MemoryStorage__Compact' : val :=
  rec: "MemoryStorage__Compact'" "ms" "compactIndex" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "compactIndex" := (ref_ty uint64T "compactIndex") in
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "compactIndex") ≤ (![uint64T] "offset")
    then return: (![error] (globals.get ErrCompacted #()))
    else do:  #());;;
    (if: (![uint64T] "compactIndex") > (((method_call MemoryStorage' "lastIndex" #()) (![ptrT] "ms")) #())
    then
      do:  (let: "$a0" := #"compact %d is out of bound lastindex(%d)"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "compactIndex")) in
      let: "$sl1" := (interface.make uint64' (((method_call MemoryStorage' "lastIndex" #()) (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" ((func_call getLogger #()) #())) "$a0" "$a1")
    else do:  #());;;
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] "compactIndex") - (![uint64T] "offset")) in
    do:  ("i" <-[uint64T] "$r0");;;
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 raftpb.Entry #(W64 1) ((let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") - (![uint64T] "i"))) in
    do:  ("ents" <-[sliceT] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) (![uint64T] "i")))) in
    do:  ((struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) (![uint64T] "i")))) in
    do:  ((struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0))) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
    let: "$a1" := (let: "$s" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.slice raftpb.Entry "$s" ((![uint64T] "i") + #(W64 1)) (slice.len "$s")) in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ("ents" <-[sliceT] "$r0");;;
    let: "$r0" := (![sliceT] "ents") in
    do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT] "$r0");;;
    return: (#interface.nil)).

(* Append the new entries to storage.
   TODO (xiangli): ensure the entries are continuous and
   entries[0].Index > ms.entries[0].Index

   go: storage.go:277:26 *)
Definition MemoryStorage__Append' : val :=
  rec: "MemoryStorage__Append'" "ms" "entries" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "entries" := (ref_ty sliceT "entries") in
    (if: (let: "$a0" := (![sliceT] "entries") in
    slice.len "$a0") = #(W64 0)
    then return: (#interface.nil)
    else do:  #());;;
    do:  (((method_call sync.Mutex' "Lock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := ((method_call sync.Mutex' "Unlock" #()) (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "first" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((method_call MemoryStorage' "firstIndex" #()) (![ptrT] "ms")) #()) in
    do:  ("first" <-[uint64T] "$r0");;;
    let: "last" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0)))) + (let: "$a0" := (![sliceT] "entries") in
    slice.len "$a0")) - #(W64 1)) in
    do:  ("last" <-[uint64T] "$r0");;;
    (if: (![uint64T] "last") < (![uint64T] "first")
    then return: (#interface.nil)
    else do:  #());;;
    (if: (![uint64T] "first") > (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0))))
    then
      let: "$r0" := (let: "$s" := (![sliceT] "entries") in
      slice.slice raftpb.Entry "$s" ((![uint64T] "first") - (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0))))) (slice.len "$s")) in
      do:  ("entries" <-[sliceT] "$r0")
    else do:  #());;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0)))) - (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0))))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") > (![uint64T] "offset"))
    then
      let: "$r0" := (let: "$a0" := (let: "$s" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
      slice.full_slice raftpb.Entry "$s" #(W64 0) (![uint64T] "offset") (![uint64T] "offset")) in
      let: "$a1" := (![sliceT] "entries") in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT] "$r0")
    else
      (if: "$sw" = ((let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
      slice.len "$a0") = (![uint64T] "offset"))
      then
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
        let: "$a1" := (![sliceT] "entries") in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT] "$r0")
      else
        do:  (let: "$a0" := #"missing log entry [last: %d, append at: %d]"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64' (((method_call MemoryStorage' "lastIndex" #()) (![ptrT] "ms")) #())) in
        let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0))))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" ((func_call getLogger #()) #())) "$a0" "$a1")));;;
    return: (#interface.nil)).

Definition entryID' : (go_string * go_string) := (pkg_name', "entryID").

(* pbEntryID returns the ID of the given raftpb.Entry.

   go: types.go:34:6 *)
Definition pbEntryID' : val :=
  rec: "pbEntryID'" "entry" :=
    exception_do (let: "entry" := (ref_ty ptrT "entry") in
    return: (let: "$term" := (![uint64T] (struct.field_ref raftpb.Entry "Term" (![ptrT] "entry"))) in
     let: "$index" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (![ptrT] "entry"))) in
     struct.make entryID [{
       "term" ::= "$term";
       "index" ::= "$index"
     }])).

Definition logSlice' : (go_string * go_string) := (pkg_name', "logSlice").

(* lastIndex returns the index of the last entry in this log slice. Returns
   prev.index if there are no entries.

   go: types.go:78:19 *)
Definition logSlice__lastIndex' : val :=
  rec: "logSlice__lastIndex'" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    return: ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "s"))) + (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "s")) in
     slice.len "$a0"))).

(* lastEntryID returns the ID of the last entry in this log slice, or prev if
   there are no entries.

   go: types.go:84:19 *)
Definition logSlice__lastEntryID' : val :=
  rec: "logSlice__lastEntryID'" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    (let: "ln" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "s")) in
    slice.len "$a0") in
    do:  ("ln" <-[intT] "$r0");;;
    (if: (![intT] "ln") ≠ #(W64 0)
    then
      return: (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref logSlice "entries" "s")) ((![intT] "ln") - #(W64 1))) in
       (func_call pbEntryID #()) "$a0")
    else do:  #()));;;
    return: (![entryID] (struct.field_ref logSlice "prev" "s"))).

(* valid returns nil iff the logSlice is a well-formed log slice. See logSlice
   comment for details on what constitutes a valid raft log slice.

   go: types.go:93:19 *)
Definition logSlice__valid' : val :=
  rec: "logSlice__valid'" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    let: "prev" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (![entryID] (struct.field_ref logSlice "prev" "s")) in
    do:  ("prev" <-[entryID] "$r0");;;
    do:  (let: "$range" := (![sliceT] (struct.field_ref logSlice "entries" "s")) in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      let: "id" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref logSlice "entries" "s")) (![intT] "i")) in
      (func_call pbEntryID #()) "$a0") in
      do:  ("id" <-[entryID] "$r0");;;
      (if: ((![uint64T] (struct.field_ref entryID "term" "id")) < (![uint64T] (struct.field_ref entryID "term" "prev"))) || ((![uint64T] (struct.field_ref entryID "index" "id")) ≠ ((![uint64T] (struct.field_ref entryID "index" "prev")) + #(W64 1)))
      then
        return: (let: "$a0" := #"leader term %d: entries %+v and %+v not consistent"%go in
         let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref logSlice "term" "s"))) in
         let: "$sl1" := (interface.make entryID' (![entryID] "prev")) in
         let: "$sl2" := (interface.make entryID' (![entryID] "id")) in
         slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
         (func_call fmt.Errorf #()) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (![entryID] "id") in
      do:  ("prev" <-[entryID] "$r0")));;;
    (if: (![uint64T] (struct.field_ref logSlice "term" "s")) < (![uint64T] (struct.field_ref entryID "term" "prev"))
    then
      return: (let: "$a0" := #"leader term %d: entry %+v has a newer term"%go in
       let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref logSlice "term" "s"))) in
       let: "$sl1" := (interface.make entryID' (![entryID] "prev")) in
       slice.literal interfaceT ["$sl0"; "$sl1"])) in
       (func_call fmt.Errorf #()) "$a0" "$a1")
    else do:  #());;;
    return: (#interface.nil)).

(* go: util.go:25:21 *)
Definition StateType__MarshalJSON' : val :=
  rec: "StateType__MarshalJSON'" "st" <> :=
    exception_do (let: "st" := (ref_ty StateType "st") in
    return: (string.to_bytes (let: "$a0" := #"%q"%go in
     let: "$a1" := ((let: "$sl0" := (interface.make string' (((method_call StateType' "String" #()) (![StateType] "st")) #())) in
     slice.literal interfaceT ["$sl0"])) in
     (func_call fmt.Sprintf #()) "$a0" "$a1"), #interface.nil)).

Definition isLocalMsg : (go_string * go_string) := (pkg_name', "isLocalMsg"%go).

Definition isResponseMsg : (go_string * go_string) := (pkg_name', "isResponseMsg"%go).

(* go: util.go:52:6 *)
Definition isMsgInArray' : val :=
  rec: "isMsgInArray'" "msgt" "arr" :=
    exception_do (let: "arr" := (ref_ty sliceT "arr") in
    let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    let: "i" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (to_u64 (![raftpb.MessageType] "msgt")) in
    do:  ("i" <-[intT] "$r0");;;
    return: ((int_lt (![intT] "i") (let: "$a0" := (![sliceT] "arr") in
     slice.len "$a0")) && (![boolT] (slice.elem_ref boolT (![sliceT] "arr") (![intT] "i"))))).

Definition isMsgInArray : (go_string * go_string) := (pkg_name', "isMsgInArray"%go).

(* go: util.go:57:6 *)
Definition IsLocalMsg' : val :=
  rec: "IsLocalMsg'" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    return: (let: "$a0" := (![raftpb.MessageType] "msgt") in
     let: "$a1" := (let: "$a" := (globals.get isLocalMsg #()) in
     array.slice "$a" #(W64 0) (array.len (arrayT 23 boolT))) in
     (func_call isMsgInArray #()) "$a0" "$a1")).

(* go: util.go:61:6 *)
Definition IsResponseMsg' : val :=
  rec: "IsResponseMsg'" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    return: (let: "$a0" := (![raftpb.MessageType] "msgt") in
     let: "$a1" := (let: "$a" := (globals.get isResponseMsg #()) in
     array.slice "$a" #(W64 0) (array.len (arrayT 23 boolT))) in
     (func_call isMsgInArray #()) "$a0" "$a1")).

(* go: util.go:65:6 *)
Definition IsLocalMsgTarget' : val :=
  rec: "IsLocalMsgTarget'" "id" :=
    exception_do (let: "id" := (ref_ty uint64T "id") in
    return: (((![uint64T] "id") = LocalAppendThread) || ((![uint64T] "id") = LocalApplyThread))).

(* voteResponseType maps vote and prevote message types to their corresponding responses.

   go: util.go:70:6 *)
Definition voteRespMsgType' : val :=
  rec: "voteRespMsgType'" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    let: "$sw" := (![raftpb.MessageType] "msgt") in
    (if: "$sw" = raftpb.MsgVote
    then return: (raftpb.MsgVoteResp)
    else
      (if: "$sw" = raftpb.MsgPreVote
      then return: (raftpb.MsgPreVoteResp)
      else
        do:  (let: "$a0" := (interface.make string' (let: "$a0" := #"not a vote message: %s"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType' (![raftpb.MessageType] "msgt")) in
        slice.literal interfaceT ["$sl0"])) in
        (func_call fmt.Sprintf #()) "$a0" "$a1")) in
        Panic "$a0")))).

(* go: util.go:81:6 *)
Definition DescribeHardState' : val :=
  rec: "DescribeHardState'" "hs" :=
    exception_do (let: "hs" := (ref_ty raftpb.HardState "hs") in
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
    let: "$a1" := #"Term:%d"%go in
    let: "$a2" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.HardState "Term" "hs"))) in
    slice.literal interfaceT ["$sl0"])) in
    (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2");;;
    (if: (![uint64T] (struct.field_ref raftpb.HardState "Vote" "hs")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
      let: "$a1" := #" Vote:%d"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.HardState "Vote" "hs"))) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
    let: "$a1" := #" Commit:%d"%go in
    let: "$a2" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.HardState "Commit" "hs"))) in
    slice.literal interfaceT ["$sl0"])) in
    (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2");;;
    return: (((method_call strings.Builder' "String" #()) "buf") #())).

Definition DescribeHardState : (go_string * go_string) := (pkg_name', "DescribeHardState"%go).

(* go: util.go:91:6 *)
Definition DescribeSoftState' : val :=
  rec: "DescribeSoftState'" "ss" :=
    exception_do (let: "ss" := (ref_ty SoftState "ss") in
    return: (let: "$a0" := #"Lead:%d State:%s"%go in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref SoftState "Lead" "ss"))) in
     let: "$sl1" := (interface.make StateType' (![StateType] (struct.field_ref SoftState "RaftState" "ss"))) in
     slice.literal interfaceT ["$sl0"; "$sl1"])) in
     (func_call fmt.Sprintf #()) "$a0" "$a1")).

Definition DescribeSoftState : (go_string * go_string) := (pkg_name', "DescribeSoftState"%go).

(* go: util.go:95:6 *)
Definition DescribeConfState' : val :=
  rec: "DescribeConfState'" "state" :=
    exception_do (let: "state" := (ref_ty raftpb.ConfState "state") in
    return: (let: "$a0" := #"Voters:%v VotersOutgoing:%v Learners:%v LearnersNext:%v AutoLeave:%v"%go in
     let: "$a1" := ((let: "$sl0" := (interface.make slice' (![sliceT] (struct.field_ref raftpb.ConfState "Voters" "state"))) in
     let: "$sl1" := (interface.make slice' (![sliceT] (struct.field_ref raftpb.ConfState "VotersOutgoing" "state"))) in
     let: "$sl2" := (interface.make slice' (![sliceT] (struct.field_ref raftpb.ConfState "Learners" "state"))) in
     let: "$sl3" := (interface.make slice' (![sliceT] (struct.field_ref raftpb.ConfState "LearnersNext" "state"))) in
     let: "$sl4" := (interface.make bool' (![boolT] (struct.field_ref raftpb.ConfState "AutoLeave" "state"))) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
     (func_call fmt.Sprintf #()) "$a0" "$a1")).

Definition DescribeConfState : (go_string * go_string) := (pkg_name', "DescribeConfState"%go).

(* go: util.go:102:6 *)
Definition DescribeSnapshot' : val :=
  rec: "DescribeSnapshot'" "snap" :=
    exception_do (let: "snap" := (ref_ty raftpb.Snapshot "snap") in
    let: "m" := (ref_ty raftpb.SnapshotMetadata (zero_val raftpb.SnapshotMetadata)) in
    let: "$r0" := (![raftpb.SnapshotMetadata] (struct.field_ref raftpb.Snapshot "Metadata" "snap")) in
    do:  ("m" <-[raftpb.SnapshotMetadata] "$r0");;;
    return: (let: "$a0" := #"Index:%d Term:%d ConfState:%s"%go in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" "m"))) in
     let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" "m"))) in
     let: "$sl2" := (interface.make string' (let: "$a0" := (![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" "m")) in
     (func_call DescribeConfState #()) "$a0")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
     (func_call fmt.Sprintf #()) "$a0" "$a1")).

Definition DescribeSnapshot : (go_string * go_string) := (pkg_name', "DescribeSnapshot"%go).

Definition EntryFormatter : go_type := funcT.

Definition DescribeEntries : (go_string * go_string) := (pkg_name', "DescribeEntries"%go).

(* go: util.go:107:6 *)
Definition DescribeReady' : val :=
  rec: "DescribeReady'" "rd" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "rd" := (ref_ty Ready "rd") in
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    (if: (![ptrT] (struct.field_ref Ready "SoftState" "rd")) ≠ #null
    then
      do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string' (let: "$a0" := (![SoftState] (![ptrT] (struct.field_ref Ready "SoftState" "rd"))) in
      (func_call DescribeSoftState #()) "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprint #()) "$a0" "$a1");;;
      do:  (let: "$a0" := #(W8 10) in
      ((method_call strings.Builder' "WriteByte" #()) "buf") "$a0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    (func_call IsEmptyHardState #()) "$a0"))
    then
      do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
      let: "$a1" := #"HardState %s"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make string' (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
      (func_call DescribeHardState #()) "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2");;;
      do:  (let: "$a0" := #(W8 10) in
      ((method_call strings.Builder' "WriteByte" #()) "buf") "$a0")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "ReadStates" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
      let: "$a1" := #"ReadStates %v
      "%go in
      let: "$a2" := ((let: "$sl0" := (interface.make slice' (![sliceT] (struct.field_ref Ready "ReadStates" "rd"))) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #"Entries:
      "%go in
      ((method_call strings.Builder' "WriteString" #()) "buf") "$a0");;;
      do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string' (let: "$a0" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
      let: "$a1" := (![EntryFormatter] "f") in
      (func_call DescribeEntries #()) "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprint #()) "$a0" "$a1")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    (func_call IsEmptySnap #()) "$a0"))
    then
      do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
      let: "$a1" := #"Snapshot %s
      "%go in
      let: "$a2" := ((let: "$sl0" := (interface.make string' (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      (func_call DescribeSnapshot #()) "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #"CommittedEntries:
      "%go in
      ((method_call strings.Builder' "WriteString" #()) "buf") "$a0");;;
      do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string' (let: "$a0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
      let: "$a1" := (![EntryFormatter] "f") in
      (func_call DescribeEntries #()) "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprint #()) "$a0" "$a1")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #"Messages:
      "%go in
      ((method_call strings.Builder' "WriteString" #()) "buf") "$a0");;;
      do:  (let: "$range" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
      slice.for_range raftpb.Message "$range" (λ: <> "msg",
        let: "msg" := ref_ty raftpb.Message "msg" in
        do:  (let: "$a0" := (interface.make strings.Builder'ptr "buf") in
        let: "$a1" := ((let: "$sl0" := (interface.make string' (let: "$a0" := (![raftpb.Message] "msg") in
        let: "$a1" := (![EntryFormatter] "f") in
        (func_call DescribeMessage #()) "$a0" "$a1")) in
        slice.literal interfaceT ["$sl0"])) in
        (func_call fmt.Fprint #()) "$a0" "$a1");;;
        do:  (let: "$a0" := #(W8 10) in
        ((method_call strings.Builder' "WriteByte" #()) "buf") "$a0")))
    else do:  #());;;
    (if: int_gt (((method_call strings.Builder' "Len" #()) "buf") #()) #(W64 0)
    then
      return: (let: "$a0" := #"Ready MustSync=%t:
       %s"%go in
       let: "$a1" := ((let: "$sl0" := (interface.make bool' (![boolT] (struct.field_ref Ready "MustSync" "rd"))) in
       let: "$sl1" := (interface.make string' (((method_call strings.Builder' "String" #()) "buf") #())) in
       slice.literal interfaceT ["$sl0"; "$sl1"])) in
       (func_call fmt.Sprintf #()) "$a0" "$a1")
    else do:  #());;;
    return: (#"<empty Ready>"%go)).

Definition DescribeReady : (go_string * go_string) := (pkg_name', "DescribeReady"%go).

Definition EntryFormatter' : (go_string * go_string) := (pkg_name', "EntryFormatter").

Definition describeMessageWithIndent : (go_string * go_string) := (pkg_name', "describeMessageWithIndent"%go).

(* DescribeMessage returns a concise human-readable description of a
   Message for debugging.

   go: util.go:150:6 *)
Definition DescribeMessage' : val :=
  rec: "DescribeMessage'" "m" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "m" := (ref_ty raftpb.Message "m") in
    return: (let: "$a0" := #""%go in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := (![EntryFormatter] "f") in
     (func_call describeMessageWithIndent #()) "$a0" "$a1" "$a2")).

Definition DescribeEntry : (go_string * go_string) := (pkg_name', "DescribeEntry"%go).

Definition describeTarget : (go_string * go_string) := (pkg_name', "describeTarget"%go).

(* go: util.go:154:6 *)
Definition describeMessageWithIndent' : val :=
  rec: "describeMessageWithIndent'" "indent" "m" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "indent" := (ref_ty stringT "indent") in
    let: "buf" := (ref_ty bytes.Buffer (zero_val bytes.Buffer)) in
    do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
    let: "$a1" := #"%s%s->%s %v Term:%d Log:%d/%d"%go in
    let: "$a2" := ((let: "$sl0" := (interface.make string' (![stringT] "indent")) in
    let: "$sl1" := (interface.make string' (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    (func_call describeTarget #()) "$a0")) in
    let: "$sl2" := (interface.make string' (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "To" "m")) in
    (func_call describeTarget #()) "$a0")) in
    let: "$sl3" := (interface.make raftpb.MessageType' (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
    let: "$sl4" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
    let: "$sl5" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
    let: "$sl6" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2");;;
    (if: ![boolT] (struct.field_ref raftpb.Message "Reject" "m")
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
      let: "$a1" := #" Rejected (Hint: %d)"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
      let: "$a1" := #" Commit:%d"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Commit" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref raftpb.Message "Vote" "m")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
      let: "$a1" := #" Vote:%d"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Message "Vote" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (let: "ln" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
    slice.len "$a0") in
    do:  ("ln" <-[intT] "$r0");;;
    (if: (![intT] "ln") = #(W64 1)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
      let: "$a1" := #" Entries:[%s]"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make string' (let: "$a0" := (![raftpb.Entry] (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0))) in
      let: "$a1" := (![EntryFormatter] "f") in
      (func_call DescribeEntry #()) "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else
      (if: int_gt (![intT] "ln") #(W64 1)
      then
        do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
        let: "$a1" := ((let: "$sl0" := (interface.make string' #" Entries:["%go) in
        slice.literal interfaceT ["$sl0"])) in
        (func_call fmt.Fprint #()) "$a0" "$a1");;;
        do:  (let: "$range" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
        slice.for_range raftpb.Entry "$range" (λ: <> "e",
          let: "e" := ref_ty raftpb.Entry "e" in
          do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
          let: "$a1" := #"
          %s  "%go in
          let: "$a2" := ((let: "$sl0" := (interface.make string' (![stringT] "indent")) in
          slice.literal interfaceT ["$sl0"])) in
          (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2");;;
          do:  (let: "$a0" := (let: "$a0" := (![raftpb.Entry] "e") in
          let: "$a1" := (![EntryFormatter] "f") in
          (func_call DescribeEntry #()) "$a0" "$a1") in
          ((method_call bytes.Buffer' "WriteString" #()) "buf") "$a0")));;;
        do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
        let: "$a1" := #"
        %s]"%go in
        let: "$a2" := ((let: "$sl0" := (interface.make string' (![stringT] "indent")) in
        slice.literal interfaceT ["$sl0"])) in
        (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
      else do:  #())));;;
    (let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
    do:  ("s" <-[ptrT] "$r0");;;
    (if: ((![ptrT] "s") ≠ #null) && (~ (let: "$a0" := (![raftpb.Snapshot] (![ptrT] "s")) in
    (func_call IsEmptySnap #()) "$a0"))
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
      let: "$a1" := #"
      %s  Snapshot: %s"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make string' (![stringT] "indent")) in
      let: "$sl1" := (interface.make string' (let: "$a0" := (![raftpb.Snapshot] (![ptrT] "s")) in
      (func_call DescribeSnapshot #()) "$a0")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else do:  #()));;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Responses" "m")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
      let: "$a1" := #" Responses:["%go in
      let: "$a2" := #slice.nil in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2");;;
      do:  (let: "$range" := (![sliceT] (struct.field_ref raftpb.Message "Responses" "m")) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        do:  (let: "$a0" := #"
        "%go in
        ((method_call bytes.Buffer' "WriteString" #()) "buf") "$a0");;;
        do:  (let: "$a0" := (let: "$a0" := ((![stringT] "indent") + #"  "%go) in
        let: "$a1" := (![raftpb.Message] "m") in
        let: "$a2" := (![EntryFormatter] "f") in
        (func_call describeMessageWithIndent #()) "$a0" "$a1" "$a2") in
        ((method_call bytes.Buffer' "WriteString" #()) "buf") "$a0")));;;
      do:  (let: "$a0" := (interface.make bytes.Buffer'ptr "buf") in
      let: "$a1" := #"
      %s]"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make string' (![stringT] "indent")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call fmt.Fprintf #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    return: (((method_call bytes.Buffer' "String" #()) "buf") #())).

(* go: util.go:191:6 *)
Definition describeTarget' : val :=
  rec: "describeTarget'" "id" :=
    exception_do (let: "id" := (ref_ty uint64T "id") in
    let: "$sw" := (![uint64T] "id") in
    (if: "$sw" = None
    then return: (#"None"%go)
    else
      (if: "$sw" = LocalAppendThread
      then return: (#"AppendThread"%go)
      else
        (if: "$sw" = LocalApplyThread
        then return: (#"ApplyThread"%go)
        else
          return: (let: "$a0" := #"%x"%go in
           let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] "id")) in
           slice.literal interfaceT ["$sl0"])) in
           (func_call fmt.Sprintf #()) "$a0" "$a1"))))).

(* DescribeEntry returns a concise human-readable description of an
   Entry for debugging.

   go: util.go:206:6 *)
Definition DescribeEntry' : val :=
  rec: "DescribeEntry'" "e" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "e" := (ref_ty raftpb.Entry "e") in
    (if: (![EntryFormatter] "f") = #func.nil
    then
      let: "$r0" := (λ: "data",
        exception_do (let: "data" := (ref_ty sliceT "data") in
        return: (let: "$a0" := #"%q"%go in
         let: "$a1" := ((let: "$sl0" := (interface.make slice' (![sliceT] "data")) in
         slice.literal interfaceT ["$sl0"])) in
         (func_call fmt.Sprintf #()) "$a0" "$a1"))
        ) in
      do:  ("f" <-[EntryFormatter] "$r0")
    else do:  #());;;
    let: "formatConfChange" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (λ: "cc",
      exception_do (let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
      return: (let: "$a0" := (struct.field_get raftpb.ConfChangeV2 "Changes" ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #())) in
       (func_call raftpb.ConfChangesToString #()) "$a0"))
      ) in
    do:  ("formatConfChange" <-[funcT] "$r0");;;
    let: "formatted" := (ref_ty stringT (zero_val stringT)) in
    let: "$sw" := (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" "e")) in
    (if: "$sw" = raftpb.EntryNormal
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" "e")) in
      (![EntryFormatter] "f") "$a0") in
      do:  ("formatted" <-[stringT] "$r0")
    else
      (if: "$sw" = raftpb.EntryConfChange
      then
        let: "cc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
        (let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" "e")) in
        ((method_call raftpb.ConfChange' "Unmarshal" #()) "cc") "$a0") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ #interface.nil
        then
          let: "$r0" := ((interface.get "Error" (![error] "err")) #()) in
          do:  ("formatted" <-[stringT] "$r0")
        else
          let: "$r0" := (let: "$a0" := (interface.make raftpb.ConfChange' (![raftpb.ConfChange] "cc")) in
          (![funcT] "formatConfChange") "$a0") in
          do:  ("formatted" <-[stringT] "$r0")))
      else
        (if: "$sw" = raftpb.EntryConfChangeV2
        then
          let: "cc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
          (let: "err" := (ref_ty error (zero_val error)) in
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" "e")) in
          ((method_call raftpb.ConfChangeV2' "Unmarshal" #()) "cc") "$a0") in
          do:  ("err" <-[error] "$r0");;;
          (if: (![error] "err") ≠ #interface.nil
          then
            let: "$r0" := ((interface.get "Error" (![error] "err")) #()) in
            do:  ("formatted" <-[stringT] "$r0")
          else
            let: "$r0" := (let: "$a0" := (interface.make raftpb.ConfChangeV2' (![raftpb.ConfChangeV2] "cc")) in
            (![funcT] "formatConfChange") "$a0") in
            do:  ("formatted" <-[stringT] "$r0")))
        else #())));;;
    (if: (![stringT] "formatted") ≠ #""%go
    then
      let: "$r0" := (#" "%go + (![stringT] "formatted")) in
      do:  ("formatted" <-[stringT] "$r0")
    else do:  #());;;
    return: (let: "$a0" := #"%d/%d %s%s"%go in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Entry "Term" "e"))) in
     let: "$sl1" := (interface.make uint64' (![uint64T] (struct.field_ref raftpb.Entry "Index" "e"))) in
     let: "$sl2" := (interface.make raftpb.EntryType' (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" "e"))) in
     let: "$sl3" := (interface.make string' (![stringT] "formatted")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
     (func_call fmt.Sprintf #()) "$a0" "$a1")).

(* DescribeEntries calls DescribeEntry for each Entry, adding a newline to
   each.

   go: util.go:244:6 *)
Definition DescribeEntries' : val :=
  rec: "DescribeEntries'" "ents" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "ents" := (ref_ty sliceT "ents") in
    let: "buf" := (ref_ty bytes.Buffer (zero_val bytes.Buffer)) in
    do:  (let: "$range" := (![sliceT] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "e",
      let: "e" := ref_ty raftpb.Entry "e" in
      let: ("$ret0", "$ret1") := (let: "$a0" := ((let: "$a0" := (![raftpb.Entry] "e") in
      let: "$a1" := (![EntryFormatter] "f") in
      (func_call DescribeEntry #()) "$a0" "$a1") + #"
      "%go) in
      ((method_call bytes.Buffer' "WriteString" #()) "buf") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  "$r1"));;;
    return: (((method_call bytes.Buffer' "String" #()) "buf") #())).

(* go: util.go:256:6 *)
Definition entsSize' : val :=
  rec: "entsSize'" "ents" :=
    exception_do (let: "ents" := (ref_ty sliceT "ents") in
    let: "size" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    do:  (let: "$range" := (![sliceT] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "ent",
      let: "ent" := ref_ty raftpb.Entry "ent" in
      do:  ("size" <-[entryEncodingSize] ((![entryEncodingSize] "size") + (((method_call raftpb.Entry' "Size" #()) "ent") #())))));;;
    return: (![entryEncodingSize] "size")).

(* limitSize returns the longest prefix of the given entries slice, such that
   its total byte size does not exceed maxSize. Always returns a non-empty slice
   if the input is non-empty, so, as an exception, if the size of the first
   entry exceeds maxSize, a non-empty slice with just this entry is returned.

   go: util.go:268:6 *)
Definition limitSize' : val :=
  rec: "limitSize'" "ents" "maxSize" :=
    exception_do (let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "ents" := (ref_ty sliceT "ents") in
    (if: (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") = #(W64 0)
    then return: (![sliceT] "ents")
    else do:  #());;;
    let: "size" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (((method_call raftpb.Entry' "Size" #()) (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0))) #()) in
    do:  ("size" <-[intT] "$r0");;;
    (let: "limit" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 1) in
    do:  ("limit" <-[intT] "$r0");;;
    (for: (λ: <>, int_lt (![intT] "limit") (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0")); (λ: <>, do:  ("limit" <-[intT] ((![intT] "limit") + #(W64 1)))) := λ: <>,
      do:  ("size" <-[intT] ((![intT] "size") + (((method_call raftpb.Entry' "Size" #()) (slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "limit"))) #())));;;
      (if: (![intT] "size") > (![entryEncodingSize] "maxSize")
      then
        return: (let: "$s" := (![sliceT] "ents") in
         slice.slice raftpb.Entry "$s" #(W64 0) (![intT] "limit"))
      else do:  #())));;;
    return: (![sliceT] "ents")).

Definition entryPayloadSize' : (go_string * go_string) := (pkg_name', "entryPayloadSize").

(* payloadSize is the size of the payload of the provided entry.

   go: util.go:289:6 *)
Definition payloadSize' : val :=
  rec: "payloadSize'" "e" :=
    exception_do (let: "e" := (ref_ty raftpb.Entry "e") in
    return: (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" "e")) in
     slice.len "$a0")).

Definition payloadSize : (go_string * go_string) := (pkg_name', "payloadSize"%go).

(* payloadsSize is the size of the payloads of the provided entries.

   go: util.go:294:6 *)
Definition payloadsSize' : val :=
  rec: "payloadsSize'" "ents" :=
    exception_do (let: "ents" := (ref_ty sliceT "ents") in
    let: "s" := (ref_ty entryPayloadSize (zero_val entryPayloadSize)) in
    do:  (let: "$range" := (![sliceT] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "e",
      let: "e" := ref_ty raftpb.Entry "e" in
      do:  ("s" <-[entryPayloadSize] ((![entryPayloadSize] "s") + (let: "$a0" := (![raftpb.Entry] "e") in
      (func_call payloadSize #()) "$a0")))));;;
    return: (![entryPayloadSize] "s")).

(* go: util.go:302:6 *)
Definition assertConfStatesEquivalent' : val :=
  rec: "assertConfStatesEquivalent'" "l" "cs1" "cs2" :=
    exception_do (let: "cs2" := (ref_ty raftpb.ConfState "cs2") in
    let: "cs1" := (ref_ty raftpb.ConfState "cs1") in
    let: "l" := (ref_ty Logger "l") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![raftpb.ConfState] "cs2") in
    ((method_call raftpb.ConfState' "Equivalent" #()) (![raftpb.ConfState] "cs1")) "$a0") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") = #interface.nil
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := ((let: "$sl0" := (![error] "err") in
    slice.literal interfaceT ["$sl0"])) in
    (interface.get "Panic" (![Logger] "l")) "$a0")).

(* extend appends vals to the given dst slice. It differs from the standard
   slice append only in the way it allocates memory. If cap(dst) is not enough
   for appending the values, precisely size len(dst)+len(vals) is allocated.

   Use this instead of standard append in situations when this is the last
   append to dst, so there is no sense in allocating more than needed.

   go: util.go:316:6 *)
Definition extend' : val :=
  rec: "extend'" "dst" "vals" :=
    exception_do (let: "vals" := (ref_ty sliceT "vals") in
    let: "dst" := (ref_ty sliceT "dst") in
    let: "need" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((let: "$a0" := (![sliceT] "dst") in
    slice.len "$a0") + (let: "$a0" := (![sliceT] "vals") in
    slice.len "$a0")) in
    do:  ("need" <-[intT] "$r0");;;
    (if: int_leq (![intT] "need") (let: "$a0" := (![sliceT] "dst") in
    slice.cap "$a0")
    then
      return: (let: "$a0" := (![sliceT] "dst") in
       let: "$a1" := (![sliceT] "vals") in
       (slice.append sliceT) "$a0" "$a1")
    else do:  #());;;
    let: "buf" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 raftpb.Entry (![intT] "need") (![intT] "need")) in
    do:  ("buf" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := (![sliceT] "buf") in
    let: "$a1" := (![sliceT] "dst") in
    (slice.copy raftpb.Entry) "$a0" "$a1");;;
    do:  (let: "$a0" := (let: "$s" := (![sliceT] "buf") in
    slice.slice raftpb.Entry "$s" (let: "$a0" := (![sliceT] "dst") in
    slice.len "$a0") (slice.len "$s")) in
    let: "$a1" := (![sliceT] "vals") in
    (slice.copy raftpb.Entry) "$a0" "$a1");;;
    return: (![sliceT] "buf")).

Definition define' : val :=
  rec: "define'" <> :=
    exception_do (do:  (globals.put isResponseMsg (ref_ty (arrayT 23 boolT) (zero_val (arrayT 23 boolT))));;;
    do:  (globals.put isLocalMsg (ref_ty (arrayT 23 boolT) (zero_val (arrayT 23 boolT))));;;
    do:  (globals.put ErrSnapshotTemporarilyUnavailable (ref_ty error (zero_val error)));;;
    do:  (globals.put ErrUnavailable (ref_ty error (zero_val error)));;;
    do:  (globals.put ErrSnapOutOfDate (ref_ty error (zero_val error)));;;
    do:  (globals.put ErrCompacted (ref_ty error (zero_val error)));;;
    do:  (globals.put ErrStepPeerNotFound (ref_ty error (zero_val error)));;;
    do:  (globals.put ErrStepLocalMsg (ref_ty error (zero_val error)));;;
    do:  (globals.put nopStepper (ref_ty ptrT (zero_val ptrT)));;;
    do:  (globals.put stepFollowerGlobal (ref_ty funcT (zero_val funcT)));;;
    do:  (globals.put stepCandidateGlobal (ref_ty funcT (zero_val funcT)));;;
    do:  (globals.put stepLeaderGlobal (ref_ty funcT (zero_val funcT)));;;
    do:  (globals.put errBreak (ref_ty error (zero_val error)));;;
    do:  (globals.put stmap (ref_ty (arrayT 4 stringT) (zero_val (arrayT 4 stringT))));;;
    do:  (globals.put globalRand (ref_ty ptrT (zero_val ptrT)));;;
    do:  (globals.put ErrProposalDropped (ref_ty error (zero_val error)));;;
    do:  (globals.put ErrStopped (ref_ty error (zero_val error)));;;
    do:  (globals.put emptyState (ref_ty raftpb.HardState (zero_val raftpb.HardState)));;;
    do:  (globals.put raftLogger (ref_ty Logger (zero_val Logger)));;;
    do:  (globals.put raftLoggerMu (ref_ty sync.Mutex (zero_val sync.Mutex)));;;
    do:  (globals.put discardLogger (ref_ty ptrT (zero_val ptrT)));;;
    do:  (globals.put defaultLogger (ref_ty ptrT (zero_val ptrT)))).

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init pkg_name' (λ: <>,
      exception_do (do:  testing.initialize';;;
      do:  assert.initialize';;;
      do:  tracker.initialize';;;
      do:  quorum.initialize';;;
      do:  confchange.initialize';;;
      do:  strings.initialize';;;
      do:  sort.initialize';;;
      do:  big.initialize';;;
      do:  math.initialize';;;
      do:  rand.initialize';;;
      do:  bytes.initialize';;;
      do:  context.initialize';;;
      do:  sync.initialize';;;
      do:  os.initialize';;;
      do:  log.initialize';;;
      do:  io.initialize';;;
      do:  fmt.initialize';;;
      do:  raftpb.initialize';;;
      do:  errors.initialize';;;
      do:  (define' #());;;
      let: "$r0" := (ref_ty DefaultLogger (let: "$Logger" := (let: "$a0" := (interface.make os.File'ptr (![ptrT] (globals.get os.Stderr #()))) in
      let: "$a1" := #"raft"%go in
      let: "$a2" := #(W64 log.LstdFlags) in
      (func_call log.New #()) "$a0" "$a1" "$a2") in
      struct.make DefaultLogger [{
        "Logger" ::= "$Logger";
        "debug" ::= zero_val boolT
      }])) in
      do:  ((globals.get defaultLogger #()) <-[ptrT] "$r0");;;
      let: "$r0" := (ref_ty DefaultLogger (let: "$Logger" := (let: "$a0" := (![io.Writer] (globals.get io.Discard #())) in
      let: "$a1" := #""%go in
      let: "$a2" := #(W64 0) in
      (func_call log.New #()) "$a0" "$a1" "$a2") in
      struct.make DefaultLogger [{
        "Logger" ::= "$Logger";
        "debug" ::= zero_val boolT
      }])) in
      do:  ((globals.get discardLogger #()) <-[ptrT] "$r0");;;
      let: "$r0" := (interface.make DefaultLogger'ptr (![ptrT] (globals.get defaultLogger #()))) in
      do:  ((globals.get raftLogger #()) <-[Logger] "$r0");;;
      let: "$r0" := (struct.make raftpb.HardState [{
        "Term" ::= zero_val uint64T;
        "Vote" ::= zero_val uint64T;
        "Commit" ::= zero_val uint64T
      }]) in
      do:  ((globals.get emptyState #()) <-[raftpb.HardState] "$r0");;;
      let: "$r0" := (let: "$a0" := #"raft: stopped"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get ErrStopped #()) <-[error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"raft proposal dropped"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get ErrProposalDropped #()) <-[error] "$r0");;;
      let: "$r0" := (ref_ty lockedRand (struct.make lockedRand [{
        "mu" ::= zero_val sync.Mutex
      }])) in
      do:  ((globals.get globalRand #()) <-[ptrT] "$r0");;;
      let: "$r0" := ((let: "$ar0" := #"StateFollower"%go in
      let: "$ar1" := #"StateCandidate"%go in
      let: "$ar2" := #"StateLeader"%go in
      let: "$ar3" := #"StatePreCandidate"%go in
      array.literal ["$ar0"; "$ar1"; "$ar2"; "$ar3"])) in
      do:  ((globals.get stmap #()) <-[arrayT 4 stringT] "$r0");;;
      let: "$r0" := (let: "$a0" := #"break"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get errBreak #()) <-[error] "$r0");;;
      let: "$r0" := (ref_ty blackHole (struct.make blackHole [{
      }])) in
      do:  ((globals.get nopStepper #()) <-[ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := #"raft: cannot step raft local message"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get ErrStepLocalMsg #()) <-[error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"raft: cannot step as peer not found"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get ErrStepPeerNotFound #()) <-[error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"requested index is unavailable due to compaction"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get ErrCompacted #()) <-[error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"requested index is older than the existing snapshot"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get ErrSnapOutOfDate #()) <-[error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"requested entry at index is unavailable"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get ErrUnavailable #()) <-[error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"snapshot is temporarily unavailable"%go in
      (func_call errors.New #()) "$a0") in
      do:  ((globals.get ErrSnapshotTemporarilyUnavailable #()) <-[error] "$r0");;;
      let: "$r0" := ((let: "$ar0" := #true in
      let: "$ar1" := #true in
      let: "$ar2" := (zero_val boolT) in
      let: "$ar3" := (zero_val boolT) in
      let: "$ar4" := (zero_val boolT) in
      let: "$ar5" := (zero_val boolT) in
      let: "$ar6" := (zero_val boolT) in
      let: "$ar7" := (zero_val boolT) in
      let: "$ar8" := (zero_val boolT) in
      let: "$ar9" := (zero_val boolT) in
      let: "$ar10" := #true in
      let: "$ar11" := #true in
      let: "$ar12" := #true in
      let: "$ar13" := (zero_val boolT) in
      let: "$ar14" := (zero_val boolT) in
      let: "$ar15" := (zero_val boolT) in
      let: "$ar16" := (zero_val boolT) in
      let: "$ar17" := (zero_val boolT) in
      let: "$ar18" := (zero_val boolT) in
      let: "$ar19" := #true in
      let: "$ar20" := #true in
      let: "$ar21" := #true in
      let: "$ar22" := #true in
      array.literal ["$ar0"; "$ar1"; "$ar2"; "$ar3"; "$ar4"; "$ar5"; "$ar6"; "$ar7"; "$ar8"; "$ar9"; "$ar10"; "$ar11"; "$ar12"; "$ar13"; "$ar14"; "$ar15"; "$ar16"; "$ar17"; "$ar18"; "$ar19"; "$ar20"; "$ar21"; "$ar22"])) in
      do:  ((globals.get isLocalMsg #()) <-[arrayT 23 boolT] "$r0");;;
      let: "$r0" := ((let: "$ar0" := (zero_val boolT) in
      let: "$ar1" := (zero_val boolT) in
      let: "$ar2" := (zero_val boolT) in
      let: "$ar3" := (zero_val boolT) in
      let: "$ar4" := #true in
      let: "$ar5" := (zero_val boolT) in
      let: "$ar6" := #true in
      let: "$ar7" := (zero_val boolT) in
      let: "$ar8" := (zero_val boolT) in
      let: "$ar9" := #true in
      let: "$ar10" := #true in
      let: "$ar11" := (zero_val boolT) in
      let: "$ar12" := (zero_val boolT) in
      let: "$ar13" := (zero_val boolT) in
      let: "$ar14" := (zero_val boolT) in
      let: "$ar15" := (zero_val boolT) in
      let: "$ar16" := #true in
      let: "$ar17" := (zero_val boolT) in
      let: "$ar18" := #true in
      let: "$ar19" := (zero_val boolT) in
      let: "$ar20" := #true in
      let: "$ar21" := (zero_val boolT) in
      let: "$ar22" := #true in
      array.literal ["$ar0"; "$ar1"; "$ar2"; "$ar3"; "$ar4"; "$ar5"; "$ar6"; "$ar7"; "$ar8"; "$ar9"; "$ar10"; "$ar11"; "$ar12"; "$ar13"; "$ar14"; "$ar15"; "$ar16"; "$ar17"; "$ar18"; "$ar19"; "$ar20"; "$ar21"; "$ar22"])) in
      do:  ((globals.get isResponseMsg #()) <-[arrayT 23 boolT] "$r0");;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := (func_call stepFollower #()) in
        do:  ((globals.get stepFollowerGlobal #()) <-[funcT] "$r0");;;
        let: "$r0" := (func_call stepCandidate #()) in
        do:  ((globals.get stepCandidateGlobal #()) <-[funcT] "$r0");;;
        let: "$r0" := (func_call stepLeader #()) in
        do:  ((globals.get stepLeaderGlobal #()) <-[funcT] "$r0"))
        ) #()))
      ).

End code.
