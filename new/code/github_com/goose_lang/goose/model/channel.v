(* autogenerated from github.com/goose-lang/goose/model/channel *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.sync.

Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.
Section code.
Context `{ffi_syntax}.


Definition ChannelState : go_type := uint64T.

Definition start : expr := #(W64 0).

Definition receiver_ready : expr := #(W64 1).

Definition sender_ready : expr := #(W64 2).

Definition receiver_done : expr := #(W64 3).

Definition sender_done : expr := #(W64 4).

Definition closed : expr := #(W64 5).

Definition Channel : val :=
  λ: "T", type.structT [
    (#"lock"%go, #ptrT);
    (#"state"%go, #ChannelState);
    (#"buffer"%go, #sliceT);
    (#"first"%go, #uint64T);
    (#"count"%go, #uint64T);
    (#"v"%go, "T")
  ].

(* buffer_size = 0 is an unbuffered channel

   go: channel.go:36:6 *)
Definition NewChannelRef : val :=
  rec: "NewChannelRef" "T" "buffer_size" :=
    exception_do (let: "buffer_size" := (mem.alloc "buffer_size") in
    return: (mem.alloc (let: "$buffer" := (slice.make2 "T" (![#uint64T] "buffer_size")) in
     let: "$lock" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$first" := #(W64 0) in
     let: "$count" := #(W64 0) in
     let: "$state" := start in
     struct.make (Channel "T") [{
       "lock" ::= "$lock";
       "state" ::= "$state";
       "buffer" ::= "$buffer";
       "first" ::= "$first";
       "count" ::= "$count";
       "v" ::= type.zero_val "T"
     }]))).

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:51:22 *)
Definition Channel__Send : val :=
  rec: "Channel__Send" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "sendCase" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (!["T"] "val") in
    ((func_call #channel.channel #"NewSendCase"%go) "T") "$a0" "$a1") in
    do:  ("sendCase" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "sendCase") in
    let: "$a1" := #true in
    ((func_call #channel.channel #"Select1"%go) "T") "$a0" "$a1");;;
    return: (#());;;
    return: #()).

Definition SelectDir : go_type := uint64T.

Definition SelectCase : val :=
  λ: "T", type.structT [
    (#"channel"%go, #ptrT);
    (#"dir"%go, #SelectDir);
    (#"Value"%go, "T");
    (#"Ok"%go, #boolT)
  ].

(* Equivalent to:
   value, ok := <-c
   Notably, this requires the user to consume the ok bool which is not actually required with Go
   channels. This should be able to be solved by adding an overload wrapper that discards the ok
   bool.

   go: channel.go:72:22 *)
Definition Channel__Receive : val :=
  rec: "Channel__Receive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "recvCase" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    ((func_call #channel.channel #"NewRecvCase"%go) "T") "$a0") in
    do:  ("recvCase" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "recvCase") in
    let: "$a1" := #true in
    ((func_call #channel.channel #"Select1"%go) "T") "$a0" "$a1");;;
    return: (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "recvCase")), ![#boolT] (struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "recvCase")))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:92:22 *)
Definition Channel__TryClose : val :=
  rec: "Channel__TryClose" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"close of closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) ≠ receiver_done) && ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) ≠ sender_done)
    then
      let: "$r0" := closed in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:110:22 *)
Definition Channel__Close : val :=
  rec: "Channel__Close" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"close of nil channel"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "done" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("done" <-[#boolT] "$r0");;;
    (for: (λ: <>, (~ (![#boolT] "done"))); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "$r0" := ((method_call #channel.channel #"Channel'ptr" #"TryClose" (![#ptrT] "c") "T") #()) in
      do:  ("done" <-[#boolT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #()));;;
    return: #()).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated.

   go: channel.go:128:22 *)
Definition Channel__ReceiveDiscardOk : val :=
  rec: "Channel__ReceiveDiscardOk" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: ("$ret0", "$ret1") := ((method_call #channel.channel #"Channel'ptr" #"Receive" (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-["T"] "$r0");;;
    do:  "$r1";;;
    return: (!["T"] "return_val")).

(* If there is a value available in the buffer, consume it, otherwise, don't select.

   go: channel.go:135:22 *)
Definition Channel__BufferedTryReceiveLocked : val :=
  rec: "Channel__BufferedTryReceiveLocked" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "v" := (mem.alloc (type.zero_val "T")) in
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) > #(W64 0)
    then
      let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) (![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))))) in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
      let: "$r0" := (((![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0"))) in
      do:  ((struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c")) <-[#uint64T] "$r0");;;
      do:  ((struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")) <-[#uint64T] ((![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) - #(W64 1)));;;
      return: (#true, !["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")), #true)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then return: (#true, !["T"] "v", #false)
    else do:  #());;;
    return: (#false, !["T"] "v", #true)).

(* go: channel.go:149:22 *)
Definition Channel__BufferedTryReceive : val :=
  rec: "Channel__BufferedTryReceive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #channel.channel #"Channel'ptr" #"BufferedTryReceiveLocked" (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("selected" <-[#boolT] "$r0");;;
    do:  ("return_val" <-["T"] "$r1");;;
    do:  ("ok" <-[#boolT] "$r2");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#boolT] "selected", !["T"] "return_val", ![#boolT] "ok")).

Definition OfferResult : go_type := uint64T.

(* Offer was rescinded (other party didn't arrive in time) *)
Definition OfferRescinded : expr := #(W64 0).

(* Other party responded to our offer *)
Definition CompletedExchange : expr := #(W64 1).

(* Unexpected state, indicates model bugs. *)
Definition CloseInterruptedOffer : expr := #(W64 2).

(* go: channel.go:164:22 *)
Definition Channel__UnbufferedTryReceive : val :=
  rec: "Channel__UnbufferedTryReceive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "local_val" := (mem.alloc (type.zero_val "T")) in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "local_val", #false)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_ready
    then
      let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
      do:  ("local_val" <-["T"] "$r0");;;
      let: "$r0" := receiver_done in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "local_val", #true)
    else do:  #());;;
    (if: (((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_done) || ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_ready)) || ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_done)
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#false, !["T"] "local_val", #true)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = start
    then
      let: "$r0" := receiver_ready in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #false)
      else do:  #());;;
      (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_ready
      then
        let: "$r0" := start in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false, !["T"] "local_val", #true)
      else do:  #());;;
      (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_done
      then
        let: "$r0" := start in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
        let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
        do:  ("local_val" <-["T"] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #true)
      else do:  #());;;
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"not supposed to be here!"%go) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"not supposed to be here!"%go) in
    Panic "$a0")).

(* Non-blocking receive function used for select statements. Blocking receive is modeled as
   a single blocking select statement which amounts to a for loop until selected.

   go: channel.go:215:22 *)
Definition Channel__TryReceive : val :=
  rec: "Channel__TryReceive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) > #(W64 0)
    then
      let: (("$ret0", "$ret1"), "$ret2") := (((method_call #channel.channel #"Channel'ptr" #"BufferedTryReceive" (![#ptrT] "c") "T") #())) in
      return: ("$ret0", "$ret1", "$ret2")
    else
      let: (("$ret0", "$ret1"), "$ret2") := (((method_call #channel.channel #"Channel'ptr" #"UnbufferedTryReceive" (![#ptrT] "c") "T") #())) in
      return: ("$ret0", "$ret1", "$ret2"))).

Definition SenderState : go_type := uint64T.

(* Sender found a waiting receiver *)
Definition SenderCompletedWithReceiver : expr := #(W64 0).

(* Sender made an offer (no receiver waiting) *)
Definition SenderMadeOffer : expr := #(W64 1).

(* Exchange in progress, don't select *)
Definition SenderCannotProceed : expr := #(W64 2).

(* go: channel.go:231:22 *)
Definition Channel__SenderCompleteOrOffer : val :=
  rec: "Channel__SenderCompleteOrOffer" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_ready
    then
      let: "$r0" := sender_done in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
      return: (SenderCompletedWithReceiver)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = start
    then
      let: "$r0" := sender_ready in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
      return: (SenderMadeOffer)
    else do:  #());;;
    return: (SenderCannotProceed)).

(* go: channel.go:252:22 *)
Definition Channel__SenderCheckOfferResult : val :=
  rec: "Channel__SenderCheckOfferResult" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_done
    then
      let: "$r0" := start in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (CompletedExchange)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_ready
    then
      let: "$r0" := start in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (OfferRescinded)
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"Invalid state transition with open receive offer"%go) in
    Panic "$a0")).

(* If the buffer has free space, push our value.

   go: channel.go:270:22 *)
Definition Channel__BufferedTrySend : val :=
  rec: "Channel__BufferedTrySend" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) < (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0"))
    then
      let: "last" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))) + (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")))) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0"))) in
      do:  ("last" <-[#uint64T] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) (![#uint64T] "last")) <-["T"] "$r0");;;
      do:  ((struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")) <-[#uint64T] ((![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) + #(W64 1)));;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:287:22 *)
Definition Channel__TrySend : val :=
  rec: "Channel__TrySend" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    let: "buffer_size" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) in
    do:  ("buffer_size" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "buffer_size") ≠ #(W64 0)
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "sendResult" := (mem.alloc (type.zero_val #boolT)) in
      let: "$r0" := (let: "$a0" := (!["T"] "val") in
      (method_call #channel.channel #"Channel'ptr" #"BufferedTrySend" (![#ptrT] "c") "T") "$a0") in
      do:  ("sendResult" <-[#boolT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (![#boolT] "sendResult")
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "senderState" := (mem.alloc (type.zero_val #SenderState)) in
    let: "$r0" := (let: "$a0" := (!["T"] "val") in
    (method_call #channel.channel #"Channel'ptr" #"SenderCompleteOrOffer" (![#ptrT] "c") "T") "$a0") in
    do:  ("senderState" <-[#SenderState] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#SenderState] "senderState") = SenderMadeOffer
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "offerResult" := (mem.alloc (type.zero_val #OfferResult)) in
      let: "$r0" := ((method_call #channel.channel #"Channel'ptr" #"SenderCheckOfferResult" (![#ptrT] "c") "T") #()) in
      do:  ("offerResult" <-[#OfferResult] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: ((![#OfferResult] "offerResult") = CompletedExchange)
    else do:  #());;;
    return: ((![#SenderState] "senderState") = SenderCompletedWithReceiver)).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:323:22 *)
Definition Channel__Len : val :=
  rec: "Channel__Len" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    let: "chan_len" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$r0" := (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#uint64T] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:338:22 *)
Definition Channel__Cap : val :=
  rec: "Channel__Cap" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
     slice.len "$a0"))).

(* case Chan <- Send *)
Definition SelectSend : expr := #(W64 0).

(* case <-Chan: *)
Definition SelectRecv : expr := #(W64 1).

(* go: channel.go:364:6 *)
Definition NewSendCase : val :=
  rec: "NewSendCase" "T" "channel" "value" :=
    exception_do (let: "value" := (mem.alloc "value") in
    let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectSend in
     let: "$Value" := (!["T"] "value") in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= "$Value";
       "Ok" ::= type.zero_val #boolT
     }]))).

(* go: channel.go:372:6 *)
Definition NewRecvCase : val :=
  rec: "NewRecvCase" "T" "channel" :=
    exception_do (let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectRecv in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= type.zero_val "T";
       "Ok" ::= type.zero_val #boolT
     }]))).

(* Uses the applicable Try<Operation> function on the select case's channel. Default is always
   selectable so simply returns true.

   go: channel.go:381:6 *)
Definition TrySelect : val :=
  rec: "TrySelect" "T" "select_case" :=
    exception_do (let: "select_case" := (mem.alloc "select_case") in
    let: "channel" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref (SelectCase "T") #"channel"%go (![#ptrT] "select_case"))) in
    do:  ("channel" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "channel") = #null
    then return: (#false)
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectSend
    then
      return: (let: "$a0" := (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case"))) in
       (method_call #channel.channel #"Channel'ptr" #"TrySend" (![#ptrT] "channel") "T") "$a0")
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectRecv
    then
      let: "item" := (mem.alloc (type.zero_val "T")) in
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := ((method_call #channel.channel #"Channel'ptr" #"TryReceive" (![#ptrT] "channel") "T") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[#boolT] "$r0");;;
      do:  ("item" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      let: "$r0" := (!["T"] "item") in
      do:  ((struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case")) <-["T"] "$r0");;;
      let: "$r0" := (![#boolT] "ok") in
      do:  ((struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "select_case")) <-[#boolT] "$r0");;;
      return: (![#boolT] "selected")
    else do:  #());;;
    return: (#false)).

(* Select1 performs a select operation on 1 case. This is used for Send and
   Receive as well, since these channel operations in Go are equivalent to
   a single case select statement with no default.

   go: channel.go:408:6 *)
Definition Select1 : val :=
  rec: "Select1" "T1" "case1" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case1" := (mem.alloc "case1") in
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#ptrT] "case1") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0") in
      do:  ("selected" <-[#boolT] "$r0");;;
      (if: (![#boolT] "selected") || (~ (![#boolT] "blocking"))
      then break: #()
      else do:  #()));;;
    return: (![#boolT] "selected")).

(* go: channel.go:421:6 *)
Definition TrySelectCase2 : val :=
  rec: "TrySelectCase2" "T1" "T2" "index" "case1" "case2" :=
    exception_do (let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"index needs to be 0 or 1"%go) in
    Panic "$a0")).

(* go: channel.go:434:6 *)
Definition Select2 : val :=
  rec: "Select2" "T1" "T2" "case1" "case2" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 2)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    ((func_call #channel.channel #"TrySelectCase2"%go) "T1" "T2") "$a0" "$a1" "$a2"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0"
      then return: (#(W64 1))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 2))
      else do:  #()))).

(* go: channel.go:458:6 *)
Definition TrySelectCase3 : val :=
  rec: "TrySelectCase3" "T1" "T2" "T3" "index" "case1" "case2" "case3" :=
    exception_do (let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"index needs to be 0, 1 or 2"%go) in
    Panic "$a0")).

(* go: channel.go:475:6 *)
Definition Select3 : val :=
  rec: "Select3" "T1" "T2" "T3" "case1" "case2" "case3" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 3)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    ((func_call #channel.channel #"TrySelectCase3"%go) "T1" "T2" "T3") "$a0" "$a1" "$a2" "$a3"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0"
      then return: (#(W64 2))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 3))
      else do:  #()))).

(* go: channel.go:502:6 *)
Definition TrySelectCase4 : val :=
  rec: "TrySelectCase4" "T1" "T2" "T3" "T4" "index" "case1" "case2" "case3" "case4" :=
    exception_do (let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       ((func_call #channel.channel #"TrySelect"%go) "T4") "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"index needs to be 0, 1, 2 or 3"%go) in
    Panic "$a0")).

(* go: channel.go:523:6 *)
Definition Select4 : val :=
  rec: "Select4" "T1" "T2" "T3" "T4" "case1" "case2" "case3" "case4" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 4)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    ((func_call #channel.channel #"TrySelectCase4"%go) "T1" "T2" "T3" "T4") "$a0" "$a1" "$a2" "$a3" "$a4"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      ((func_call #channel.channel #"TrySelect"%go) "T4") "$a0"
      then return: (#(W64 3))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 4))
      else do:  #()))).

(* go: channel.go:554:6 *)
Definition TrySelectCase5 : val :=
  rec: "TrySelectCase5" "T1" "T2" "T3" "T4" "T5" "index" "case1" "case2" "case3" "case4" "case5" :=
    exception_do (let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       ((func_call #channel.channel #"TrySelect"%go) "T4") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 4)
    then
      return: (let: "$a0" := (![#ptrT] "case5") in
       ((func_call #channel.channel #"TrySelect"%go) "T5") "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"index needs to be 0, 1, 2, 3 or 4"%go) in
    Panic "$a0")).

(* go: channel.go:579:6 *)
Definition Select5 : val :=
  rec: "Select5" "T1" "T2" "T3" "T4" "T5" "case1" "case2" "case3" "case4" "case5" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 5)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    let: "$a5" := (![#ptrT] "case5") in
    ((func_call #channel.channel #"TrySelectCase5"%go) "T1" "T2" "T3" "T4" "T5") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      ((func_call #channel.channel #"TrySelect"%go) "T1") "$a0"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      ((func_call #channel.channel #"TrySelect"%go) "T2") "$a0"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      ((func_call #channel.channel #"TrySelect"%go) "T3") "$a0"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      ((func_call #channel.channel #"TrySelect"%go) "T4") "$a0"
      then return: (#(W64 3))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case5") in
      ((func_call #channel.channel #"TrySelect"%go) "T5") "$a0"
      then return: (#(W64 4))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 5))
      else do:  #()))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("NewChannelRef"%go, NewChannelRef); ("NewSendCase"%go, NewSendCase); ("NewRecvCase"%go, NewRecvCase); ("TrySelect"%go, TrySelect); ("Select1"%go, Select1); ("TrySelectCase2"%go, TrySelectCase2); ("Select2"%go, Select2); ("TrySelectCase3"%go, TrySelectCase3); ("Select3"%go, Select3); ("TrySelectCase4"%go, TrySelectCase4); ("Select4"%go, Select4); ("TrySelectCase5"%go, TrySelectCase5); ("Select5"%go, Select5)].

Definition msets' : list (go_string * (list (go_string * val))) := [("ChannelState"%go, []); ("ChannelState'ptr"%go, []); ("Channel"%go, []); ("Channel'ptr"%go, [("BufferedTryReceive"%go, Channel__BufferedTryReceive); ("BufferedTryReceiveLocked"%go, Channel__BufferedTryReceiveLocked); ("BufferedTrySend"%go, Channel__BufferedTrySend); ("Cap"%go, Channel__Cap); ("Close"%go, Channel__Close); ("Len"%go, Channel__Len); ("Receive"%go, Channel__Receive); ("ReceiveDiscardOk"%go, Channel__ReceiveDiscardOk); ("Send"%go, Channel__Send); ("SenderCheckOfferResult"%go, Channel__SenderCheckOfferResult); ("SenderCompleteOrOffer"%go, Channel__SenderCompleteOrOffer); ("TryClose"%go, Channel__TryClose); ("TryReceive"%go, Channel__TryReceive); ("TrySend"%go, Channel__TrySend); ("UnbufferedTryReceive"%go, Channel__UnbufferedTryReceive)]); ("OfferResult"%go, []); ("OfferResult'ptr"%go, []); ("SenderState"%go, []); ("SenderState'ptr"%go, []); ("SelectDir"%go, []); ("SelectDir'ptr"%go, []); ("SelectCase"%go, []); ("SelectCase'ptr"%go, [])].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync.sync; primitive.primitive];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init channel.channel (λ: <>,
      exception_do (do:  primitive.initialize';;;
      do:  sync.initialize')
      ).

End code.
End channel.
