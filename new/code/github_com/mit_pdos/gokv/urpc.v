(* autogenerated from github.com/mit-pdos/gokv/urpc *)
From New.golang Require Import defn.
From New.code Require github_com.goose_lang.goose.machine.
From New.code Require github_com.goose_lang.std.
From New.code Require github_com.mit_pdos.gokv.grove_ffi.
From New.code Require github_com.tchajed.marshal.
From New.code Require log.
From New.code Require sync.

From New Require Import grove_prelude.

Definition Server : go_type := structT [
  "handlers" :: mapT uint64T funcT
].

Definition Server__mset : list (string * val) := [
].

(* go: urpc.go:19:20 *)
Definition Server__rpcHandle : val :=
  rec: "Server__rpcHandle" "srv" "conn" "rpcid" "seqno" "data" :=
    exception_do (let: "srv" := ref_ty ptrT "srv" in
    let: "data" := ref_ty (sliceT byteT) "data" in
    let: "seqno" := ref_ty uint64T "seqno" in
    let: "rpcid" := ref_ty uint64T "rpcid" in
    let: "conn" := ref_ty grove_ffi.Connection "conn" in
    let: "replyData" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    do:  ("replyData" <-[ptrT] "$r0");;;
    let: "f" := ref_ty funcT (zero_val funcT) in
    let: "$r0" := Fst (map.get (![mapT uint64T funcT] (struct.field_ref Server "handlers" (![ptrT] "srv"))) (![uint64T] "rpcid")) in
    do:  ("f" <-[funcT] "$r0");;;
    do:  (let: "$a0" := ![sliceT byteT] "data" in
    let: "$a1" := ![ptrT] "replyData" in
    (![funcT] "f") "$a0" "$a1");;;
    let: "data1" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := slice.make3 byteT #0 (#8 + (slice.len (![sliceT byteT] (![ptrT] "replyData")))) in
    do:  ("data1" <-[sliceT byteT] "$r0");;;
    let: "data2" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$a0" := ![sliceT byteT] "data1" in
    let: "$a1" := ![uint64T] "seqno" in
    marshal.WriteInt "$a0" "$a1" in
    do:  ("data2" <-[sliceT byteT] "$r0");;;
    let: "data3" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$a0" := ![sliceT byteT] "data2" in
    let: "$a1" := ![sliceT byteT] (![ptrT] "replyData") in
    marshal.WriteBytes "$a0" "$a1" in
    do:  ("data3" <-[sliceT byteT] "$r0");;;
    do:  (let: "$a0" := ![grove_ffi.Connection] "conn" in
    let: "$a1" := ![sliceT byteT] "data3" in
    grove_ffi.Send "$a0" "$a1");;;
    do:  #()).

(* go: urpc.go:36:20 *)
Definition Server__readThread : val :=
  rec: "Server__readThread" "srv" "conn" :=
    exception_do (let: "srv" := ref_ty ptrT "srv" in
    let: "conn" := ref_ty grove_ffi.Connection "conn" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "r" := ref_ty grove_ffi.ReceiveRet (zero_val grove_ffi.ReceiveRet) in
      let: "$r0" := let: "$a0" := ![grove_ffi.Connection] "conn" in
      grove_ffi.Receive "$a0" in
      do:  ("r" <-[grove_ffi.ReceiveRet] "$r0");;;
      (if: ![boolT] (struct.field_ref grove_ffi.ReceiveRet "Err" "r")
      then
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "data" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
      let: "$r0" := ![sliceT byteT] (struct.field_ref grove_ffi.ReceiveRet "Data" "r") in
      do:  ("data" <-[sliceT byteT] "$r0");;;
      let: "rpcid" := ref_ty uint64T (zero_val uint64T) in
      let: ("$ret0", "$ret1") := let: "$a0" := ![sliceT byteT] "data" in
      marshal.ReadInt "$a0" in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("rpcid" <-[uint64T] "$r0");;;
      do:  ("data" <-[sliceT byteT] "$r1");;;
      let: "seqno" := ref_ty uint64T (zero_val uint64T) in
      let: ("$ret0", "$ret1") := let: "$a0" := ![sliceT byteT] "data" in
      marshal.ReadInt "$a0" in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("seqno" <-[uint64T] "$r0");;;
      do:  ("data" <-[sliceT byteT] "$r1");;;
      let: "req" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
      let: "$r0" := ![sliceT byteT] "data" in
      do:  ("req" <-[sliceT byteT] "$r0");;;
      let: "$go" := (λ: <>,
        do:  (let: "$a0" := ![grove_ffi.Connection] "conn" in
        let: "$a1" := ![uint64T] "rpcid" in
        let: "$a2" := ![uint64T] "seqno" in
        let: "$a3" := ![sliceT byteT] "req" in
        (Server__rpcHandle (![ptrT] "srv")) "$a0" "$a1" "$a2" "$a3");;;
        do:  #()
        ) in
      do:  (Fork ("$go" #()));;;
      continue: #();;;
      do:  #());;;
    do:  #()).

(* go: urpc.go:58:20 *)
Definition Server__Serve : val :=
  rec: "Server__Serve" "srv" "host" :=
    exception_do (let: "srv" := ref_ty ptrT "srv" in
    let: "host" := ref_ty uint64T "host" in
    let: "listener" := ref_ty grove_ffi.Listener (zero_val grove_ffi.Listener) in
    let: "$r0" := let: "$a0" := ![uint64T] "host" in
    grove_ffi.Listen "$a0" in
    do:  ("listener" <-[grove_ffi.Listener] "$r0");;;
    let: "$go" := (λ: <>,
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        let: "conn" := ref_ty grove_ffi.Connection (zero_val grove_ffi.Connection) in
        let: "$r0" := let: "$a0" := ![grove_ffi.Listener] "listener" in
        grove_ffi.Accept "$a0" in
        do:  ("conn" <-[grove_ffi.Connection] "$r0");;;
        let: "$go" := (λ: <>,
          do:  (let: "$a0" := ![grove_ffi.Connection] "conn" in
          (Server__readThread (![ptrT] "srv")) "$a0");;;
          do:  #()
          ) in
        do:  (Fork ("$go" #()));;;
        do:  #());;;
      do:  #()
      ) in
    do:  (Fork ("$go" #()));;;
    do:  #()).

Definition Server__mset_ptr : list (string * val) := [
  ("Serve", Server__Serve);
  ("readThread", Server__readThread);
  ("rpcHandle", Server__rpcHandle)
].

(* go: urpc.go:32:6 *)
Definition MakeServer : val :=
  rec: "MakeServer" "handlers" :=
    exception_do (let: "handlers" := ref_ty (mapT uint64T funcT) "handlers" in
    return: (ref_ty Server (struct.make Server [{
       "handlers" ::= ![mapT uint64T funcT] "handlers"
     }]));;;
    do:  #()).

Definition callbackStateWaiting : expr := #0.

Definition callbackStateDone : expr := #1.

Definition callbackStateAborted : expr := #2.

Definition Callback : go_type := structT [
  "reply" :: ptrT;
  "state" :: ptrT;
  "cond" :: ptrT
].

Definition Callback__mset : list (string * val) := [
].

Definition Callback__mset_ptr : list (string * val) := [
].

Definition Client : go_type := structT [
  "mu" :: ptrT;
  "conn" :: grove_ffi.Connection;
  "seq" :: uint64T;
  "pending" :: mapT uint64T ptrT
].

Definition Client__mset : list (string * val) := [
].

Definition ErrTimeout : expr := #1.

Definition ErrDisconnect : expr := #2.

(* go: urpc.go:188:19 *)
Definition Client__CallComplete : val :=
  rec: "Client__CallComplete" "cl" "cb" "reply" "timeout_ms" :=
    exception_do (let: "cl" := ref_ty ptrT "cl" in
    let: "timeout_ms" := ref_ty uint64T "timeout_ms" in
    let: "reply" := ref_ty ptrT "reply" in
    let: "cb" := ref_ty ptrT "cb" in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
    (if: (![uint64T] (![ptrT] (struct.field_ref Callback "state" (![ptrT] "cb")))) = callbackStateWaiting
    then
      do:  (let: "$a0" := ![ptrT] (struct.field_ref Callback "cond" (![ptrT] "cb")) in
      let: "$a1" := ![uint64T] "timeout_ms" in
      machine.WaitTimeout "$a0" "$a1");;;
      do:  #()
    else do:  #());;;
    let: "state" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (![ptrT] (struct.field_ref Callback "state" (![ptrT] "cb"))) in
    do:  ("state" <-[uint64T] "$r0");;;
    (if: (![uint64T] "state") = callbackStateDone
    then
      let: "$r0" := ![sliceT byteT] (![ptrT] (struct.field_ref Callback "reply" (![ptrT] "cb"))) in
      do:  ((![ptrT] "reply") <-[sliceT byteT] "$r0");;;
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
      return: (#0);;;
      do:  #()
    else
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
      (if: (![uint64T] "state") = callbackStateAborted
      then
        return: (ErrDisconnect);;;
        do:  #()
      else
        return: (ErrTimeout);;;
        do:  #());;;
      do:  #());;;
    do:  #()).

Definition ErrNone : expr := #0.

(* go: urpc.go:155:19 *)
Definition Client__CallStart : val :=
  rec: "Client__CallStart" "cl" "rpcid" "args" :=
    exception_do (let: "cl" := ref_ty ptrT "cl" in
    let: "args" := ref_ty (sliceT byteT) "args" in
    let: "rpcid" := ref_ty uint64T "rpcid" in
    let: "reply_buf" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    do:  ("reply_buf" <-[ptrT] "$r0");;;
    let: "cb" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty Callback (struct.make Callback [{
      "reply" ::= ![ptrT] "reply_buf";
      "state" ::= ref_ty uint64T (zero_val uint64T);
      "cond" ::= let: "$a0" := interface.make sync.Mutex__mset_ptr (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl"))) in
      sync.NewCond "$a0"
    }]) in
    do:  ("cb" <-[ptrT] "$r0");;;
    let: "$r0" := callbackStateWaiting in
    do:  ((![ptrT] (struct.field_ref Callback "state" (![ptrT] "cb"))) <-[uint64T] "$r0");;;
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
    let: "seqno" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] (struct.field_ref Client "seq" (![ptrT] "cl")) in
    do:  ("seqno" <-[uint64T] "$r0");;;
    let: "$r0" := let: "$a0" := ![uint64T] (struct.field_ref Client "seq" (![ptrT] "cl")) in
    let: "$a1" := #1 in
    std.SumAssumeNoOverflow "$a0" "$a1" in
    do:  ((struct.field_ref Client "seq" (![ptrT] "cl")) <-[uint64T] "$r0");;;
    let: "$r0" := ![ptrT] "cb" in
    do:  (map.insert (![mapT uint64T ptrT] (struct.field_ref Client "pending" (![ptrT] "cl"))) (![uint64T] "seqno") "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
    let: "data1" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := slice.make3 byteT #0 ((#8 + #8) + (slice.len (![sliceT byteT] "args"))) in
    do:  ("data1" <-[sliceT byteT] "$r0");;;
    let: "data2" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$a0" := ![sliceT byteT] "data1" in
    let: "$a1" := ![uint64T] "rpcid" in
    marshal.WriteInt "$a0" "$a1" in
    do:  ("data2" <-[sliceT byteT] "$r0");;;
    let: "data3" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$a0" := ![sliceT byteT] "data2" in
    let: "$a1" := ![uint64T] "seqno" in
    marshal.WriteInt "$a0" "$a1" in
    do:  ("data3" <-[sliceT byteT] "$r0");;;
    let: "reqData" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
    let: "$r0" := let: "$a0" := ![sliceT byteT] "data3" in
    let: "$a1" := ![sliceT byteT] "args" in
    marshal.WriteBytes "$a0" "$a1" in
    do:  ("reqData" <-[sliceT byteT] "$r0");;;
    (if: let: "$a0" := ![grove_ffi.Connection] (struct.field_ref Client "conn" (![ptrT] "cl")) in
    let: "$a1" := ![sliceT byteT] "reqData" in
    grove_ffi.Send "$a0" "$a1"
    then
      return: (ref_ty Callback (struct.make Callback [{
       }]), ErrDisconnect);;;
      do:  #()
    else do:  #());;;
    return: (![ptrT] "cb", ErrNone);;;
    do:  #()).

(* go: urpc.go:215:19 *)
Definition Client__Call : val :=
  rec: "Client__Call" "cl" "rpcid" "args" "reply" "timeout_ms" :=
    exception_do (let: "cl" := ref_ty ptrT "cl" in
    let: "timeout_ms" := ref_ty uint64T "timeout_ms" in
    let: "reply" := ref_ty ptrT "reply" in
    let: "args" := ref_ty (sliceT byteT) "args" in
    let: "rpcid" := ref_ty uint64T "rpcid" in
    let: "err" := ref_ty uint64T (zero_val uint64T) in
    let: "cb" := ref_ty ptrT (zero_val ptrT) in
    let: ("$ret0", "$ret1") := let: "$a0" := ![uint64T] "rpcid" in
    let: "$a1" := ![sliceT byteT] "args" in
    (Client__CallStart (![ptrT] "cl")) "$a0" "$a1" in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cb" <-[ptrT] "$r0");;;
    do:  ("err" <-[uint64T] "$r1");;;
    (if: (![uint64T] "err") ≠ #0
    then
      return: (![uint64T] "err");;;
      do:  #()
    else do:  #());;;
    return: (let: "$a0" := ![ptrT] "cb" in
     let: "$a1" := ![ptrT] "reply" in
     let: "$a2" := ![uint64T] "timeout_ms" in
     (Client__CallComplete (![ptrT] "cl")) "$a0" "$a1" "$a2");;;
    do:  #()).

(* go: urpc.go:88:19 *)
Definition Client__replyThread : val :=
  rec: "Client__replyThread" "cl" <> :=
    exception_do (let: "cl" := ref_ty ptrT "cl" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "r" := ref_ty grove_ffi.ReceiveRet (zero_val grove_ffi.ReceiveRet) in
      let: "$r0" := let: "$a0" := ![grove_ffi.Connection] (struct.field_ref Client "conn" (![ptrT] "cl")) in
      grove_ffi.Receive "$a0" in
      do:  ("r" <-[grove_ffi.ReceiveRet] "$r0");;;
      (if: ![boolT] (struct.field_ref grove_ffi.ReceiveRet "Err" "r")
      then
        do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
        do:  (MapIter (![mapT uint64T ptrT] (struct.field_ref Client "pending" (![ptrT] "cl"))) (λ: <> "cb",
          let: "$r0" := callbackStateAborted in
          do:  ((![ptrT] (struct.field_ref Callback "state" (![ptrT] "cb"))) <-[uint64T] "$r0");;;
          do:  ((sync.Cond__Signal (![ptrT] (struct.field_ref Callback "cond" (![ptrT] "cb")))) #());;;
          do:  #()));;;
        do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
        break: #();;;
        do:  #()
      else do:  #());;;
      let: "data" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
      let: "$r0" := ![sliceT byteT] (struct.field_ref grove_ffi.ReceiveRet "Data" "r") in
      do:  ("data" <-[sliceT byteT] "$r0");;;
      let: "seqno" := ref_ty uint64T (zero_val uint64T) in
      let: ("$ret0", "$ret1") := let: "$a0" := ![sliceT byteT] "data" in
      marshal.ReadInt "$a0" in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("seqno" <-[uint64T] "$r0");;;
      do:  ("data" <-[sliceT byteT] "$r1");;;
      let: "reply" := ref_ty (sliceT byteT) (zero_val (sliceT byteT)) in
      let: "$r0" := ![sliceT byteT] "data" in
      do:  ("reply" <-[sliceT byteT] "$r0");;;
      do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
      let: "ok" := ref_ty boolT (zero_val boolT) in
      let: "cb" := ref_ty ptrT (zero_val ptrT) in
      let: ("$ret0", "$ret1") := map.get (![mapT uint64T ptrT] (struct.field_ref Client "pending" (![ptrT] "cl"))) (![uint64T] "seqno") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cb" <-[ptrT] "$r0");;;
      do:  ("ok" <-[boolT] "$r1");;;
      (if: ![boolT] "ok"
      then
        do:  (MapDelete (![mapT uint64T ptrT] (struct.field_ref Client "pending" (![ptrT] "cl"))) (![uint64T] "seqno"));;;
        let: "$r0" := ![sliceT byteT] "reply" in
        do:  ((![ptrT] (struct.field_ref Callback "reply" (![ptrT] "cb"))) <-[sliceT byteT] "$r0");;;
        let: "$r0" := callbackStateDone in
        do:  ((![ptrT] (struct.field_ref Callback "state" (![ptrT] "cb"))) <-[uint64T] "$r0");;;
        do:  ((sync.Cond__Signal (![ptrT] (struct.field_ref Callback "cond" (![ptrT] "cb")))) #());;;
        do:  #()
      else do:  #());;;
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Client "mu" (![ptrT] "cl")))) #());;;
      continue: #();;;
      do:  #());;;
    do:  #()).

Definition Client__mset_ptr : list (string * val) := [
  ("Call", Client__Call);
  ("CallComplete", Client__CallComplete);
  ("CallStart", Client__CallStart);
  ("replyThread", Client__replyThread)
].

(* go: urpc.go:120:6 *)
Definition TryMakeClient : val :=
  rec: "TryMakeClient" "host_name" :=
    exception_do (let: "host_name" := ref_ty uint64T "host_name" in
    let: "host" := ref_ty uint64T (zero_val uint64T) in
    let: "$r0" := ![uint64T] "host_name" in
    do:  ("host" <-[uint64T] "$r0");;;
    let: "a" := ref_ty grove_ffi.ConnectRet (zero_val grove_ffi.ConnectRet) in
    let: "$r0" := let: "$a0" := ![uint64T] "host" in
    grove_ffi.Connect "$a0" in
    do:  ("a" <-[grove_ffi.ConnectRet] "$r0");;;
    let: "nilClient" := ref_ty ptrT (zero_val ptrT) in
    (if: ![boolT] (struct.field_ref grove_ffi.ConnectRet "Err" "a")
    then
      return: (#1, ![ptrT] "nilClient");;;
      do:  #()
    else do:  #());;;
    let: "cl" := ref_ty ptrT (zero_val ptrT) in
    let: "$r0" := ref_ty Client (struct.make Client [{
      "conn" ::= ![grove_ffi.Connection] (struct.field_ref grove_ffi.ConnectRet "Connection" "a");
      "mu" ::= ref_ty sync.Mutex (zero_val sync.Mutex);
      "seq" ::= #1;
      "pending" ::= map.make uint64T ptrT #()
    }]) in
    do:  ("cl" <-[ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      do:  ((Client__replyThread (![ptrT] "cl")) #());;;
      do:  #()
      ) in
    do:  (Fork ("$go" #()));;;
    return: (#0, ![ptrT] "cl");;;
    do:  #()).

(* go: urpc.go:140:6 *)
Definition MakeClient : val :=
  rec: "MakeClient" "host_name" :=
    exception_do (let: "host_name" := ref_ty uint64T "host_name" in
    let: "cl" := ref_ty ptrT (zero_val ptrT) in
    let: "err" := ref_ty uint64T (zero_val uint64T) in
    let: ("$ret0", "$ret1") := let: "$a0" := ![uint64T] "host_name" in
    TryMakeClient "$a0" in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  ("cl" <-[ptrT] "$r1");;;
    (if: (![uint64T] "err") ≠ #0
    then
      do:  (let: "$a0" := #(str "Unable to connect to %s") in
      let: "$a1" := (let: "$sl0" := interface.make string__mset (let: "$a0" := ![uint64T] "host_name" in
      grove_ffi.AddressToStr "$a0") in
      slice.literal ["$sl0"]) in
      log.Printf "$a0" "$a1");;;
      do:  #()
    else do:  #());;;
    do:  (let: "$a0" := (![uint64T] "err") = #0 in
    machine.Assume "$a0");;;
    return: (![ptrT] "cl");;;
    do:  #()).

Definition Error : go_type := uint64T.
