(* autogenerated from github.com/sanjit-bhat/pav/marshalutil *)
From New.golang Require Import defn.
Require Export New.code.github_com.tchajed.marshal.

Definition marshalutil : go_string := "github.com/sanjit-bhat/pav/marshalutil".

Module marshalutil.
Section code.
Context `{ffi_syntax}.


(* go: marshalutil.go:9:6 *)
Definition ReadBool : val :=
  rec: "ReadBool" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
    slice.len "$a0")) < #(W64 1)
    then return: (#false, #slice.nil, #true)
    else do:  #());;;
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #marshal.marshal #"ReadBool"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[#boolT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    return: (![#boolT] "data", ![#sliceT] "b2", #false)).

(* go: marshalutil.go:18:6 *)
Definition ReadConstBool : val :=
  rec: "ReadConstBool" "b0" "cst" :=
    exception_do (let: "cst" := (mem.alloc "cst") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "res" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #marshalutil.marshalutil #"ReadBool"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("res" <-[#boolT] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (#slice.nil, #true)
    else do:  #());;;
    (if: (![#boolT] "res") ≠ (![#boolT] "cst")
    then return: (#slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "b", #false)).

(* go: marshalutil.go:30:6 *)
Definition ReadInt : val :=
  rec: "ReadInt" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
    slice.len "$a0")) < #(W64 8)
    then return: (#(W64 0), #slice.nil, #true)
    else do:  #());;;
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[#uint64T] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    return: (![#uint64T] "data", ![#sliceT] "b2", #false)).

(* go: marshalutil.go:39:6 *)
Definition ReadConstInt : val :=
  rec: "ReadConstInt" "b0" "cst" :=
    exception_do (let: "cst" := (mem.alloc "cst") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "res" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #marshalutil.marshalutil #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("res" <-[#uint64T] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (#slice.nil, #true)
    else do:  #());;;
    (if: (![#uint64T] "res") ≠ (![#uint64T] "cst")
    then return: (#slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "b", #false)).

(* go: marshalutil.go:51:6 *)
Definition ReadByte : val :=
  rec: "ReadByte" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
    slice.len "$a0")) < #(W64 1)
    then return: (#(W8 0), #slice.nil, #true)
    else do:  #());;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := #(W64 1) in
    (func_call #marshal.marshal #"ReadBytes"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[#sliceT] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    return: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "data") #(W64 0)), ![#sliceT] "b", #false)).

(* go: marshalutil.go:60:6 *)
Definition ReadConstByte : val :=
  rec: "ReadConstByte" "b0" "cst" :=
    exception_do (let: "cst" := (mem.alloc "cst") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "res" := (mem.alloc (type.zero_val #byteT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #marshalutil.marshalutil #"ReadByte"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("res" <-[#byteT] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (#slice.nil, #true)
    else do:  #());;;
    (if: (![#byteT] "res") ≠ (![#byteT] "cst")
    then return: (#slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "b", #false)).

(* go: marshalutil.go:72:6 *)
Definition WriteByte : val :=
  rec: "WriteByte" "b0" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := ((let: "$sl0" := (![#byteT] "data") in
    slice.literal #byteT ["$sl0"])) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: marshalutil.go:78:6 *)
Definition ReadBytes : val :=
  rec: "ReadBytes" "b0" "length" :=
    exception_do (let: "length" := (mem.alloc "length") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
    slice.len "$a0")) < (![#uint64T] "length")
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] "length") in
    (func_call #marshal.marshal #"ReadBytes"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[#sliceT] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    return: (![#sliceT] "data", ![#sliceT] "b", #false)).

(* go: marshalutil.go:87:6 *)
Definition ReadSlice1D : val :=
  rec: "ReadSlice1D" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #marshalutil.marshalutil #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (#slice.nil, #slice.nil, ![#boolT] "err")
    else do:  #());;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] "length") in
    (func_call #marshalutil.marshalutil #"ReadBytes"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[#sliceT] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (#slice.nil, #slice.nil, ![#boolT] "err")
    else do:  #());;;
    return: (![#sliceT] "data", ![#sliceT] "b", #false)).

(* go: marshalutil.go:100:6 *)
Definition WriteSlice1D : val :=
  rec: "WriteSlice1D" "b0" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] "data") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: marshalutil.go:107:6 *)
Definition ReadSlice2D : val :=
  rec: "ReadSlice2D" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #marshalutil.marshalutil #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (#slice.nil, #slice.nil, ![#boolT] "err")
    else do:  #());;;
    let: "data0" := (mem.alloc (type.zero_val #sliceT)) in
    let: "err0" := (mem.alloc (type.zero_val #boolT)) in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "data1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "err1" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
      (func_call #marshalutil.marshalutil #"ReadSlice1D"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("data1" <-[#sliceT] "$r0");;;
      do:  ("b" <-[#sliceT] "$r1");;;
      do:  ("err1" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err1"
      then
        let: "$r0" := (![#boolT] "err1") in
        do:  ("err0" <-[#boolT] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data0") in
      let: "$a1" := ((let: "$sl0" := (![#sliceT] "data1") in
      slice.literal #sliceT ["$sl0"])) in
      (slice.append #sliceT) "$a0" "$a1") in
      do:  ("data0" <-[#sliceT] "$r0"));;;
    (if: ![#boolT] "err0"
    then return: (#slice.nil, #slice.nil, ![#boolT] "err0")
    else do:  #());;;
    return: (![#sliceT] "data0", ![#sliceT] "b", #false)).

(* go: marshalutil.go:132:6 *)
Definition WriteSlice2D : val :=
  rec: "WriteSlice2D" "b0" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "data") in
    (let: "data1" := (mem.alloc (type.zero_val #sliceT)) in
    slice.for_range #sliceT "$range" (λ: "$key" "$value",
      do:  ("data1" <-[#sliceT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#sliceT] "data1") in
      (func_call #marshalutil.marshalutil #"WriteSlice1D"%go) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

(* go: marshalutil.go:141:6 *)
Definition ReadSlice3D : val :=
  rec: "ReadSlice3D" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #marshalutil.marshalutil #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (#slice.nil, #slice.nil, ![#boolT] "err")
    else do:  #());;;
    let: "data0" := (mem.alloc (type.zero_val #sliceT)) in
    let: "err0" := (mem.alloc (type.zero_val #boolT)) in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "data1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "err1" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b") in
      (func_call #marshalutil.marshalutil #"ReadSlice2D"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("data1" <-[#sliceT] "$r0");;;
      do:  ("b" <-[#sliceT] "$r1");;;
      do:  ("err1" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err1"
      then
        let: "$r0" := (![#boolT] "err1") in
        do:  ("err0" <-[#boolT] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data0") in
      let: "$a1" := ((let: "$sl0" := (![#sliceT] "data1") in
      slice.literal #sliceT ["$sl0"])) in
      (slice.append #sliceT) "$a0" "$a1") in
      do:  ("data0" <-[#sliceT] "$r0"));;;
    (if: ![#boolT] "err0"
    then return: (#slice.nil, #slice.nil, ![#boolT] "err0")
    else do:  #());;;
    return: (![#sliceT] "data0", ![#sliceT] "b", #false)).

(* go: marshalutil.go:166:6 *)
Definition WriteSlice3D : val :=
  rec: "WriteSlice3D" "b0" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "data") in
    (let: "data1" := (mem.alloc (type.zero_val #sliceT)) in
    slice.for_range #sliceT "$range" (λ: "$key" "$value",
      do:  ("data1" <-[#sliceT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#sliceT] "data1") in
      (func_call #marshalutil.marshalutil #"WriteSlice2D"%go) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("ReadBool"%go, ReadBool); ("ReadConstBool"%go, ReadConstBool); ("ReadInt"%go, ReadInt); ("ReadConstInt"%go, ReadConstInt); ("ReadByte"%go, ReadByte); ("ReadConstByte"%go, ReadConstByte); ("WriteByte"%go, WriteByte); ("ReadBytes"%go, ReadBytes); ("ReadSlice1D"%go, ReadSlice1D); ("WriteSlice1D"%go, WriteSlice1D); ("ReadSlice2D"%go, ReadSlice2D); ("WriteSlice2D"%go, WriteSlice2D); ("ReadSlice3D"%go, ReadSlice3D); ("WriteSlice3D"%go, WriteSlice3D)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo marshalutil.marshalutil :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init marshalutil.marshalutil (λ: <>,
      exception_do (do:  marshal.initialize')
      ).

End code.
End marshalutil.
