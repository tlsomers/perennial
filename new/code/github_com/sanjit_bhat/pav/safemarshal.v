(* autogenerated from github.com/sanjit-bhat/pav/safemarshal *)
From New.golang Require Import defn.
Require Export New.code.github_com.tchajed.marshal.

Definition safemarshal : go_string := "github.com/sanjit-bhat/pav/safemarshal".

Module safemarshal.
Section code.
Context `{ffi_syntax}.


(* go: safemarshal.go:9:6 *)
Definition ReadBool : val :=
  rec: "ReadBool" "b" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #boolT)) in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "rem") in
    slice.len "$a0")) < #(W64 1)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#boolT] "data", ![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "rem") in
    (func_call #marshal.marshal #"ReadBool"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[#boolT] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    return: (![#boolT] "data", ![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:19:6 *)
Definition ReadConstBool : val :=
  rec: "ReadConstBool" "b" "cst" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "cst" := (mem.alloc "cst") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "rem") in
    (func_call #safemarshal.safemarshal #"ReadBool"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[#boolT] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    (if: (![#boolT] "data") ≠ (![#boolT] "cst")
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    return: (![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:32:6 *)
Definition ReadInt : val :=
  rec: "ReadInt" "b" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #uint64T)) in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "rem") in
    slice.len "$a0")) < #(W64 8)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "data", ![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "rem") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[#uint64T] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    return: (![#uint64T] "data", ![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:42:6 *)
Definition ReadConstInt : val :=
  rec: "ReadConstInt" "b" "cst" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "cst" := (mem.alloc "cst") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "rem") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[#uint64T] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    (if: (![#uint64T] "data") ≠ (![#uint64T] "cst")
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    return: (![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:55:6 *)
Definition ReadByte : val :=
  rec: "ReadByte" "b" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #byteT)) in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "rem") in
    slice.len "$a0")) < #(W64 1)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#byteT] "data", ![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    let: "data0" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "rem") in
    let: "$a1" := #(W64 1) in
    (func_call #marshal.marshal #"ReadBytes"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data0" <-[#sliceT] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    let: "$r0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "data0") #(W64 0))) in
    do:  ("data" <-[#byteT] "$r0");;;
    return: (![#byteT] "data", ![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:66:6 *)
Definition ReadConstByte : val :=
  rec: "ReadConstByte" "b" "cst" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "cst" := (mem.alloc "cst") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #byteT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "rem") in
    (func_call #safemarshal.safemarshal #"ReadByte"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[#byteT] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    (if: (![#byteT] "data") ≠ (![#byteT] "cst")
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    return: (![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:79:6 *)
Definition WriteByte : val :=
  rec: "WriteByte" "b" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b" := (mem.alloc "b") in
    return: (let: "$a0" := (![#sliceT] "b") in
     let: "$a1" := ((let: "$sl0" := (![#byteT] "data") in
     slice.literal #byteT ["$sl0"])) in
     (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1")).

(* go: safemarshal.go:83:6 *)
Definition ReadBytes : val :=
  rec: "ReadBytes" "b" "length" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "length" := (mem.alloc "length") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "rem") in
    slice.len "$a0")) < (![#uint64T] "length")
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "rem") in
    let: "$a1" := (![#uint64T] "length") in
    (func_call #marshal.marshal #"ReadBytes"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[#sliceT] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:93:6 *)
Definition ReadSlice1D : val :=
  rec: "ReadSlice1D" "b" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "rem") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![#sliceT] "rem") in
    let: "$a1" := (![#uint64T] "length") in
    (func_call #safemarshal.safemarshal #"ReadBytes"%go) "$a0" "$a1")) in
    return: ("$ret0", "$ret1", "$ret2")).

(* go: safemarshal.go:102:6 *)
Definition WriteSlice1D : val :=
  rec: "WriteSlice1D" "b" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     let: "$a1" := (![#sliceT] "data") in
     (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1")).

(* go: safemarshal.go:107:6 *)
Definition ReadSlice2D : val :=
  rec: "ReadSlice2D" "b" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "rem") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "data0" := (mem.alloc (type.zero_val #sliceT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "rem") in
      (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("data0" <-[#sliceT] "$r0");;;
      do:  ("rem" <-[#sliceT] "$r1");;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := ((let: "$sl0" := (![#sliceT] "data0") in
      slice.literal #sliceT ["$sl0"])) in
      (slice.append #sliceT) "$a0" "$a1") in
      do:  ("data" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:124:6 *)
Definition WriteSlice2D : val :=
  rec: "WriteSlice2D" "b" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "data") in
    (let: "data1" := (mem.alloc (type.zero_val #sliceT)) in
    slice.for_range #sliceT "$range" (λ: "$key" "$value",
      do:  ("data1" <-[#sliceT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#sliceT] "data1") in
      (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

(* go: safemarshal.go:132:6 *)
Definition ReadSlice3D : val :=
  rec: "ReadSlice3D" "b" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "rem" := (mem.alloc (type.zero_val #sliceT)) in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("rem" <-[#sliceT] "$r0");;;
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "rem") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("rem" <-[#sliceT] "$r1");;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")
    else do:  #());;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "data0" := (mem.alloc (type.zero_val #sliceT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "rem") in
      (func_call #safemarshal.safemarshal #"ReadSlice2D"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("data0" <-[#sliceT] "$r0");;;
      do:  ("rem" <-[#sliceT] "$r1");;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := ((let: "$sl0" := (![#sliceT] "data0") in
      slice.literal #sliceT ["$sl0"])) in
      (slice.append #sliceT) "$a0" "$a1") in
      do:  ("data" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "data", ![#sliceT] "rem", ![#boolT] "err")).

(* go: safemarshal.go:149:6 *)
Definition WriteSlice3D : val :=
  rec: "WriteSlice3D" "b" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "data") in
    (let: "data1" := (mem.alloc (type.zero_val #sliceT)) in
    slice.for_range #sliceT "$range" (λ: "$key" "$value",
      do:  ("data1" <-[#sliceT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#sliceT] "data1") in
      (func_call #safemarshal.safemarshal #"WriteSlice2D"%go) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("ReadBool"%go, ReadBool); ("ReadConstBool"%go, ReadConstBool); ("ReadInt"%go, ReadInt); ("ReadConstInt"%go, ReadConstInt); ("ReadByte"%go, ReadByte); ("ReadConstByte"%go, ReadConstByte); ("WriteByte"%go, WriteByte); ("ReadBytes"%go, ReadBytes); ("ReadSlice1D"%go, ReadSlice1D); ("WriteSlice1D"%go, WriteSlice1D); ("ReadSlice2D"%go, ReadSlice2D); ("WriteSlice2D"%go, WriteSlice2D); ("ReadSlice3D"%go, ReadSlice3D); ("WriteSlice3D"%go, WriteSlice3D)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo safemarshal.safemarshal :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init safemarshal.safemarshal (λ: <>,
      exception_do (do:  marshal.initialize')
      ).

End code.
End safemarshal.
